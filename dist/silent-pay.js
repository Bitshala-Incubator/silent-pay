var Pn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zp(r) {
  if (r.__esModule)
    return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(r, i);
    Object.defineProperty(t, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return r[i];
      }
    });
  }), t;
}
var Of = {};
Object.defineProperty(Of, "__esModule", { value: !0 });
var Pf = Of.bech32m = Of.bech32 = void 0;
const Zc = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", i8 = {};
for (let r = 0; r < Zc.length; r++) {
  const e = Zc.charAt(r);
  i8[e] = r;
}
function Mn(r) {
  const e = r >> 25;
  return (r & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function a2(r) {
  let e = 1;
  for (let t = 0; t < r.length; ++t) {
    const i = r.charCodeAt(t);
    if (i < 33 || i > 126)
      return "Invalid prefix (" + r + ")";
    e = Mn(e) ^ i >> 5;
  }
  e = Mn(e);
  for (let t = 0; t < r.length; ++t) {
    const i = r.charCodeAt(t);
    e = Mn(e) ^ i & 31;
  }
  return e;
}
function V1(r, e, t, i) {
  let n = 0, c = 0;
  const o = (1 << t) - 1, d = [];
  for (let l = 0; l < r.length; ++l)
    for (n = n << e | r[l], c += e; c >= t; )
      c -= t, d.push(n >> c & o);
  if (i)
    c > 0 && d.push(n << t - c & o);
  else {
    if (c >= e)
      return "Excess padding";
    if (n << t - c & o)
      return "Non-zero padding";
  }
  return d;
}
function Up(r) {
  return V1(r, 8, 5, !0);
}
function Cp(r) {
  const e = V1(r, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function Tp(r) {
  const e = V1(r, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function s8(r) {
  let e;
  r === "bech32" ? e = 1 : e = 734539939;
  function t(o, d, l) {
    if (l = l || 90, o.length + 7 + d.length > l)
      throw new TypeError("Exceeds length limit");
    o = o.toLowerCase();
    let h = a2(o);
    if (typeof h == "string")
      throw new Error(h);
    let x = o + "1";
    for (let b = 0; b < d.length; ++b) {
      const g = d[b];
      if (g >> 5)
        throw new Error("Non 5-bit word");
      h = Mn(h) ^ g, x += Zc.charAt(g);
    }
    for (let b = 0; b < 6; ++b)
      h = Mn(h);
    h ^= e;
    for (let b = 0; b < 6; ++b) {
      const g = h >> (5 - b) * 5 & 31;
      x += Zc.charAt(g);
    }
    return x;
  }
  function i(o, d) {
    if (d = d || 90, o.length < 8)
      return o + " too short";
    if (o.length > d)
      return "Exceeds length limit";
    const l = o.toLowerCase(), h = o.toUpperCase();
    if (o !== l && o !== h)
      return "Mixed-case string " + o;
    o = l;
    const x = o.lastIndexOf("1");
    if (x === -1)
      return "No separator character for " + o;
    if (x === 0)
      return "Missing prefix for " + o;
    const b = o.slice(0, x), g = o.slice(x + 1);
    if (g.length < 6)
      return "Data too short";
    let w = a2(b);
    if (typeof w == "string")
      return w;
    const I = [];
    for (let B = 0; B < g.length; ++B) {
      const y = g.charAt(B), A = i8[y];
      if (A === void 0)
        return "Unknown character " + y;
      w = Mn(w) ^ A, !(B + 6 >= g.length) && I.push(A);
    }
    return w !== e ? "Invalid checksum for " + o : { prefix: b, words: I };
  }
  function n(o, d) {
    const l = i(o, d);
    if (typeof l == "object")
      return l;
  }
  function c(o, d) {
    const l = i(o, d);
    if (typeof l == "object")
      return l;
    throw new Error(l);
  }
  return {
    decodeUnsafe: n,
    decode: c,
    encode: t,
    toWords: Up,
    fromWordsUnsafe: Cp,
    fromWords: Tp
  };
}
Of.bech32 = s8("bech32");
Pf = Of.bech32m = s8("bech32m");
var If = {}, ou = { exports: {} };
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
function n8(r, e) {
  if (!r) {
    const t = new Error(e || "Assertion failed");
    throw Error.captureStackTrace && Error.captureStackTrace(t, n8), t;
  }
}
var _e = n8;
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */
var Ba, h2;
function f8() {
  if (h2)
    return Ba;
  h2 = 1;
  const r = _e, e = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  class t {
    /**
     * Create a ChaCha20 context.
     * @constructor
     */
    constructor() {
      this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, e && (this.bytes = Buffer.alloc(64));
    }
    /**
     * Initialize chacha20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */
    init(l, h, x) {
      if (x == null && (x = 0), r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), r(Number.isSafeInteger(x)), l.length !== 16 && l.length !== 32)
        throw new RangeError("Invalid key size.");
      if (h.length >= 24 && (l = t.derive(l, h.slice(0, 16)), h = h.slice(16)), this.state[0] = 1634760805, this.state[1] = l.length < 32 ? 824206446 : 857760878, this.state[2] = l.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = c(l, 0), this.state[5] = c(l, 4), this.state[6] = c(l, 8), this.state[7] = c(l, 12), this.state[8] = c(l, 16 % l.length), this.state[9] = c(l, 20 % l.length), this.state[10] = c(l, 24 % l.length), this.state[11] = c(l, 28 % l.length), this.state[12] = x >>> 0, h.length === 8)
        this.state[13] = x / 4294967296 >>> 0, this.state[14] = c(h, 0), this.state[15] = c(h, 4);
      else if (h.length === 12)
        this.state[13] = c(h, 0), this.state[14] = c(h, 4), this.state[15] = c(h, 8);
      else if (h.length === 16)
        this.state[12] = c(h, 0), this.state[13] = c(h, 4), this.state[14] = c(h, 8), this.state[15] = c(h, 12);
      else
        throw new RangeError("Invalid nonce size.");
      return this.pos = 0, this;
    }
    /**
     * Encrypt/decrypt data.
     * @param {Buffer} data - Will be mutated.
     * @returns {Buffer}
     */
    encrypt(l) {
      if (r(Buffer.isBuffer(l)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let h = 0; h < l.length; h++)
        this.pos & 63 || (this._block(), this.pos = 0), l[h] ^= this.bytes[this.pos++];
      return l;
    }
    /**
     * Stir the stream.
     */
    _block() {
      for (let l = 0; l < 16; l++)
        this.stream[l] = this.state[l];
      for (let l = 0; l < 10; l++)
        i(this.stream, 0, 4, 8, 12), i(this.stream, 1, 5, 9, 13), i(this.stream, 2, 6, 10, 14), i(this.stream, 3, 7, 11, 15), i(this.stream, 0, 5, 10, 15), i(this.stream, 1, 6, 11, 12), i(this.stream, 2, 7, 8, 13), i(this.stream, 3, 4, 9, 14);
      for (let l = 0; l < 16; l++)
        this.stream[l] += this.state[l];
      if (e)
        for (let l = 0; l < 16; l++)
          o(this.bytes, this.stream[l], l * 4);
      this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1);
    }
    /**
     * Destroy context.
     */
    destroy() {
      for (let l = 0; l < 16; l++)
        this.state[l] = 0, this.stream[l] = 0;
      if (e)
        for (let l = 0; l < 64; l++)
          this.bytes[l] = 0;
      return this.pos = -1, this;
    }
    /**
     * Derive key with XChaCha20.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @returns {Buffer}
     */
    static derive(l, h) {
      if (r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), l.length !== 16 && l.length !== 32)
        throw new RangeError("Invalid key size.");
      if (h.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const x = new Uint32Array(16);
      x[0] = 1634760805, x[1] = l.length < 32 ? 824206446 : 857760878, x[2] = l.length < 32 ? 2036477238 : 2036477234, x[3] = 1797285236, x[4] = c(l, 0), x[5] = c(l, 4), x[6] = c(l, 8), x[7] = c(l, 12), x[8] = c(l, 16 % l.length), x[9] = c(l, 20 % l.length), x[10] = c(l, 24 % l.length), x[11] = c(l, 28 % l.length), x[12] = c(h, 0), x[13] = c(h, 4), x[14] = c(h, 8), x[15] = c(h, 12);
      for (let g = 0; g < 10; g++)
        i(x, 0, 4, 8, 12), i(x, 1, 5, 9, 13), i(x, 2, 6, 10, 14), i(x, 3, 7, 11, 15), i(x, 0, 5, 10, 15), i(x, 1, 6, 11, 12), i(x, 2, 7, 8, 13), i(x, 3, 4, 9, 14);
      const b = Buffer.alloc(32);
      return o(b, x[0], 0), o(b, x[1], 4), o(b, x[2], 8), o(b, x[3], 12), o(b, x[12], 16), o(b, x[13], 20), o(b, x[14], 24), o(b, x[15], 28), b;
    }
  }
  t.native = 0;
  function i(d, l, h, x, b) {
    d[l] += d[h], d[b] = n(d[b] ^ d[l], 16), d[x] += d[b], d[h] = n(d[h] ^ d[x], 12), d[l] += d[h], d[b] = n(d[b] ^ d[l], 8), d[x] += d[b], d[h] = n(d[h] ^ d[x], 7);
  }
  function n(d, l) {
    return d << l | d >>> 32 - l;
  }
  function c(d, l) {
    return d[l++] + d[l++] * 256 + d[l++] * 65536 + d[l] * 16777216;
  }
  function o(d, l, h) {
    return d[h++] = l, l >>>= 8, d[h++] = l, l >>>= 8, d[h++] = l, l >>>= 8, d[h++] = l, h;
  }
  return Ba = t, Ba;
}
/*!
 * poly1305.js - poly1305 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on floodyberry/poly1305-donna:
 *   Placed into the public domain by Andrew Moon.
 *   https://github.com/floodyberry/poly1305-donna
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Poly1305
 *   https://cr.yp.to/mac.html
 *   https://tools.ietf.org/html/rfc7539#section-2.5
 *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h
 */
var va, d2;
function c8() {
  if (d2)
    return va;
  d2 = 1;
  const r = _e;
  class e {
    /**
     * Create a Poly1305 context.
     * @constructor
     */
    constructor() {
      this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.buffer = Buffer.alloc(16), this.fin = -1, this.leftover = 0;
    }
    /**
     * Initialize poly1305 with a key.
     * @param {Buffer} key
     */
    init(c) {
      r(Buffer.isBuffer(c) && c.length >= 32);
      const o = t(c, 0), d = t(c, 2), l = t(c, 4), h = t(c, 6), x = t(c, 8), b = t(c, 10), g = t(c, 12), w = t(c, 14);
      this.r[0] = o & 8191, this.r[1] = (o >>> 13 | d << 3) & 8191, this.r[2] = (d >>> 10 | l << 6) & 7939, this.r[3] = (l >>> 7 | h << 9) & 8191, this.r[4] = (h >>> 4 | x << 12) & 255, this.r[5] = x >>> 1 & 8190, this.r[6] = (x >>> 14 | b << 2) & 8191, this.r[7] = (b >>> 11 | g << 5) & 8065, this.r[8] = (g >>> 8 | w << 8) & 8191, this.r[9] = w >>> 5 & 127;
      for (let I = 0; I < 10; I++)
        this.h[I] = 0;
      for (let I = 0; I < 8; I++)
        this.pad[I] = t(c, 16 + 2 * I);
      return this.fin = 0, this.leftover = 0, this;
    }
    /**
     * Process 16 byte blocks.
     * @private
     * @param {Buffer} data - Blocks.
     * @param {Number} bytes - Size.
     * @param {Number} m - Offset pointer.
     */
    _blocks(c, o, d) {
      const l = this.fin ? 0 : 2048, h = new Uint32Array(10);
      for (; o >= 16; ) {
        const x = t(c, d + 0), b = t(c, d + 2), g = t(c, d + 4), w = t(c, d + 6), I = t(c, d + 8), B = t(c, d + 10), y = t(c, d + 12), A = t(c, d + 14);
        this.h[0] += x & 8191, this.h[1] += (x >>> 13 | b << 3) & 8191, this.h[2] += (b >>> 10 | g << 6) & 8191, this.h[3] += (g >>> 7 | w << 9) & 8191, this.h[4] += (w >>> 4 | I << 12) & 8191, this.h[5] += I >>> 1 & 8191, this.h[6] += (I >>> 14 | B << 2) & 8191, this.h[7] += (B >>> 11 | y << 5) & 8191, this.h[8] += (y >>> 8 | A << 8) & 8191, this.h[9] += A >>> 5 | l;
        let _ = 0;
        for (let q = 0; q < 10; q++) {
          h[q] = _;
          for (let U = 0; U < 10; U++) {
            let z = this.h[U];
            U <= q ? z *= this.r[q - U] : z *= 5 * this.r[q + 10 - U], h[q] += z, U === 4 && (_ = h[q] >>> 13, h[q] &= 8191);
          }
          _ += h[q] >>> 13, h[q] &= 8191;
        }
        _ = (_ << 2) + _, _ += h[0], h[0] = _ & 8191, _ = _ >>> 13, h[1] += _;
        for (let q = 0; q < 10; q++)
          this.h[q] = h[q];
        d += 16, o -= 16;
      }
    }
    /**
     * Update the MAC with data (will be
     * processed as 16 byte blocks).
     * @param {Buffer} data
     */
    update(c) {
      if (r(Buffer.isBuffer(c)), this.fin === -1)
        throw new Error("Context is not initialized.");
      let o = c.length, d = 0;
      if (this.leftover) {
        let l = 16 - this.leftover;
        l > o && (l = o);
        for (let h = 0; h < l; h++)
          this.buffer[this.leftover + h] = c[d + h];
        if (o -= l, d += l, this.leftover += l, this.leftover < 16)
          return this;
        this._blocks(this.buffer, 16, 0), this.leftover = 0;
      }
      if (o >= 16) {
        const l = o & -16;
        this._blocks(c, l, d), d += l, o -= l;
      }
      if (o) {
        for (let l = 0; l < o; l++)
          this.buffer[this.leftover + l] = c[d + l];
        this.leftover += o;
      }
      return this;
    }
    /**
     * Finalize and return a 16-byte MAC.
     * @returns {Buffer}
     */
    final() {
      if (this.fin === -1)
        throw new Error("Context is not initialized.");
      const c = Buffer.alloc(16), o = new Uint16Array(10);
      if (this.leftover) {
        let x = this.leftover;
        for (this.buffer[x++] = 1; x < 16; x++)
          this.buffer[x] = 0;
        this.fin = 1, this._blocks(this.buffer, 16, 0);
      }
      let d = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (let x = 2; x < 10; x++)
        this.h[x] += d, d = this.h[x] >>> 13, this.h[x] &= 8191;
      this.h[0] += d * 5, d = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += d, d = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += d, o[0] = this.h[0] + 5, d = o[0] >>> 13, o[0] &= 8191;
      for (let x = 1; x < 10; x++)
        o[x] = this.h[x] + d, d = o[x] >>> 13, o[x] &= 8191;
      let l = (d ^ 1) - 1;
      for (let x = 0; x < 10; x++)
        o[x] &= l;
      l = ~l;
      for (let x = 0; x < 10; x++)
        this.h[x] = this.h[x] & l | o[x];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      let h = this.h[0] + this.pad[0];
      this.h[0] = h;
      for (let x = 1; x < 8; x++)
        h = this.h[x] + this.pad[x] + (h >>> 16), this.h[x] = h;
      for (let x = 0; x < 8; x++)
        i(c, this.h[x], x * 2);
      return this.destroy(), c;
    }
    /**
     * Destroy the context.
     */
    destroy() {
      for (let c = 0; c < 10; c++)
        this.r[c] = 0, this.h[c] = 0;
      for (let c = 0; c < 8; c++)
        this.pad[c] = 0;
      for (let c = 0; c < 16; c++)
        this.buffer[c] = 0;
      this.fin = -1, this.leftover = 0;
    }
    /**
     * Finalize and verify MAC against tag.
     * @param {Buffer} tag
     * @returns {Boolean}
     */
    verify(c) {
      r(Buffer.isBuffer(c)), r(c.length === 16);
      const o = this.final();
      let d = 0;
      for (let l = 0; l < 16; l++)
        d |= o[l] ^ c[l];
      return d - 1 >>> 31 !== 0;
    }
  }
  e.native = 0;
  function t(n, c) {
    return n[c++] + n[c] * 256;
  }
  function i(n, c, o) {
    return n[o++] = c, n[o++] = c >>> 8, o;
  }
  return va = e, va;
}
/*!
 * aead.js - aead for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7539#section-2.8
 *   https://github.com/openssh/openssh-portable
 */
var Ea, u2;
function Dp() {
  if (u2)
    return Ea;
  u2 = 1;
  const r = _e, e = f8(), t = c8(), i = Buffer.alloc(16, 0);
  class n {
    /**
     * Create an AEAD context.
     * @constructor
     */
    constructor() {
      this.chacha = new e(), this.poly = new t(), this.key = Buffer.alloc(64), this.mode = -1, this.aadLen = 0, this.cipherLen = 0;
    }
    /**
     * Initialize the AEAD with a key and iv.
     * @param {Buffer} key
     * @param {Buffer} iv - IV / packet sequence number.
     */
    init(l, h) {
      return r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), this.key.fill(0), this.chacha.init(l, h, 0), this.chacha.encrypt(this.key), this.poly.init(this.key), this.mode = 0, this.aadLen = 0, this.cipherLen = 0, this;
    }
    /**
     * Update the aad (will be finalized
     * on an encrypt/decrypt call).
     * @param {Buffer} aad
     */
    aad(l) {
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0)
        throw new Error("Invalid state for aad.");
      return this.poly.update(l), this.aadLen += l.length, this;
    }
    /**
     * Encrypt a piece of data.
     * @param {Buffer} data
     */
    encrypt(l) {
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0 && this.mode !== 1)
        throw new Error("Invalid state for encrypt.");
      return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 1), this.chacha.encrypt(l), this.poly.update(l), this.cipherLen += l.length, l;
    }
    /**
     * Decrypt a piece of data.
     * @param {Buffer} data
     */
    decrypt(l) {
      if (r(Buffer.isBuffer(l)), this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0 && this.mode !== 2)
        throw new Error("Invalid state for decrypt.");
      return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 2), this.cipherLen += l.length, this.poly.update(l), this.chacha.encrypt(l), l;
    }
    /**
     * Authenticate data without decrypting.
     * @param {Buffer} data
     */
    auth(l) {
      if (r(Buffer.isBuffer(l)), this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0 && this.mode !== 3)
        throw new Error("Invalid state for auth.");
      return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 3), this.cipherLen += l.length, this.poly.update(l), l;
    }
    /**
     * Finalize the aead and generate a MAC.
     * @returns {Buffer} MAC
     */
    final() {
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      const l = Buffer.alloc(16);
      o(l, this.aadLen, 0), o(l, this.cipherLen, 8), this.mode === 0 && this._pad16(this.aadLen), this._pad16(this.cipherLen), this.poly.update(l);
      const h = this.poly.final();
      return this.destroy(), h;
    }
    /**
     * Destroy the context.
     */
    destroy() {
      this.chacha.destroy(), this.poly.destroy();
      for (let l = 0; l < 64; l++)
        this.key[l] = 0;
      return this.mode = -1, this.aadLen = 0, this.cipherLen = 0, this;
    }
    /**
     * Finalize and verify MAC against tag.
     * @param {Buffer} tag
     * @returns {Boolean}
     */
    verify(l) {
      r(Buffer.isBuffer(l)), r(l.length === 16);
      const h = this.final();
      let x = 0;
      for (let b = 0; b < 16; b++)
        x |= h[b] ^ l[b];
      return x - 1 >>> 31 !== 0;
    }
    /**
     * Pad a chunk before updating mac.
     * @private
     * @param {Number} size
     */
    _pad16(l) {
      const h = l & 15;
      h > 0 && this.poly.update(i.slice(0, 16 - h));
    }
    /**
     * Encrypt a piece of data.
     * @param {Buffer} key
     * @param {Buffer} iv
     * @param {Buffer} msg
     * @param {Buffer?} aad
     * @returns {Buffer} tag
     */
    static encrypt(l, h, x, b) {
      const g = new n();
      return g.init(l, h), b && g.aad(b), g.encrypt(x), g.final();
    }
    /**
     * Decrypt a piece of data.
     * @param {Buffer} key
     * @param {Buffer} iv
     * @param {Buffer} msg
     * @param {Buffer} tag
     * @param {Buffer?} aad
     * @returns {Boolean}
     */
    static decrypt(l, h, x, b, g) {
      const w = new n();
      return w.init(l, h), g && w.aad(g), w.decrypt(x), w.verify(b);
    }
    /**
     * Authenticate data without decrypting.
     * @param {Buffer} key
     * @param {Buffer} iv
     * @param {Buffer} msg
     * @param {Buffer} tag
     * @param {Buffer?} aad
     * @returns {Boolean}
     */
    static auth(l, h, x, b, g) {
      const w = new n();
      return w.init(l, h), g && w.aad(g), w.auth(x), w.verify(b);
    }
  }
  n.native = e.native;
  function c(d, l, h) {
    return d[h++] = l, l >>>= 8, d[h++] = l, l >>>= 8, d[h++] = l, l >>>= 8, d[h++] = l, h;
  }
  function o(d, l, h) {
    const x = l * 23283064365386963e-26 >>> 0, b = l >>> 0;
    return c(d, b, h + 0), c(d, x, h + 4), h + 8;
  }
  return Ea = n, Ea;
}
var au = { exports: {} }, Rs = {};
const Lp = {}, Kp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Lp
}, Symbol.toStringTag, { value: "Module" })), M0 = /* @__PURE__ */ zp(Kp);
/*!
 * random-openssl.js - random number generator for bcrypto
 * Copyright (c) 2014-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 */
var l2;
function $p() {
  if (l2)
    return Rs;
  l2 = 1;
  const r = _e, e = M0, t = e.randomFillSync.bind(e), i = new Uint32Array(16);
  let n = 0;
  function c(b) {
    r(b >>> 0 === b);
    const g = Buffer.alloc(b);
    return t(g, 0, b), g;
  }
  function o(b, g, w) {
    return r(Buffer.isBuffer(b)), g == null && (g = 0), r(g >>> 0 === g), w == null && (w = b.length - g), r(w >>> 0 === w), r(g + w <= b.length), t(b, g, w), b;
  }
  function d() {
    return n & 15 || (x(i), n = 0), i[n++];
  }
  function l(b, g) {
    r(b >>> 0 === b), r(g >>> 0 === g), r(g >= b);
    const w = g - b;
    if (w === 0)
      return b;
    const I = -w >>> 0;
    let B, y;
    do
      B = d(), y = B % w;
    while (B - y > I);
    return y + b;
  }
  let h = null;
  function x(b) {
    if (r(b != null && typeof b == "object"), r(b.buffer instanceof ArrayBuffer), h === null)
      try {
        t(new Uint32Array(1)), h = !0;
      } catch {
        h = !1;
      }
    h || (b = Buffer.from(b.buffer, b.byteOffset, b.byteLength)), t(b);
  }
  return Rs.native = 1, Rs.randomBytes = c, Rs.randomFill = o, Rs.randomInt = d, Rs.randomRange = l, Rs;
}
var ls = {};
/*!
 * loady.js - dynamic loader for node.js
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/loady
 */
var Ia, x2;
function o8() {
  if (x2)
    return Ia;
  x2 = 1;
  const r = M0, e = M0, t = [
    "Debug",
    "Release",
    "MinSizeRel",
    "RelWithDebInfo"
  ];
  function i(h, x) {
    if (typeof h != "string")
      throw new TypeError('"name" must be a string.');
    if (typeof x != "string")
      throw new TypeError('"root" must be a string.');
    if (!r.existsSync)
      throw l(h);
    e.extname(h) !== ".node" && (h += ".node"), x = o(x);
    const b = `${h}\0${x}`;
    if (i.cache[b])
      return i.cache[b];
    if (process.pkg && !c(h) && (h = e.resolve(process.execPath, "..", h)), c(h)) {
      const g = e.resolve(x, h);
      if (!r.existsSync(g))
        throw l(g);
      const w = d(g);
      return i.cache[b] = w, w;
    }
    for (; ; ) {
      const g = e.join(x, "build");
      if (r.existsSync(g)) {
        const I = [e.join(g, h)];
        for (const B of t)
          I.push(e.join(g, B, h));
        for (const B of I)
          if (r.existsSync(B)) {
            const y = d(B);
            return i.cache[b] = y, y;
          }
      }
      const w = e.dirname(x);
      if (w === x)
        break;
      x = w;
    }
    throw l(h);
  }
  i.cache = /* @__PURE__ */ Object.create(null);
  function n(h, x) {
    const b = i(h, x);
    if (n.cache[b])
      return n.cache[b];
    if (!process.dlopen)
      throw new Error(`${h}: cannot open shared object file`);
    const g = { exports: {} };
    return process.dlopen(g, b), n.cache[b] = g.exports, g.exports;
  }
  n.cache = /* @__PURE__ */ Object.create(null);
  function c(h) {
    return process.platform === "win32" && (h = h.replace("\\", "/")), h[0] === "/" || h.startsWith("./") || h.startsWith("../");
  }
  function o(h) {
    if (h.indexOf("file:") === 0) {
      const x = M0;
      if (!x.fileURLToPath)
        throw new Error("File URLs are unsupported on this platform.");
      return e.resolve(x.fileURLToPath(h), "..");
    }
    return e.resolve(h);
  }
  function d(h) {
    try {
      return r.realpathSync(h);
    } catch {
      return e.resolve(h);
    }
  }
  function l(h) {
    const x = new Error(`Cannot find module '${h}'`);
    throw x.code = "MODULE_NOT_FOUND", x;
  }
  return n.load = n, n.resolve = i, Ia = n, Ia;
}
/*!
 * random-torsion.js - random number generator for bcrypto
 * Copyright (c) 2014-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var b2;
function Hp() {
  if (b2)
    return ls;
  b2 = 1;
  const r = _e, e = o8()("bcrypto", __dirname);
  function t(d) {
    r(d >>> 0 === d);
    const l = Buffer.alloc(d);
    return e.getrandom(l, 0, d);
  }
  function i(d, l, h) {
    return r(Buffer.isBuffer(d)), l == null && (l = 0), r(l >>> 0 === l), h == null && (h = d.length - l), r(h >>> 0 === h), e.getrandom(d, l, h);
  }
  function n() {
    return e.random();
  }
  function c(d, l) {
    return r(d >>> 0 === d), r(l >>> 0 === l), r(l >= d), d + e.uniform(l - d);
  }
  function o(d) {
    r(d >>> 0 === d);
    const l = Buffer.alloc(d);
    return e.getentropy(l, 0, d);
  }
  return ls.native = 2, ls.randomBytes = t, ls.randomFill = i, ls.randomInt = n, ls.randomRange = c, ls._getEntropy = o, ls;
}
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.BCRYPTO_FORCE_TORSION !== "1" ? au.exports = $p() : au.exports = Hp();
var a8 = au.exports;
/*!
 * binding.js - bindings for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Aa, p2;
function Dt() {
  if (p2)
    return Aa;
  p2 = 1;
  const r = _e, e = a8, t = o8()("bcrypto", __dirname);
  t.hashes = {
    __proto__: null,
    NONE: 0,
    BLAKE2B160: 1,
    BLAKE2B256: 2,
    BLAKE2B384: 3,
    BLAKE2B512: 4,
    BLAKE2S128: 5,
    BLAKE2S160: 6,
    BLAKE2S224: 7,
    BLAKE2S256: 8,
    GOST94: 9,
    HASH160: 10,
    HASH256: 11,
    KECCAK224: 12,
    KECCAK256: 13,
    KECCAK384: 14,
    KECCAK512: 15,
    MD2: 16,
    MD4: 17,
    MD5: 18,
    MD5SHA1: 19,
    RIPEMD160: 20,
    SHA1: 21,
    SHA224: 22,
    SHA256: 23,
    SHA384: 24,
    SHA512: 25,
    SHA3_224: 26,
    SHA3_256: 27,
    SHA3_384: 28,
    SHA3_512: 29,
    SHAKE128: 30,
    SHAKE256: 31,
    WHIRLPOOL: 32
  }, t.curves = {
    wei: {
      __proto__: null,
      P192: 0,
      P224: 1,
      P256: 2,
      P384: 3,
      P521: 4,
      SECP256K1: 5
    },
    mont: {
      __proto__: null,
      X25519: 0,
      X448: 1
    },
    edwards: {
      __proto__: null,
      ED25519: 0,
      ED448: 1,
      ED1174: 2
    }
  }, t.ciphers = {
    __proto__: null,
    AES128: 0,
    AES192: 1,
    AES256: 2,
    ARC2: 3,
    ARC2_GUTMANN: 4,
    ARC2_40: 5,
    ARC2_64: 6,
    ARC2_128: 7,
    ARC2_128_GUTMANN: 8,
    BLOWFISH: 9,
    CAMELLIA128: 10,
    CAMELLIA192: 11,
    CAMELLIA256: 12,
    CAST5: 13,
    DES: 14,
    DES_EDE: 15,
    DES_EDE3: 16,
    IDEA: 17,
    SERPENT128: 18,
    SERPENT192: 19,
    SERPENT256: 20,
    TWOFISH128: 21,
    TWOFISH192: 22,
    TWOFISH256: 23
  }, t.modes = {
    __proto__: null,
    RAW: 0,
    ECB: 1,
    CBC: 2,
    CTS: 3,
    XTS: 4,
    CTR: 5,
    CFB: 6,
    OFB: 7,
    GCM: 8,
    CCM: 9,
    EAX: 10
  }, t.algorithms = {
    __proto__: null,
    "AES-128": 0,
    "AES-192": 1,
    "AES-256": 2,
    ARC2: 3,
    "ARC2-GUTMANN": 4,
    "ARC2-40": 5,
    "ARC2-64": 6,
    "ARC2-128": 7,
    "ARC2-128-GUTMANN": 8,
    BF: 9,
    BLOWFISH: 9,
    "CAMELLIA-128": 10,
    "CAMELLIA-192": 11,
    "CAMELLIA-256": 12,
    CAST5: 13,
    DES: 14,
    "DES-EDE": 15,
    "DES-EDE3": 16,
    IDEA: 17,
    "SERPENT-128": 18,
    "SERPENT-192": 19,
    "SERPENT-256": 20,
    "TWOFISH-128": 21,
    "TWOFISH-192": 22,
    "TWOFISH-256": 23
  }, t.NULL = Buffer.alloc(0), t.ternary = function(o) {
    return o == null ? -1 : (r(typeof o == "boolean"), o | 0);
  }, t.hash = function(o) {
    r(o && typeof o.id == "string");
    const d = t.hashes[o.id];
    return r(d >>> 0 === d), d;
  };
  const i = {
    wei: {
      __proto__: null
    },
    mont: {
      __proto__: null
    },
    edwards: {
      __proto__: null
    }
  };
  t.curve = function(o, d) {
    r(typeof o == "string"), r(typeof d == "string");
    const l = i[o];
    if (r(l), l[d])
      return l[d];
    const h = t.curves[o];
    r(h);
    const x = h[d];
    r(x >>> 0 === x);
    let b;
    switch (o) {
      case "wei":
        b = t.wei_curve_create(x), t.wei_curve_randomize(b, t.entropy());
        break;
      case "mont":
        b = t.mont_curve_create(x);
        break;
      case "edwards":
        b = t.edwards_curve_create(x), t.edwards_curve_randomize(b, t.entropy());
        break;
    }
    return l[d] = b, b;
  };
  let n = null;
  return t.secp256k1 = function() {
    return n || (n = t.secp256k1_context_create(), t.secp256k1_context_randomize(n, t.entropy(32))), n;
  }, t.entropy = function(o = t.ENTROPY_SIZE) {
    return e.randomBytes(o);
  }, t.hint = function() {
    return e.randomInt() & 65535;
  }, t.copy = function(o) {
    r(Buffer.isBuffer(o));
    const d = Buffer.allocUnsafeSlow(o.length);
    return r(o.copy(d, 0) === o.length), d;
  }, t.encode = function(o) {
    r(Array.isArray(o));
    let d = 0;
    for (const x of o)
      r(x == null || Buffer.isBuffer(x)), d += 2, x && (r(x.length <= 65535), d += x.length);
    const l = Buffer.allocUnsafeSlow(d);
    let h = 0;
    for (const x of o) {
      if (!x) {
        l[h++] = 0, l[h++] = 0;
        continue;
      }
      l[h++] = x.length >> 8, l[h++] = x.length, h += x.copy(l, h);
    }
    return r(h === d), l;
  }, t.decode = function(o, d) {
    r(Buffer.isBuffer(o)), r(d >>> 0 === d);
    const l = new Array(d);
    let h = 0;
    for (let x = 0; x < d; x++) {
      r(h + 2 <= o.length);
      const b = o[h++] * 256 + o[h++];
      r(h + b <= o.length);
      const g = Buffer.allocUnsafeSlow(b);
      r(o.copy(g, 0, h, h + b) === b), l[x] = g, h += b;
    }
    return r(h === o.length), t.cleanse(o), l;
  }, Aa = t, Aa;
}
/*!
 * aead.js - aead for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var _a, m2;
function Fp() {
  if (m2)
    return _a;
  m2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor() {
      this._handle = e.aead_create();
    }
    init(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.aead_init(this._handle, n, c), this;
    }
    aad(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.aead_aad(this._handle, n), this;
    }
    encrypt(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.aead_encrypt(this._handle, n), n;
    }
    decrypt(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.aead_decrypt(this._handle, n), n;
    }
    auth(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.aead_auth(this._handle, n), n;
    }
    final() {
      return r(this instanceof t), e.aead_final(this._handle);
    }
    destroy() {
      return r(this instanceof t), e.aead_destroy(this._handle), this;
    }
    verify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.aead_verify(this._handle, n);
    }
    static encrypt(n, c, o, d) {
      return d == null && (d = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), e.aead_static_encrypt(n, c, o, d);
    }
    static decrypt(n, c, o, d, l) {
      return l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), e.aead_static_decrypt(n, c, o, d, l);
    }
    static auth(n, c, o, d, l) {
      return l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), e.aead_static_auth(n, c, o, d, l);
    }
  }
  return t.native = 2, _a = t, _a;
}
/*!
 * aead.js - aead for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? ou.exports = Dp() : ou.exports = Fp();
var Vp = ou.exports, hu = { exports: {} }, tf = {};
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on openssl/openssl:
 *   Based on code entered into the public domain by Vincent Rijmen.
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 */
var Ma, g2;
function G1() {
  if (g2)
    return Ma;
  g2 = 1;
  const r = _e, e = new Uint32Array([
    3328402341,
    4168907908,
    4000806809,
    4135287693,
    4294111757,
    3597364157,
    3731845041,
    2445657428,
    1613770832,
    33620227,
    3462883241,
    1445669757,
    3892248089,
    3050821474,
    1303096294,
    3967186586,
    2412431941,
    528646813,
    2311702848,
    4202528135,
    4026202645,
    2992200171,
    2387036105,
    4226871307,
    1101901292,
    3017069671,
    1604494077,
    1169141738,
    597466303,
    1403299063,
    3832705686,
    2613100635,
    1974974402,
    3791519004,
    1033081774,
    1277568618,
    1815492186,
    2118074177,
    4126668546,
    2211236943,
    1748251740,
    1369810420,
    3521504564,
    4193382664,
    3799085459,
    2883115123,
    1647391059,
    706024767,
    134480908,
    2512897874,
    1176707941,
    2646852446,
    806885416,
    932615841,
    168101135,
    798661301,
    235341577,
    605164086,
    461406363,
    3756188221,
    3454790438,
    1311188841,
    2142417613,
    3933566367,
    302582043,
    495158174,
    1479289972,
    874125870,
    907746093,
    3698224818,
    3025820398,
    1537253627,
    2756858614,
    1983593293,
    3084310113,
    2108928974,
    1378429307,
    3722699582,
    1580150641,
    327451799,
    2790478837,
    3117535592,
    0,
    3253595436,
    1075847264,
    3825007647,
    2041688520,
    3059440621,
    3563743934,
    2378943302,
    1740553945,
    1916352843,
    2487896798,
    2555137236,
    2958579944,
    2244988746,
    3151024235,
    3320835882,
    1336584933,
    3992714006,
    2252555205,
    2588757463,
    1714631509,
    293963156,
    2319795663,
    3925473552,
    67240454,
    4269768577,
    2689618160,
    2017213508,
    631218106,
    1269344483,
    2723238387,
    1571005438,
    2151694528,
    93294474,
    1066570413,
    563977660,
    1882732616,
    4059428100,
    1673313503,
    2008463041,
    2950355573,
    1109467491,
    537923632,
    3858759450,
    4260623118,
    3218264685,
    2177748300,
    403442708,
    638784309,
    3287084079,
    3193921505,
    899127202,
    2286175436,
    773265209,
    2479146071,
    1437050866,
    4236148354,
    2050833735,
    3362022572,
    3126681063,
    840505643,
    3866325909,
    3227541664,
    427917720,
    2655997905,
    2749160575,
    1143087718,
    1412049534,
    999329963,
    193497219,
    2353415882,
    3354324521,
    1807268051,
    672404540,
    2816401017,
    3160301282,
    369822493,
    2916866934,
    3688947771,
    1681011286,
    1949973070,
    336202270,
    2454276571,
    201721354,
    1210328172,
    3093060836,
    2680341085,
    3184776046,
    1135389935,
    3294782118,
    965841320,
    831886756,
    3554993207,
    4068047243,
    3588745010,
    2345191491,
    1849112409,
    3664604599,
    26054028,
    2983581028,
    2622377682,
    1235855840,
    3630984372,
    2891339514,
    4092916743,
    3488279077,
    3395642799,
    4101667470,
    1202630377,
    268961816,
    1874508501,
    4034427016,
    1243948399,
    1546530418,
    941366308,
    1470539505,
    1941222599,
    2546386513,
    3421038627,
    2715671932,
    3899946140,
    1042226977,
    2521517021,
    1639824860,
    227249030,
    260737669,
    3765465232,
    2084453954,
    1907733956,
    3429263018,
    2420656344,
    100860677,
    4160157185,
    470683154,
    3261161891,
    1781871967,
    2924959737,
    1773779408,
    394692241,
    2579611992,
    974986535,
    664706745,
    3655459128,
    3958962195,
    731420851,
    571543859,
    3530123707,
    2849626480,
    126783113,
    865375399,
    765172662,
    1008606754,
    361203602,
    3387549984,
    2278477385,
    2857719295,
    1344809080,
    2782912378,
    59542671,
    1503764984,
    160008576,
    437062935,
    1707065306,
    3622233649,
    2218934982,
    3496503480,
    2185314755,
    697932208,
    1512910199,
    504303377,
    2075177163,
    2824099068,
    1841019862,
    739644986
  ]), t = new Uint32Array([
    2781242211,
    2230877308,
    2582542199,
    2381740923,
    234877682,
    3184946027,
    2984144751,
    1418839493,
    1348481072,
    50462977,
    2848876391,
    2102799147,
    434634494,
    1656084439,
    3863849899,
    2599188086,
    1167051466,
    2636087938,
    1082771913,
    2281340285,
    368048890,
    3954334041,
    3381544775,
    201060592,
    3963727277,
    1739838676,
    4250903202,
    3930435503,
    3206782108,
    4149453988,
    2531553906,
    1536934080,
    3262494647,
    484572669,
    2923271059,
    1783375398,
    1517041206,
    1098792767,
    49674231,
    1334037708,
    1550332980,
    4098991525,
    886171109,
    150598129,
    2481090929,
    1940642008,
    1398944049,
    1059722517,
    201851908,
    1385547719,
    1699095331,
    1587397571,
    674240536,
    2704774806,
    252314885,
    3039795866,
    151914247,
    908333586,
    2602270848,
    1038082786,
    651029483,
    1766729511,
    3447698098,
    2682942837,
    454166793,
    2652734339,
    1951935532,
    775166490,
    758520603,
    3000790638,
    4004797018,
    4217086112,
    4137964114,
    1299594043,
    1639438038,
    3464344499,
    2068982057,
    1054729187,
    1901997871,
    2534638724,
    4121318227,
    1757008337,
    0,
    750906861,
    1614815264,
    535035132,
    3363418545,
    3988151131,
    3201591914,
    1183697867,
    3647454910,
    1265776953,
    3734260298,
    3566750796,
    3903871064,
    1250283471,
    1807470800,
    717615087,
    3847203498,
    384695291,
    3313910595,
    3617213773,
    1432761139,
    2484176261,
    3481945413,
    283769337,
    100925954,
    2180939647,
    4037038160,
    1148730428,
    3123027871,
    3813386408,
    4087501137,
    4267549603,
    3229630528,
    2315620239,
    2906624658,
    3156319645,
    1215313976,
    82966005,
    3747855548,
    3245848246,
    1974459098,
    1665278241,
    807407632,
    451280895,
    251524083,
    1841287890,
    1283575245,
    337120268,
    891687699,
    801369324,
    3787349855,
    2721421207,
    3431482436,
    959321879,
    1469301956,
    4065699751,
    2197585534,
    1199193405,
    2898814052,
    3887750493,
    724703513,
    2514908019,
    2696962144,
    2551808385,
    3516813135,
    2141445340,
    1715741218,
    2119445034,
    2872807568,
    2198571144,
    3398190662,
    700968686,
    3547052216,
    1009259540,
    2041044702,
    3803995742,
    487983883,
    1991105499,
    1004265696,
    1449407026,
    1316239930,
    504629770,
    3683797321,
    168560134,
    1816667172,
    3837287516,
    1570751170,
    1857934291,
    4014189740,
    2797888098,
    2822345105,
    2754712981,
    936633572,
    2347923833,
    852879335,
    1133234376,
    1500395319,
    3084545389,
    2348912013,
    1689376213,
    3533459022,
    3762923945,
    3034082412,
    4205598294,
    133428468,
    634383082,
    2949277029,
    2398386810,
    3913789102,
    403703816,
    3580869306,
    2297460856,
    1867130149,
    1918643758,
    607656988,
    4049053350,
    3346248884,
    1368901318,
    600565992,
    2090982877,
    2632479860,
    557719327,
    3717614411,
    3697393085,
    2249034635,
    2232388234,
    2430627952,
    1115438654,
    3295786421,
    2865522278,
    3633334344,
    84280067,
    33027830,
    303828494,
    2747425121,
    1600795957,
    4188952407,
    3496589753,
    2434238086,
    1486471617,
    658119965,
    3106381470,
    953803233,
    334231800,
    3005978776,
    857870609,
    3151128937,
    1890179545,
    2298973838,
    2805175444,
    3056442267,
    574365214,
    2450884487,
    550103529,
    1233637070,
    4289353045,
    2018519080,
    2057691103,
    2399374476,
    4166623649,
    2148108681,
    387583245,
    3664101311,
    836232934,
    3330556482,
    3100665960,
    3280093505,
    2955516313,
    2002398509,
    287182607,
    3413881008,
    4238890068,
    3597515707,
    975967766
  ]), i = new Uint32Array([
    1671808611,
    2089089148,
    2006576759,
    2072901243,
    4061003762,
    1807603307,
    1873927791,
    3310653893,
    810573872,
    16974337,
    1739181671,
    729634347,
    4263110654,
    3613570519,
    2883997099,
    1989864566,
    3393556426,
    2191335298,
    3376449993,
    2106063485,
    4195741690,
    1508618841,
    1204391495,
    4027317232,
    2917941677,
    3563566036,
    2734514082,
    2951366063,
    2629772188,
    2767672228,
    1922491506,
    3227229120,
    3082974647,
    4246528509,
    2477669779,
    644500518,
    911895606,
    1061256767,
    4144166391,
    3427763148,
    878471220,
    2784252325,
    3845444069,
    4043897329,
    1905517169,
    3631459288,
    827548209,
    356461077,
    67897348,
    3344078279,
    593839651,
    3277757891,
    405286936,
    2527147926,
    84871685,
    2595565466,
    118033927,
    305538066,
    2157648768,
    3795705826,
    3945188843,
    661212711,
    2999812018,
    1973414517,
    152769033,
    2208177539,
    745822252,
    439235610,
    455947803,
    1857215598,
    1525593178,
    2700827552,
    1391895634,
    994932283,
    3596728278,
    3016654259,
    695947817,
    3812548067,
    795958831,
    2224493444,
    1408607827,
    3513301457,
    0,
    3979133421,
    543178784,
    4229948412,
    2982705585,
    1542305371,
    1790891114,
    3410398667,
    3201918910,
    961245753,
    1256100938,
    1289001036,
    1491644504,
    3477767631,
    3496721360,
    4012557807,
    2867154858,
    4212583931,
    1137018435,
    1305975373,
    861234739,
    2241073541,
    1171229253,
    4178635257,
    33948674,
    2139225727,
    1357946960,
    1011120188,
    2679776671,
    2833468328,
    1374921297,
    2751356323,
    1086357568,
    2408187279,
    2460827538,
    2646352285,
    944271416,
    4110742005,
    3168756668,
    3066132406,
    3665145818,
    560153121,
    271589392,
    4279952895,
    4077846003,
    3530407890,
    3444343245,
    202643468,
    322250259,
    3962553324,
    1608629855,
    2543990167,
    1154254916,
    389623319,
    3294073796,
    2817676711,
    2122513534,
    1028094525,
    1689045092,
    1575467613,
    422261273,
    1939203699,
    1621147744,
    2174228865,
    1339137615,
    3699352540,
    577127458,
    712922154,
    2427141008,
    2290289544,
    1187679302,
    3995715566,
    3100863416,
    339486740,
    3732514782,
    1591917662,
    186455563,
    3681988059,
    3762019296,
    844522546,
    978220090,
    169743370,
    1239126601,
    101321734,
    611076132,
    1558493276,
    3260915650,
    3547250131,
    2901361580,
    1655096418,
    2443721105,
    2510565781,
    3828863972,
    2039214713,
    3878868455,
    3359869896,
    928607799,
    1840765549,
    2374762893,
    3580146133,
    1322425422,
    2850048425,
    1823791212,
    1459268694,
    4094161908,
    3928346602,
    1706019429,
    2056189050,
    2934523822,
    135794696,
    3134549946,
    2022240376,
    628050469,
    779246638,
    472135708,
    2800834470,
    3032970164,
    3327236038,
    3894660072,
    3715932637,
    1956440180,
    522272287,
    1272813131,
    3185336765,
    2340818315,
    2323976074,
    1888542832,
    1044544574,
    3049550261,
    1722469478,
    1222152264,
    50660867,
    4127324150,
    236067854,
    1638122081,
    895445557,
    1475980887,
    3117443513,
    2257655686,
    3243809217,
    489110045,
    2662934430,
    3778599393,
    4162055160,
    2561878936,
    288563729,
    1773916777,
    3648039385,
    2391345038,
    2493985684,
    2612407707,
    505560094,
    2274497927,
    3911240169,
    3460925390,
    1442818645,
    678973480,
    3749357023,
    2358182796,
    2717407649,
    2306869641,
    219617805,
    3218761151,
    3862026214,
    1120306242,
    1756942440,
    1103331905,
    2578459033,
    762796589,
    252780047,
    2966125488,
    1425844308,
    3151392187,
    372911126
  ]), n = new Uint32Array([
    1667474886,
    2088535288,
    2004326894,
    2071694838,
    4075949567,
    1802223062,
    1869591006,
    3318043793,
    808472672,
    16843522,
    1734846926,
    724270422,
    4278065639,
    3621216949,
    2880169549,
    1987484396,
    3402253711,
    2189597983,
    3385409673,
    2105378810,
    4210693615,
    1499065266,
    1195886990,
    4042263547,
    2913856577,
    3570689971,
    2728590687,
    2947541573,
    2627518243,
    2762274643,
    1920112356,
    3233831835,
    3082273397,
    4261223649,
    2475929149,
    640051788,
    909531756,
    1061110142,
    4160160501,
    3435941763,
    875846760,
    2779116625,
    3857003729,
    4059105529,
    1903268834,
    3638064043,
    825316194,
    353713962,
    67374088,
    3351728789,
    589522246,
    3284360861,
    404236336,
    2526454071,
    84217610,
    2593830191,
    117901582,
    303183396,
    2155911963,
    3806477791,
    3958056653,
    656894286,
    2998062463,
    1970642922,
    151591698,
    2206440989,
    741110872,
    437923380,
    454765878,
    1852748508,
    1515908788,
    2694904667,
    1381168804,
    993742198,
    3604373943,
    3014905469,
    690584402,
    3823320797,
    791638366,
    2223281939,
    1398011302,
    3520161977,
    0,
    3991743681,
    538992704,
    4244381667,
    2981218425,
    1532751286,
    1785380564,
    3419096717,
    3200178535,
    960056178,
    1246420628,
    1280103576,
    1482221744,
    3486468741,
    3503319995,
    4025428677,
    2863326543,
    4227536621,
    1128514950,
    1296947098,
    859002214,
    2240123921,
    1162203018,
    4193849577,
    33687044,
    2139062782,
    1347481760,
    1010582648,
    2678045221,
    2829640523,
    1364325282,
    2745433693,
    1077985408,
    2408548869,
    2459086143,
    2644360225,
    943212656,
    4126475505,
    3166494563,
    3065430391,
    3671750063,
    555836226,
    269496352,
    4294908645,
    4092792573,
    3537006015,
    3452783745,
    202118168,
    320025894,
    3974901699,
    1600119230,
    2543297077,
    1145359496,
    387397934,
    3301201811,
    2812801621,
    2122220284,
    1027426170,
    1684319432,
    1566435258,
    421079858,
    1936954854,
    1616945344,
    2172753945,
    1330631070,
    3705438115,
    572679748,
    707427924,
    2425400123,
    2290647819,
    1179044492,
    4008585671,
    3099120491,
    336870440,
    3739122087,
    1583276732,
    185277718,
    3688593069,
    3772791771,
    842159716,
    976899700,
    168435220,
    1229577106,
    101059084,
    606366792,
    1549591736,
    3267517855,
    3553849021,
    2897014595,
    1650632388,
    2442242105,
    2509612081,
    3840161747,
    2038008818,
    3890688725,
    3368567691,
    926374254,
    1835907034,
    2374863873,
    3587531953,
    1313788572,
    2846482505,
    1819063512,
    1448540844,
    4109633523,
    3941213647,
    1701162954,
    2054852340,
    2930698567,
    134748176,
    3132806511,
    2021165296,
    623210314,
    774795868,
    471606328,
    2795958615,
    3031746419,
    3334885783,
    3907527627,
    3722280097,
    1953799400,
    522133822,
    1263263126,
    3183336545,
    2341176845,
    2324333839,
    1886425312,
    1044267644,
    3048588401,
    1718004428,
    1212733584,
    50529542,
    4143317495,
    235803164,
    1633788866,
    892690282,
    1465383342,
    3115962473,
    2256965911,
    3250673817,
    488449850,
    2661202215,
    3789633753,
    4177007595,
    2560144171,
    286339874,
    1768537042,
    3654906025,
    2391705863,
    2492770099,
    2610673197,
    505291324,
    2273808917,
    3924369609,
    3469625735,
    1431699370,
    673740880,
    3755965093,
    2358021891,
    2711746649,
    2307489801,
    218961690,
    3217021541,
    3873845719,
    1111672452,
    1751693520,
    1094828930,
    2576986153,
    757954394,
    252645662,
    2964376443,
    1414855848,
    3149649517,
    370555436
  ]), c = new Uint32Array([
    1374988112,
    2118214995,
    437757123,
    975658646,
    1001089995,
    530400753,
    2902087851,
    1273168787,
    540080725,
    2910219766,
    2295101073,
    4110568485,
    1340463100,
    3307916247,
    641025152,
    3043140495,
    3736164937,
    632953703,
    1172967064,
    1576976609,
    3274667266,
    2169303058,
    2370213795,
    1809054150,
    59727847,
    361929877,
    3211623147,
    2505202138,
    3569255213,
    1484005843,
    1239443753,
    2395588676,
    1975683434,
    4102977912,
    2572697195,
    666464733,
    3202437046,
    4035489047,
    3374361702,
    2110667444,
    1675577880,
    3843699074,
    2538681184,
    1649639237,
    2976151520,
    3144396420,
    4269907996,
    4178062228,
    1883793496,
    2403728665,
    2497604743,
    1383856311,
    2876494627,
    1917518562,
    3810496343,
    1716890410,
    3001755655,
    800440835,
    2261089178,
    3543599269,
    807962610,
    599762354,
    33778362,
    3977675356,
    2328828971,
    2809771154,
    4077384432,
    1315562145,
    1708848333,
    101039829,
    3509871135,
    3299278474,
    875451293,
    2733856160,
    92987698,
    2767645557,
    193195065,
    1080094634,
    1584504582,
    3178106961,
    1042385657,
    2531067453,
    3711829422,
    1306967366,
    2438237621,
    1908694277,
    67556463,
    1615861247,
    429456164,
    3602770327,
    2302690252,
    1742315127,
    2968011453,
    126454664,
    3877198648,
    2043211483,
    2709260871,
    2084704233,
    4169408201,
    0,
    159417987,
    841739592,
    504459436,
    1817866830,
    4245618683,
    260388950,
    1034867998,
    908933415,
    168810852,
    1750902305,
    2606453969,
    607530554,
    202008497,
    2472011535,
    3035535058,
    463180190,
    2160117071,
    1641816226,
    1517767529,
    470948374,
    3801332234,
    3231722213,
    1008918595,
    303765277,
    235474187,
    4069246893,
    766945465,
    337553864,
    1475418501,
    2943682380,
    4003061179,
    2743034109,
    4144047775,
    1551037884,
    1147550661,
    1543208500,
    2336434550,
    3408119516,
    3069049960,
    3102011747,
    3610369226,
    1113818384,
    328671808,
    2227573024,
    2236228733,
    3535486456,
    2935566865,
    3341394285,
    496906059,
    3702665459,
    226906860,
    2009195472,
    733156972,
    2842737049,
    294930682,
    1206477858,
    2835123396,
    2700099354,
    1451044056,
    573804783,
    2269728455,
    3644379585,
    2362090238,
    2564033334,
    2801107407,
    2776292904,
    3669462566,
    1068351396,
    742039012,
    1350078989,
    1784663195,
    1417561698,
    4136440770,
    2430122216,
    775550814,
    2193862645,
    2673705150,
    1775276924,
    1876241833,
    3475313331,
    3366754619,
    270040487,
    3902563182,
    3678124923,
    3441850377,
    1851332852,
    3969562369,
    2203032232,
    3868552805,
    2868897406,
    566021896,
    4011190502,
    3135740889,
    1248802510,
    3936291284,
    699432150,
    832877231,
    708780849,
    3332740144,
    899835584,
    1951317047,
    4236429990,
    3767586992,
    866637845,
    4043610186,
    1106041591,
    2144161806,
    395441711,
    1984812685,
    1139781709,
    3433712980,
    3835036895,
    2664543715,
    1282050075,
    3240894392,
    1181045119,
    2640243204,
    25965917,
    4203181171,
    4211818798,
    3009879386,
    2463879762,
    3910161971,
    1842759443,
    2597806476,
    933301370,
    1509430414,
    3943906441,
    3467192302,
    3076639029,
    3776767469,
    2051518780,
    2631065433,
    1441952575,
    404016761,
    1942435775,
    1408749034,
    1610459739,
    3745345300,
    2017778566,
    3400528769,
    3110650942,
    941896748,
    3265478751,
    371049330,
    3168937228,
    675039627,
    4279080257,
    967311729,
    135050206,
    3635733660,
    1683407248,
    2076935265,
    3576870512,
    1215061108,
    3501741890
  ]), o = new Uint32Array([
    1347548327,
    1400783205,
    3273267108,
    2520393566,
    3409685355,
    4045380933,
    2880240216,
    2471224067,
    1428173050,
    4138563181,
    2441661558,
    636813900,
    4233094615,
    3620022987,
    2149987652,
    2411029155,
    1239331162,
    1730525723,
    2554718734,
    3781033664,
    46346101,
    310463728,
    2743944855,
    3328955385,
    3875770207,
    2501218972,
    3955191162,
    3667219033,
    768917123,
    3545789473,
    692707433,
    1150208456,
    1786102409,
    2029293177,
    1805211710,
    3710368113,
    3065962831,
    401639597,
    1724457132,
    3028143674,
    409198410,
    2196052529,
    1620529459,
    1164071807,
    3769721975,
    2226875310,
    486441376,
    2499348523,
    1483753576,
    428819965,
    2274680428,
    3075636216,
    598438867,
    3799141122,
    1474502543,
    711349675,
    129166120,
    53458370,
    2592523643,
    2782082824,
    4063242375,
    2988687269,
    3120694122,
    1559041666,
    730517276,
    2460449204,
    4042459122,
    2706270690,
    3446004468,
    3573941694,
    533804130,
    2328143614,
    2637442643,
    2695033685,
    839224033,
    1973745387,
    957055980,
    2856345839,
    106852767,
    1371368976,
    4181598602,
    1033297158,
    2933734917,
    1179510461,
    3046200461,
    91341917,
    1862534868,
    4284502037,
    605657339,
    2547432937,
    3431546947,
    2003294622,
    3182487618,
    2282195339,
    954669403,
    3682191598,
    1201765386,
    3917234703,
    3388507166,
    0,
    2198438022,
    1211247597,
    2887651696,
    1315723890,
    4227665663,
    1443857720,
    507358933,
    657861945,
    1678381017,
    560487590,
    3516619604,
    975451694,
    2970356327,
    261314535,
    3535072918,
    2652609425,
    1333838021,
    2724322336,
    1767536459,
    370938394,
    182621114,
    3854606378,
    1128014560,
    487725847,
    185469197,
    2918353863,
    3106780840,
    3356761769,
    2237133081,
    1286567175,
    3152976349,
    4255350624,
    2683765030,
    3160175349,
    3309594171,
    878443390,
    1988838185,
    3704300486,
    1756818940,
    1673061617,
    3403100636,
    272786309,
    1075025698,
    545572369,
    2105887268,
    4174560061,
    296679730,
    1841768865,
    1260232239,
    4091327024,
    3960309330,
    3497509347,
    1814803222,
    2578018489,
    4195456072,
    575138148,
    3299409036,
    446754879,
    3629546796,
    4011996048,
    3347532110,
    3252238545,
    4270639778,
    915985419,
    3483825537,
    681933534,
    651868046,
    2755636671,
    3828103837,
    223377554,
    2607439820,
    1649704518,
    3270937875,
    3901806776,
    1580087799,
    4118987695,
    3198115200,
    2087309459,
    2842678573,
    3016697106,
    1003007129,
    2802849917,
    1860738147,
    2077965243,
    164439672,
    4100872472,
    32283319,
    2827177882,
    1709610350,
    2125135846,
    136428751,
    3874428392,
    3652904859,
    3460984630,
    3572145929,
    3593056380,
    2939266226,
    824852259,
    818324884,
    3224740454,
    930369212,
    2801566410,
    2967507152,
    355706840,
    1257309336,
    4148292826,
    243256656,
    790073846,
    2373340630,
    1296297904,
    1422699085,
    3756299780,
    3818836405,
    457992840,
    3099667487,
    2135319889,
    77422314,
    1560382517,
    1945798516,
    788204353,
    1521706781,
    1385356242,
    870912086,
    325965383,
    2358957921,
    2050466060,
    2388260884,
    2313884476,
    4006521127,
    901210569,
    3990953189,
    1014646705,
    1503449823,
    1062597235,
    2031621326,
    3212035895,
    3931371469,
    1533017514,
    350174575,
    2256028891,
    2177544179,
    1052338372,
    741876788,
    1606591296,
    1914052035,
    213705253,
    2334669897,
    1107234197,
    1899603969,
    3725069491,
    2631447780,
    2422494913,
    1635502980,
    1893020342,
    1950903388,
    1120974935
  ]), d = new Uint32Array([
    2807058932,
    1699970625,
    2764249623,
    1586903591,
    1808481195,
    1173430173,
    1487645946,
    59984867,
    4199882800,
    1844882806,
    1989249228,
    1277555970,
    3623636965,
    3419915562,
    1149249077,
    2744104290,
    1514790577,
    459744698,
    244860394,
    3235995134,
    1963115311,
    4027744588,
    2544078150,
    4190530515,
    1608975247,
    2627016082,
    2062270317,
    1507497298,
    2200818878,
    567498868,
    1764313568,
    3359936201,
    2305455554,
    2037970062,
    1047239e3,
    1910319033,
    1337376481,
    2904027272,
    2892417312,
    984907214,
    1243112415,
    830661914,
    861968209,
    2135253587,
    2011214180,
    2927934315,
    2686254721,
    731183368,
    1750626376,
    4246310725,
    1820824798,
    4172763771,
    3542330227,
    48394827,
    2404901663,
    2871682645,
    671593195,
    3254988725,
    2073724613,
    145085239,
    2280796200,
    2779915199,
    1790575107,
    2187128086,
    472615631,
    3029510009,
    4075877127,
    3802222185,
    4107101658,
    3201631749,
    1646252340,
    4270507174,
    1402811438,
    1436590835,
    3778151818,
    3950355702,
    3963161475,
    4020912224,
    2667994737,
    273792366,
    2331590177,
    104699613,
    95345982,
    3175501286,
    2377486676,
    1560637892,
    3564045318,
    369057872,
    4213447064,
    3919042237,
    1137477952,
    2658625497,
    1119727848,
    2340947849,
    1530455833,
    4007360968,
    172466556,
    266959938,
    516552836,
    0,
    2256734592,
    3980931627,
    1890328081,
    1917742170,
    4294704398,
    945164165,
    3575528878,
    958871085,
    3647212047,
    2787207260,
    1423022939,
    775562294,
    1739656202,
    3876557655,
    2530391278,
    2443058075,
    3310321856,
    547512796,
    1265195639,
    437656594,
    3121275539,
    719700128,
    3762502690,
    387781147,
    218828297,
    3350065803,
    2830708150,
    2848461854,
    428169201,
    122466165,
    3720081049,
    1627235199,
    648017665,
    4122762354,
    1002783846,
    2117360635,
    695634755,
    3336358691,
    4234721005,
    4049844452,
    3704280881,
    2232435299,
    574624663,
    287343814,
    612205898,
    1039717051,
    840019705,
    2708326185,
    793451934,
    821288114,
    1391201670,
    3822090177,
    376187827,
    3113855344,
    1224348052,
    1679968233,
    2361698556,
    1058709744,
    752375421,
    2431590963,
    1321699145,
    3519142200,
    2734591178,
    188127444,
    2177869557,
    3727205754,
    2384911031,
    3215212461,
    2648976442,
    2450346104,
    3432737375,
    1180849278,
    331544205,
    3102249176,
    4150144569,
    2952102595,
    2159976285,
    2474404304,
    766078933,
    313773861,
    2570832044,
    2108100632,
    1668212892,
    3145456443,
    2013908262,
    418672217,
    3070356634,
    2594734927,
    1852171925,
    3867060991,
    3473416636,
    3907448597,
    2614737639,
    919489135,
    164948639,
    2094410160,
    2997825956,
    590424639,
    2486224549,
    1723872674,
    3157750862,
    3399941250,
    3501252752,
    3625268135,
    2555048196,
    3673637356,
    1343127501,
    4130281361,
    3599595085,
    2957853679,
    1297403050,
    81781910,
    3051593425,
    2283490410,
    532201772,
    1367295589,
    3926170974,
    895287692,
    1953757831,
    1093597963,
    492483431,
    3528626907,
    1446242576,
    1192455638,
    1636604631,
    209336225,
    344873464,
    1015671571,
    669961897,
    3375740769,
    3857572124,
    2973530695,
    3747192018,
    1933530610,
    3464042516,
    935293895,
    3454686199,
    2858115069,
    1863638845,
    3683022916,
    4085369519,
    3292445032,
    875313188,
    1080017571,
    3279033885,
    621591778,
    1233856572,
    2504130317,
    24197544,
    3017672716,
    3835484340,
    3247465558,
    2220981195,
    3060847922,
    1551124588,
    1463996600
  ]), l = new Uint32Array([
    4104605777,
    1097159550,
    396673818,
    660510266,
    2875968315,
    2638606623,
    4200115116,
    3808662347,
    821712160,
    1986918061,
    3430322568,
    38544885,
    3856137295,
    718002117,
    893681702,
    1654886325,
    2975484382,
    3122358053,
    3926825029,
    4274053469,
    796197571,
    1290801793,
    1184342925,
    3556361835,
    2405426947,
    2459735317,
    1836772287,
    1381620373,
    3196267988,
    1948373848,
    3764988233,
    3385345166,
    3263785589,
    2390325492,
    1480485785,
    3111247143,
    3780097726,
    2293045232,
    548169417,
    3459953789,
    3746175075,
    439452389,
    1362321559,
    1400849762,
    1685577905,
    1806599355,
    2174754046,
    137073913,
    1214797936,
    1174215055,
    3731654548,
    2079897426,
    1943217067,
    1258480242,
    529487843,
    1437280870,
    3945269170,
    3049390895,
    3313212038,
    923313619,
    679998e3,
    3215307299,
    57326082,
    377642221,
    3474729866,
    2041877159,
    133361907,
    1776460110,
    3673476453,
    96392454,
    878845905,
    2801699524,
    777231668,
    4082475170,
    2330014213,
    4142626212,
    2213296395,
    1626319424,
    1906247262,
    1846563261,
    562755902,
    3708173718,
    1040559837,
    3871163981,
    1418573201,
    3294430577,
    114585348,
    1343618912,
    2566595609,
    3186202582,
    1078185097,
    3651041127,
    3896688048,
    2307622919,
    425408743,
    3371096953,
    2081048481,
    1108339068,
    2216610296,
    0,
    2156299017,
    736970802,
    292596766,
    1517440620,
    251657213,
    2235061775,
    2933202493,
    758720310,
    265905162,
    1554391400,
    1532285339,
    908999204,
    174567692,
    1474760595,
    4002861748,
    2610011675,
    3234156416,
    3693126241,
    2001430874,
    303699484,
    2478443234,
    2687165888,
    585122620,
    454499602,
    151849742,
    2345119218,
    3064510765,
    514443284,
    4044981591,
    1963412655,
    2581445614,
    2137062819,
    19308535,
    1928707164,
    1715193156,
    4219352155,
    1126790795,
    600235211,
    3992742070,
    3841024952,
    836553431,
    1669664834,
    2535604243,
    3323011204,
    1243905413,
    3141400786,
    4180808110,
    698445255,
    2653899549,
    2989552604,
    2253581325,
    3252932727,
    3004591147,
    1891211689,
    2487810577,
    3915653703,
    4237083816,
    4030667424,
    2100090966,
    865136418,
    1229899655,
    953270745,
    3399679628,
    3557504664,
    4118925222,
    2061379749,
    3079546586,
    2915017791,
    983426092,
    2022837584,
    1607244650,
    2118541908,
    2366882550,
    3635996816,
    972512814,
    3283088770,
    1568718495,
    3499326569,
    3576539503,
    621982671,
    2895723464,
    410887952,
    2623762152,
    1002142683,
    645401037,
    1494807662,
    2595684844,
    1335535747,
    2507040230,
    4293295786,
    3167684641,
    367585007,
    3885750714,
    1865862730,
    2668221674,
    2960971305,
    2763173681,
    1059270954,
    2777952454,
    2724642869,
    1320957812,
    2194319100,
    2429595872,
    2815956275,
    77089521,
    3973773121,
    3444575871,
    2448830231,
    1305906550,
    4021308739,
    2857194700,
    2516901860,
    3518358430,
    1787304780,
    740276417,
    1699839814,
    1592394909,
    2352307457,
    2272556026,
    188821243,
    1729977011,
    3687994002,
    274084841,
    3594982253,
    3613494426,
    2701949495,
    4162096729,
    322734571,
    2837966542,
    1640576439,
    484830689,
    1202797690,
    3537852828,
    4067639125,
    349075736,
    3342319475,
    4157467219,
    4255800159,
    1030690015,
    1155237496,
    2951971274,
    1757691577,
    607398968,
    2738905026,
    499347990,
    3794078908,
    1011452712,
    227885567,
    2818666809,
    213114376,
    3034881240,
    1455525988,
    3414450555,
    850817237,
    1817998408,
    3092726480
  ]), h = new Uint8Array([
    82,
    9,
    106,
    213,
    48,
    54,
    165,
    56,
    191,
    64,
    163,
    158,
    129,
    243,
    215,
    251,
    124,
    227,
    57,
    130,
    155,
    47,
    255,
    135,
    52,
    142,
    67,
    68,
    196,
    222,
    233,
    203,
    84,
    123,
    148,
    50,
    166,
    194,
    35,
    61,
    238,
    76,
    149,
    11,
    66,
    250,
    195,
    78,
    8,
    46,
    161,
    102,
    40,
    217,
    36,
    178,
    118,
    91,
    162,
    73,
    109,
    139,
    209,
    37,
    114,
    248,
    246,
    100,
    134,
    104,
    152,
    22,
    212,
    164,
    92,
    204,
    93,
    101,
    182,
    146,
    108,
    112,
    72,
    80,
    253,
    237,
    185,
    218,
    94,
    21,
    70,
    87,
    167,
    141,
    157,
    132,
    144,
    216,
    171,
    0,
    140,
    188,
    211,
    10,
    247,
    228,
    88,
    5,
    184,
    179,
    69,
    6,
    208,
    44,
    30,
    143,
    202,
    63,
    15,
    2,
    193,
    175,
    189,
    3,
    1,
    19,
    138,
    107,
    58,
    145,
    17,
    65,
    79,
    103,
    220,
    234,
    151,
    242,
    207,
    206,
    240,
    180,
    230,
    115,
    150,
    172,
    116,
    34,
    231,
    173,
    53,
    133,
    226,
    249,
    55,
    232,
    28,
    117,
    223,
    110,
    71,
    241,
    26,
    113,
    29,
    41,
    197,
    137,
    111,
    183,
    98,
    14,
    170,
    24,
    190,
    27,
    252,
    86,
    62,
    75,
    198,
    210,
    121,
    32,
    154,
    219,
    192,
    254,
    120,
    205,
    90,
    244,
    31,
    221,
    168,
    51,
    136,
    7,
    199,
    49,
    177,
    18,
    16,
    89,
    39,
    128,
    236,
    95,
    96,
    81,
    127,
    169,
    25,
    181,
    74,
    13,
    45,
    229,
    122,
    159,
    147,
    201,
    156,
    239,
    160,
    224,
    59,
    77,
    174,
    42,
    245,
    176,
    200,
    235,
    187,
    60,
    131,
    83,
    153,
    97,
    23,
    43,
    4,
    126,
    186,
    119,
    214,
    38,
    225,
    105,
    20,
    99,
    85,
    33,
    12,
    125
  ]), x = new Uint32Array([
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    452984832,
    905969664
  ]);
  class b {
    constructor(y = 256) {
      r(y >>> 0 === y), this.bits = y, this.rounds = g(y), this.key = null, this.encKey = null, this.decKey = null;
    }
    get blockSize() {
      return 16;
    }
    init(y) {
      if (r(Buffer.isBuffer(y)), y.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      return this.destroy(), this.key = Buffer.from(y), this.encKey = null, this.decKey = null, this;
    }
    createEncryptKey() {
      if (!this.key)
        throw new Error("Cipher is not initialized.");
      const y = this.key;
      if (y.length !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      const A = new Uint32Array(60);
      A[0] = w(y, 0), A[1] = w(y, 4), A[2] = w(y, 8), A[3] = w(y, 12);
      let _ = 0, q = 0;
      if (this.bits === 128) {
        for (; ; ) {
          const U = A[_ + 3];
          if (A[_ + 4] = A[_] ^ i[U >>> 16 & 255] & 4278190080 ^ n[U >>> 8 & 255] & 16711680 ^ e[U >>> 0 & 255] & 65280 ^ t[U >>> 24 & 255] & 255 ^ x[q], A[_ + 5] = A[_ + 1] ^ A[_ + 4], A[_ + 6] = A[_ + 2] ^ A[_ + 5], A[_ + 7] = A[_ + 3] ^ A[_ + 6], q += 1, q === 10)
            break;
          _ += 4;
        }
        return A;
      }
      if (A[_ + 4] = w(y, 16), A[_ + 5] = w(y, 20), this.bits === 192) {
        for (; ; ) {
          const U = A[_ + 5];
          if (A[_ + 6] = A[_] ^ i[U >>> 16 & 255] & 4278190080 ^ n[U >>> 8 & 255] & 16711680 ^ e[U >>> 0 & 255] & 65280 ^ t[U >>> 24 & 255] & 255 ^ x[q], A[_ + 7] = A[_ + 1] ^ A[_ + 6], A[_ + 8] = A[_ + 2] ^ A[_ + 7], A[_ + 9] = A[_ + 3] ^ A[_ + 8], q += 1, q === 8)
            break;
          A[_ + 10] = A[_ + 4] ^ A[_ + 9], A[_ + 11] = A[_ + 5] ^ A[_ + 10], _ += 6;
        }
        return A;
      }
      if (A[_ + 6] = w(y, 24), A[_ + 7] = w(y, 28), this.bits === 256) {
        for (; ; ) {
          let U = A[_ + 7];
          if (A[_ + 8] = A[_] ^ i[U >>> 16 & 255] & 4278190080 ^ n[U >>> 8 & 255] & 16711680 ^ e[U >>> 0 & 255] & 65280 ^ t[U >>> 24 & 255] & 255 ^ x[q], A[_ + 9] = A[_ + 1] ^ A[_ + 8], A[_ + 10] = A[_ + 2] ^ A[_ + 9], A[_ + 11] = A[_ + 3] ^ A[_ + 10], q += 1, q === 7)
            break;
          U = A[_ + 11], A[_ + 12] = A[_ + 4] ^ i[U >>> 24 & 255] & 4278190080 ^ n[U >>> 16 & 255] & 16711680 ^ e[U >>> 8 & 255] & 65280 ^ t[U >>> 0 & 255] & 255, A[_ + 13] = A[_ + 5] ^ A[_ + 12], A[_ + 14] = A[_ + 6] ^ A[_ + 13], A[_ + 15] = A[_ + 7] ^ A[_ + 14], _ += 8;
        }
        return A;
      }
      throw new Error("Bad key size.");
    }
    createDecryptKey() {
      const y = this.createEncryptKey();
      let A = 0;
      for (let _ = 0, q = 4 * this.rounds; _ < q; _ += 4, q -= 4) {
        let U = y[A + _ + 0];
        y[A + _ + 0] = y[A + q + 0], y[A + q + 0] = U, U = y[A + _ + 1], y[A + _ + 1] = y[A + q + 1], y[A + q + 1] = U, U = y[A + _ + 2], y[A + _ + 2] = y[A + q + 2], y[A + q + 2] = U, U = y[A + _ + 3], y[A + _ + 3] = y[A + q + 3], y[A + q + 3] = U;
      }
      for (let _ = 1; _ < this.rounds; _++)
        A += 4, y[A + 0] = c[t[y[A + 0] >>> 24 & 255] & 255] ^ o[t[y[A + 0] >>> 16 & 255] & 255] ^ d[t[y[A + 0] >>> 8 & 255] & 255] ^ l[t[y[A + 0] >>> 0 & 255] & 255], y[A + 1] = c[t[y[A + 1] >>> 24 & 255] & 255] ^ o[t[y[A + 1] >>> 16 & 255] & 255] ^ d[t[y[A + 1] >>> 8 & 255] & 255] ^ l[t[y[A + 1] >>> 0 & 255] & 255], y[A + 2] = c[t[y[A + 2] >>> 24 & 255] & 255] ^ o[t[y[A + 2] >>> 16 & 255] & 255] ^ d[t[y[A + 2] >>> 8 & 255] & 255] ^ l[t[y[A + 2] >>> 0 & 255] & 255], y[A + 3] = c[t[y[A + 3] >>> 24 & 255] & 255] ^ o[t[y[A + 3] >>> 16 & 255] & 255] ^ d[t[y[A + 3] >>> 8 & 255] & 255] ^ l[t[y[A + 3] >>> 0 & 255] & 255];
      return y;
    }
    getEncryptKey() {
      return this.encKey || (this.encKey = this.createEncryptKey()), this.encKey;
    }
    getDecryptKey() {
      return this.decKey || (this.decKey = this.createDecryptKey()), this.decKey;
    }
    encrypt(y, A, _, q) {
      const U = this.getEncryptKey();
      let z = w(_, q + 0) ^ U[0], E = w(_, q + 4) ^ U[1], H = w(_, q + 8) ^ U[2], k = w(_, q + 12) ^ U[3], V = this.rounds >>> 1, T = 0, ie, N, G, F;
      for (; ie = e[z >>> 24 & 255] ^ t[E >>> 16 & 255] ^ i[H >>> 8 & 255] ^ n[k >>> 0 & 255] ^ U[T + 4], N = e[E >>> 24 & 255] ^ t[H >>> 16 & 255] ^ i[k >>> 8 & 255] ^ n[z >>> 0 & 255] ^ U[T + 5], G = e[H >>> 24 & 255] ^ t[k >>> 16 & 255] ^ i[z >>> 8 & 255] ^ n[E >>> 0 & 255] ^ U[T + 6], F = e[k >>> 24 & 255] ^ t[z >>> 16 & 255] ^ i[E >>> 8 & 255] ^ n[H >>> 0 & 255] ^ U[T + 7], T += 8, V -= 1, V !== 0; )
        z = e[ie >>> 24 & 255] ^ t[N >>> 16 & 255] ^ i[G >>> 8 & 255] ^ n[F >>> 0 & 255] ^ U[T + 0], E = e[N >>> 24 & 255] ^ t[G >>> 16 & 255] ^ i[F >>> 8 & 255] ^ n[ie >>> 0 & 255] ^ U[T + 1], H = e[G >>> 24 & 255] ^ t[F >>> 16 & 255] ^ i[ie >>> 8 & 255] ^ n[N >>> 0 & 255] ^ U[T + 2], k = e[F >>> 24 & 255] ^ t[ie >>> 16 & 255] ^ i[N >>> 8 & 255] ^ n[G >>> 0 & 255] ^ U[T + 3];
      return z = i[ie >>> 24 & 255] & 4278190080 ^ n[N >>> 16 & 255] & 16711680 ^ e[G >>> 8 & 255] & 65280 ^ t[F >>> 0 & 255] & 255 ^ U[T + 0], E = i[N >>> 24 & 255] & 4278190080 ^ n[G >>> 16 & 255] & 16711680 ^ e[F >>> 8 & 255] & 65280 ^ t[ie >>> 0 & 255] & 255 ^ U[T + 1], H = i[G >>> 24 & 255] & 4278190080 ^ n[F >>> 16 & 255] & 16711680 ^ e[ie >>> 8 & 255] & 65280 ^ t[N >>> 0 & 255] & 255 ^ U[T + 2], k = i[F >>> 24 & 255] & 4278190080 ^ n[ie >>> 16 & 255] & 16711680 ^ e[N >>> 8 & 255] & 65280 ^ t[G >>> 0 & 255] & 255 ^ U[T + 3], I(y, z, A + 0), I(y, E, A + 4), I(y, H, A + 8), I(y, k, A + 12), this;
    }
    decrypt(y, A, _, q) {
      const U = this.getDecryptKey();
      let z = w(_, q + 0) ^ U[0], E = w(_, q + 4) ^ U[1], H = w(_, q + 8) ^ U[2], k = w(_, q + 12) ^ U[3], V = this.rounds >>> 1, T = 0, ie, N, G, F;
      for (; ie = c[z >>> 24 & 255] ^ o[k >>> 16 & 255] ^ d[H >>> 8 & 255] ^ l[E >>> 0 & 255] ^ U[T + 4], N = c[E >>> 24 & 255] ^ o[z >>> 16 & 255] ^ d[k >>> 8 & 255] ^ l[H >>> 0 & 255] ^ U[T + 5], G = c[H >>> 24 & 255] ^ o[E >>> 16 & 255] ^ d[z >>> 8 & 255] ^ l[k >>> 0 & 255] ^ U[T + 6], F = c[k >>> 24 & 255] ^ o[H >>> 16 & 255] ^ d[E >>> 8 & 255] ^ l[z >>> 0 & 255] ^ U[T + 7], T += 8, V -= 1, V !== 0; )
        z = c[ie >>> 24 & 255] ^ o[F >>> 16 & 255] ^ d[G >>> 8 & 255] ^ l[N >>> 0 & 255] ^ U[T + 0], E = c[N >>> 24 & 255] ^ o[ie >>> 16 & 255] ^ d[F >>> 8 & 255] ^ l[G >>> 0 & 255] ^ U[T + 1], H = c[G >>> 24 & 255] ^ o[N >>> 16 & 255] ^ d[ie >>> 8 & 255] ^ l[F >>> 0 & 255] ^ U[T + 2], k = c[F >>> 24 & 255] ^ o[G >>> 16 & 255] ^ d[N >>> 8 & 255] ^ l[ie >>> 0 & 255] ^ U[T + 3];
      return z = h[ie >>> 24 & 255] << 24 ^ h[F >>> 16 & 255] << 16 ^ h[G >>> 8 & 255] << 8 ^ h[N >>> 0 & 255] << 0 ^ U[T + 0], E = h[N >>> 24 & 255] << 24 ^ h[ie >>> 16 & 255] << 16 ^ h[F >>> 8 & 255] << 8 ^ h[G >>> 0 & 255] << 0 ^ U[T + 1], H = h[G >>> 24 & 255] << 24 ^ h[N >>> 16 & 255] << 16 ^ h[ie >>> 8 & 255] << 8 ^ h[F >>> 0 & 255] << 0 ^ U[T + 2], k = h[F >>> 24 & 255] << 24 ^ h[G >>> 16 & 255] << 16 ^ h[N >>> 8 & 255] << 8 ^ h[ie >>> 0 & 255] << 0 ^ U[T + 3], I(y, z, A + 0), I(y, E, A + 4), I(y, H, A + 8), I(y, k, A + 12), this;
    }
    destroy() {
      if (this.key)
        for (let y = 0; y < this.key.length; y++)
          this.key[y] = 0;
      if (this.encKey)
        for (let y = 0; y < 60; y++)
          this.encKey[y] = 0;
      if (this.decKey)
        for (let y = 0; y < 60; y++)
          this.decKey[y] = 0;
      return this.key = null, this.encKey = null, this.decKey = null, this;
    }
  }
  function g(B) {
    switch (B) {
      case 128:
        return 10;
      case 192:
        return 12;
      case 256:
        return 14;
      default:
        throw new Error("Bad key size.");
    }
  }
  function w(B, y) {
    return B[y++] * 16777216 + B[y++] * 65536 + B[y++] * 256 + B[y];
  }
  function I(B, y, A) {
    return B[A++] = y >>> 24, B[A++] = y >>> 16, B[A++] = y >>> 8, B[A++] = y, A;
  }
  return Ma = b, Ma;
}
var Lt = {};
/*!
 * ghash.js - ghash for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Galois/Counter_Mode
 *   https://dx.doi.org/10.6028/NIST.SP.800-38D
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go
 *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs
 */
var Na, w2;
function Gp() {
  if (w2)
    return Na;
  w2 = 1;
  const r = _e, e = Buffer.alloc(16, 0), t = -1, i = new Uint16Array([
    0,
    7200,
    14400,
    9312,
    28800,
    27808,
    18624,
    21728,
    57600,
    64800,
    55616,
    50528,
    37248,
    36256,
    43456,
    46560
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(4), this.block = Buffer.alloc(16), this.size = t, this.adLen = 0, this.ctLen = 0, this.table = new Array(16);
      for (let b = 0; b < 16; b++)
        this.table[b] = new Uint32Array(4);
    }
    init(b) {
      r(Buffer.isBuffer(b)), r(b.length === 16);
      for (let w = 0; w < 4; w++)
        this.state[w] = 0;
      this.size = 0, this.adLen = 0, this.ctLen = 0;
      for (let w = 0; w < 16; w++)
        for (let I = 0; I < 4; I++)
          this.table[w][I] = 0;
      const g = new Uint32Array(4);
      g[1] = l(b, 0), g[0] = l(b, 4), g[3] = l(b, 8), g[2] = l(b, 12), this.table[d(1)] = g;
      for (let w = 2; w < 16; w += 2)
        this.table[d(w)] = this.double(this.table[d(w >>> 1)]), this.table[d(w + 1)] = this.add(this.table[d(w)], g);
      return this;
    }
    absorb(b) {
      return this._absorb(b, b.length), this;
    }
    _absorb(b, g) {
      r(this.size !== t, "Context is not initialized.");
      let w = this.size & 15, I = 0;
      if (this.size += g, w > 0) {
        let B = 16 - w;
        if (B > g && (B = g), b.copy(this.block, w, I, I + B), w += B, g -= B, I += B, w < 16)
          return;
        this.transform(this.block, 0);
      }
      for (; g >= 16; )
        this.transform(b, I), I += 16, g -= 16;
      g > 0 && b.copy(this.block, 0, I, I + g);
    }
    transform(b, g) {
      this.state[1] ^= l(b, g + 0), this.state[0] ^= l(b, g + 4), this.state[3] ^= l(b, g + 8), this.state[2] ^= l(b, g + 12), this.mul(this.state);
    }
    pad() {
      const b = this.size & 15;
      b !== 0 && this._absorb(e, 16 - b);
    }
    aad(b) {
      return r(Buffer.isBuffer(b)), r(this.ctLen === 0), this.adLen += b.length, this.absorb(b);
    }
    update(b) {
      return r(Buffer.isBuffer(b)), b.length === 0 ? this : (this.ctLen === 0 && this.pad(), this.ctLen += b.length, this.absorb(b));
    }
    final() {
      const b = Buffer.alloc(16);
      this.pad();
      const g = this.adLen * 8, w = this.ctLen * 8;
      this.state[1] ^= c(g), this.state[0] ^= o(g), this.state[3] ^= c(w), this.state[2] ^= o(w), this.mul(this.state), h(b, this.state[1], 0), h(b, this.state[0], 4), h(b, this.state[3], 8), h(b, this.state[2], 12);
      for (let I = 0; I < 4; I++)
        this.state[I] = 0;
      for (let I = 0; I < 16; I++)
        this.block[I] = 0;
      this.size = t, this.adLen = 0, this.ctLen = 0;
      for (let I = 0; I < 16; I++)
        for (let B = 0; B < 4; B++)
          this.table[I][B] = 0;
      return b;
    }
    destroy() {
      for (let b = 0; b < 4; b++)
        this.state[b] = 0;
      for (let b = 0; b < 16; b++)
        this.block[b] = 0;
      this.size = t, this.adLen = 0, this.ctLen = 0;
      for (let b = 0; b < 16; b++)
        for (let g = 0; g < 4; g++)
          this.table[b][g] = 0;
    }
    add(b, g) {
      r(b instanceof Uint32Array), r(b.length === 4), r(g instanceof Uint32Array), r(g.length === 4);
      const w = new Uint32Array(4);
      return w[0] = b[0] ^ g[0], w[1] = b[1] ^ g[1], w[2] = b[2] ^ g[2], w[3] = b[3] ^ g[3], w;
    }
    double(b) {
      r(b instanceof Uint32Array), r(b.length === 4);
      const g = new Uint32Array(4), w = (b[2] & 1) === 1;
      let I;
      return g[3] = b[3], g[2] = b[2], I = g[3] & 1, g[3] >>>= 1, g[2] >>>= 1, g[2] |= I << 31, g[3] |= (b[0] & 1) << 31, g[1] = b[1], g[0] = b[0], I = g[1] & 1, g[1] >>>= 1, g[0] >>>= 1, g[0] |= I << 31, w && (g[1] ^= 3774873600, g[0] ^= 0), g;
    }
    mul(b) {
      r(b instanceof Uint32Array), r(b.length === 4);
      const g = new Uint32Array(4), w = new Uint32Array(2);
      let I, B;
      for (let y = 0; y < 2; y++) {
        w[0] = b[2], w[1] = b[3], y === 1 && (w[0] = b[0], w[1] = b[1]);
        for (let A = 0; A < 64; A += 4) {
          const _ = g[2] & 15;
          I = g[3] & 15, g[3] >>>= 4, g[2] >>>= 4, g[2] |= I << 28, g[3] |= g[0] << 28, I = g[1] & 15, g[1] >>>= 4, g[0] >>>= 4, g[0] |= I << 28, g[1] ^= i[_] << 16, B = this.table[w[0] & 15], g[0] ^= B[0], g[1] ^= B[1], g[2] ^= B[2], g[3] ^= B[3], I = w[1] & 15, w[1] >>>= 4, w[0] >>>= 4, w[0] |= I << 28;
        }
      }
      b[0] = g[0], b[1] = g[1], b[2] = g[2], b[3] = g[3];
    }
  }
  function c(x) {
    return x * (1 / 4294967296) >>> 0;
  }
  function o(x) {
    return x >>> 0;
  }
  function d(x) {
    return x = x << 2 & 12 | x >>> 2 & 3, x = x << 1 & 10 | x >>> 1 & 5, x;
  }
  function l(x, b) {
    return x[b++] * 16777216 + x[b++] * 65536 + x[b++] * 256 + x[b++];
  }
  function h(x, b, g) {
    return x[g++] = b >>> 24, x[g++] = b >>> 16, x[g++] = b >>> 8, x[g++] = b, g;
  }
  return Na = n, Na;
}
/*!
 * modes.js - cipher modes for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
 */
var y2;
function h8() {
  if (y2)
    return Lt;
  y2 = 1;
  const r = _e, e = Gp(), t = Buffer.alloc(0), i = new Uint32Array([
    27,
    135,
    1061,
    0,
    293,
    0,
    0,
    0,
    524355
    // 128
  ]);
  class n {
    constructor(Z) {
      r(Z && typeof Z.encrypt == "function"), r(typeof Z.blockSize == "number"), this.ctx = Z;
    }
    get blockSize() {
      return this.ctx.blockSize;
    }
    init(Z, L) {
      throw new Error("Not implemented.");
    }
    update(Z) {
      throw new Error("Not implemented.");
    }
    crypt(Z, L) {
      throw new Error("Not implemented.");
    }
    final() {
      throw new Error("Not implemented.");
    }
    destroy() {
      throw new Error("Not implemented.");
    }
    setAutoPadding(Z) {
      return r(typeof Z == "boolean"), this._setAutoPadding(Z), this;
    }
    setAAD(Z) {
      return r(Buffer.isBuffer(Z)), this._setAAD(Z), this;
    }
    setCCM(Z, L, oe) {
      return r(Z >>> 0 === Z), r(L >>> 0 === L), r(oe == null || Buffer.isBuffer(oe)), this._setCCM(Z, L, oe), this;
    }
    getAuthTag() {
      return this._getAuthTag();
    }
    setAuthTag(Z) {
      return r(Buffer.isBuffer(Z)), this._setAuthTag(Z), this;
    }
    _setAutoPadding(Z) {
      throw new Error("Not available.");
    }
    _setAAD(Z) {
      throw new Error("Cipher is not authenticated.");
    }
    _setCCM(Z, L, oe) {
      throw new Error("Not available.");
    }
    _getAuthTag() {
      throw new Error("Cipher is not authenticated.");
    }
    _setAuthTag(Z) {
      throw new Error("Cipher is not authenticated.");
    }
  }
  class c extends n {
    constructor(Z, L) {
      super(Z), this.padding = !0, this.unpad = L, this.block = Buffer.alloc(this.blockSize), this.blockPos = -1, this.last = null, this.lastSize = 0, L && (this.last = Buffer.alloc(this.blockSize));
    }
    init(Z, L) {
      return L == null && (L = t), r(Buffer.isBuffer(Z)), r(Buffer.isBuffer(L)), this.ctx.init(Z), this.blockPos = 0, this.lastSize = 0, this._init(Z, L), this;
    }
    _updateSize(Z) {
      if (this.blockPos + Z < this.blockSize)
        return 0;
      let L = 0;
      return this.unpad && (L += this.lastSize), this.blockPos > 0 && (Z -= this.blockSize - this.blockPos, L += this.blockSize), Z >= this.blockSize && (L += Z - Z % this.blockSize), r(L >= this.blockSize), L;
    }
    update(Z) {
      if (r(Buffer.isBuffer(Z)), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      const L = this._updateSize(Z.length), oe = Buffer.alloc(L);
      if (this.blockPos + Z.length < this.blockSize)
        return this.blockPos += Z.copy(this.block, this.blockPos, 0, Z.length), oe;
      let s = Z.length, a = 0, p = 0;
      if (this.unpad && (p += this.last.copy(oe, p, 0, this.lastSize)), this.blockPos > 0) {
        const v = this.blockSize - this.blockPos;
        a += Z.copy(this.block, this.blockPos, a, a + v), s -= v, this._update(oe, p, this.block, 0), p += this.blockSize, this.blockPos = 0;
      }
      for (; s >= this.blockSize; )
        this._update(oe, p, Z, a), a += this.blockSize, s -= this.blockSize, p += this.blockSize;
      return s > 0 && (this.blockPos = Z.copy(this.block, 0, a, a + s)), r(p === L), this.unpad ? (this.lastSize = oe.copy(this.last, 0, L - this.blockSize, L), oe.slice(0, L - this.blockSize)) : oe;
    }
    crypt(Z, L) {
      if (r(Buffer.isBuffer(Z)), r(Buffer.isBuffer(L)), r(Z.length === L.length), this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.unpad || this.blockPos !== 0)
        throw new Error("Cannot crypt while buffering.");
      if (L.length % this.blockSize !== 0)
        throw new Error("Input must be a multiple of the block size.");
      const oe = this.blockSize;
      let s = L.length, a = 0;
      for (; s > 0; )
        this._update(Z, a, L, a), a += oe, s -= oe;
      return Z;
    }
    final() {
      if (this.blockPos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      this.ctx.destroy(), this.blockPos = -1, this.lastSize = 0;
      for (let Z = 0; Z < this.blockSize; Z++)
        this.block[Z] = 0;
      if (this.unpad)
        for (let Z = 0; Z < this.blockSize; Z++)
          this.last[Z] = 0;
      return this._destroy(), this;
    }
    _init(Z, L) {
      throw new Error("Not implemented.");
    }
    _update(Z, L, oe, s) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class o extends n {
    constructor(Z) {
      super(Z), this.pos = -1;
    }
    init(Z, L) {
      return L == null && (L = t), r(Buffer.isBuffer(Z)), r(Buffer.isBuffer(L)), this.ctx.init(Z), this.pos = 0, this._init(Z, L), this;
    }
    update(Z) {
      if (r(Buffer.isBuffer(Z)), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      const L = Buffer.alloc(Z.length);
      return this._crypt(L, Z), L;
    }
    crypt(Z, L) {
      if (r(Buffer.isBuffer(Z)), r(Buffer.isBuffer(L)), r(Z.length === L.length), this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this._crypt(Z, L), Z;
    }
    final() {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      try {
        return this._final();
      } finally {
        this.destroy();
      }
    }
    destroy() {
      return this.ctx.destroy(), this.pos = -1, this._destroy(), this;
    }
    _init(Z, L) {
      throw new Error("Not implemented.");
    }
    _crypt(Z, L) {
      throw new Error("Not implemented.");
    }
    _final() {
      throw new Error("Not implemented.");
    }
    _destroy() {
      throw new Error("Not implemented.");
    }
  }
  class d extends c {
    constructor(Z) {
      super(Z, !1);
    }
    _init(Z, L) {
      r(L.length === 0);
    }
    _update(Z, L, oe, s) {
      this.ctx.encrypt(Z, L, oe, s);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad encrypt (trailing bytes).");
      return Buffer.alloc(0);
    }
    _destroy() {
    }
  }
  class l extends c {
    constructor(Z) {
      super(Z, !1);
    }
    _init(Z, L) {
      r(L.length === 0);
    }
    _update(Z, L, oe, s) {
      this.ctx.decrypt(Z, L, oe, s);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      return Buffer.alloc(0);
    }
    _destroy() {
    }
  }
  class h extends c {
    constructor(Z) {
      super(Z, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return Buffer.alloc(0);
      }
      const Z = this.blockSize - this.blockPos, L = Buffer.from(this.block);
      for (let oe = this.blockPos; oe < this.blockSize; oe++)
        L[oe] = Z;
      return this._update(L, 0, L, 0), L;
    }
    _setAutoPadding(Z) {
      this.padding = Z;
    }
  }
  class x extends c {
    constructor(Z) {
      super(Z, !0);
    }
    _final() {
      if (this.blockPos !== 0)
        throw new Error("Bad decrypt (trailing bytes).");
      if (!this.padding)
        return Buffer.alloc(0);
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      r(this.lastSize === this.last.length), r(this.lastSize === this.blockSize);
      const Z = Buffer.from(this.last);
      let L = Z[Z.length - 1], oe = 1;
      oe &= L - 1 >>> 31 ^ 1, oe &= L - this.blockSize - 1 >>> 31, L &= -oe;
      const s = this.blockSize - L;
      for (let a = 0; a < this.blockSize; a++) {
        const p = Z[a];
        oe &= a - s >>> 31 | (p ^ L) - 1 >>> 31;
      }
      if (!oe)
        throw new Error("Bad decrypt (padding).");
      return Z.slice(0, s);
    }
    _setAutoPadding(Z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = Z, this.unpad = Z;
    }
  }
  class b extends h {
    constructor(Z) {
      super(Z);
    }
    _init(Z, L) {
      r(L.length === 0);
    }
    _update(Z, L, oe, s) {
      this.ctx.encrypt(Z, L, oe, s);
    }
    _destroy() {
    }
  }
  class g extends x {
    constructor(Z) {
      super(Z);
    }
    _init(Z, L) {
      r(L.length === 0);
    }
    _update(Z, L, oe, s) {
      this.ctx.decrypt(Z, L, oe, s);
    }
    _destroy() {
    }
  }
  class w extends h {
    constructor(Z) {
      super(Z), this.prev = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(L.length === this.blockSize), L.copy(this.prev, 0);
    }
    _update(Z, L, oe, s) {
      for (let a = 0; a < this.blockSize; a++)
        this.prev[a] ^= oe[s + a];
      this.ctx.encrypt(Z, L, this.prev, 0), Z.copy(this.prev, 0, L, L + this.blockSize);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.prev[Z] = 0;
    }
  }
  class I extends x {
    constructor(Z) {
      super(Z), this.prev = Buffer.alloc(this.blockSize), this.tmp = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(L.length === this.blockSize), L.copy(this.prev, 0);
    }
    _update(Z, L, oe, s) {
      if (dt(Z, L, oe, s)) {
        this.prev.copy(this.tmp, 0), oe.copy(this.prev, 0, s, s + this.blockSize), this.ctx.decrypt(Z, L, oe, s);
        for (let a = 0; a < this.blockSize; a++)
          Z[L + a] ^= this.tmp[a];
      } else {
        this.ctx.decrypt(Z, L, oe, s);
        for (let a = 0; a < this.blockSize; a++)
          Z[L + a] ^= this.prev[a];
        oe.copy(this.prev, 0, s, s + this.blockSize);
      }
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.prev[Z] = 0, this.tmp[Z] = 0;
    }
  }
  class B extends c {
    constructor(Z) {
      super(Z, !0), this.prev = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(L.length === this.blockSize), L.copy(this.prev, 0);
    }
    _update(Z, L, oe, s) {
      for (let a = 0; a < this.blockSize; a++)
        this.prev[a] ^= oe[s + a];
      this.ctx.encrypt(Z, L, this.prev, 0), Z.copy(this.prev, 0, L, L + this.blockSize);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return Buffer.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      for (let L = 0; L < this.blockPos; L++)
        this.prev[L] ^= this.block[L];
      this.ctx.encrypt(this.prev, 0, this.prev, 0);
      const Z = this.last.slice(0, this.blockPos);
      return Buffer.concat([this.prev, Z]);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.prev[Z] = 0;
    }
    _setAutoPadding(Z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = Z, this.unpad = Z;
    }
  }
  class y extends c {
    constructor(Z) {
      super(Z, !0), this.prev = Buffer.alloc(this.blockSize), this.tmp = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(L.length === this.blockSize), L.copy(this.prev, 0);
    }
    _update(Z, L, oe, s) {
      if (dt(Z, L, oe, s)) {
        this.prev.copy(this.tmp, 0), oe.copy(this.prev, 0, s, s + this.blockSize), this.ctx.decrypt(Z, L, oe, s);
        for (let a = 0; a < this.blockSize; a++)
          Z[L + a] ^= this.tmp[a];
      } else {
        this.ctx.decrypt(Z, L, oe, s);
        for (let a = 0; a < this.blockSize; a++)
          Z[L + a] ^= this.prev[a];
        oe.copy(this.prev, 0, s, s + this.blockSize);
      }
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return Buffer.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      const Z = Buffer.alloc(this.blockSize);
      this.ctx.decrypt(this.prev, 0, this.prev, 0);
      for (let oe = 0; oe < this.blockSize; oe++)
        Z[oe] = this.last[oe] ^ this.prev[oe];
      for (let oe = 0; oe < this.blockPos; oe++)
        this.last[oe] = this.block[oe], this.block[oe] ^= this.prev[oe];
      for (let oe = this.blockPos; oe < this.blockSize; oe++)
        this.last[oe] = this.prev[oe];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let oe = 0; oe < this.blockSize; oe++)
        this.last[oe] ^= Z[oe];
      const L = this.block.slice(0, this.blockPos);
      return Buffer.concat([this.last, L]);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.prev[Z] = 0, this.tmp[Z] = 0;
    }
    _setAutoPadding(Z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = Z, this.unpad = Z;
    }
  }
  class A extends c {
    constructor(Z, L) {
      super(Z, !0), this.encrypt = L, this.poly = i[this.blockSize >>> 4], this.tweak = Buffer.alloc(this.blockSize), this.prev = Buffer.alloc(this.blockSize);
    }
    init(Z, L) {
      r(Buffer.isBuffer(Z)), r(Buffer.isBuffer(L)), r(Z.length > 0 && (Z.length & 1) === 0), r(L.length === this.blockSize);
      const oe = Z.length >>> 1, s = Z.slice(0, oe), a = Z.slice(oe);
      if (Se(s, a, oe))
        throw new Error("XTS keys are equal.");
      return this.ctx.init(a), this.ctx.encrypt(this.tweak, 0, L, 0), this.ctx.init(s), this.blockPos = 0, this.lastSize = 0, this;
    }
    _shift() {
      let Z = 0;
      this.encrypt || this.tweak.copy(this.prev, 0);
      for (let L = 0; L < this.blockSize; L++) {
        const oe = this.tweak[L] >> 7;
        this.tweak[L] <<= 1, this.tweak[L] |= Z, Z = oe;
      }
      Z = -Z & 255, this.tweak[2] ^= this.poly >> 16 & Z, this.tweak[1] ^= this.poly >> 8 & Z, this.tweak[0] ^= this.poly >> 0 & Z;
    }
    _update(Z, L, oe, s) {
      for (let a = 0; a < this.blockSize; a++)
        Z[L + a] = oe[s + a] ^ this.tweak[a];
      this.encrypt ? this.ctx.encrypt(Z, L, Z, L) : this.ctx.decrypt(Z, L, Z, L);
      for (let a = 0; a < this.blockSize; a++)
        Z[L + a] ^= this.tweak[a];
      this._shift();
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.tweak[Z] = 0, this.prev[Z] = 0;
    }
    _setAutoPadding(Z) {
      if (this.lastSize !== 0 || this.blockPos !== 0)
        throw new Error("Cannot set auto padding.");
      this.padding = Z, this.unpad = Z;
    }
  }
  class _ extends A {
    constructor(Z) {
      super(Z, !0);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad encrypt (trailing bytes).");
        return Buffer.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad encrypt (no data).");
      if (this.blockPos === 0)
        return Buffer.from(this.last);
      const Z = Buffer.alloc(this.blockPos);
      for (let L = 0; L < this.blockPos; L++)
        Z[L] = this.last[L], this.last[L] = this.block[L];
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.tweak[L];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.tweak[L];
      return Buffer.concat([this.last, Z]);
    }
  }
  class q extends A {
    constructor(Z) {
      super(Z, !1);
    }
    _final() {
      if (!this.padding) {
        if (this.blockPos !== 0)
          throw new Error("Bad decrypt (trailing bytes).");
        return Buffer.alloc(0);
      }
      if (this.lastSize === 0)
        throw new Error("Bad decrypt (no data).");
      if (this.blockPos === 0)
        return Buffer.from(this.last);
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.prev[L];
      this.ctx.encrypt(this.last, 0, this.last, 0);
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.prev[L];
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.tweak[L];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.tweak[L];
      const Z = Buffer.alloc(this.blockPos);
      for (let L = 0; L < this.blockPos; L++)
        Z[L] = this.last[L], this.last[L] = this.block[L];
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.prev[L];
      this.ctx.decrypt(this.last, 0, this.last, 0);
      for (let L = 0; L < this.blockSize; L++)
        this.last[L] ^= this.prev[L];
      return Buffer.concat([this.last, Z]);
    }
  }
  class U extends o {
    constructor(Z) {
      super(Z), this.state = Buffer.alloc(this.blockSize), this.ctr = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(L.length === this.blockSize), L.copy(this.ctr, 0);
    }
    _increment() {
      for (let Z = this.ctr.length - 1; Z >= 0 && (this.ctr[Z] += 1, this.ctr[Z] === 0); Z--)
        ;
    }
    _crypt(Z, L) {
      const oe = this.blockSize - 1;
      for (let s = 0; s < L.length; s++)
        this.pos & oe || (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), Z[s] = L[s] ^ this.state[this.pos++];
    }
    _final() {
      return Buffer.alloc(0);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.state[Z] = 0, this.ctr[Z] = 0;
    }
  }
  class z extends U {
    constructor(Z) {
      super(Z);
    }
  }
  class E extends U {
    constructor(Z) {
      super(Z);
    }
  }
  class H extends o {
    constructor(Z) {
      super(Z), this.state = Buffer.alloc(this.blockSize), this.prev = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(L.length === this.blockSize), L.copy(this.prev, 0);
    }
    _final() {
      return Buffer.alloc(0);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.state[Z] = 0, this.prev[Z] = 0;
    }
  }
  class k extends H {
    constructor(Z) {
      super(Z);
    }
    _crypt(Z, L) {
      const oe = this.blockSize - 1;
      for (let s = 0; s < L.length; s++)
        this.pos & oe || (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), Z[s] = L[s] ^ this.state[this.pos], this.prev[this.pos] = Z[s], this.pos += 1;
    }
  }
  class V extends H {
    constructor(Z) {
      super(Z);
    }
    _crypt(Z, L) {
      const oe = this.blockSize - 1;
      for (let s = 0; s < L.length; s++)
        this.pos & oe || (this.ctx.encrypt(this.state, 0, this.prev, 0), this.pos = 0), this.prev[this.pos] = L[s], Z[s] = L[s] ^ this.state[this.pos], this.pos += 1;
    }
  }
  class T extends o {
    constructor(Z) {
      super(Z), this.state = Buffer.alloc(this.blockSize);
    }
    _init(Z, L) {
      r(Buffer.isBuffer(L)), r(L.length === this.blockSize), L.copy(this.state, 0);
    }
    _crypt(Z, L) {
      const oe = this.blockSize - 1;
      for (let s = 0; s < L.length; s++)
        this.pos & oe || (this.ctx.encrypt(this.state, 0, this.state, 0), this.pos = 0), Z[s] = L[s] ^ this.state[this.pos++];
    }
    _final() {
      return Buffer.alloc(0);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.state[Z] = 0;
    }
  }
  class ie extends T {
    constructor(Z) {
      super(Z);
    }
  }
  class N extends T {
    constructor(Z) {
      super(Z);
    }
  }
  class G extends o {
    constructor(Z, L) {
      r(Z.blockSize === 16), super(Z), this.encrypt = L, this.hash = new e(), this.ctr = Buffer.alloc(16), this.state = Buffer.alloc(16), this.key = Buffer.alloc(16), this.mask = Buffer.alloc(16), this.tag = null, this.mac = null;
    }
    _init(Z, L) {
      for (let oe = 0; oe < 16; oe++)
        this.ctr[oe] = 0, this.key[oe] = 0, this.mask[oe] = 0;
      return this._encipher(this.key, this.key), this.hash.init(this.key), L.length !== 12 && (this.hash.update(L), L = this.hash.final(), this.hash.init(this.key)), L.copy(this.ctr, 0), L.length === 12 && (this.ctr[12] = 0, this.ctr[13] = 0, this.ctr[14] = 0, this.ctr[15] = 1), this._encipher(this.mask, this.mask), this.tag = null, this.mac = null, this;
    }
    _increment() {
      let Z = 1, L = 4;
      for (; L--; )
        Z += this.ctr[12 + L], this.ctr[12 + L] = Z, Z >>= 8;
    }
    _encipher(Z, L) {
      for (let oe = 0; oe < L.length; oe++)
        this.pos & 15 || (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), Z[oe] = L[oe] ^ this.state[this.pos++];
    }
    _crypt(Z, L) {
      this.encrypt ? (this._encipher(Z, L), this.hash.update(Z)) : (this.hash.update(L), this._encipher(Z, L));
    }
    _final() {
      const Z = this.hash.final();
      for (let L = 0; L < 16; L++)
        Z[L] ^= this.mask[L];
      if (this.encrypt)
        return this.mac = Z, Buffer.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Se(Z, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return Buffer.alloc(0);
    }
    _destroy() {
      this.hash.destroy();
      for (let Z = 0; Z < 16; Z++)
        this.ctr[Z] = 0, this.state[Z] = 0, this.key[Z] = 0, this.mask[Z] = 0;
      if (this.tag) {
        for (let Z = 0; Z < this.tag.length; Z++)
          this.tag[Z] = 0;
        this.tag = null;
      }
    }
    _setAAD(Z) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash.aad(Z), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return Buffer.from(this.mac);
    }
    _setAuthTag(Z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (Z.length !== 4 && Z.length !== 8 && (Z.length < 12 || Z.length > 16))
        throw new RangeError("Invalid tag size.");
      return this.tag = Buffer.from(Z), this;
    }
  }
  class F extends G {
    constructor(Z) {
      super(Z, !0);
    }
  }
  class W extends G {
    constructor(Z) {
      super(Z, !1);
    }
  }
  class ce {
    constructor(Z) {
      this.ctx = Z, this.size = Z.blockSize, this.mac = Buffer.alloc(this.size), this.pos = -1;
    }
    init() {
      return this.mac.fill(0), this.pos = 0, this;
    }
    update(Z) {
      if (r(Buffer.isBuffer(Z)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let L = 0; L < Z.length; L++)
        this.mac[this.pos++] ^= Z[L], this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    pad() {
      this.pos > 0 && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0);
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      return this.pad(), this.pos = -1, Buffer.from(this.mac);
    }
  }
  class ne extends o {
    constructor(Z, L) {
      r(Z.blockSize === 16), super(Z), this.encrypt = L, this.hash = new ce(Z), this.state = Buffer.alloc(16), this.ctr = Buffer.alloc(16), this.tagLen = 0, this.iv = null, this.mac = null, this.tag = null;
    }
    _increment() {
      for (let Z = 15; Z >= 1 && (this.ctr[Z] += 1, this.ctr[Z] === 0); Z--)
        ;
    }
    _encipher(Z, L) {
      for (let oe = 0; oe < L.length; oe++)
        this.pos & 15 || (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), Z[oe] = L[oe] ^ this.state[this.pos++];
    }
    _init(Z, L) {
      if (L.length < 7)
        throw new RangeError("Invalid nonce length.");
      L.length > 13 && (L = L.slice(0, 13)), this.iv = Buffer.from(L), this.pos = -1, this.tagLen = 0, this.mac = null, this.tag = null;
    }
    _setCCM(Z, L, oe) {
      if (!this.iv)
        throw new Error("Cipher is not initialized.");
      let s = Z, a = Math.ceil((32 - Math.clz32(s)) / 8);
      a < 2 && (a = 2);
      const p = L, v = 15 - a, C = (oe && oe.length > 0) | 0, K = Buffer.alloc(16);
      if (p < 4 || p > 16 || p & 1)
        throw new RangeError("Invalid tag length.");
      K[0] = 64 * C + 8 * ((p - 2) / 2) + (a - 1), this.iv.copy(K, 1, 0, Math.min(v, this.iv.length));
      for (let O = 15; O >= 1 + v; O--)
        K[O] = s & 255, s >>>= 8;
      if (r(s === 0), this.hash.init(), this.hash.update(K), C) {
        if (oe.length < 65280) {
          const O = Buffer.alloc(2);
          O[0] = oe.length >>> 8, O[1] = oe.length >>> 0, this.hash.update(O);
        } else if (oe.length < 4294967295) {
          const O = Buffer.alloc(6);
          O[0] = 255, O[1] = 254, O[2] = oe.length >>> 24, O[3] = oe.length >>> 16, O[4] = oe.length >>> 8, O[5] = oe.length >>> 0, this.hash.update(O);
        } else
          throw new RangeError("Invalid AAD length.");
        this.hash.update(oe), this.hash.pad();
      }
      K[0] &= 7, K[15] = 1;
      for (let O = 14; O >= 1 + v; O--)
        K[O] = 0;
      K.copy(this.ctr, 0), this.pos = 0, this.tagLen = p, this.iv = null;
    }
    _crypt(Z, L) {
      this.encrypt ? (this.hash.update(L), this._encipher(Z, L)) : (this._encipher(Z, L), this.hash.update(Z));
    }
    _final() {
      const Z = this.hash.final();
      let L = 16 - ((this.ctr[0] & 7) + 1);
      for (; L < 16; )
        this.ctr[L++] = 0;
      if (this.pos = 0, this._encipher(Z, Z), this.encrypt)
        return this.mac = Z.slice(0, this.tagLen), Buffer.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Se(Z, this.tag, this.tagLen))
        throw new Error("Invalid tag.");
      return Buffer.alloc(0);
    }
    _destroy() {
      for (let Z = 0; Z < 16; Z++)
        this.state[Z] = 0, this.ctr[Z] = 0;
      this.tagLen = 0, this.iv = null, this.tag = null;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return Buffer.from(this.mac);
    }
    _setAuthTag(Z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (this.tagLen === 0 || Z.length !== this.tagLen)
        throw new RangeError("Invalid tag size.");
      return this.tag = Buffer.from(Z), this;
    }
  }
  class xe extends ne {
    constructor(Z) {
      super(Z, !0);
    }
  }
  class he extends ne {
    constructor(Z) {
      super(Z, !1);
    }
  }
  class me {
    constructor(Z) {
      this.ctx = Z, this.poly = i[Z.blockSize >>> 4], this.size = Z.blockSize, this.mac = Buffer.alloc(this.size), this.pos = -1;
    }
    init(Z) {
      return this.mac.fill(0), this.pos = 0, Z != null && (this.mac[this.size - 1] ^= Z, this.pos = this.size), this;
    }
    shift(Z, L) {
      let oe = 0;
      for (let s = this.size - 1; s >= 0; s--) {
        const a = L[s] >> 7;
        Z[s] = L[s] << 1 | oe, oe = a;
      }
      oe = -oe & 255, Z[this.size - 3] ^= this.poly >> 16 & oe, Z[this.size - 2] ^= this.poly >> 8 & oe, Z[this.size - 1] ^= this.poly >> 0 & oe;
    }
    update(Z) {
      if (r(Buffer.isBuffer(Z)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let L = 0; L < Z.length; L++)
        this.pos === this.size && (this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = 0), this.mac[this.pos++] ^= Z[L];
    }
    final() {
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      const Z = Buffer.alloc(this.size);
      this.ctx.encrypt(Z, 0, Z, 0), this.shift(Z, Z), this.pos < this.size && (this.mac[this.pos] ^= 128, this.shift(Z, Z));
      for (let L = 0; L < this.size; L++)
        this.mac[L] ^= Z[L];
      return this.ctx.encrypt(this.mac, 0, this.mac, 0), this.pos = -1, Buffer.from(this.mac);
    }
  }
  class Ne extends o {
    constructor(Z, L) {
      super(Z), this.encrypt = L, this.hash1 = new me(Z), this.hash2 = new me(Z), this.state = Buffer.alloc(this.blockSize), this.ctr = Buffer.alloc(this.blockSize), this.mask = Buffer.alloc(this.blockSize), this.mac = null, this.tag = null;
    }
    _increment() {
      let Z = this.blockSize, L = 1;
      for (; Z--; )
        L += this.ctr[Z], this.ctr[Z] = L, L >>= 8;
    }
    _encipher(Z, L) {
      const oe = this.blockSize - 1;
      for (let s = 0; s < L.length; s++)
        this.pos & oe || (this.ctx.encrypt(this.state, 0, this.ctr, 0), this._increment(), this.pos = 0), Z[s] = L[s] ^ this.state[this.pos++];
    }
    _init(Z, L) {
      r(L.length > 0), this.hash1.init(0), this.hash1.update(L), this.mask = this.hash1.final(), this.mask.copy(this.ctr, 0), this.hash1.init(1), this.hash2.init(2), this.mac = null, this.tag = null;
    }
    _crypt(Z, L) {
      this.encrypt ? (this._encipher(Z, L), this.hash2.update(Z)) : (this.hash2.update(L), this._encipher(Z, L));
    }
    _final() {
      const Z = Buffer.alloc(this.blockSize), L = this.hash1.final(), oe = this.hash2.final();
      for (let s = 0; s < this.blockSize; s++)
        Z[s] = L[s] ^ oe[s] ^ this.mask[s];
      if (this.encrypt)
        return this.mac = Z, Buffer.alloc(0);
      if (!this.tag)
        throw new Error("No tag provided.");
      if (!Se(Z, this.tag, this.tag.length))
        throw new Error("Invalid tag.");
      return Buffer.alloc(0);
    }
    _destroy() {
      for (let Z = 0; Z < this.blockSize; Z++)
        this.state[Z] = 0, this.ctr[Z] = 0, this.mask[Z] = 0;
      this.tag = null;
    }
    _setAAD(Z) {
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      return this.hash1.update(Z), this;
    }
    _getAuthTag() {
      if (!this.encrypt)
        throw new Error("Must be a cipher context.");
      if (!this.mac)
        throw new Error("Cipher is not finalized.");
      return Buffer.from(this.mac);
    }
    _setAuthTag(Z) {
      if (this.encrypt)
        throw new Error("Must be a decipher context.");
      if (this.pos === -1)
        throw new Error("Cipher is not initialized.");
      if (Z.length === 0 || Z.length > this.blockSize)
        throw new RangeError("Invalid tag size.");
      return this.tag = Buffer.from(Z), this;
    }
  }
  class Je extends Ne {
    constructor(Z) {
      super(Z, !0);
    }
  }
  class Ze extends Ne {
    constructor(Z) {
      super(Z, !1);
    }
  }
  function ht(we, Z = !0) {
    switch (r(typeof we == "string"), r(typeof Z == "boolean"), we) {
      case "RAW":
        return Z ? d : l;
      case "ECB":
        return Z ? b : g;
      case "CBC":
        return Z ? w : I;
      case "CTS":
        return Z ? B : y;
      case "XTS":
        return Z ? _ : q;
      case "CTR":
        return Z ? z : E;
      case "CFB":
        return Z ? k : V;
      case "OFB":
        return Z ? ie : N;
      case "GCM":
        return Z ? F : W;
      case "CCM":
        return Z ? xe : he;
      case "EAX":
        return Z ? Je : Ze;
      default:
        throw new Error(`Unknown mode: ${we}.`);
    }
  }
  function dt(we, Z, L, oe) {
    return we.buffer === L.buffer && we.byteOffset === L.byteOffset && Z === oe;
  }
  function Se(we, Z, L) {
    let oe = 0;
    for (let s = 0; s < L; s++)
      oe |= we[s] ^ Z[s];
    return oe - 1 >>> 31;
  }
  return Lt.Mode = n, Lt.Block = c, Lt.Stream = o, Lt.RawCipher = d, Lt.RawDecipher = l, Lt.PKCS7Cipher = h, Lt.PKCS7Decipher = x, Lt.ECBCipher = b, Lt.ECBDecipher = g, Lt.CBCCipher = w, Lt.CBCDecipher = I, Lt.CTSCipher = B, Lt.CTSDecipher = y, Lt.XTS = A, Lt.XTSCipher = _, Lt.XTSDecipher = q, Lt.CTR = U, Lt.CTRCipher = z, Lt.CTRDecipher = E, Lt.CFB = H, Lt.CFBCipher = k, Lt.CFBDecipher = V, Lt.OFB = T, Lt.OFBCipher = ie, Lt.OFBDecipher = N, Lt.GCM = G, Lt.GCMCipher = F, Lt.GCMDecipher = W, Lt.CBCMAC = ce, Lt.CCM = ne, Lt.CCMCipher = xe, Lt.CCMDecipher = he, Lt.CMAC = me, Lt.EAX = Ne, Lt.EAXCipher = Je, Lt.EAXDecipher = Ze, Lt.get = ht, Lt;
}
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var S2;
function Yp() {
  if (S2)
    return tf;
  S2 = 1;
  const r = G1(), { CBCCipher: e, CBCDecipher: t } = h8();
  function i(c, o, d) {
    const l = new e(new r(256));
    return l.init(o, d), Buffer.concat([l.update(c), l.final()]);
  }
  function n(c, o, d) {
    const l = new t(new r(256));
    return l.init(o, d), Buffer.concat([l.update(c), l.final()]);
  }
  return tf.native = 0, tf.encipher = i, tf.decipher = n, tf;
}
var rf = {};
/*!
 * aes.js - aes for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var B2;
function Jp() {
  if (B2)
    return rf;
  B2 = 1;
  const r = _e, e = Dt(), t = e.ciphers.AES256, i = e.modes.CBC;
  function n(o, d, l) {
    r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l));
    const { buffer: h, length: x } = e.cipher_encrypt(t, i, d, l, o);
    return Buffer.from(h, 0, x);
  }
  function c(o, d, l) {
    r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l));
    const { buffer: h, length: x } = e.cipher_decrypt(t, i, d, l, o);
    return Buffer.from(h, 0, x);
  }
  return rf.native = 2, rf.encipher = n, rf.decipher = c, rf;
}
/*!
 * aes.js - aes for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? hu.exports = Yp() : hu.exports = Jp();
var Xp = hu.exports, du = { exports: {} };
/*!
 * arc4.js - ARC4 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RC4
 *   http://cypherpunks.venona.com/archive/1994/09/msg00304.html
 *   https://web.archive.org/web/20080207125928/http://cypherpunks.venona.com/archive/1994/09/msg00304.html
 *   https://tools.ietf.org/html/rfc4345
 *   https://tools.ietf.org/html/rfc6229
 *   https://github.com/golang/go/blob/master/src/crypto/rc4/rc4.go
 */
var Oa, v2;
function Zp() {
  if (v2)
    return Oa;
  v2 = 1;
  const r = _e;
  class e {
    constructor() {
      this.s = new Uint32Array(256), this.i = -1, this.j = -1;
    }
    init(i) {
      r(Buffer.isBuffer(i));
      const n = i.length;
      if (n < 1 || n > 256)
        throw new Error("Invalid key size.");
      const c = this.s;
      for (let d = 0; d < 256; d++)
        c[d] = d;
      let o = 0;
      for (let d = 0; d < 256; d++)
        o += c[d] + i[d % n], o &= 255, [c[d], c[o]] = [c[o], c[d]];
      return this.i = 0, this.j = 0, this;
    }
    encrypt(i) {
      if (r(Buffer.isBuffer(i)), this.i === -1)
        throw new Error("Context is not initialized.");
      const n = this.s;
      let { i: c, j: o } = this, d, l;
      for (let h = 0; h < i.length; h++)
        c = c + 1 & 255, d = n[c], o = o + d & 255, l = n[o], n[c] = l, n[o] = d, i[h] ^= n[d + l & 255];
      return this.i = c, this.j = o, i;
    }
    destroy() {
      for (let i = 0; i < 256; i++)
        this.s[i] = 0;
      return this.i = -1, this.j = -1, this;
    }
  }
  return e.native = 0, Oa = e, Oa;
}
/*!
 * arc4.js - ARC4 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Pa, E2;
function Wp() {
  if (E2)
    return Pa;
  E2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor() {
      this._handle = e.arc4_create();
    }
    init(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.arc4_init(this._handle, n), this;
    }
    encrypt(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.arc4_crypt(this._handle, n), n;
    }
    destroy() {
      return r(this instanceof t), e.arc4_destroy(this._handle), this;
    }
  }
  return t.native = 2, Pa = t, Pa;
}
/*!
 * arc4.js - arc4 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? du.exports = Zp() : du.exports = Wp();
var jp = du.exports, uu = { exports: {} }, xs = {}, lu = { exports: {} };
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */
const on = _e;
let Qp = class {
  /**
   * Create an HMAC.
   * @param {Function} Hash
   * @param {Number} size
   * @param {Array} [x=[]]
   * @param {Array} [y=[]]
   */
  constructor(e, t, i = [], n = []) {
    on(typeof e == "function"), on(t >>> 0 === t), on(Array.isArray(i)), on(Array.isArray(n)), this.hash = e, this.size = t, this.x = i, this.y = n, this.inner = new e(), this.outer = new e();
  }
  /**
   * Initialize HMAC context.
   * @param {Buffer} data
   */
  init(e) {
    if (on(Buffer.isBuffer(e)), e.length > this.size) {
      const i = this.hash, n = new i();
      n.init(...this.x), n.update(e), e = n.final(...this.y), on(e.length <= this.size);
    }
    const t = Buffer.alloc(this.size);
    for (let i = 0; i < e.length; i++)
      t[i] = e[i] ^ 54;
    for (let i = e.length; i < t.length; i++)
      t[i] = 54;
    this.inner.init(...this.x), this.inner.update(t);
    for (let i = 0; i < e.length; i++)
      t[i] = e[i] ^ 92;
    for (let i = e.length; i < t.length; i++)
      t[i] = 92;
    return this.outer.init(...this.x), this.outer.update(t), this;
  }
  /**
   * Update HMAC context.
   * @param {Buffer} data
   */
  update(e) {
    return this.inner.update(e), this;
  }
  /**
   * Finalize HMAC context.
   * @returns {Buffer}
   */
  final() {
    return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y);
  }
};
var Rr = Qp;
/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */
var Ra, I2;
function d8() {
  if (I2)
    return Ra;
  I2 = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(16, 0), n = Buffer.alloc(128, 0);
  n[0] = 128;
  const c = new Uint32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  class o {
    constructor() {
      this.state = new Uint32Array(16), this.msg = new Uint32Array(160), this.block = Buffer.alloc(128), this.size = t;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 4089235720, this.state[2] = 3144134277, this.state[3] = 2227873595, this.state[4] = 1013904242, this.state[5] = 4271175723, this.state[6] = 2773480762, this.state[7] = 1595750129, this.state[8] = 1359893119, this.state[9] = 2917565137, this.state[10] = 2600822924, this.state[11] = 725511199, this.state[12] = 528734635, this.state[13] = 4215389547, this.state[14] = 1541459225, this.state[15] = 327033209, this.size = 0, this;
    }
    update(ne) {
      return r(Buffer.isBuffer(ne)), this._update(ne, ne.length), this;
    }
    final() {
      return this._final(Buffer.alloc(64));
    }
    _update(ne, xe) {
      r(this.size !== t, "Context is not initialized.");
      let he = this.size & 127, me = 0;
      if (this.size += xe, he > 0) {
        let Ne = 128 - he;
        if (Ne > xe && (Ne = xe), ne.copy(this.block, he, me, me + Ne), he += Ne, xe -= Ne, me += Ne, he < 128)
          return;
        this._transform(this.block, 0);
      }
      for (; xe >= 128; )
        this._transform(ne, me), me += 128, xe -= 128;
      xe > 0 && ne.copy(this.block, 0, me, me + xe);
    }
    /**
     * Finalize SHA512 context.
     * @private
     * @param {Buffer} out
     * @returns {Buffer}
     */
    _final(ne) {
      r(this.size !== t, "Context is not initialized.");
      const xe = this.size & 127, he = this.size * 8;
      W(i, he * (1 / 4294967296) >>> 0, 8), W(i, he >>> 0, 12), this._update(n, 1 + (239 - xe & 127)), this._update(i, 16);
      for (let me = 0; me < 16; me++)
        W(ne, this.state[me], me * 4), this.state[me] = 0;
      for (let me = 0; me < 160; me++)
        this.msg[me] = 0;
      for (let me = 0; me < 128; me++)
        this.block[me] = 0;
      return this.size = t, ne;
    }
    _prepare(ne, xe) {
      const he = this.msg;
      let me = 0;
      for (; me < 32; me++)
        he[me] = F(ne, xe + me * 4);
      for (; me < 160; me += 2) {
        const Ne = N(he[me - 4], he[me - 3]), Je = G(he[me - 4], he[me - 3]), Ze = he[me - 14], ht = he[me - 13], dt = T(he[me - 30], he[me - 29]), Se = ie(he[me - 30], he[me - 29]), we = he[me - 32], Z = he[me - 31];
        he[me + 0] = x(Ne, Je, Ze, ht, dt, Se, we, Z), he[me + 1] = b(Ne, Je, Ze, ht, dt, Se, we, Z);
      }
    }
    _transform(ne, xe) {
      const he = this.msg;
      this._prepare(ne, xe);
      let me = this.state[0], Ne = this.state[1], Je = this.state[2], Ze = this.state[3], ht = this.state[4], dt = this.state[5], Se = this.state[6], we = this.state[7], Z = this.state[8], L = this.state[9], oe = this.state[10], s = this.state[11], a = this.state[12], p = this.state[13], v = this.state[14], C = this.state[15];
      for (let K = 0; K < he.length; K += 2) {
        let O = v, $ = C, u = k(Z, L), S = V(Z, L);
        const M = _(Z, L, oe, s, a), Y = q(Z, L, oe, s, a, p), J = c[K + 0], X = c[K + 1], re = he[K + 0], ae = he[K + 1], de = g(O, $, u, S, M, Y, J, X, re, ae), ge = w(O, $, u, S, M, Y, J, X, re, ae);
        O = E(me, Ne), $ = H(me, Ne), u = U(me, Ne, Je, Ze, ht), S = z(me, Ne, Je, Ze, ht, dt);
        const Be = l(O, $, u, S), ve = h(O, $, u, S);
        v = a, C = p, a = oe, p = s, oe = Z, s = L, Z = l(Se, we, de, ge), L = h(we, we, de, ge), Se = ht, we = dt, ht = Je, dt = Ze, Je = me, Ze = Ne, me = l(de, ge, Be, ve), Ne = h(de, ge, Be, ve);
      }
      d(this.state, 0, me, Ne), d(this.state, 2, Je, Ze), d(this.state, 4, ht, dt), d(this.state, 6, Se, we), d(this.state, 8, Z, L), d(this.state, 10, oe, s), d(this.state, 12, a, p), d(this.state, 14, v, C);
    }
    static hash() {
      return new o();
    }
    static hmac() {
      return new e(o, 128);
    }
    static digest(ne) {
      return o.ctx.init().update(ne).final();
    }
    static root(ne, xe) {
      return r(Buffer.isBuffer(ne) && ne.length === 64), r(Buffer.isBuffer(xe) && xe.length === 64), o.ctx.init().update(ne).update(xe).final();
    }
    static multi(ne, xe, he) {
      const { ctx: me } = o;
      return me.init(), me.update(ne), me.update(xe), he && me.update(he), me.final();
    }
    static mac(ne, xe) {
      return o.hmac().init(xe).update(ne).final();
    }
  }
  o.native = 0, o.id = "SHA512", o.size = 64, o.bits = 512, o.blockSize = 128, o.zero = Buffer.alloc(64, 0), o.ctx = new o();
  function d(ce, ne, xe, he) {
    const me = ce[ne + 0], Ne = ce[ne + 1], Je = he + Ne >>> 0, Ze = (Je < he) + xe + me;
    ce[ne + 0] = Ze >>> 0, ce[ne + 1] = Je;
  }
  function l(ce, ne, xe, he) {
    return (ne + he >>> 0 < ne) + ce + xe >>> 0;
  }
  function h(ce, ne, xe, he) {
    return ne + he >>> 0;
  }
  function x(ce, ne, xe, he, me, Ne, Je, Ze) {
    let ht = 0, dt = ne;
    return dt = dt + he >>> 0, ht += dt < ne, dt = dt + Ne >>> 0, ht += dt < Ne, dt = dt + Ze >>> 0, ht += dt < Ze, ce + xe + me + Je + ht >>> 0;
  }
  function b(ce, ne, xe, he, me, Ne, Je, Ze) {
    return ne + he + Ne + Ze >>> 0;
  }
  function g(ce, ne, xe, he, me, Ne, Je, Ze, ht, dt) {
    let Se = 0, we = ne;
    return we = we + he >>> 0, Se += we < ne, we = we + Ne >>> 0, Se += we < Ne, we = we + Ze >>> 0, Se += we < Ze, we = we + dt >>> 0, Se += we < dt, ce + xe + me + Je + ht + Se >>> 0;
  }
  function w(ce, ne, xe, he, me, Ne, Je, Ze, ht, dt) {
    return ne + he + Ne + Ze + dt >>> 0;
  }
  function I(ce, ne, xe) {
    return (ne << 32 - xe | ce >>> xe) >>> 0;
  }
  function B(ce, ne, xe) {
    return (ce << 32 - xe | ne >>> xe) >>> 0;
  }
  function y(ce, ne, xe) {
    return ce >>> xe;
  }
  function A(ce, ne, xe) {
    return (ce << 32 - xe | ne >>> xe) >>> 0;
  }
  function _(ce, ne, xe, he, me, Ne) {
    return (ce & xe ^ ~ce & me) >>> 0;
  }
  function q(ce, ne, xe, he, me, Ne) {
    return (ne & he ^ ~ne & Ne) >>> 0;
  }
  function U(ce, ne, xe, he, me, Ne) {
    return (ce & xe ^ ce & me ^ xe & me) >>> 0;
  }
  function z(ce, ne, xe, he, me, Ne) {
    return (ne & he ^ ne & Ne ^ he & Ne) >>> 0;
  }
  function E(ce, ne) {
    const xe = I(ce, ne, 28), he = I(ne, ce, 2), me = I(ne, ce, 7);
    return (xe ^ he ^ me) >>> 0;
  }
  function H(ce, ne) {
    const xe = B(ce, ne, 28), he = B(ne, ce, 2), me = B(ne, ce, 7);
    return (xe ^ he ^ me) >>> 0;
  }
  function k(ce, ne) {
    const xe = I(ce, ne, 14), he = I(ce, ne, 18), me = I(ne, ce, 9);
    return (xe ^ he ^ me) >>> 0;
  }
  function V(ce, ne) {
    const xe = B(ce, ne, 14), he = B(ce, ne, 18), me = B(ne, ce, 9);
    return (xe ^ he ^ me) >>> 0;
  }
  function T(ce, ne) {
    const xe = I(ce, ne, 1), he = I(ce, ne, 8), me = y(ce, ne, 7);
    return (xe ^ he ^ me) >>> 0;
  }
  function ie(ce, ne) {
    const xe = B(ce, ne, 1), he = B(ce, ne, 8), me = A(ce, ne, 7);
    return (xe ^ he ^ me) >>> 0;
  }
  function N(ce, ne) {
    const xe = I(ce, ne, 19), he = I(ne, ce, 29), me = y(ce, ne, 6);
    return (xe ^ he ^ me) >>> 0;
  }
  function G(ce, ne) {
    const xe = B(ce, ne, 19), he = B(ne, ce, 29), me = A(ce, ne, 6);
    return (xe ^ he ^ me) >>> 0;
  }
  function F(ce, ne) {
    return ce[ne++] * 16777216 + ce[ne++] * 65536 + ce[ne++] * 256 + ce[ne];
  }
  function W(ce, ne, xe) {
    return ce[xe++] = ne >>> 24, ce[xe++] = ne >>> 16, ce[xe++] = ne >>> 8, ce[xe++] = ne, xe;
  }
  return Ra = o, Ra;
}
var sf = {};
/*!
 * hash.js - hash implementation for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var A2;
function q0() {
  if (A2)
    return sf;
  A2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor(c) {
      r(c >>> 0 === c), this._handle = e.hash_create(c);
    }
    init() {
      return r(this instanceof t), e.hash_init(this._handle), this;
    }
    update(c) {
      return r(this instanceof t), r(Buffer.isBuffer(c)), e.hash_update(this._handle, c), this;
    }
    final() {
      return r(this instanceof t), e.hash_final(this._handle);
    }
    static hash(c) {
      return new t(c);
    }
    static hmac(c) {
      return new i(c);
    }
    static digest(c, o) {
      return r(c >>> 0 === c), r(Buffer.isBuffer(o)), e.hash_digest(c, o);
    }
    static root(c, o, d) {
      return r(c >>> 0 === c), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), e.hash_root(c, o, d);
    }
    static multi(c, o, d, l) {
      return l == null && (l = e.NULL), r(c >>> 0 === c), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), e.hash_multi(c, o, d, l);
    }
    static mac(c, o, d) {
      return i.digest(c, o, d);
    }
  }
  class i {
    constructor(c) {
      r(c >>> 0 === c), this._handle = e.hmac_create(c);
    }
    init(c) {
      return r(this instanceof i), r(Buffer.isBuffer(c)), e.hmac_init(this._handle, c), this;
    }
    update(c) {
      return r(this instanceof i), r(Buffer.isBuffer(c)), e.hmac_update(this._handle, c), this;
    }
    final() {
      return r(this instanceof i), e.hmac_final(this._handle);
    }
    static digest(c, o, d) {
      return r(c >>> 0 === c), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), e.hmac_digest(c, o, d);
    }
  }
  return sf.Hash = t, sf.HMAC = i, sf.hashes = e.hashes, sf;
}
/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ka, _2;
function em() {
  if (_2)
    return ka;
  _2 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.SHA512);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.SHA512);
    }
    static digest(c) {
      return r.digest(t.SHA512, c);
    }
    static root(c, o) {
      return r.root(t.SHA512, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.SHA512, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.SHA512, c, o);
    }
  }
  return i.native = 2, i.id = "SHA512", i.size = 64, i.bits = 512, i.blockSize = 128, i.zero = Buffer.alloc(64, 0), i.ctx = new i(), ka = i, ka;
}
/*!
 * sha512.js - sha512 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? lu.exports = d8() : lu.exports = em();
var Cf = lu.exports;
/*!
 * blowfish.js - blowfish for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on joyent/node-bcrypt-pbkdf:
 *   Copyright (c) 2016, Joyent Inc
 *   https://github.com/joyent/node-bcrypt-pbkdf
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Blowfish_(cipher)
 *   https://www.schneier.com/blowfish.html
 *   https://github.com/joyent/node-bcrypt-pbkdf/blob/master/index.js
 */
var qa, M2;
function u8() {
  if (M2)
    return qa;
  M2 = 1;
  const r = _e, e = new Uint32Array([
    3509652390,
    2564797868,
    805139163,
    3491422135,
    3101798381,
    1780907670,
    3128725573,
    4046225305,
    614570311,
    3012652279,
    134345442,
    2240740374,
    1667834072,
    1901547113,
    2757295779,
    4103290238,
    227898511,
    1921955416,
    1904987480,
    2182433518,
    2069144605,
    3260701109,
    2620446009,
    720527379,
    3318853667,
    677414384,
    3393288472,
    3101374703,
    2390351024,
    1614419982,
    1822297739,
    2954791486,
    3608508353,
    3174124327,
    2024746970,
    1432378464,
    3864339955,
    2857741204,
    1464375394,
    1676153920,
    1439316330,
    715854006,
    3033291828,
    289532110,
    2706671279,
    2087905683,
    3018724369,
    1668267050,
    732546397,
    1947742710,
    3462151702,
    2609353502,
    2950085171,
    1814351708,
    2050118529,
    680887927,
    999245976,
    1800124847,
    3300911131,
    1713906067,
    1641548236,
    4213287313,
    1216130144,
    1575780402,
    4018429277,
    3917837745,
    3693486850,
    3949271944,
    596196993,
    3549867205,
    258830323,
    2213823033,
    772490370,
    2760122372,
    1774776394,
    2652871518,
    566650946,
    4142492826,
    1728879713,
    2882767088,
    1783734482,
    3629395816,
    2517608232,
    2874225571,
    1861159788,
    326777828,
    3124490320,
    2130389656,
    2716951837,
    967770486,
    1724537150,
    2185432712,
    2364442137,
    1164943284,
    2105845187,
    998989502,
    3765401048,
    2244026483,
    1075463327,
    1455516326,
    1322494562,
    910128902,
    469688178,
    1117454909,
    936433444,
    3490320968,
    3675253459,
    1240580251,
    122909385,
    2157517691,
    634681816,
    4142456567,
    3825094682,
    3061402683,
    2540495037,
    79693498,
    3249098678,
    1084186820,
    1583128258,
    426386531,
    1761308591,
    1047286709,
    322548459,
    995290223,
    1845252383,
    2603652396,
    3431023940,
    2942221577,
    3202600964,
    3727903485,
    1712269319,
    422464435,
    3234572375,
    1170764815,
    3523960633,
    3117677531,
    1434042557,
    442511882,
    3600875718,
    1076654713,
    1738483198,
    4213154764,
    2393238008,
    3677496056,
    1014306527,
    4251020053,
    793779912,
    2902807211,
    842905082,
    4246964064,
    1395751752,
    1040244610,
    2656851899,
    3396308128,
    445077038,
    3742853595,
    3577915638,
    679411651,
    2892444358,
    2354009459,
    1767581616,
    3150600392,
    3791627101,
    3102740896,
    284835224,
    4246832056,
    1258075500,
    768725851,
    2589189241,
    3069724005,
    3532540348,
    1274779536,
    3789419226,
    2764799539,
    1660621633,
    3471099624,
    4011903706,
    913787905,
    3497959166,
    737222580,
    2514213453,
    2928710040,
    3937242737,
    1804850592,
    3499020752,
    2949064160,
    2386320175,
    2390070455,
    2415321851,
    4061277028,
    2290661394,
    2416832540,
    1336762016,
    1754252060,
    3520065937,
    3014181293,
    791618072,
    3188594551,
    3933548030,
    2332172193,
    3852520463,
    3043980520,
    413987798,
    3465142937,
    3030929376,
    4245938359,
    2093235073,
    3534596313,
    375366246,
    2157278981,
    2479649556,
    555357303,
    3870105701,
    2008414854,
    3344188149,
    4221384143,
    3956125452,
    2067696032,
    3594591187,
    2921233993,
    2428461,
    544322398,
    577241275,
    1471733935,
    610547355,
    4027169054,
    1432588573,
    1507829418,
    2025931657,
    3646575487,
    545086370,
    48609733,
    2200306550,
    1653985193,
    298326376,
    1316178497,
    3007786442,
    2064951626,
    458293330,
    2589141269,
    3591329599,
    3164325604,
    727753846,
    2179363840,
    146436021,
    1461446943,
    4069977195,
    705550613,
    3059967265,
    3887724982,
    4281599278,
    3313849956,
    1404054877,
    2845806497,
    146425753,
    1854211946
  ]), t = new Uint32Array([
    1266315497,
    3048417604,
    3681880366,
    3289982499,
    290971e4,
    1235738493,
    2632868024,
    2414719590,
    3970600049,
    1771706367,
    1449415276,
    3266420449,
    422970021,
    1963543593,
    2690192192,
    3826793022,
    1062508698,
    1531092325,
    1804592342,
    2583117782,
    2714934279,
    4024971509,
    1294809318,
    4028980673,
    1289560198,
    2221992742,
    1669523910,
    35572830,
    157838143,
    1052438473,
    1016535060,
    1802137761,
    1753167236,
    1386275462,
    3080475397,
    2857371447,
    1040679964,
    2145300060,
    2390574316,
    1461121720,
    2956646967,
    4031777805,
    4028374788,
    33600511,
    2920084762,
    1018524850,
    629373528,
    3691585981,
    3515945977,
    2091462646,
    2486323059,
    586499841,
    988145025,
    935516892,
    3367335476,
    2599673255,
    2839830854,
    265290510,
    3972581182,
    2759138881,
    3795373465,
    1005194799,
    847297441,
    406762289,
    1314163512,
    1332590856,
    1866599683,
    4127851711,
    750260880,
    613907577,
    1450815602,
    3165620655,
    3734664991,
    3650291728,
    3012275730,
    3704569646,
    1427272223,
    778793252,
    1343938022,
    2676280711,
    2052605720,
    1946737175,
    3164576444,
    3914038668,
    3967478842,
    3682934266,
    1661551462,
    3294938066,
    4011595847,
    840292616,
    3712170807,
    616741398,
    312560963,
    711312465,
    1351876610,
    322626781,
    1910503582,
    271666773,
    2175563734,
    1594956187,
    70604529,
    3617834859,
    1007753275,
    1495573769,
    4069517037,
    2549218298,
    2663038764,
    504708206,
    2263041392,
    3941167025,
    2249088522,
    1514023603,
    1998579484,
    1312622330,
    694541497,
    2582060303,
    2151582166,
    1382467621,
    776784248,
    2618340202,
    3323268794,
    2497899128,
    2784771155,
    503983604,
    4076293799,
    907881277,
    423175695,
    432175456,
    1378068232,
    4145222326,
    3954048622,
    3938656102,
    3820766613,
    2793130115,
    2977904593,
    26017576,
    3274890735,
    3194772133,
    1700274565,
    1756076034,
    4006520079,
    3677328699,
    720338349,
    1533947780,
    354530856,
    688349552,
    3973924725,
    1637815568,
    332179504,
    3949051286,
    53804574,
    2852348879,
    3044236432,
    1282449977,
    3583942155,
    3416972820,
    4006381244,
    1617046695,
    2628476075,
    3002303598,
    1686838959,
    431878346,
    2686675385,
    1700445008,
    1080580658,
    1009431731,
    832498133,
    3223435511,
    2605976345,
    2271191193,
    2516031870,
    1648197032,
    4164389018,
    2548247927,
    300782431,
    375919233,
    238389289,
    3353747414,
    2531188641,
    2019080857,
    1475708069,
    455242339,
    2609103871,
    448939670,
    3451063019,
    1395535956,
    2413381860,
    1841049896,
    1491858159,
    885456874,
    4264095073,
    4001119347,
    1565136089,
    3898914787,
    1108368660,
    540939232,
    1173283510,
    2745871338,
    3681308437,
    4207628240,
    3343053890,
    4016749493,
    1699691293,
    1103962373,
    3625875870,
    2256883143,
    3830138730,
    1031889488,
    3479347698,
    1535977030,
    4236805024,
    3251091107,
    2132092099,
    1774941330,
    1199868427,
    1452454533,
    157007616,
    2904115357,
    342012276,
    595725824,
    1480756522,
    206960106,
    497939518,
    591360097,
    863170706,
    2375253569,
    3596610801,
    1814182875,
    2094937945,
    3421402208,
    1082520231,
    3463918190,
    2785509508,
    435703966,
    3908032597,
    1641649973,
    2842273706,
    3305899714,
    1510255612,
    2148256476,
    2655287854,
    3276092548,
    4258621189,
    236887753,
    3681803219,
    274041037,
    1734335097,
    3815195456,
    3317970021,
    1899903192,
    1026095262,
    4050517792,
    356393447,
    2410691914,
    3873677099,
    3682840055
  ]), i = new Uint32Array([
    3913112168,
    2491498743,
    4132185628,
    2489919796,
    1091903735,
    1979897079,
    3170134830,
    3567386728,
    3557303409,
    857797738,
    1136121015,
    1342202287,
    507115054,
    2535736646,
    337727348,
    3213592640,
    1301675037,
    2528481711,
    1895095763,
    1721773893,
    3216771564,
    62756741,
    2142006736,
    835421444,
    2531993523,
    1442658625,
    3659876326,
    2882144922,
    676362277,
    1392781812,
    170690266,
    3921047035,
    1759253602,
    3611846912,
    1745797284,
    664899054,
    1329594018,
    3901205900,
    3045908486,
    2062866102,
    2865634940,
    3543621612,
    3464012697,
    1080764994,
    553557557,
    3656615353,
    3996768171,
    991055499,
    499776247,
    1265440854,
    648242737,
    3940784050,
    980351604,
    3713745714,
    1749149687,
    3396870395,
    4211799374,
    3640570775,
    1161844396,
    3125318951,
    1431517754,
    545492359,
    4268468663,
    3499529547,
    1437099964,
    2702547544,
    3433638243,
    2581715763,
    2787789398,
    1060185593,
    1593081372,
    2418618748,
    4260947970,
    69676912,
    2159744348,
    86519011,
    2512459080,
    3838209314,
    1220612927,
    3339683548,
    133810670,
    1090789135,
    1078426020,
    1569222167,
    845107691,
    3583754449,
    4072456591,
    1091646820,
    628848692,
    1613405280,
    3757631651,
    526609435,
    236106946,
    48312990,
    2942717905,
    3402727701,
    1797494240,
    859738849,
    992217954,
    4005476642,
    2243076622,
    3870952857,
    3732016268,
    765654824,
    3490871365,
    2511836413,
    1685915746,
    3888969200,
    1414112111,
    2273134842,
    3281911079,
    4080962846,
    172450625,
    2569994100,
    980381355,
    4109958455,
    2819808352,
    2716589560,
    2568741196,
    3681446669,
    3329971472,
    1835478071,
    660984891,
    3704678404,
    4045999559,
    3422617507,
    3040415634,
    1762651403,
    1719377915,
    3470491036,
    2693910283,
    3642056355,
    3138596744,
    1364962596,
    2073328063,
    1983633131,
    926494387,
    3423689081,
    2150032023,
    4096667949,
    1749200295,
    3328846651,
    309677260,
    2016342300,
    1779581495,
    3079819751,
    111262694,
    1274766160,
    443224088,
    298511866,
    1025883608,
    3806446537,
    1145181785,
    168956806,
    3641502830,
    3584813610,
    1689216846,
    3666258015,
    3200248200,
    1692713982,
    2646376535,
    4042768518,
    1618508792,
    1610833997,
    3523052358,
    4130873264,
    2001055236,
    3610705100,
    2202168115,
    4028541809,
    2961195399,
    1006657119,
    2006996926,
    3186142756,
    1430667929,
    3210227297,
    1314452623,
    4074634658,
    4101304120,
    2273951170,
    1399257539,
    3367210612,
    3027628629,
    1190975929,
    2062231137,
    2333990788,
    2221543033,
    2438960610,
    1181637006,
    548689776,
    2362791313,
    3372408396,
    3104550113,
    3145860560,
    296247880,
    1970579870,
    3078560182,
    3769228297,
    1714227617,
    3291629107,
    3898220290,
    166772364,
    1251581989,
    493813264,
    448347421,
    195405023,
    2709975567,
    677966185,
    3703036547,
    1463355134,
    2715995803,
    1338867538,
    1343315457,
    2802222074,
    2684532164,
    233230375,
    2599980071,
    2000651841,
    3277868038,
    1638401717,
    4028070440,
    3237316320,
    6314154,
    819756386,
    300326615,
    590932579,
    1405279636,
    3267499572,
    3150704214,
    2428286686,
    3959192993,
    3461946742,
    1862657033,
    1266418056,
    963775037,
    2089974820,
    2263052895,
    1917689273,
    448879540,
    3550394620,
    3981727096,
    150775221,
    3627908307,
    1303187396,
    508620638,
    2975983352,
    2726630617,
    1817252668,
    1876281319,
    1457606340,
    908771278,
    3720792119,
    3617206836,
    2455994898,
    1729034894,
    1080033504
  ]), n = new Uint32Array([
    976866871,
    3556439503,
    2881648439,
    1522871579,
    1555064734,
    1336096578,
    3548522304,
    2579274686,
    3574697629,
    3205460757,
    3593280638,
    3338716283,
    3079412587,
    564236357,
    2993598910,
    1781952180,
    1464380207,
    3163844217,
    3332601554,
    1699332808,
    1393555694,
    1183702653,
    3581086237,
    1288719814,
    691649499,
    2847557200,
    2895455976,
    3193889540,
    2717570544,
    1781354906,
    1676643554,
    2592534050,
    3230253752,
    1126444790,
    2770207658,
    2633158820,
    2210423226,
    2615765581,
    2414155088,
    3127139286,
    673620729,
    2805611233,
    1269405062,
    4015350505,
    3341807571,
    4149409754,
    1057255273,
    2012875353,
    2162469141,
    2276492801,
    2601117357,
    993977747,
    3918593370,
    2654263191,
    753973209,
    36408145,
    2530585658,
    25011837,
    3520020182,
    2088578344,
    530523599,
    2918365339,
    1524020338,
    1518925132,
    3760827505,
    3759777254,
    1202760957,
    3985898139,
    3906192525,
    674977740,
    4174734889,
    2031300136,
    2019492241,
    3983892565,
    4153806404,
    3822280332,
    352677332,
    2297720250,
    60907813,
    90501309,
    3286998549,
    1016092578,
    2535922412,
    2839152426,
    457141659,
    509813237,
    4120667899,
    652014361,
    1966332200,
    2975202805,
    55981186,
    2327461051,
    676427537,
    3255491064,
    2882294119,
    3433927263,
    1307055953,
    942726286,
    933058658,
    2468411793,
    3933900994,
    4215176142,
    1361170020,
    2001714738,
    2830558078,
    3274259782,
    1222529897,
    1679025792,
    2729314320,
    3714953764,
    1770335741,
    151462246,
    3013232138,
    1682292957,
    1483529935,
    471910574,
    1539241949,
    458788160,
    3436315007,
    1807016891,
    3718408830,
    978976581,
    1043663428,
    3165965781,
    1927990952,
    4200891579,
    2372276910,
    3208408903,
    3533431907,
    1412390302,
    2931980059,
    4132332400,
    1947078029,
    3881505623,
    4168226417,
    2941484381,
    1077988104,
    1320477388,
    886195818,
    18198404,
    3786409e3,
    2509781533,
    112762804,
    3463356488,
    1866414978,
    891333506,
    18488651,
    661792760,
    1628790961,
    3885187036,
    3141171499,
    876946877,
    2693282273,
    1372485963,
    791857591,
    2686433993,
    3759982718,
    3167212022,
    3472953795,
    2716379847,
    445679433,
    3561995674,
    3504004811,
    3574258232,
    54117162,
    3331405415,
    2381918588,
    3769707343,
    4154350007,
    1140177722,
    4074052095,
    668550556,
    3214352940,
    367459370,
    261225585,
    2610173221,
    4209349473,
    3468074219,
    3265815641,
    314222801,
    3066103646,
    3808782860,
    282218597,
    3406013506,
    3773591054,
    379116347,
    1285071038,
    846784868,
    2669647154,
    3771962079,
    3550491691,
    2305946142,
    453669953,
    1268987020,
    3317592352,
    3279303384,
    3744833421,
    2610507566,
    3859509063,
    266596637,
    3847019092,
    517658769,
    3462560207,
    3443424879,
    370717030,
    4247526661,
    2224018117,
    4143653529,
    4112773975,
    2788324899,
    2477274417,
    1456262402,
    2901442914,
    1517677493,
    1846949527,
    2295493580,
    3734397586,
    2176403920,
    1280348187,
    1908823572,
    3871786941,
    846861322,
    1172426758,
    3287448474,
    3383383037,
    1655181056,
    3139813346,
    901632758,
    1897031941,
    2986607138,
    3066810236,
    3447102507,
    1393639104,
    373351379,
    950779232,
    625454576,
    3124240540,
    4148612726,
    2007998917,
    544563296,
    2244738638,
    2330496472,
    2058025392,
    1291430526,
    424198748,
    50039436,
    29584100,
    3605783033,
    2429876329,
    2791104160,
    1057563949,
    3255363231,
    3075367218,
    3463963227,
    1469046755,
    985887462
  ]), c = new Uint32Array([
    608135816,
    2242054355,
    320440878,
    57701188,
    2752067618,
    698298832,
    137296536,
    3964562569,
    1160258022,
    953160567,
    3193202383,
    887688300,
    3232508343,
    3380367581,
    1065670069,
    3041331479,
    2450970073,
    2306472731
  ]);
  class o {
    constructor() {
      this.S = [
        new Uint32Array(e.length),
        new Uint32Array(t.length),
        new Uint32Array(i.length),
        new Uint32Array(n.length)
      ], this.P = new Uint32Array(c.length), this.block = new Uint32Array(2), this.off = 0;
    }
    get blockSize() {
      return 8;
    }
    init(w, I) {
      return r(Buffer.isBuffer(w)), r(w.length >= 1 && w.length <= 72), I != null && (r(Buffer.isBuffer(I)), r(I.length <= 1096)), l(this.S[0], e), l(this.S[1], t), l(this.S[2], i), l(this.S[3], n), l(this.P, c), this.off = 0, I && I.length > 0 ? this.expandstate(w, I) : this.expand0state(w), this;
    }
    encrypt(w, I, B, y) {
      const A = this.block;
      return A[0] = x(B, y + 0), A[1] = x(B, y + 4), this.encipher(A, 0), b(w, A[0], I + 0), b(w, A[1], I + 4), this;
    }
    decrypt(w, I, B, y) {
      const A = this.block;
      return A[0] = x(B, y + 0), A[1] = x(B, y + 4), this.decipher(A, 0), b(w, A[0], I + 0), b(w, A[1], I + 4), this;
    }
    destroy() {
      return h(this.S[0]), h(this.S[1]), h(this.S[2]), h(this.S[3]), h(this.P), h(this.block), this.off = 0, this;
    }
    encipher(w, I) {
      const B = this.S, y = this.P;
      let A = w[I + 0] ^ y[0], _ = w[I + 1];
      _ ^= d(B, A) ^ y[1], A ^= d(B, _) ^ y[2], _ ^= d(B, A) ^ y[3], A ^= d(B, _) ^ y[4], _ ^= d(B, A) ^ y[5], A ^= d(B, _) ^ y[6], _ ^= d(B, A) ^ y[7], A ^= d(B, _) ^ y[8], _ ^= d(B, A) ^ y[9], A ^= d(B, _) ^ y[10], _ ^= d(B, A) ^ y[11], A ^= d(B, _) ^ y[12], _ ^= d(B, A) ^ y[13], A ^= d(B, _) ^ y[14], _ ^= d(B, A) ^ y[15], A ^= d(B, _) ^ y[16], w[I + 0] = _ ^ y[17], w[I + 1] = A;
    }
    decipher(w, I) {
      const B = this.S, y = this.P;
      let A = w[I + 0] ^ y[17], _ = w[I + 1];
      _ ^= d(B, A) ^ y[16], A ^= d(B, _) ^ y[15], _ ^= d(B, A) ^ y[14], A ^= d(B, _) ^ y[13], _ ^= d(B, A) ^ y[12], A ^= d(B, _) ^ y[11], _ ^= d(B, A) ^ y[10], A ^= d(B, _) ^ y[9], _ ^= d(B, A) ^ y[8], A ^= d(B, _) ^ y[7], _ ^= d(B, A) ^ y[6], A ^= d(B, _) ^ y[5], _ ^= d(B, A) ^ y[4], A ^= d(B, _) ^ y[3], _ ^= d(B, A) ^ y[2], A ^= d(B, _) ^ y[1], w[I + 0] = _ ^ y[0], w[I + 1] = A;
    }
    stream2word(w) {
      if (w.length === 0)
        return this.off = 0, 0;
      const I = w[(this.off + 0) % w.length] * 16777216 + w[(this.off + 1) % w.length] * 65536 + w[(this.off + 2) % w.length] * 256 + w[(this.off + 3) % w.length] * 1;
      return this.off = (this.off + 4) % w.length, I;
    }
    expand0state(w) {
      const I = new Uint32Array(2);
      this.off = 0;
      for (let B = 0; B < 18; B++)
        this.P[B] ^= this.stream2word(w);
      this.off = 0;
      for (let B = 0; B < 18; B += 2)
        this.encipher(I, 0), this.P[B + 0] = I[0], this.P[B + 1] = I[1];
      for (let B = 0; B < 4; B++)
        for (let y = 0; y < 256; y += 2)
          this.encipher(I, 0), this.S[B][y + 0] = I[0], this.S[B][y + 1] = I[1];
    }
    expandstate(w, I) {
      const B = new Uint32Array(2);
      this.off = 0;
      for (let y = 0; y < 18; y++)
        this.P[y] ^= this.stream2word(w);
      this.off = 0;
      for (let y = 0; y < 18; y += 2)
        B[0] ^= this.stream2word(I), B[1] ^= this.stream2word(I), this.encipher(B, 0), this.P[y + 0] = B[0], this.P[y + 1] = B[1];
      for (let y = 0; y < 4; y++)
        for (let A = 0; A < 256; A += 2)
          B[0] ^= this.stream2word(I), B[1] ^= this.stream2word(I), this.encipher(B, 0), this.S[y][A + 0] = B[0], this.S[y][A + 1] = B[1];
      this.off = 0;
    }
    enc(w) {
      const I = w.length >>> 1;
      for (let B = 0; B < I; B++)
        this.encipher(w, B * 2);
    }
    dec(w) {
      const I = w.length >>> 1;
      for (let B = 0; B < I; B++)
        this.decipher(w, B * 2);
    }
  }
  function d(g, w) {
    return (g[0][w >>> 24 & 255] + g[1][w >>> 16 & 255] ^ g[2][w >>> 8 & 255]) + g[3][w >>> 0 & 255];
  }
  function l(g, w) {
    for (let I = 0; I < w.length; I++)
      g[I] = w[I];
  }
  function h(g) {
    for (let w = 0; w < g.length; w++)
      g[w] = 0;
  }
  function x(g, w) {
    return g[w++] * 16777216 + g[w++] * 65536 + g[w++] * 256 + g[w];
  }
  function b(g, w, I) {
    return g[I++] = w >>> 24, g[I++] = w >>> 16, g[I++] = w >>> 8, g[I++] = w, I;
  }
  return qa = o, qa;
}
/*!
 * bcrypt.js - bcrypt for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on joyent/node-bcrypt-pbkdf:
 *   Copyright (c) 2016, Joyent Inc
 *   https://github.com/joyent/node-bcrypt-pbkdf
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Bcrypt
 *   http://www.usenix.org/events/usenix99/provos/provos_html/node1.html
 *   https://hackernoon.com/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd
 *   https://github.com/openbsd/src/blob/master/lib/libc/crypt/bcrypt.c
 *   https://github.com/openssh/openssh-portable
 *   https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/bcrypt_pbkdf.c
 *   https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/blowfish.c
 *   https://github.com/joyent/node-bcrypt-pbkdf/blob/master/index.js
 */
var N2;
function tm() {
  if (N2)
    return xs;
  N2 = 1;
  const r = _e, e = Cf, t = u8(), i = Buffer.from("OrpheanBeholderScryDoubt", "binary"), n = 6, c = 24, o = 16, d = 23, l = Buffer.from("OxychromaticBlowfishSwatDynamite", "binary"), h = 8, x = 32, b = Buffer.alloc(1, 0);
  function g(N, G, F) {
    if (typeof N == "string" && (N = Buffer.from(N, "utf8")), typeof G == "string" && (G = Buffer.from(G, "utf8")), G == null && (G = Buffer.alloc(0)), r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(F >>> 0 === F), F < 4 || F > 31)
      throw new RangeError("Invalid rounds.");
    return q(Buffer.alloc(c), N, G, F);
  }
  function w(N, G, F, W = "b") {
    if (typeof N == "string" && (N = Buffer.from(N, "utf8")), typeof G == "string" && (G = Buffer.from(G, "utf8")), r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(F >>> 0 === F), r(typeof W == "string"), G.length !== o)
      throw new RangeError("Invalid salt length.");
    switch (W) {
      case "a":
        N = Buffer.concat([N, b]), N = N.slice(0, N.length & 255);
        break;
      case "b":
        N.length > 72 ? N = N.slice(0, 73) : N = Buffer.concat([N, b]);
        break;
      default:
        throw new Error("Invalid minor version.");
    }
    return g(N, G, F).slice(0, d);
  }
  function I(N, G, F, W = "b") {
    const ce = w(N, G, F, W);
    return z(W, F, G, ce);
  }
  function B(N, G) {
    const [F, W, ce, ne] = E(G), xe = w(N, ce, W, F);
    let he = 0;
    for (let me = 0; me < d; me++)
      he |= xe[me] ^ ne[me];
    return he - 1 >>> 31 !== 0;
  }
  function y(N, G, F) {
    if (typeof N == "string" && (N = Buffer.from(N, "utf8")), typeof G == "string" && (G = Buffer.from(G, "utf8")), G == null && (G = Buffer.alloc(0)), r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(F >>> 0 === F), F < 4 || F > 31)
      throw new RangeError("Invalid rounds.");
    return U(Buffer.alloc(x), N, G, F);
  }
  function A(N, G, F, W) {
    typeof N == "string" && (N = Buffer.from(N, "utf8")), typeof G == "string" && (G = Buffer.from(G, "utf8")), G == null && (G = Buffer.alloc(0)), r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(F >>> 0 === F), r(W >>> 0 === W);
    const ce = Buffer.alloc(x), ne = Buffer.alloc(x), xe = Buffer.alloc(G.length + 4), he = Buffer.alloc(W);
    if (F < 1 || N.length === 0 || G.length === 0 || W === 0 || W > ce.length ** 2 || G.length > 1 << 20)
      throw new Error("Invalid bcrypt parameters.");
    const me = (W + ce.length - 1) / ce.length >>> 0, Ne = (W + me - 1) / me >>> 0;
    G.copy(xe, 0);
    const Je = e.digest(N);
    let Ze = Buffer.alloc(0), ht = W, dt = Ne;
    for (let Se = 1; ht > 0; Se++) {
      xe[G.length + 0] = Se >>> 24, xe[G.length + 1] = Se >>> 16, xe[G.length + 2] = Se >>> 8, xe[G.length + 3] = Se, Ze = e.digest(xe), U(ne, Je, Ze, 6), ne.copy(ce, 0);
      for (let Z = 1; Z < F; Z++) {
        Ze = e.digest(ne), U(ne, Je, Ze, 6);
        for (let L = 0; L < ce.length; L++)
          ce[L] ^= ne[L];
      }
      dt = Math.min(dt, ht);
      let we = 0;
      for (; we < dt; we++) {
        const Z = we * me + (Se - 1);
        if (Z >= W)
          break;
        he[Z] = ce[we];
      }
      ht -= we;
    }
    return he;
  }
  async function _(N, G, F, W) {
    return A(N, G, F, W);
  }
  function q(N, G, F, W) {
    const ce = new t(), ne = new Uint32Array(n);
    ce.init(G, F);
    const xe = 2 ** W;
    for (let he = 0; he < xe; he++)
      ce.expand0state(G), ce.expand0state(F);
    for (let he = 0; he < n; he++)
      ne[he] = ce.stream2word(i);
    for (let he = 0; he < 64; he++)
      ce.enc(ne);
    for (let he = 0; he < n; he++)
      N[4 * he + 0] = ne[he] >>> 24, N[4 * he + 1] = ne[he] >>> 16, N[4 * he + 2] = ne[he] >>> 8, N[4 * he + 3] = ne[he];
    return N;
  }
  function U(N, G, F, W) {
    const ce = new t(), ne = new Uint32Array(h);
    ce.init(G, F);
    const xe = 2 ** W;
    for (let he = 0; he < xe; he++)
      ce.expand0state(F), ce.expand0state(G);
    for (let he = 0; he < h; he++)
      ne[he] = ce.stream2word(l);
    for (let he = 0; he < 64; he++)
      ce.enc(ne);
    for (let he = 0; he < h; he++)
      N[4 * he + 3] = ne[he] >>> 24, N[4 * he + 2] = ne[he] >>> 16, N[4 * he + 1] = ne[he] >>> 8, N[4 * he + 0] = ne[he];
    return N;
  }
  function z(N, G, F, W) {
    r(typeof N == "string"), r(G >>> 0 === G), r(Buffer.isBuffer(F)), r(Buffer.isBuffer(W)), r(N === "a" || N === "b"), r(G >= 4 && G <= 31), r(F.length === o), r(W.length === d);
    let ce = G.toString(10);
    return G < 10 && (ce = "0" + ce), `$2${N}$${ce}$${V(F)}${V(W)}`;
  }
  function E(N) {
    if (r(typeof N == "string"), N.length < 46)
      throw new Error("Invalid bcrypt string.");
    if (N[0] !== "$" || N[1] !== "2")
      throw new Error("Invalid major version.");
    const G = N[2];
    switch (G) {
      case "a":
      case "b":
        break;
      default:
        throw new Error("Invalid minor version.");
    }
    if (N[3] !== "$")
      throw new Error("Invalid bcrypt string.");
    const F = N.charCodeAt(4) - 48, W = N.charCodeAt(5) - 48;
    if (F < 0 || F > 9 || W < 0 || W > 9)
      throw new Error("Invalid bcrypt string.");
    const ce = F * 10 + W;
    if (ce < 4 || ce > 31)
      throw new Error("Invalid log rounds.");
    if (N[6] !== "$")
      throw new Error("Invalid bcrypt string.");
    let ne = 7, xe, he;
    if ([ne, xe] = T(N, ne, o), xe == null)
      throw new Error("Invalid salt.");
    if ([ne, he] = T(N, ne, d), he == null)
      throw new Error("Invalid hash.");
    if (ne !== N.length)
      throw new Error("Invalid bcrypt string.");
    return [G, ce, xe, he];
  }
  const H = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", k = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function V(N) {
    r(Buffer.isBuffer(N));
    let G = 0, F = "", W, ce;
    for (; G < N.length; ) {
      if (W = N[G++], F += H[W >>> 2], W = (W & 3) << 4, G >= N.length) {
        F += H[W];
        break;
      }
      if (ce = N[G++], W |= ce >>> 4 & 15, F += H[W], W = (ce & 15) << 2, G >= N.length) {
        F += H[W];
        break;
      }
      ce = N[G++], W |= ce >>> 6 & 3, F += H[W], F += H[ce & 63];
    }
    return F;
  }
  function T(N, G, F) {
    r(typeof N == "string"), r(G >>> 0 === G), r(F >>> 0 === F);
    const W = Buffer.alloc(F);
    let ce = 0, ne, xe, he, me;
    for (; ce < F; ) {
      if (ne = ie(N, G++), ne === -1)
        return [G, null];
      if (xe = ie(N, G++), xe === -1)
        return [G, null];
      if (W[ce++] = ne << 2 | (xe & 48) >>> 4, ce >= F)
        break;
      if (he = ie(N, G++), he === -1)
        return [G, null];
      if (W[ce++] = (xe & 15) << 4 | (he & 60) >>> 2, ce >= F)
        break;
      if (me = ie(N, G++), me === -1)
        return [G, null];
      W[ce++] = (he & 3) << 6 | me;
    }
    return [G, W];
  }
  function ie(N, G) {
    if (G >= N.length)
      return -1;
    const F = N.charCodeAt(G);
    return F & 65408 ? -1 : k[F];
  }
  return xs.native = 0, xs.generate = I, xs.verify = B, xs.pbkdf = A, xs.pbkdfAsync = _, xs.hash256 = y, xs;
}
var ks = {};
/*!
 * bcrypt.js - bcrypt for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var O2;
function rm() {
  if (O2)
    return ks;
  O2 = 1;
  const r = _e, e = Dt();
  function t(o, d, l, h = "b") {
    return typeof o == "string" && (o = Buffer.from(o, "utf8")), r(Buffer.isBuffer(o)), r(typeof d == "string" || Buffer.isBuffer(d)), r(l >>> 0 === l), r(typeof h == "string"), r(h.length === 1), h = h.charCodeAt(0) & 127, e.bcrypt_generate(o, d, l, h);
  }
  function i(o, d) {
    return typeof o == "string" && (o = Buffer.from(o, "utf8")), r(Buffer.isBuffer(o)), r(typeof d == "string"), e.bcrypt_verify(o, d);
  }
  function n(o, d, l, h) {
    return typeof o == "string" && (o = Buffer.from(o, "utf8")), typeof d == "string" && (d = Buffer.from(d, "utf8")), d == null && (d = e.NULL), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), r(h >>> 0 === h), e.bcrypt_pbkdf(o, d, l, h);
  }
  async function c(o, d, l, h) {
    return typeof o == "string" && (o = Buffer.from(o, "utf8")), typeof d == "string" && (d = Buffer.from(d, "utf8")), d == null && (d = e.NULL), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), r(h >>> 0 === h), e.bcrypt_pbkdf_async(o, d, l, h);
  }
  return ks.native = 2, ks.generate = t, ks.verify = i, ks.pbkdf = n, ks.pbkdfAsync = c, ks;
}
/*!
 * bcrypt.js - bcrypt for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? uu.exports = tm() : uu.exports = rm();
var l8 = uu.exports, xu = { exports: {} };
/*!
 * blake2b.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dcposch/blakejs:
 *   Daniel Clemens Posch (CC0)
 *   https://github.com/dcposch/blakejs/blob/master/blake2b.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)
 *   https://tools.ietf.org/html/rfc7693
 */
var za, P2;
function im() {
  if (P2)
    return za;
  P2 = 1;
  const r = _e, e = Rr, t = 2147483648, i = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]), n = new Uint8Array([
    0,
    2,
    4,
    6,
    8,
    10,
    12,
    14,
    16,
    18,
    20,
    22,
    24,
    26,
    28,
    30,
    28,
    20,
    8,
    16,
    18,
    30,
    26,
    12,
    2,
    24,
    0,
    4,
    22,
    14,
    10,
    6,
    22,
    16,
    24,
    0,
    10,
    4,
    30,
    26,
    20,
    28,
    6,
    12,
    14,
    2,
    18,
    8,
    14,
    18,
    6,
    2,
    26,
    24,
    22,
    28,
    4,
    12,
    10,
    20,
    8,
    0,
    30,
    16,
    18,
    0,
    10,
    14,
    4,
    8,
    20,
    30,
    28,
    2,
    22,
    24,
    12,
    16,
    6,
    26,
    4,
    24,
    12,
    20,
    0,
    22,
    16,
    6,
    8,
    26,
    14,
    10,
    30,
    28,
    2,
    18,
    24,
    10,
    2,
    30,
    28,
    26,
    8,
    20,
    0,
    14,
    12,
    6,
    18,
    4,
    16,
    22,
    26,
    22,
    14,
    28,
    24,
    2,
    6,
    18,
    10,
    0,
    30,
    8,
    16,
    12,
    4,
    20,
    12,
    30,
    28,
    18,
    22,
    6,
    0,
    16,
    24,
    4,
    26,
    14,
    2,
    8,
    20,
    10,
    20,
    4,
    16,
    8,
    14,
    12,
    2,
    10,
    30,
    22,
    18,
    28,
    6,
    24,
    26,
    0,
    0,
    2,
    4,
    6,
    8,
    10,
    12,
    14,
    16,
    18,
    20,
    22,
    24,
    26,
    28,
    30,
    28,
    20,
    8,
    16,
    18,
    30,
    26,
    12,
    2,
    24,
    0,
    4,
    22,
    14,
    10,
    6
  ]);
  class c {
    constructor() {
      this.state = new Uint32Array(16), this.V = new Uint32Array(32), this.M = new Uint32Array(32), this.block = Buffer.alloc(128), this.size = 32, this.count = 0, this.pos = t;
    }
    init(b, g) {
      if (b == null && (b = 32), r(b >>> 0 === b), r(g == null || Buffer.isBuffer(g)), b === 0 || b > 64)
        throw new Error("Bad output length.");
      if (g && g.length > 64)
        throw new Error("Bad key length.");
      const w = g ? g.length : 0;
      for (let I = 0; I < 16; I++)
        this.state[I] = i[I];
      if (this.size = b, this.count = 0, this.pos = 0, this.state[0] ^= 16842752 ^ w << 8 ^ this.size, w > 0) {
        const I = Buffer.alloc(128, 0);
        g.copy(I, 0), this.update(I);
      }
      return this;
    }
    update(b) {
      r(Buffer.isBuffer(b)), r(!(this.pos & t), "Context is not initialized.");
      let g = 0, w = b.length;
      if (w > 0) {
        const I = this.pos, B = 128 - I;
        if (w > B)
          for (this.pos = 0, b.copy(this.block, I, g, g + B), this.count += 128, this._compress(this.block, 0, !1), g += B, w -= B; w > 128; )
            this.count += 128, this._compress(b, g, !1), g += 128, w -= 128;
        b.copy(this.block, this.pos, g, g + w), this.pos += w;
      }
      return this;
    }
    final() {
      r(!(this.pos & t), "Context is not initialized."), this.count += this.pos, this.block.fill(0, this.pos, 128), this._compress(this.block, 0, !0), this.pos = t;
      const b = Buffer.alloc(this.size);
      for (let g = 0; g < this.size; g++)
        b[g] = this.state[g >>> 2] >>> 8 * (g & 3);
      for (let g = 0; g < 16; g++)
        this.state[g] = 0;
      for (let g = 0; g < 32; g++)
        this.V[g] = 0, this.M[g] = 0;
      for (let g = 0; g < 128; g++)
        this.block[g] = 0;
      return b;
    }
    _compress(b, g, w) {
      const { V: I, M: B } = this;
      for (let y = 0; y < 16; y++)
        I[y] = this.state[y], I[y + 16] = i[y];
      I[24] ^= this.count, I[25] ^= this.count * (1 / 4294967296), I[26] ^= 0, I[27] ^= 0, w && (I[28] ^= -1, I[29] ^= -1, I[29] ^= 0, I[30] ^= 0);
      for (let y = 0; y < 32; y++)
        B[y] = h(b, g), g += 4;
      for (let y = 0; y < 12; y++)
        l(I, B, 0, 8, 16, 24, n[y * 16 + 0], n[y * 16 + 1]), l(I, B, 2, 10, 18, 26, n[y * 16 + 2], n[y * 16 + 3]), l(I, B, 4, 12, 20, 28, n[y * 16 + 4], n[y * 16 + 5]), l(I, B, 6, 14, 22, 30, n[y * 16 + 6], n[y * 16 + 7]), l(I, B, 0, 10, 20, 30, n[y * 16 + 8], n[y * 16 + 9]), l(I, B, 2, 12, 22, 24, n[y * 16 + 10], n[y * 16 + 11]), l(I, B, 4, 14, 16, 26, n[y * 16 + 12], n[y * 16 + 13]), l(I, B, 6, 8, 18, 28, n[y * 16 + 14], n[y * 16 + 15]);
      for (let y = 0; y < 16; y++)
        this.state[y] ^= I[y] ^ I[y + 16];
    }
    static hash() {
      return new c();
    }
    static hmac(b) {
      return new e(c, 128, [b]);
    }
    static digest(b, g, w) {
      const { ctx: I } = c;
      return I.init(g, w), I.update(b), I.final();
    }
    static root(b, g, w, I) {
      w == null && (w = 32), r(Buffer.isBuffer(b) && b.length === w), r(Buffer.isBuffer(g) && g.length === w);
      const { ctx: B } = c;
      return B.init(w, I), B.update(b), B.update(g), B.final();
    }
    static multi(b, g, w, I, B) {
      const { ctx: y } = c;
      return y.init(I, B), y.update(b), y.update(g), w && y.update(w), y.final();
    }
    static mac(b, g, w) {
      return c.hmac(w).init(g).update(b).final();
    }
  }
  c.native = 0, c.id = "BLAKE2B256", c.size = 32, c.bits = 256, c.blockSize = 128, c.zero = Buffer.alloc(32, 0), c.ctx = new c();
  function o(x, b, g) {
    const w = x[b + 0] + x[g + 0], I = x[b + 1] + x[g + 1], B = w >= 4294967296 | 0;
    x[b + 0] = w, x[b + 1] = I + B;
  }
  function d(x, b, g, w) {
    const I = x[b + 0] + g, B = x[b + 1] + w, y = I >= 4294967296 | 0;
    x[b + 0] = I, x[b + 1] = B + y;
  }
  function l(x, b, g, w, I, B, y, A) {
    const _ = b[y + 0], q = b[y + 1], U = b[A + 0], z = b[A + 1];
    o(x, g, w), d(x, g, _, q);
    const E = x[B + 0] ^ x[g + 0], H = x[B + 1] ^ x[g + 1];
    x[B + 0] = H, x[B + 1] = E, o(x, I, B);
    const k = x[w + 0] ^ x[I + 0], V = x[w + 1] ^ x[I + 1];
    x[w + 0] = k >>> 24 ^ V << 8, x[w + 1] = V >>> 24 ^ k << 8, o(x, g, w), d(x, g, U, z);
    const T = x[B + 0] ^ x[g + 0], ie = x[B + 1] ^ x[g + 1];
    x[B + 0] = T >>> 16 ^ ie << 16, x[B + 1] = ie >>> 16 ^ T << 16, o(x, I, B);
    const N = x[w + 0] ^ x[I + 0], G = x[w + 1] ^ x[I + 1];
    x[w + 0] = G >>> 31 ^ N << 1, x[w + 1] = N >>> 31 ^ G << 1;
  }
  function h(x, b) {
    return x[b++] + x[b++] * 256 + x[b++] * 65536 + x[b] * 16777216;
  }
  return za = c, za;
}
/*!
 * blake2b.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ua, R2;
function sm() {
  if (R2)
    return Ua;
  R2 = 1;
  const r = _e, e = Dt(), t = Rr;
  class i {
    constructor() {
      this._handle = e.blake2b_create();
    }
    init(c, o) {
      return c == null && (c = 32), o == null && (o = e.NULL), r(this instanceof i), r(c >>> 0 === c), r(Buffer.isBuffer(o)), e.blake2b_init(this._handle, c, o), this;
    }
    update(c) {
      return r(this instanceof i), r(Buffer.isBuffer(c)), e.blake2b_update(this._handle, c), this;
    }
    final() {
      return r(this instanceof i), e.blake2b_final(this._handle);
    }
    static hash() {
      return new i();
    }
    static hmac(c) {
      return new t(i, 128, [c]);
    }
    static digest(c, o, d) {
      return o == null && (o = 32), d == null && (d = e.NULL), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(Buffer.isBuffer(d)), e.blake2b_digest(c, o, d);
    }
    static root(c, o, d, l) {
      return d == null && (d = 32), l == null && (l = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(d >>> 0 === d), r(Buffer.isBuffer(l)), e.blake2b_root(c, o, d, l);
    }
    static multi(c, o, d, l, h) {
      return d == null && (d = e.NULL), l == null && (l = 32), h == null && (h = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), r(Buffer.isBuffer(h)), e.blake2b_multi(c, o, d, l, h);
    }
    static mac(c, o, d) {
      return i.hmac(d).init(o).update(c).final();
    }
  }
  return i.native = 2, i.id = "BLAKE2B256", i.size = 32, i.bits = 256, i.blockSize = 128, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), Ua = i, Ua;
}
/*!
 * blake2b.js - blake2b for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? xu.exports = im() : xu.exports = sm();
var Tf = xu.exports;
/*!
 * blake2b160.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const x8 = Tf;
class fi extends x8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(20, e);
  }
  static hash() {
    return new fi();
  }
  static hmac() {
    return super.hmac(20);
  }
  static digest(e, t) {
    return super.digest(e, 20, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 20, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 20, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 20);
  }
}
fi.native = x8.native;
fi.id = "BLAKE2B160";
fi.size = 20;
fi.bits = 160;
fi.blockSize = 128;
fi.zero = Buffer.alloc(20, 0);
fi.ctx = new fi();
var nm = fi;
/*!
 * blake2b256.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const b8 = Tf;
class ci extends b8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(32, e);
  }
  static hash() {
    return new ci();
  }
  static hmac() {
    return super.hmac(32);
  }
  static digest(e, t) {
    return super.digest(e, 32, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 32, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 32, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 32);
  }
}
ci.native = b8.native;
ci.id = "BLAKE2B256";
ci.size = 32;
ci.bits = 256;
ci.blockSize = 128;
ci.zero = Buffer.alloc(32, 0);
ci.ctx = new ci();
var fm = ci;
/*!
 * blake2b384.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const p8 = Tf;
class oi extends p8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(48, e);
  }
  static hash() {
    return new oi();
  }
  static hmac() {
    return super.hmac(48);
  }
  static digest(e, t) {
    return super.digest(e, 48, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 48, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 48, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 48);
  }
}
oi.native = p8.native;
oi.id = "BLAKE2B384";
oi.size = 48;
oi.bits = 384;
oi.blockSize = 128;
oi.zero = Buffer.alloc(48, 0);
oi.ctx = new oi();
var cm = oi;
/*!
 * blake2b512.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const m8 = Tf;
class ai extends m8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(64, e);
  }
  static hash() {
    return new ai();
  }
  static hmac() {
    return super.hmac(64);
  }
  static digest(e, t) {
    return super.digest(e, 64, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 64, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 64, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 64);
  }
}
ai.native = m8.native;
ai.id = "BLAKE2B512";
ai.size = 64;
ai.bits = 512;
ai.blockSize = 128;
ai.zero = Buffer.alloc(64, 0);
ai.ctx = new ai();
var om = ai, bu = { exports: {} };
/*!
 * blake2s.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dcposch/blakejs:
 *   Daniel Clemens Posch (CC0)
 *   https://github.com/dcposch/blakejs/blob/master/blake2s.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)
 *   https://tools.ietf.org/html/rfc7693
 */
var Ca, k2;
function am() {
  if (k2)
    return Ca;
  k2 = 1;
  const r = _e, e = Rr, t = 2147483648, i = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), n = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  class c {
    constructor() {
      this.state = new Uint32Array(8), this.V = new Uint32Array(16), this.M = new Uint32Array(16), this.block = Buffer.alloc(64), this.size = 32, this.count = 0, this.pos = t;
    }
    init(x, b) {
      if (x == null && (x = 32), r(x >>> 0 === x), r(b == null || Buffer.isBuffer(b)), x === 0 || x > 32)
        throw new Error("Bad output length.");
      if (b && b.length > 32)
        throw new Error("Bad key length.");
      const g = b ? b.length : 0;
      for (let w = 0; w < 8; w++)
        this.state[w] = i[w];
      if (this.size = x, this.count = 0, this.pos = 0, this.state[0] ^= 16842752 ^ g << 8 ^ this.size, g > 0) {
        const w = Buffer.alloc(64, 0);
        b.copy(w, 0), this.update(w);
      }
      return this;
    }
    update(x) {
      r(Buffer.isBuffer(x)), r(!(this.pos & t), "Context is not initialized.");
      let b = 0, g = x.length;
      if (g > 0) {
        const w = this.pos, I = 64 - w;
        if (g > I)
          for (this.pos = 0, x.copy(this.block, w, b, b + I), this.count += 64, this._compress(this.block, 0, !1), b += I, g -= I; g > 64; )
            this.count += 64, this._compress(x, b, !1), b += 64, g -= 64;
        x.copy(this.block, this.pos, b, b + g), this.pos += g;
      }
      return this;
    }
    final() {
      r(!(this.pos & t), "Context is not initialized."), this.count += this.pos, this.block.fill(0, this.pos, 64), this._compress(this.block, 0, !0), this.pos = t;
      const x = Buffer.alloc(this.size);
      for (let b = 0; b < this.size; b++)
        x[b] = this.state[b >>> 2] >>> 8 * (b & 3);
      for (let b = 0; b < 8; b++)
        this.state[b] = 0;
      for (let b = 0; b < 16; b++)
        this.V[b] = 0, this.M[b] = 0;
      for (let b = 0; b < 64; b++)
        this.block[b] = 0;
      return x;
    }
    _compress(x, b, g) {
      const { V: w, M: I } = this;
      for (let B = 0; B < 8; B++)
        w[B] = this.state[B], w[B + 8] = i[B];
      w[12] ^= this.count, w[13] ^= this.count * (1 / 4294967296), g && (w[14] ^= -1, w[15] ^= 0);
      for (let B = 0; B < 16; B++)
        I[B] = l(x, b), b += 4;
      for (let B = 0; B < 10; B++)
        d(w, I, 0, 4, 8, 12, n[B * 16 + 0], n[B * 16 + 1]), d(w, I, 1, 5, 9, 13, n[B * 16 + 2], n[B * 16 + 3]), d(w, I, 2, 6, 10, 14, n[B * 16 + 4], n[B * 16 + 5]), d(w, I, 3, 7, 11, 15, n[B * 16 + 6], n[B * 16 + 7]), d(w, I, 0, 5, 10, 15, n[B * 16 + 8], n[B * 16 + 9]), d(w, I, 1, 6, 11, 12, n[B * 16 + 10], n[B * 16 + 11]), d(w, I, 2, 7, 8, 13, n[B * 16 + 12], n[B * 16 + 13]), d(w, I, 3, 4, 9, 14, n[B * 16 + 14], n[B * 16 + 15]);
      for (let B = 0; B < 8; B++)
        this.state[B] ^= w[B] ^ w[B + 8];
    }
    static hash() {
      return new c();
    }
    static hmac(x) {
      return new e(c, 64, [x]);
    }
    static digest(x, b, g) {
      const { ctx: w } = c;
      return w.init(b, g), w.update(x), w.final();
    }
    static root(x, b, g, w) {
      g == null && (g = 32), r(Buffer.isBuffer(x) && x.length === g), r(Buffer.isBuffer(b) && b.length === g);
      const { ctx: I } = c;
      return I.init(g, w), I.update(x), I.update(b), I.final();
    }
    static multi(x, b, g, w, I) {
      const { ctx: B } = c;
      return B.init(w, I), B.update(x), B.update(b), g && B.update(g), B.final();
    }
    static mac(x, b, g) {
      return c.hmac(g).init(b).update(x).final();
    }
  }
  c.native = 0, c.id = "BLAKE2S256", c.size = 32, c.bits = 256, c.blockSize = 64, c.zero = Buffer.alloc(32, 0), c.ctx = new c();
  function o(h, x) {
    return h >>> x ^ h << 32 - x;
  }
  function d(h, x, b, g, w, I, B, y) {
    const A = x[B], _ = x[y];
    h[b] = h[b] + h[g] + A, h[I] = o(h[I] ^ h[b], 16), h[w] = h[w] + h[I], h[g] = o(h[g] ^ h[w], 12), h[b] = h[b] + h[g] + _, h[I] = o(h[I] ^ h[b], 8), h[w] = h[w] + h[I], h[g] = o(h[g] ^ h[w], 7);
  }
  function l(h, x) {
    return h[x++] + h[x++] * 256 + h[x++] * 65536 + h[x] * 16777216;
  }
  return Ca = c, Ca;
}
/*!
 * blake2s.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ta, q2;
function hm() {
  if (q2)
    return Ta;
  q2 = 1;
  const r = _e, e = Dt(), t = Rr;
  class i {
    constructor() {
      this._handle = e.blake2s_create();
    }
    init(c, o) {
      return c == null && (c = 32), o == null && (o = e.NULL), r(this instanceof i), r(c >>> 0 === c), r(Buffer.isBuffer(o)), e.blake2s_init(this._handle, c, o), this;
    }
    update(c) {
      return r(this instanceof i), r(Buffer.isBuffer(c)), e.blake2s_update(this._handle, c), this;
    }
    final() {
      return r(this instanceof i), e.blake2s_final(this._handle);
    }
    static hash() {
      return new i();
    }
    static hmac(c) {
      return new t(i, 64, [c]);
    }
    static digest(c, o, d) {
      return o == null && (o = 32), d == null && (d = e.NULL), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(Buffer.isBuffer(d)), e.blake2s_digest(c, o, d);
    }
    static root(c, o, d, l) {
      return d == null && (d = 32), l == null && (l = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(d >>> 0 === d), r(Buffer.isBuffer(l)), e.blake2s_root(c, o, d, l);
    }
    static multi(c, o, d, l, h) {
      return d == null && (d = e.NULL), l == null && (l = 32), h == null && (h = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), r(Buffer.isBuffer(h)), e.blake2s_multi(c, o, d, l, h);
    }
    static mac(c, o, d) {
      return i.hmac(d).init(o).update(c).final();
    }
  }
  return i.native = 2, i.id = "BLAKE2S256", i.size = 32, i.bits = 256, i.blockSize = 64, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), Ta = i, Ta;
}
/*!
 * blake2s.js - blake2s for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? bu.exports = am() : bu.exports = hm();
var Df = bu.exports;
/*!
 * blake2s128.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const g8 = Df;
class hi extends g8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(16, e);
  }
  static hash() {
    return new hi();
  }
  static hmac() {
    return super.hmac(16);
  }
  static digest(e, t) {
    return super.digest(e, 16, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 16, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 16, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 16);
  }
}
hi.native = g8.native;
hi.id = "BLAKE2S128";
hi.size = 16;
hi.bits = 128;
hi.blockSize = 64;
hi.zero = Buffer.alloc(16, 0);
hi.ctx = new hi();
var dm = hi;
/*!
 * blake2s160.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const w8 = Df;
class di extends w8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(20, e);
  }
  static hash() {
    return new di();
  }
  static hmac() {
    return super.hmac(20);
  }
  static digest(e, t) {
    return super.digest(e, 20, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 20, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 20, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 20);
  }
}
di.native = w8.native;
di.id = "BLAKE2S160";
di.size = 20;
di.bits = 160;
di.blockSize = 64;
di.zero = Buffer.alloc(20, 0);
di.ctx = new di();
var um = di;
/*!
 * blake2s224.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const y8 = Df;
class ui extends y8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(28, e);
  }
  static hash() {
    return new ui();
  }
  static hmac() {
    return super.hmac(28);
  }
  static digest(e, t) {
    return super.digest(e, 28, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 28, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 28, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 28);
  }
}
ui.native = y8.native;
ui.id = "BLAKE2S224";
ui.size = 28;
ui.bits = 224;
ui.blockSize = 64;
ui.zero = Buffer.alloc(28, 0);
ui.ctx = new ui();
var lm = ui;
/*!
 * blake2s256.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const S8 = Df;
class li extends S8 {
  constructor() {
    super();
  }
  init(e) {
    return super.init(32, e);
  }
  static hash() {
    return new li();
  }
  static hmac() {
    return super.hmac(32);
  }
  static digest(e, t) {
    return super.digest(e, 32, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 32, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 32, n);
  }
  static mac(e, t) {
    return super.mac(e, t, 32);
  }
}
li.native = S8.native;
li.id = "BLAKE2S256";
li.size = 32;
li.bits = 256;
li.blockSize = 64;
li.zero = Buffer.alloc(32, 0);
li.ctx = new li();
var xm = li, B8 = { exports: {} }, Da = {};
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var z2;
function Y1() {
  if (z2)
    return Da;
  z2 = 1;
  const { inspect: r } = M0;
  return Da.custom = r.custom || "inspect", Da;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
var La, U2;
function bm() {
  if (U2)
    return La;
  U2 = 1;
  const { custom: r } = Y1(), e = (1n << 8n) - 1n, t = (1n << 16n) - 1n, i = (1n << 32n) - 1n, n = (1n << 64n) - 1n, c = (1n << 128n) - 1n, o = (1n << 256n) - 1n, d = 9007199254740991n, l = new Int8Array(new Int16Array([1]).buffer)[0] === 0 ? "be" : "le", h = 4, x = 1 << h - 1, b = BigInt((1 << h) - 1), g = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  };
  class w {
    constructor(f, m, D) {
      this.n = 0n, this.red = null, this.from(f, m, D);
    }
    /*
     * Compat
     */
    get negative() {
      return this.n < 0n ? 1 : 0;
    }
    set negative(f) {
      (f & 1) !== this.negative && (this.n = -this.n);
    }
    get length() {
      return lt(this.n, 26);
    }
    /*
     * Addition
     */
    iadd(f) {
      return N(w.isBN(f), "num", "bignum"), this.n += f.n, this;
    }
    iaddn(f) {
      return N(he(f), "num", "smi"), this.n += BigInt(f), this;
    }
    add(f) {
      return this.clone().iadd(f);
    }
    addn(f) {
      return this.clone().iaddn(f);
    }
    /*
     * Subtraction
     */
    isub(f) {
      return N(w.isBN(f), "num", "bignum"), this.n -= f.n, this;
    }
    isubn(f) {
      return N(he(f), "num", "smi"), this.n -= BigInt(f), this;
    }
    sub(f) {
      return this.clone().isub(f);
    }
    subn(f) {
      return this.clone().isubn(f);
    }
    /*
     * Multiplication
     */
    imul(f) {
      return N(w.isBN(f), "num", "bignum"), this.n *= f.n, this;
    }
    imuln(f) {
      return N(he(f), "num", "smi"), this.n *= BigInt(f), this;
    }
    mul(f) {
      return this.clone().imul(f);
    }
    muln(f) {
      return this.clone().imuln(f);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(f, m) {
      return N(w.isBN(f), "num", "bignum"), N(m - 1 >>> 0 === m - 1, "bits", "uint32"), new w(ht(this.n, f.n, m));
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(f) {
      N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n);
      const [m, D] = dt(this.n, f.n);
      return [new w(m), new w(D)];
    }
    /*
     * Truncation Division
     */
    iquo(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n /= f.n, this;
    }
    iquon(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n /= BigInt(f), this;
    }
    quo(f) {
      return this.clone().iquo(f);
    }
    quon(f) {
      return this.clone().iquon(f);
    }
    /*
     * Truncation Modulo
     */
    irem(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n %= f.n, this;
    }
    iremn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n %= BigInt(f), this;
    }
    rem(f) {
      return this.clone().irem(f);
    }
    remn(f) {
      return this.clone().iremn(f);
    }
    remrn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), Se(this.n, f);
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(f) {
      N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n);
      const [m, D] = we(this.n, f.n);
      return [new w(m), new w(D)];
    }
    /*
     * Euclidean Division
     */
    idiv(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n = Z(this.n, f.n), this;
    }
    idivn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n = Z(this.n, BigInt(f)), this;
    }
    div(f) {
      return this.clone().idiv(f);
    }
    divn(f) {
      return this.clone().idivn(f);
    }
    /*
     * Euclidean Modulo
     */
    imod(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n = L(this.n, f.n), this;
    }
    imodn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n = L(this.n, BigInt(f)), this;
    }
    mod(f) {
      return this.clone().imod(f);
    }
    modn(f) {
      return this.clone().imodn(f);
    }
    modrn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), oe(this.n, f);
    }
    /*
     * Round Division
     */
    divRound(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), new w(s(this.n, f.n));
    }
    /*
     * Exponentiation
     */
    ipow(f) {
      return N(w.isBN(f), "num", "bignum"), this.n **= Le(f.n), this;
    }
    ipown(f) {
      return N(he(f), "num", "smi"), this.n **= Le(BigInt(f)), this;
    }
    pow(f) {
      return this.clone().ipow(f);
    }
    pown(f) {
      return this.clone().ipown(f);
    }
    isqr() {
      return this.n *= this.n, this;
    }
    sqr() {
      return this.clone().isqr();
    }
    /*
     * Roots
     */
    rootrem(f) {
      const [m, D] = p(this.n, f);
      return [new w(m), new w(D)];
    }
    iroot(f) {
      return this.n = v(this.n, f), this;
    }
    root(f) {
      return this.clone().iroot(f);
    }
    isPower(f) {
      return C(this.n, f);
    }
    sqrtrem() {
      const [f, m] = K(this.n);
      return [new w(f), new w(m)];
    }
    isqrt() {
      return this.n = O(this.n), this;
    }
    sqrt() {
      return this.clone().isqrt();
    }
    isSquare() {
      return $(this.n);
    }
    /*
     * AND
     */
    iand(f) {
      return N(w.isBN(f), "num", "bignum"), this.n &= f.n, this;
    }
    iandn(f) {
      return N(he(f), "num", "smi"), this.n &= BigInt(f), this;
    }
    and(f) {
      return this.clone().iand(f);
    }
    andn(f) {
      return this.clone().iandn(f);
    }
    andrn(f) {
      N(he(f), "num", "smi");
      const m = this.n & BigInt(f);
      if (m < -0x3ffffffn || m > 0x3ffffffn)
        throw new RangeError("Number exceeds 26 bits.");
      return Number(m);
    }
    /*
     * Unsigned AND
     */
    iuand(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = S(this.n, f.n), this;
    }
    iuandn(f) {
      return N(he(f), "num", "smi"), this.n = M(this.n, f), this;
    }
    uand(f) {
      return this.clone().iuand(f);
    }
    uandn(f) {
      return this.clone().iuandn(f);
    }
    uandrn(f) {
      return N(he(f), "num", "smi"), Number(M(this.n, f));
    }
    /*
     * OR
     */
    ior(f) {
      return N(w.isBN(f), "num", "bignum"), this.n |= f.n, this;
    }
    iorn(f) {
      return N(he(f), "num", "smi"), this.n |= BigInt(f), this;
    }
    or(f) {
      return this.clone().ior(f);
    }
    orn(f) {
      return this.clone().iorn(f);
    }
    /*
     * Unsigned OR
     */
    iuor(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = Y(this.n, f.n), this;
    }
    iuorn(f) {
      return N(he(f), "num", "smi"), this.n = J(this.n, f), this;
    }
    uor(f) {
      return this.clone().iuor(f);
    }
    uorn(f) {
      return this.clone().iuorn(f);
    }
    /*
     * XOR
     */
    ixor(f) {
      return N(w.isBN(f), "num", "bignum"), this.n ^= f.n, this;
    }
    ixorn(f) {
      return N(he(f), "num", "smi"), this.n ^= BigInt(f), this;
    }
    xor(f) {
      return this.clone().ixor(f);
    }
    xorn(f) {
      return this.clone().ixorn(f);
    }
    /*
     * Unsigned XOR
     */
    iuxor(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = X(this.n, f.n), this;
    }
    iuxorn(f) {
      return N(he(f), "num", "smi"), this.n = re(this.n, f), this;
    }
    uxor(f) {
      return this.clone().ixor(f);
    }
    uxorn(f) {
      return this.clone().iuxorn(f);
    }
    /*
     * NOT
     */
    inot() {
      return this.n = ~this.n, this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(f) {
      return N(f >>> 0 === f, "width", "uint32"), this.n = ge(this.n, f), this;
    }
    notn(f) {
      return this.clone().inotn(f);
    }
    /*
     * Left Shift
     */
    ishl(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n <<= f.n, this;
    }
    ishln(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n <<= BigInt(f), this;
    }
    shl(f) {
      return this.clone().ishl(f);
    }
    shln(f) {
      return this.clone().ishln(f);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n <<= f.n, this;
    }
    iushln(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n <<= BigInt(f), this;
    }
    ushl(f) {
      return this.clone().iushl(f);
    }
    ushln(f) {
      return this.clone().iushln(f);
    }
    /*
     * Right Shift
     */
    ishr(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n >>= f.n, this;
    }
    ishrn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n >>= BigInt(f), this;
    }
    shr(f) {
      return this.clone().ishr(f);
    }
    shrn(f) {
      return this.clone().ishrn(f);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n = ae(this.n, f.n), this;
    }
    iushrn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n = de(this.n, f), this;
    }
    ushr(f) {
      return this.clone().iushr(f);
    }
    ushrn(f) {
      return this.clone().iushrn(f);
    }
    /*
     * Bit Manipulation
     */
    setn(f, m) {
      return N(f >>> 0 === f, "bit", "uint32"), this.n = Be(this.n, f, m), this;
    }
    usetn(f, m) {
      return N(f >>> 0 === f, "bit", "uint32"), this.n = ve(this.n, f, m), this;
    }
    testn(f) {
      return N(f >>> 0 === f, "bit", "uint32"), Oe(this.n, f);
    }
    utestn(f) {
      return N(f >>> 0 === f, "bit", "uint32"), Ie(this.n, f);
    }
    imaskn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n = Re(this.n, f), this;
    }
    maskn(f) {
      return this.clone().imaskn(f);
    }
    iumaskn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n = ft(this.n, f), this;
    }
    umaskn(f) {
      return this.clone().iumaskn(f);
    }
    andln(f) {
      return Ye(this.n, f);
    }
    bit(f) {
      return this.utestn(f);
    }
    bits(f, m) {
      return N(f >>> 0 === f, "pos", "uint32"), N(m >>> 0 === m, "width", "uint32"), N(m <= 26, "width", "width"), Fe(this.n, f, m);
    }
    /*
     * Negation
     */
    ineg() {
      return this.n = -this.n, this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.n = Le(this.n), this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(f) {
      return N(w.isBN(f), "num", "bignum"), He(this.n, f.n);
    }
    cmpn(f) {
      return N(he(f), "num", "smi"), et(this.n, f);
    }
    eq(f) {
      return N(w.isBN(f), "num", "bignum"), this.n === f.n;
    }
    eqn(f) {
      return N(he(f), "num", "smi"), this.n == f;
    }
    gt(f) {
      return N(w.isBN(f), "num", "bignum"), this.n > f.n;
    }
    gtn(f) {
      return N(he(f), "num", "smi"), this.n > f;
    }
    gte(f) {
      return N(w.isBN(f), "num", "bignum"), this.n >= f.n;
    }
    gten(f) {
      return N(he(f), "num", "smi"), this.n >= f;
    }
    lt(f) {
      return N(w.isBN(f), "num", "bignum"), this.n < f.n;
    }
    ltn(f) {
      return N(he(f), "num", "smi"), this.n < f;
    }
    lte(f) {
      return N(w.isBN(f), "num", "bignum"), this.n <= f.n;
    }
    lten(f) {
      return N(he(f), "num", "smi"), this.n <= f;
    }
    sign() {
      return (this.n > 0n) - (this.n < 0n);
    }
    isZero() {
      return this.n === 0n;
    }
    isNeg() {
      return this.n < 0n;
    }
    isPos() {
      return this.n >= 0n;
    }
    isOdd() {
      return (this.n & 1n) === 1n;
    }
    isEven() {
      return (this.n & 1n) === 0n;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(f) {
      return N(w.isBN(f), "num", "bignum"), xr(this.n, f.n);
    }
    ucmpn(f) {
      return N(he(f), "num", "smi"), tt(this.n, f);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(f) {
      return N(w.isBN(f), "num", "bignum"), W(!f.red, "legendre"), it(this.n, f.n);
    }
    jacobi(f) {
      return N(w.isBN(f), "num", "bignum"), Ht(this.n, f.n);
    }
    kronecker(f) {
      return N(w.isBN(f), "num", "bignum"), Qe(this.n, f.n);
    }
    igcd(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = st(this.n, f.n), this;
    }
    gcd(f) {
      return this.clone().igcd(f);
    }
    ilcm(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = s0(this.n, f.n), this;
    }
    lcm(f) {
      return this.clone().ilcm(f);
    }
    egcd(f) {
      N(w.isBN(f), "p", "bignum");
      const [m, D, ee] = ct(this.n, f.n);
      return [new w(m), new w(D), new w(ee)];
    }
    iinvert(f) {
      return N(w.isBN(f), "num", "bignum"), G(f.n >= 1n, "iinvert"), this.n = Xe(this.n, f.n), this;
    }
    invert(f) {
      return this.clone().iinvert(f);
    }
    ifermat(f) {
      return N(w.isBN(f), "num", "bignum"), G(f.n >= 1n, "ifermat"), W(!f.red, "ifermat"), this.n = qr(this.n, f.n), this;
    }
    fermat(f) {
      return this.clone().ifermat(f);
    }
    ipowm(f, m, D) {
      return N(w.isBN(f), "y", "bignum"), N(w.isBN(m), "m", "bignum"), G(m.n >= 1n, "ipowm"), W(!this.red && !f.red && !m.red, "ipowm"), this.n = Ge(this.n, f.n, m.n), this;
    }
    powm(f, m, D) {
      return this.clone().ipowm(f, m, D);
    }
    ipowmn(f, m, D) {
      return N(he(f), "y", "smi"), N(w.isBN(m), "m", "bignum"), G(m.n >= 1n, "ipowmn"), W(!this.red && !m.red, "ipowmn"), this.n = Ge(this.n, BigInt(f), m.n), this;
    }
    powmn(f, m, D) {
      return this.clone().ipowmn(f, m, D);
    }
    isqrtm(f) {
      return N(w.isBN(f), "p", "bignum"), G(f.n >= 1n, "isqrtm"), W(!this.red && !f.red, "isqrtm"), this.n = ot(this.n, f.n), this;
    }
    sqrtm(f) {
      return this.clone().isqrtm(f);
    }
    isqrtpq(f, m) {
      return N(w.isBN(f), "p", "bignum"), N(w.isBN(m), "q", "bignum"), G(f.n >= 1n, "isqrtpq"), G(m.n >= 1n, "isqrtpq"), W(!this.red && !f.red && !m.red, "isqrtpq"), this.n = Ki(this.n, f.n, m.n), this;
    }
    sqrtpq(f, m) {
      return this.clone().isqrtpq(f, m);
    }
    /*
     * Primality Testing
     */
    isPrime(f, m, D) {
      return N(m >>> 0 === m, "reps", "uint32"), !(!this.isPrimeMR(f, m + 1, !0) || !this.isPrimeLucas(D));
    }
    isPrimeMR(f, m, D) {
      return At(this.n, f, m, D);
    }
    isPrimeLucas(f) {
      return _t(this.n, f);
    }
    /*
     * Twos Complement
     */
    toTwos(f) {
      return N(f >>> 0 === f, "width", "uint32"), new w($i(this.n, f));
    }
    fromTwos(f) {
      return N(f >>> 0 === f, "width", "uint32"), G(f > 0, "width"), new w(Mt(this.n, f));
    }
    /*
     * Reduction Context
     */
    toRed(f) {
      if (N(f instanceof V, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return f.convertTo(this);
    }
    fromRed() {
      return F(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(f) {
      if (N(f instanceof V, "ctx", "reduction context"), this.red) {
        if (f.n !== this.red.n || f.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        G(this.n >= 0n, "red"), G(this.n < f.n, "red");
      return this.clone()._forceRed(f);
    }
    redIAdd(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIAdd"), this.red.iadd(this, f);
    }
    redAdd(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redAdd"), this.red.add(this, f);
    }
    redIAddn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIAddn"), this.red.iaddn(this, f);
    }
    redAddn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redAddn"), this.red.addn(this, f);
    }
    redISub(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redISub"), this.red.isub(this, f);
    }
    redSub(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redSub"), this.red.sub(this, f);
    }
    redISubn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redISubn"), this.red.isubn(this, f);
    }
    redSubn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redSubn"), this.red.subn(this, f);
    }
    redIMul(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIMul"), this.red.imul(this, f);
    }
    redMul(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redMul"), this.red.mul(this, f);
    }
    redIMuln(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIMuln"), this.red.imuln(this, f);
    }
    redMuln(f) {
      return N(he(f), "num", "smi"), F(this.red, "redMuln"), this.red.muln(this, f);
    }
    redIDiv(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIDiv"), this.red.idiv(this, f);
    }
    redDiv(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redDiv"), this.red.div(this, f);
    }
    redIDivn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIDivn"), this.red.idivn(this, f);
    }
    redDivn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redDivn"), this.red.divn(this, f);
    }
    redIPow(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIPow"), W(!f.red, "redIPow"), this.red.ipow(this, f);
    }
    redPow(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redPow"), W(!f.red, "redPow"), this.red.pow(this, f);
    }
    redIPown(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIPown"), this.red.ipown(this, f);
    }
    redPown(f) {
      return N(he(f), "num", "smi"), F(this.red, "redPown"), this.red.pown(this, f);
    }
    redISqr() {
      return F(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return F(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return F(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return F(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(f) {
      return F(this.red, "redIDivSqrt"), this.red.idivsqrt(this, f);
    }
    redDivSqrt(f) {
      return F(this.red, "redDivSqrt"), this.red.divsqrt(this, f);
    }
    redIsSquare() {
      return F(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIShl"), W(!f.red, "redIShl"), this.red.ishl(this, f);
    }
    redShl(f) {
      return N(w.isBN(f), "num", "bignum"), N(f.n >= 0n && f.n <= i, "num", "uint32"), F(this.red, "redShl"), W(!f.red, "redShl"), this.red.shl(this, f);
    }
    redIShln(f) {
      return N(f >>> 0 === f, "num", "uint32"), F(this.red, "redIShln"), this.red.ishln(this, f);
    }
    redShln(f) {
      return N(f >>> 0 === f, "num", "uint32"), F(this.red, "redShln"), this.red.shln(this, f);
    }
    redINeg() {
      return F(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return F(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redEq"), this.red.eq(this, f);
    }
    redEqn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redEqn"), this.red.eqn(this, f);
    }
    redIsHigh() {
      return F(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return F(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return F(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return F(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return F(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return F(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return F(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return F(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return F(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return F(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return F(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _forceRed(f) {
      return this.red = f, this;
    }
    /*
     * Helpers
     */
    clone() {
      return new w().inject(this);
    }
    inject(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = f.n, this.red = f.red, this;
    }
    set(f, m) {
      return this.fromNumber(f, m);
    }
    swap(f) {
      return N(w.isBN(f), "num", "bignum"), [this.n, f.n] = [f.n, this.n], [this.red, f.red] = [f.red, this.red], this;
    }
    reverse() {
      const f = this.n < 0n, m = l === "be" ? "le" : "be";
      return this.fromBuffer(this.toBuffer(m), l), f && (this.n = -this.n), this;
    }
    byteLength() {
      return ii(this.n);
    }
    bitLength() {
      return at(this.n);
    }
    zeroBits() {
      return nt(this.n);
    }
    isSafe() {
      return this.n <= d && this.n >= -d;
    }
    word(f) {
      return N(f >>> 0 === f, "pos", "uint32"), Hi(this.n, f);
    }
    [r]() {
      let f = "BN";
      return this.red && (f = "BN-R"), `<${f}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      if (!this.isSafe())
        throw new RangeError("Number can only safely store up to 53 bits.");
      return Number(this.n);
    }
    toDouble() {
      return Number(this.n);
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      return this.n;
    }
    toBool() {
      return this.n !== 0n;
    }
    toString(f, m) {
      return Nt(this.n, f, m);
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(f, m) {
      const D = this.toBuffer(f, m);
      return Array.from ? Array.from(D) : Array.prototype.slice.call(D);
    }
    toBuffer(f, m) {
      return j(this.n, f, m);
    }
    toArrayLike(f, m, D) {
      if (f === Buffer)
        return this.toBuffer(m, D);
      if (f === Array)
        return this.toArray(m, D);
      if (f === Int8Array || f === Uint8Array || f === Uint8ClampedArray) {
        const ee = this.toBuffer(m, D);
        return new f(ee.buffer, ee.byteOffset, ee.byteLength);
      }
      return Q(this.n, f, m, D);
    }
    encode(f, m) {
      return this.toBuffer(f, m);
    }
    /*
     * Instantiation
     */
    of(f, m) {
      return this.fromNumber(f, m);
    }
    fromNumber(f, m) {
      return m == null && (m = "be"), N(xe(f), "num", "integer"), N(m === "be" || m === "le", "endian", "endianness"), this.n = BigInt(f), m === "le" && this.reverse(), this;
    }
    fromDouble(f, m) {
      return m == null && (m = "be"), N(typeof f == "number", "num", "double"), N(m === "be" || m === "le", "endian", "endianness"), isFinite(f) || (f = 0), this.n = BigInt(Math.trunc(f)), m === "le" && this.reverse(), this;
    }
    fromBigInt(f, m) {
      return m == null && (m = "be"), N(typeof f == "bigint", "num", "bigint"), N(m === "be" || m === "le", "endian", "endianness"), this.n = f, m === "le" && this.reverse(), this;
    }
    fromBool(f) {
      return N(typeof f == "boolean", "value", "boolean"), this.set(f ? 1 : 0);
    }
    fromString(f, m, D) {
      return (m === "le" || m === "be") && ([m, D] = [D, m]), D == null && (D = "be"), N(D === "be" || D === "le", "endian", "endianness"), this.n = Ot(f, m), D === "le" && this.reverse(), this;
    }
    fromJSON(f) {
      if (w.isBN(f))
        return f.red ? f.fromRed() : f.clone();
      if (Array.isArray(f)) {
        for (const m of f)
          N(typeof m == "string", "chunk", "string");
        f = f.join("");
      }
      return this.fromString(f, 16);
    }
    fromBN(f) {
      return this.inject(f);
    }
    fromArray(f, m) {
      return N(Array.isArray(f), "data", "array"), this.n = C0(f, m), this;
    }
    fromBuffer(f, m) {
      return this.n = R(f, m), this;
    }
    fromArrayLike(f, m) {
      if (Buffer.isBuffer(f))
        return this.fromBuffer(f, m);
      if (Array.isArray(f))
        return this.fromArray(f, m);
      if (f instanceof Int8Array || f instanceof Uint8Array || f instanceof Uint8ClampedArray) {
        const D = Buffer.from(f.buffer, f.byteOffset, f.byteLength);
        return this.fromBuffer(D, m);
      }
      return this.n = C0(f, m), this;
    }
    decode(f, m) {
      return this.fromBuffer(f, m);
    }
    from(f, m, D) {
      if (f == null)
        return this;
      if ((m === "le" || m === "be") && ([m, D] = [D, m]), typeof f == "number")
        return this.fromNumber(f, D);
      if (typeof f == "bigint")
        return this.fromBigInt(f, D);
      if (typeof f == "string")
        return this.fromString(f, m, D);
      if (typeof f == "object") {
        if (w.isBN(f))
          return this.fromBN(f, D);
        if (Buffer.isBuffer(f))
          return this.fromBuffer(f, D);
        if (f.length >>> 0 === f.length)
          return this.fromArrayLike(f, D);
      }
      if (typeof f == "boolean")
        return this.fromBool(f);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...f) {
      let m = null;
      for (const D of f)
        N(w.isBN(D), "num", "bignum"), (!m || D.cmp(m) < 0) && (m = D);
      return m || new w(0);
    }
    static max(...f) {
      let m = null;
      for (const D of f)
        N(w.isBN(D), "num", "bignum"), (!m || D.cmp(m) > 0) && (m = D);
      return m || new w(0);
    }
    static cmp(f, m) {
      return N(w.isBN(f), "a", "bignum"), f.cmp(m);
    }
    static ucmp(f, m) {
      return N(w.isBN(f), "a", "bignum"), f.ucmp(m);
    }
    static red(f) {
      return new V(f, !1);
    }
    static barret(f) {
      return new V(f, !1);
    }
    static mont(f) {
      return new V(f, !0);
    }
    static _prime(f) {
      if (g[f])
        return g[f];
      let m;
      if (f === "p192")
        m = new _();
      else if (f === "p224")
        m = new q();
      else if (f === "p521")
        m = new U();
      else if (f === "k256")
        m = new z();
      else if (f === "p251")
        m = new E();
      else if (f === "p25519")
        m = new H();
      else if (f === "p448")
        m = new k();
      else
        throw new Error(`Unknown prime: "${f}".`);
      return g[f] = m, m;
    }
    static prime(f) {
      return w._prime(f).p.clone();
    }
    static pow(f, m) {
      return f === 2 ? w.shift(1, m) : new w().fromNumber(f).ipown(m);
    }
    static shift(f, m) {
      return new w().fromNumber(f).ishln(m);
    }
    static mask(f) {
      return w.shift(1, f).isubn(1);
    }
    static randomBits(f, m) {
      const D = T0(f, m);
      return new w(D);
    }
    static random(f, m, D) {
      const ee = w.cast(m, 16), te = w.cast(D, 16), se = D0(f, ee.n, te.n);
      return new w(se);
    }
    static of(f, m) {
      return new w().of(f, m);
    }
    static fromNumber(f, m) {
      return new w().fromNumber(f, m);
    }
    static fromDouble(f, m) {
      return new w().fromDouble(f, m);
    }
    static fromBigInt(f, m) {
      return new w().fromBigInt(f, m);
    }
    static fromBool(f) {
      return new w().fromBool(f);
    }
    static fromString(f, m, D) {
      return new w().fromString(f, m, D);
    }
    static fromJSON(f) {
      return new w().fromJSON(f);
    }
    static fromBN(f) {
      return new w().fromBN(f);
    }
    static fromArray(f, m) {
      return new w().fromArray(f, m);
    }
    static fromBuffer(f, m) {
      return new w().fromBuffer(f, m);
    }
    static fromArrayLike(f, m) {
      return new w().fromArrayLike(f, m);
    }
    static decode(f, m) {
      return new w().decode(f, m);
    }
    static from(f, m, D) {
      return new w().from(f, m, D);
    }
    static cast(f, m, D) {
      return w.isBN(f) ? f : new w(f, m, D);
    }
    static isBN(f) {
      return f instanceof w;
    }
  }
  w.BN = w, w.wordSize = 26, w.native = 1;
  class I {
    constructor(f, m) {
      this.name = f, this.p = new w(m, 16);
    }
    pm2(f) {
      throw new Error("Not implemented.");
    }
    fermat(f) {
      if (f === 0n)
        throw new RangeError("Not invertible.");
      return this.pm2(f);
    }
  }
  class B extends I {
    constructor(f, m) {
      super(f, m);
    }
    pm3d4(f) {
      throw new Error("Not implemented.");
    }
    pp1d4(f) {
      throw new Error("Not implemented.");
    }
    sqrt(f) {
      const m = this.p.n, D = this.pp1d4(f);
      if (D * D % m !== f)
        throw new ne(D);
      return D;
    }
    divsqrt(f, m) {
      if (f === 0n && m === 0n)
        throw new ne(m);
      const D = this.p.n, ee = f * f % D, te = ee * f % D, se = te * ee % D, ue = m * m * m % D, be = this.pm3d4(se * ue % D), Ae = te * m * be % D;
      if (m * Ae * Ae % D === f)
        return Ae;
      throw new ne(Ae);
    }
  }
  class y extends I {
    constructor(f, m, D) {
      super(f, m), this.sm1 = new w(D, 16);
    }
    pm5d8(f) {
      throw new Error("Not implemented.");
    }
    pp3d8(f) {
      throw new Error("Not implemented.");
    }
    sqrt(f) {
      const m = this.p.n, D = this.sm1.n, ee = this.pp3d8(f);
      if (ee * ee % m === f)
        return ee;
      const te = ee * D % m;
      if (te * te % m === f)
        return te;
      throw new ne(ee);
    }
    divsqrt(f, m) {
      if (f === 0n && m === 0n)
        throw new ne(m);
      const D = this.p.n, ee = this.sm1.n, te = m * m * m % D, se = te * te * m % D, ue = this.pm5d8(f * se % D), be = f * te * ue % D, Ae = m * be * be % D;
      if (Ae === f)
        return be;
      if (Ae === L(-f, D))
        return be * ee % D;
      throw Ae === L(-f * ee, D) ? new ne(be * ee % D) : new ne(be);
    }
  }
  class A extends I {
    constructor(f, m, D) {
      super(f, m), this.g = new w(D, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(f) {
      throw new Error("Not implemented.");
    }
    powE(f) {
      throw new Error("Not implemented.");
    }
    sqrt(f) {
      const m = this.p.n;
      switch (Ht(f, m)) {
        case -1:
          throw new ne(f);
        case 0:
          return 0n;
      }
      let D = this.g.n, ee = this.powE(f), te = this.powS(f), se = this.z;
      for (; ; ) {
        let ue = te, be = 0;
        for (; ue !== 1n && be < se; )
          ue = ue * ue % m, be += 1;
        if (be === 0)
          break;
        ie(be < se), ue = ke(D, se - be - 1, m), D = ue * ue % m, ee = ee * ue % m, te = te * D % m, se = be;
      }
      return ee;
    }
    divsqrt(f, m) {
      const D = this.p.n;
      if (m === 0n)
        throw new ne(m);
      return this.sqrt(f * Xe(m, D));
    }
  }
  class _ extends B {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    core(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 6, te, m), ue = le(se, 12, se, m), be = le(ue, 6, te, m), Ae = le(be, 1, f, m), $e = le(Ae, 31, Ae, m), Rt = le($e, 62, $e, m), Jt = le(Rt, 3, ee, m), mr = ke(Jt, 1, m);
      return le(mr, 62, $e, m);
    }
    pm3d4(f) {
      return this.core(f);
    }
    pm2(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 2, D, m), te = le(ee, 4, ee, m), se = le(te, 8, te, m), ue = le(se, 16, se, m), be = le(ue, 32, ue, m), Ae = le(be, 64, be, m);
      return ke(Ae, 62, m);
    }
  }
  class q extends A {
    constructor() {
      super("p224", "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001", "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74");
    }
    powS(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 2, D, m), te = le(ee, 4, ee, m), se = le(te, 8, te, m), ue = le(se, 16, se, m), be = le(ue, 32, ue, m);
      return le(be, 64, be, m);
    }
    powE(f) {
      const m = this.p.n;
      return ke(f, 127, m);
    }
    pm2(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 6, te, m), ue = le(se, 12, se, m), be = le(ue, 24, ue, m), Ae = le(be, 48, be, m), $e = le(Ae, 24, ue, m), Rt = le($e, 6, te, m), Jt = le(Rt, 1, f, m), mr = ke(Jt, 1, m);
      return le(mr, 96, Ae, m);
    }
  }
  class U extends B {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    core(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 1, f, m), ue = le(se, 1, f, m), be = le(ue, 8, ue, m), Ae = le(be, 16, be, m), $e = le(Ae, 32, Ae, m), Rt = le($e, 64, $e, m), Jt = le(Rt, 128, Rt, m), mr = le(Jt, 256, Jt, m);
      return le(mr, 7, se, m);
    }
    pm3d4(f) {
      return this.core(f);
    }
    pm2(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n;
      return ke(f, 519, m);
    }
  }
  class z extends B {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    core(f, m) {
      const D = this.p.n, ee = le(m, 1, f, D), te = le(ee, 3, ee, D), se = le(te, 3, ee, D), ue = le(se, 2, m, D), be = le(ue, 11, ue, D), Ae = le(be, 22, be, D), $e = le(Ae, 44, Ae, D), Rt = le($e, 88, $e, D), Jt = le(Rt, 44, Ae, D), mr = le(Jt, 3, ee, D), Xr = ke(mr, 1, D), si = le(Xr, 22, be, D);
      return ke(si, 4, D);
    }
    pm3d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m), se = ke(te, 1, m);
      return le(se, 2, D, m);
    }
    pm2(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m), se = ke(te, 1, m), ue = le(se, 2, D, m), be = ke(ue, 1, m);
      return le(be, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 2, D, m);
      return ke(te, 2, m);
    }
  }
  class E extends B {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    core(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 6, te, m), ue = le(se, 12, se, m), be = le(ue, 24, ue, m), Ae = le(be, 48, be, m), $e = le(Ae, 96, Ae, m), Rt = le($e, 48, be, m), Jt = le(Rt, 6, te, m);
      return le(Jt, 1, f, m);
    }
    pm3d4(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pm2(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m), te = le(ee, 1, f, m), se = ke(te, 1, m);
      return le(se, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = this.core(f), ee = le(D, 1, f, m);
      return ke(ee, 1, m);
    }
  }
  class H extends y {
    constructor() {
      super("p25519", "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed", "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0");
    }
    core(f, m) {
      const D = this.p.n, ee = le(m, 2, m, D), te = le(ee, 1, f, D), se = le(te, 5, te, D), ue = le(se, 10, se, D), be = le(ue, 20, ue, D), Ae = le(be, 10, se, D), $e = le(Ae, 50, Ae, D), Rt = le($e, 100, $e, D);
      return le(Rt, 50, Ae, D);
    }
    pm5d8(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = ke(ee, 1, m);
      return le(te, 1, f, m);
    }
    pm2(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = ke(ee, 1, m), se = le(te, 1, f, m), ue = ke(se, 1, m);
      return le(ue, 2, D, m);
    }
    pp3d8(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m);
      return ke(te, 1, m);
    }
  }
  class k extends B {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    core(f, m) {
      const D = this.p.n, ee = le(m, 1, f, D), te = le(ee, 3, ee, D), se = le(te, 3, ee, D), ue = le(se, 2, m, D), be = le(ue, 11, ue, D), Ae = le(be, 22, be, D), $e = le(Ae, 44, Ae, D), Rt = le($e, 88, $e, D), Jt = le(Rt, 44, Ae, D);
      return le(Jt, 2, m, D);
    }
    pm3d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m), se = ke(te, 1, m);
      return le(se, 222, ee, m);
    }
    pm2(f) {
      const m = this.p.n, D = this.pm3d4(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 2, D, m);
      return ke(te, 222, m);
    }
  }
  class V {
    constructor(f) {
      let m = null;
      typeof f == "string" && (m = w._prime(f), f = m.p), N(w.isBN(f), "m", "bignum"), W(!f.red, "reduction"), G(f.n >= 1n, "reduction"), this.m = f, this.n = f.n, this.prime = m, this.sm1 = null;
    }
    _verify1(f) {
      G(f.negative === 0, "red"), F(f.red != null, "red");
    }
    _verify2(f, m) {
      G((f.negative | m.negative) === 0, "red"), F(f.red != null && f.red === m.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      return this.sm1 === null && (this.n & 7n) === 5n && (this.prime ? this.sm1 = this.prime.sm1.n : this.sm1 = Ge(2n, this.n - 1n >> 2n, this.n)), this;
    }
    convertTo(f) {
      const m = new w();
      return m.n = L(f.n, this.n), m.red = this, m;
    }
    convertFrom(f) {
      const m = f.clone();
      return m.red = null, m;
    }
    iadd(f, m) {
      return this._verify2(f, m), f.n += m.n, f.n >= this.n && (f.n -= this.n), f;
    }
    add(f, m) {
      return this.iadd(f.clone(), m);
    }
    iaddn(f, m) {
      if (this._verify1(f), m < 0)
        return this.isubn(f, -m);
      let D = BigInt(m);
      return this.n < 0x4000000n && (D %= this.n), f.n += D, f.n >= this.n && (f.n -= this.n), f;
    }
    addn(f, m) {
      return this.iaddn(f.clone(), m);
    }
    isub(f, m) {
      return this._verify2(f, m), f.n -= m.n, f.n < 0n && (f.n += this.n), f;
    }
    sub(f, m) {
      return this.isub(f.clone(), m);
    }
    isubn(f, m) {
      if (this._verify1(f), m < 0)
        return this.iaddn(f, -m);
      let D = BigInt(m);
      return this.n < 0x4000000n && (D %= this.n), f.n -= D, f.n < 0n && (f.n += this.n), f;
    }
    subn(f, m) {
      return this.isubn(f.clone(), m);
    }
    imul(f, m) {
      return this._verify2(f, m), f.n *= m.n, f.n %= this.n, f;
    }
    mul(f, m) {
      return this._verify2(f, m), this.imul(f.clone(), m);
    }
    imuln(f, m) {
      return this._verify1(f), f.n *= BigInt(m), f.n = L(f.n, this.n), f;
    }
    muln(f, m) {
      return this.imuln(f.clone(), m);
    }
    idiv(f, m) {
      return f.n *= Xe(m.n, this.n), f.n %= this.n, f;
    }
    div(f, m) {
      return this.idiv(f.clone(), m);
    }
    idivn(f, m) {
      return f.n *= Xe(BigInt(m), this.n), f.n %= this.n, f;
    }
    divn(f, m) {
      return this.idivn(f.clone(), m);
    }
    ipow(f, m) {
      return this._verify1(f), f.n = Ge(f.n, m.n, this.n), f;
    }
    pow(f, m) {
      return this.ipow(f.clone(), m);
    }
    ipown(f, m) {
      return this._verify1(f), f.n = Ge(f.n, BigInt(m), this.n), f;
    }
    pown(f, m) {
      return this.ipown(f.clone(), m);
    }
    isqr(f) {
      return this._verify1(f), f.n *= f.n, f.n %= this.n, f;
    }
    sqr(f) {
      return this.isqr(f.clone());
    }
    isqrt(f) {
      return this._verify1(f), this.prime ? f.n = this.prime.sqrt(f.n) : this.sm1 != null ? f.n = Bt(f.n, this.n, this.sm1) : f.n = ot(f.n, this.n), f;
    }
    sqrt(f) {
      return this.isqrt(f.clone());
    }
    idivsqrt(f, m) {
      return this._verify2(f, m), this.prime ? f.n = this.prime.divsqrt(f.n, m.n) : f.n = Li(f.n, m.n, this.n, this.sm1), f;
    }
    divsqrt(f, m) {
      return this.idivsqrt(f.clone(), m);
    }
    isSquare(f) {
      return this._verify1(f), this.n & 1n ? Ht(f.n, this.n) >= 0 : Qe(f.n, this.n) >= 0;
    }
    ishl(f, m) {
      return this._verify1(f), f.n <<= m.n, f.n %= this.n, f;
    }
    shl(f, m) {
      return this.ishl(f.clone(), m);
    }
    ishln(f, m) {
      return this._verify1(f), f.n <<= BigInt(m), f.n %= this.n, f;
    }
    shln(f, m) {
      return this.ishln(f.clone(), m);
    }
    ineg(f) {
      return this._verify1(f), f.n !== 0n && (f.n = this.n - f.n), f;
    }
    neg(f) {
      return this.ineg(f.clone());
    }
    eq(f, m) {
      return this._verify2(f, m), f.n === m.n;
    }
    eqn(f, m) {
      if (this._verify1(f), this.n < 0x4000000n) {
        const D = Number(this.n);
        return m %= D, m < 0 && (m += D), f.n == m;
      }
      return m < 0 ? f.n === BigInt(m) + this.n : f.n == m;
    }
    isHigh(f) {
      return !this.isLow(f);
    }
    isLow(f) {
      return this._verify1(f), f.n <= this.n >> 1n;
    }
    isOdd(f) {
      return this._verify1(f), f.isOdd();
    }
    isEven(f) {
      return this._verify1(f), f.isEven();
    }
    legendre(f) {
      return this._verify1(f), it(f.n, this.n);
    }
    jacobi(f) {
      return this._verify1(f), Ht(f.n, this.n);
    }
    kronecker(f) {
      return this._verify1(f), Qe(f.n, this.n);
    }
    iinvert(f) {
      return this._verify1(f), f.n = Xe(f.n, this.n), f;
    }
    invert(f) {
      return this.iinvert(f.clone());
    }
    ifermat(f) {
      return this._verify1(f), this.prime ? f.n = this.prime.fermat(f.n) : f.n = qr(f.n, this.n), f;
    }
    fermat(f) {
      return this.ifermat(f.clone());
    }
    invertAll(f) {
      N(Array.isArray(f), "elems", "array");
      for (const se of f)
        N(w.isBN(se), "elem", "bignum"), this._verify1(se);
      const m = f.length, D = new Array(m);
      for (let se = 0; se < m; se++)
        D[se] = f[se].n;
      const ee = bt(D, this.n), te = new Array(m);
      for (let se = 0; se < m; se++)
        te[se] = new w(ee[se])._forceRed(this);
      return te;
    }
    [r]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.n.toString(10)}>`;
    }
  }
  function T(P, f, m) {
    const D = new P(f);
    return P.captureStackTrace && P.captureStackTrace(D, m), D;
  }
  function ie(P, f) {
    if (!P)
      throw T(Error, f || "Assertion failed.", ie);
  }
  function N(P, f, m) {
    if (!P) {
      const D = `"${f}" must be a(n) ${m}.`;
      throw T(TypeError, D, N);
    }
  }
  function G(P, f) {
    if (!P) {
      const m = `"${f}" only works with positive numbers.`;
      throw T(RangeError, m, G);
    }
  }
  function F(P, f) {
    if (!P) {
      const m = `"${f}" only works with red numbers.`;
      throw T(TypeError, m, F);
    }
  }
  function W(P, f) {
    if (!P) {
      const m = `"${f}" only works with normal numbers.`;
      throw T(TypeError, m, W);
    }
  }
  function ce(P) {
    if (!P)
      throw T(RangeError, "Cannot divide by zero.", ce);
  }
  class ne extends Error {
    constructor(f) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = new w(f), Error.captureStackTrace && Error.captureStackTrace(this, ne);
    }
  }
  function xe(P) {
    return Number.isSafeInteger(P);
  }
  function he(P) {
    return xe(P) && P >= -67108863 && P <= 67108863;
  }
  function me(P, f) {
    return P.allocUnsafeSlow ? P.allocUnsafeSlow(f) : new P(f);
  }
  function Ne(P) {
    if (P == null)
      return 10;
    if (typeof P == "number")
      return P;
    switch (P) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function Je(P) {
    switch (P) {
      case 2:
      case 8:
      case 10:
      case 16:
        return !0;
    }
    return !1;
  }
  function Ze(P) {
    let f = 0, m = P.length - 1, D = P.length >>> 1;
    for (; D--; ) {
      const ee = P[f];
      P[f++] = P[m], P[m--] = ee;
    }
    return P;
  }
  function ht(P, f, m) {
    const D = BigInt(m), ee = P < 0n ^ f < 0n;
    let te = P * f;
    ee && (te = -te);
    const se = te >> D - 1n & 1n;
    return te >>= D, te += se, ee && (te = -te), te;
  }
  function dt(P, f) {
    ie(f !== 0n);
    const m = P / f, D = P - m * f;
    return [m, D];
  }
  function Se(P, f) {
    return ie(f !== 0), Number(P % BigInt(f));
  }
  function we(P, f) {
    ie(f !== 0n);
    let m = P / f, D = P - m * f;
    return D < 0n && (f < 0n ? (m += 1n, D -= f) : (m -= 1n, D += f)), [m, D];
  }
  function Z(P, f) {
    ie(f !== 0n);
    let m = P / f;
    return P >= 0n || P - m * f < 0n && (f < 0n ? m += 1n : m -= 1n), m;
  }
  function L(P, f) {
    ie(f !== 0n);
    let m = P % f;
    return m < 0n && (f < 0n ? m -= f : m += f), m;
  }
  function oe(P, f) {
    let m = Se(P, f);
    return m < 0 && (f < 0 ? m -= f : m += f), m;
  }
  function s(P, f) {
    ie(f !== 0n);
    const m = f < 0n ? -(-f >> 1n) : f >> 1n;
    return P < 0n ^ f < 0n ? (P - m) / f : (P + m) / f;
  }
  function a(P, f, m) {
    if (f === 0)
      throw new RangeError("Zeroth root.");
    if (~f & P < 0n)
      throw new RangeError("Negative with even root.");
    if (P === -1n || P === 0n || P === 1n)
      return [P, 0n];
    const D = BigInt(f);
    let ee = 0n, te = 1n << BigInt(at(P) / f + 1 | 0), se, ue;
    if (P < 0n && (te = -te), f === 2)
      do
        ee = te, te = P / ee, te += ee, te >>= 1n;
      while (xr(te, ee) < 0);
    else
      do
        ee = te, te = ee ** (D - 1n), te = P / te, se = ee * (D - 1n), te += se, te /= D;
      while (xr(te, ee) < 0);
    return m && (te = ee ** D, ue = P - te), [ee, ue];
  }
  function p(P, f) {
    return a(P, f, 1);
  }
  function v(P, f) {
    return a(P, f, 0)[0];
  }
  function C(P, f) {
    if (f === 0 || ~f & P < 0n)
      return !1;
    const [, m] = p(P, f);
    return m === 0n;
  }
  function K(P) {
    return p(P, 2);
  }
  function O(P) {
    return v(P, 2);
  }
  function $(P) {
    return C(P, 2);
  }
  function u(P) {
    return (1n << BigInt(P)) - 1n;
  }
  function S(P, f) {
    const m = P < 0n, D = Le(P) & Le(f);
    return m ? -D : D;
  }
  function M(P, f) {
    return S(P, BigInt(f));
  }
  function Y(P, f) {
    const m = P < 0n, D = Le(P) | Le(f);
    return m ? -D : D;
  }
  function J(P, f) {
    return Y(P, BigInt(f));
  }
  function X(P, f) {
    const m = P < 0n, D = Le(P) ^ Le(f);
    return m ? -D : D;
  }
  function re(P, f) {
    return X(P, BigInt(f));
  }
  function ae(P, f) {
    return P < 0n ? -(-P >> f) : P >> f;
  }
  function de(P, f) {
    return ae(P, BigInt(f));
  }
  function ge(P, f) {
    const m = P < 0n;
    return m && (P = -P), P ^= u(f), m && (P = -P), P;
  }
  function Be(P, f, m) {
    return m ? P |= 1n << BigInt(f) : P &= ~(1n << BigInt(f)), P;
  }
  function ve(P, f, m) {
    const D = P < 0n;
    return D && (P = -P), P = Be(P, f, m), D && (P = -P), P;
  }
  function Oe(P, f) {
    return Number(P >> BigInt(f) & 1n);
  }
  function Ie(P, f) {
    return Oe(Le(P), f);
  }
  function Re(P, f) {
    return P & u(f);
  }
  function ft(P, f) {
    const m = P < 0n;
    return m && (P = -P), P &= u(f), m && (P = -P), P;
  }
  function Ye(P, f) {
    return P < 0n && (P = -P), Number(P & BigInt(f & 67108863));
  }
  function Fe(P, f, m) {
    P < 0n && (P = -P);
    const D = BigInt((1 << m) - 1), ee = P >> BigInt(f) & D;
    return Number(ee);
  }
  function Le(P) {
    return P < 0n ? -P : P;
  }
  function He(P, f) {
    return P < f ? -1 : P > f ? 1 : 0;
  }
  function et(P, f) {
    return P < f ? -1 : P > f ? 1 : 0;
  }
  function xr(P, f) {
    return He(Le(P), Le(f));
  }
  function tt(P, f) {
    return et(Le(P), Math.abs(f));
  }
  function it(P, f) {
    if (G(f > 0n, "legendre"), (f & 1n) === 0n)
      throw new Error("legendre: `num` must be odd.");
    const m = Ge(P, f - 1n >> 1n, f);
    if (m === 0n)
      return 0;
    if (m === 1n)
      return 1;
    if (m === f - 1n)
      return -1;
    throw new Error("Invalid prime.");
  }
  function Ht(P, f) {
    if (f === 0n || (f & 1n) === 0n)
      throw new Error("jacobi: `num` must be odd.");
    let m = P, D = f, ee = 1;
    for (D < 0n && (m < 0n && (ee = -1), D = -D), m < 0n && (m = L(m, D)); ; ) {
      if (D === 1n)
        return ee;
      if (m === 0n || (m %= D, m === 0n))
        return 0;
      const te = nt(m);
      if (te & 1) {
        const se = D & 7n;
        (se === 3n || se === 5n) && (ee = -ee);
      }
      m >>= BigInt(te), (m & 3n) === 3n && (D & 3n) === 3n && (ee = -ee), [m, D] = [D, m];
    }
  }
  function Qe(P, f) {
    const m = [0, 1, 0, -1, 0, -1, 0, 1];
    if (P === 0n)
      return Le(f) === 1n ? 1 : 0;
    if (f === 0n)
      return Le(P) === 1n ? 1 : 0;
    if (((P | f) & 1n) === 0n)
      return 0;
    const D = nt(f);
    f >>= BigInt(D);
    let ee = Ht(P, f);
    return D & 1 && (ee *= m[Number(P & 7n)]), ee | 0;
  }
  function st(P, f) {
    for (P = Le(P), f = Le(f); f !== 0n; )
      [P, f] = [f, P % f];
    return P;
  }
  function s0(P, f) {
    return P === 0n || f === 0n ? 0n : Le(P / st(P, f) * f);
  }
  function ct(P, f) {
    let m = 0n, D = 1n, ee = 1n, te = 0n, se = Le(f), ue = Le(P);
    for (; se !== 0n; ) {
      const be = ue / se;
      [ue, se] = [se, ue - be * se], [D, m] = [m, D - be * m], [te, ee] = [ee, te - be * ee];
    }
    return ue < 0n && (ue = -ue, D = -D, te = -te), P < 0n && (D = -D), f < 0n && (te = -te), [D, te, ue];
  }
  function Xe(P, f) {
    if (ie(f > 0n), f === 1n)
      throw new RangeError("Not invertible.");
    (P < 0n || P >= f) && (P = L(P, f));
    let m = 0n, D = 1n, ee = f, te = P;
    for (; te !== 0n; ) {
      const se = ee / te;
      [m, D] = [D, m - se * D], [ee, te] = [te, ee - se * te];
    }
    if (ee < 0n && (ee = -ee, m = -m), ee !== 1n)
      throw new RangeError("Not invertible.");
    return m < 0n && (m += f), m;
  }
  function qr(P, f) {
    if (ie(f > 0n), f === 1n)
      throw new RangeError("Not invertible.");
    const m = Ge(P, f - 2n, f);
    if (m === 0n)
      throw new RangeError("Not invertible.");
    return m;
  }
  function bt(P, f) {
    if (ie(f > 0n), f === 1n || !(f & 1n))
      throw new RangeError("Not invertible.");
    const m = P.length, D = new Array(m);
    if (m === 0)
      return D;
    const ee = new Array(m);
    for (let se = 0; se < m; se++) {
      let ue = P[se];
      (ue < 0n || ue >= f) && (ue = L(ue, f)), ee[se] = ue;
    }
    let te = 1n;
    for (let se = 0; se < m; se++) {
      if (ee[se] === 0n) {
        D[se] = 0n;
        continue;
      }
      D[se] = te, te = te * ee[se] % f;
    }
    te = Xe(te, f);
    for (let se = m - 1; se >= 0; se--)
      ee[se] !== 0n && (D[se] = te * D[se] % f, te = te * ee[se] % f);
    return D;
  }
  function Ge(P, f, m) {
    return ie(m > 0n), f < 0n ? (P = Xe(P, m), f = -f) : P = L(P, m), f <= i ? I0(P, f, m) : pt(P, f, m);
  }
  function I0(P, f, m) {
    let D = 1n;
    for (; f > 0n; )
      (f & 1n) === 1n && (D = D * P % m), P = P * P % m, f >>= 1n;
    return D;
  }
  function pt(P, f, m) {
    const D = new Array(x), ee = P * P % m;
    D[0] = P;
    for (let ue = 1; ue < x; ue++)
      D[ue] = D[ue - 1] * ee % m;
    let te = at(f), se = 1n;
    for (; te >= h; ) {
      let ue = h, be = Number(f >> BigInt(te - ue) & b);
      if (be < x) {
        se = se * se % m, te -= 1;
        continue;
      }
      for (; !(be & 1); )
        ue -= 1, be >>= 1;
      se === 1n ? se = D[be >> 1] : (se = ke(se, ue, m), se = se * D[be >> 1] % m), te -= ue;
    }
    for (; te--; )
      se = se * se % m, f >> BigInt(te) & 1n && (se = se * P % m);
    return se;
  }
  function ke(P, f, m) {
    for (; f--; )
      P = P * P % m;
    return P;
  }
  function le(P, f, m, D) {
    return ke(P, f, D) * m % D;
  }
  function ot(P, f) {
    return ie(f > 0n), (P < 0n || P >= f) && (P = L(P, f)), (f & 3n) === 3n ? St(P, f) : (f & 7n) === 5n ? Di(P, f) : vt(P, f);
  }
  function St(P, f) {
    const m = f + 1n >> 2n, D = Ge(P, m, f);
    if (D * D % f !== P)
      throw new ne(D);
    return D;
  }
  function Di(P, f) {
    const m = f >> 3n, D = (P << 1n) % f, ee = Ge(D, m, f), te = D * ee * ee % f, se = ee * P * (te - 1n) % f;
    if (se * se % f !== P)
      throw new ne(se);
    return se;
  }
  function Bt(P, f, m) {
    const D = f + 3n >> 3n, ee = Ge(P, D, f);
    if (ee * ee % f === P)
      return ee;
    const te = ee * m % f;
    if (te * te % f === P)
      return te;
    throw new ne(ee);
  }
  function vt(P, f) {
    if (f === 1n || (f & 1n) === 0n)
      throw new Error("Invalid prime.");
    switch (Ht(P, f)) {
      case -1:
        throw new ne(P);
      case 0:
        return 0n;
    }
    let m = f - 1n;
    const D = nt(m);
    m >>= BigInt(D);
    let ee = 2n;
    for (; Ht(ee, f) !== -1; )
      ee += 1n;
    let te = Ge(ee, m, f), se = Ge(P, m + 1n >> 1n, f), ue = Ge(P, m, f), be = D;
    for (; ; ) {
      let Ae = ue, $e = 0;
      for (; Ae !== 1n && $e < be; )
        Ae = Ae * Ae % f, $e += 1;
      if ($e === 0)
        break;
      ie($e < be), Ae = ke(te, be - $e - 1, f), te = Ae * Ae % f, se = se * Ae % f, ue = ue * te % f, be = $e;
    }
    return se;
  }
  function Li(P, f, m, D) {
    if (ie(m > 0n), (P < 0n || P >= m) && (P = L(P, m)), (f < 0n || f >= m) && (f = L(f, m)), P === 0n && f === 0n)
      throw new ne(f);
    if ((m & 3n) === 3n)
      return Et(P, f, m);
    if (D != null && (m & 7n) === 5n)
      return It(P, f, m, D);
    if (f === 0n)
      throw new ne(f);
    return ot(P * Xe(f, m), m);
  }
  function Et(P, f, m) {
    const D = m - 3n >> 2n, ee = P * P % m, te = ee * P % m, se = te * ee % m, ue = f * f * f % m, be = Ge(se * ue, D, m), Ae = te * f * be % m;
    if (f * Ae * Ae % m === P)
      return Ae;
    throw new ne(Ae);
  }
  function It(P, f, m, D) {
    const ee = m - 5n >> 3n, te = f * f * f % m, se = te * te * f % m, ue = Ge(P * se, ee, m), be = P * te * ue % m, Ae = f * be * be % m;
    if (Ae === P)
      return be;
    if (Ae === L(-P, m))
      return be * D % m;
    throw Ae === L(-P * D, m) ? new ne(be * D % m) : new ne(be);
  }
  function Ki(P, f, m) {
    ie(f > 0n), ie(m > 0n);
    const D = ot(P, f), ee = ot(P, m), [te, se] = ct(f, m);
    return L(ee * te * f + D * se * m, f * m);
  }
  function At(P, f, m, D = !1) {
    if (N(m >>> 0 === m, "reps", "uint32"), N(m > 0, "reps", "integer"), N(typeof D == "boolean", "force2", "boolean"), P < 7n)
      return P === 2n || P === 3n || P === 5n;
    if ((P & 1n) === 0n)
      return !1;
    const ee = P - 1n, te = ee - 2n, se = nt(ee), ue = ee >> BigInt(se);
    e:
      for (let be = 0; be < m; be++) {
        let Ae, $e;
        if (be === m - 1 && D ? Ae = 2n : (Ae = D0(f, 0n, te), Ae += 2n), $e = Ge(Ae, ue, P), !($e === 1n || $e === ee)) {
          for (let Rt = 1; Rt < se; Rt++) {
            if ($e = $e * $e % P, $e === ee)
              continue e;
            if ($e === 1n)
              return !1;
          }
          return !1;
        }
      }
    return !0;
  }
  function _t(P, f = 0) {
    if (N(f >>> 0 === f, "limit", "uint32"), P <= 1n)
      return !1;
    if ((P & 1n) === 0n)
      return P === 2n;
    let m = 3n;
    for (; ; ) {
      if (m > 10000n)
        throw new Error(`Cannot find (D/n) = -1 for ${P.toString(10)}.`);
      if (f !== 0 && m > f)
        return !1;
      const ue = m * m - 4n, be = Ht(ue, P);
      if (be === -1)
        break;
      if (be === 0)
        return P === m + 2n;
      if (m === 40n && $(P))
        return !1;
      m += 1n;
    }
    let D = P + 1n;
    const ee = nt(D);
    D >>= BigInt(ee);
    let te = 2n, se = m;
    for (let ue = BigInt(at(D)); ue >= 0n; ue--)
      D & 1n << ue ? (te = L(te * se - m, P), se = L(se * se - 2n, P)) : (se = L(se * te - m, P), te = L(te * te - 2n, P));
    if (te === 2n || te === P - 2n) {
      const ue = te * m % P, be = (se << 1n) % P;
      if (ue === be)
        return !0;
    }
    for (let ue = 0; ue < ee - 1; ue++) {
      if (te === 0n)
        return !0;
      if (te === 2n)
        return !1;
      te = L(te * te - 2n, P);
    }
    return !1;
  }
  function $i(P, f) {
    return P < 0n ? ge(-P, f) + 1n : P;
  }
  function Mt(P, f) {
    return Oe(P, f - 1) ? -(ge(P, f) + 1n) : P;
  }
  function lt(P, f) {
    if (P === 0n)
      return 0;
    P < 0n && (P = -P);
    let m = 0;
    for (; P >= o; )
      m += 256, P >>= 256n;
    for (; P >= c; )
      m += 128, P >>= 128n;
    for (; P >= n; )
      m += 64, P >>= 64n;
    for (; P >= i; )
      m += 32, P >>= 32n;
    for (; P >= t; )
      m += 16, P >>= 16n;
    for (; P >= e; )
      m += 8, P >>= 8n;
    for (; P > 0n; )
      m += 1, P >>= 1n;
    return (m + (f - 1)) / f >>> 0;
  }
  function ii(P) {
    return lt(P, 8);
  }
  function at(P) {
    return lt(P, 1);
  }
  function nt(P) {
    if (P === 0n)
      return 0;
    P < 0n && (P = -P);
    let f = 0;
    for (; (P & i) === 0n; )
      f += 32, P >>= 32n;
    for (; (P & t) === 0n; )
      f += 16, P >>= 16n;
    for (; (P & e) === 0n; )
      f += 8, P >>= 8n;
    for (; (P & 1n) === 0n; )
      f += 1, P >>= 1n;
    return f;
  }
  function Hi(P, f) {
    return Number(Le(P) >> BigInt(f * 26) & 0x3ffffffn);
  }
  function Nt(P, f, m) {
    if (f = Ne(f), m == null && (m = 0), m === 0 && (m = 1), N(f >>> 0 === f, "base", "uint32"), N(m >>> 0 === m, "padding", "uint32"), f < 2 || f > 36)
      throw new RangeError("Base ranges between 2 and 36.");
    let D = !1;
    P < 0n && (D = !0, P = -P);
    let ee = P.toString(f);
    for (; ee.length % m; )
      ee = "0" + ee;
    return D && (ee = "-" + ee), ee;
  }
  function Ot(P, f) {
    if (f = Ne(f), N(typeof P == "string", "str", "string"), N(f >>> 0 === f, "base", "uint32"), f < 2 || f > 36)
      throw new RangeError("Base ranges between 2 and 36.");
    if (Je(f))
      return Ke(P, f);
    let m = !1, D = 0;
    for (; D < P.length; D++) {
      switch (P.charCodeAt(D)) {
        case 9:
        case 10:
        case 13:
        case 32:
          continue;
      }
      break;
    }
    D < P.length && P.charCodeAt(D) === 45 && (m = !0, D += 1);
    const ee = BigInt(f);
    let te = 0n;
    for (; D < P.length; D++) {
      let se = P.charCodeAt(D);
      switch (se) {
        case 9:
        case 10:
        case 13:
        case 32:
          continue;
      }
      if (se >= 48 && se <= 57 ? se -= 48 : se >= 65 && se <= 90 ? se -= 65 - 10 : se >= 97 && se <= 122 ? se -= 97 - 10 : se = f, se >= f)
        throw new Error("Invalid string.");
      te *= ee, te += BigInt(se);
    }
    return m && (te = -te), te;
  }
  function Ke(P, f) {
    let m = !1, D;
    switch (P = P.replace(/\s+/g, ""), P.length > 0 && P.charCodeAt(0) === 45 && (P = P.substring(1), m = !0), f) {
      case 2:
        P = "0b" + P;
        break;
      case 8:
        P = "0o" + P;
        break;
      case 10:
        if (P.length > 1) {
          const ee = P.charCodeAt(1);
          if (ee < 48 || ee > 57)
            throw new Error("Invalid string.");
        }
        break;
      case 16:
        P = "0x" + P;
        break;
      default:
        throw new Error("Invalid base.");
    }
    try {
      D = BigInt(P);
    } catch {
      throw new Error("Invalid string.");
    }
    return m && (D = -D), D;
  }
  function j(P, f, m) {
    f == null && (f = "be"), m == null && (m = 0), N(f === "be" || f === "le", "endian", "endianness"), N(m >>> 0 === m, "length", "uint32");
    let D = Le(P).toString(16);
    D.length & 1 && (D = "0" + D);
    const ee = D.length >>> 1, te = m || Math.max(1, ee);
    if (ee > te)
      throw new RangeError("Byte array longer than desired length.");
    const se = D.padStart(te * 2, "00"), ue = Buffer.allocUnsafeSlow(te);
    return ue.write(se, "hex"), f === "le" && Ze(ue), ue;
  }
  function R(P, f) {
    f == null && (f = "be"), N(Buffer.isBuffer(P), "data", "buffer"), N(f === "be" || f === "le", "endian", "endianness"), f !== l && (P = Ze(Buffer.from(P)));
    const m = P.byteOffset & 7;
    m && (P = Buffer.from(P.buffer, P.byteOffset - m, m + P.byteLength));
    const D = new BigUint64Array(P.buffer, P.byteOffset, P.length >>> 3), ee = P.length & 7, te = P.length - ee;
    let se = 0n;
    if (l === "be") {
      for (let ue = 0; ue < D.length; ue++)
        se <<= 64n, se |= D[ue];
      for (let ue = te; ue < P.length; ue++)
        se <<= 8n, se |= BigInt(P[ue]);
      m && (se &= u((P.length - m) * 8));
    } else {
      for (let ue = P.length - 1; ue >= te; ue--)
        se <<= 8n, se |= BigInt(P[ue]);
      for (let ue = D.length - 1; ue >= 0; ue--)
        se <<= 64n, se |= D[ue];
      m && (se >>= BigInt(m * 8));
    }
    return se;
  }
  function Q(P, f, m, D) {
    m == null && (m = "be"), D == null && (D = 0), N(typeof f == "function", "ArrayType", "function"), N(m === "be" || m === "le", "endian", "endianness"), N(D >>> 0 === D, "length", "uint32");
    const ee = ii(P), te = D || Math.max(1, ee);
    if (ee > te)
      throw new RangeError("Byte array longer than desired length.");
    const se = me(f, te);
    let ue = Le(P);
    if (m === "be") {
      let be = te - 1;
      for (; ue > 0n; )
        se[be--] = Number(ue & 0xffn), ue >>= 8n;
      for (; be >= 0; be--)
        se[be] = 0;
    } else {
      let be = 0;
      for (; ue > 0n; )
        se[be++] = Number(ue & 0xffn), ue >>= 8n;
      for (; be < te; be++)
        se[be] = 0;
    }
    return se;
  }
  function C0(P, f) {
    f == null && (f = "be"), N(P && P.length >>> 0 === P.length, "data", "array-like"), N(f === "be" || f === "le", "endian", "endianness");
    let m = 0n;
    if (f === "be")
      for (let D = 0; D < P.length; D++)
        m <<= 8n, m |= BigInt(P[D] & 255);
    else
      for (let D = P.length - 1; D >= 0; D--)
        m <<= 8n, m |= BigInt(P[D] & 255);
    return m;
  }
  function T0(P, f) {
    if (N(P != null, "rng", "rng"), N(f >>> 0 === f, "bits", "uint32"), typeof P == "object") {
      N(typeof P.randomBytes == "function", "rng", "rng");
      const D = f + 7 >>> 3, ee = D * 8, te = P.randomBytes(D);
      if (N(Buffer.isBuffer(te), "bytes", "buffer"), te.length !== D)
        throw new RangeError("Invalid number of bytes returned from RNG.");
      let se = R(te);
      return ee > f && (se >>= BigInt(ee - f)), se;
    }
    N(typeof P == "function", "rng", "rng");
    const m = P(f);
    if (N(w.isBN(m), "num", "bignum"), G(m.negative === 0, "RNG"), W(!m.red, "RNG"), m.bitLength() > f)
      throw new RangeError("Invalid number of bits returned from RNG.");
    return m.n;
  }
  function D0(P, f, m) {
    if (f > m)
      throw new RangeError("Minimum cannot be greater than maximum.");
    const D = Le(m - f), ee = at(D);
    if (ee === 0)
      return f;
    for (; ; ) {
      let te = T0(P, ee);
      if (!(te >= D))
        return te += f, te;
    }
  }
  return w.Red = V, La = w, La;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
var Ka, C2;
function T2() {
  if (C2)
    return Ka;
  C2 = 1;
  const { custom: r } = Y1(), e = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ], t = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ], i = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ], n = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  }, c = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  }, o = 4, d = 1 << o - 1, l = typeof BigInt == "function";
  class h {
    constructor(s, a, p) {
      this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(s, a, p);
    }
    /*
     * Addition Engine
     */
    _iadd(s, a) {
      let p = 0, v = 0;
      for (s.length < a.length && ([s, a] = [a, s]), s !== this && this._alloc(s.length); v < a.length; v++) {
        const C = (s.words[v] | 0) + (a.words[v] | 0) + p;
        this.words[v] = C & 67108863, p = C >>> 26;
      }
      for (; p !== 0 && v < s.length; v++) {
        const C = (s.words[v] | 0) + p;
        this.words[v] = C & 67108863, p = C >>> 26;
      }
      if (this.length = s.length, p !== 0)
        this._alloc(this.length + 1), this.words[this.length++] = p;
      else if (s !== this)
        for (; v < s.length; v++)
          this.words[v] = s.words[v];
      return this;
    }
    _iaddn(s) {
      if (this.words[0] += s, this.words[0] < 67108864)
        return this;
      let a = 0;
      for (this._alloc(this.length + 1), this.words[this.length] = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, this.words[a + 1] += 1;
      return this.length = Math.max(this.length, a + 1), this;
    }
    /*
     * Addition
     */
    iadd(s) {
      if (T(h.isBN(s), "num", "bignum"), this.negative === s.negative)
        this._iadd(this, s);
      else {
        const a = this.ucmp(s);
        if (a === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        a < 0 ? (this._isub(s, this), this.negative ^= 1) : this._isub(this, s);
      }
      return this;
    }
    iaddn(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      return a && (s = -s), this.negative === a ? this._iaddn(s) : this.length === 1 && this.words[0] < s ? (this.words[0] = s - this.words[0], this.negative ^= 1) : this._isubn(s), this;
    }
    add(s) {
      return T(h.isBN(s), "num", "bignum"), s.length > this.length ? s.clone().iadd(this) : this.clone().iadd(s);
    }
    addn(s) {
      return this.clone().iaddn(s);
    }
    /*
     * Subtraction Engine
     */
    _isub(s, a) {
      let p = 0, v = 0;
      for (V(s.length >= a.length), s !== this && this._alloc(s.length); v < a.length; v++) {
        const C = (s.words[v] | 0) - (a.words[v] | 0) + p;
        p = C >> 26, this.words[v] = C & 67108863;
      }
      for (; p !== 0 && v < s.length; v++) {
        const C = (s.words[v] | 0) + p;
        p = C >> 26, this.words[v] = C & 67108863;
      }
      if (V(p === 0), s !== this)
        for (; v < s.length; v++)
          this.words[v] = s.words[v];
      return this.length = Math.max(this.length, v), this._strip();
    }
    _isubn(s) {
      if (this.words[0] -= s, this.words[0] >= 0)
        return this._normalize();
      V(this.length !== 1), this._alloc(this.length + 1);
      for (let a = 0; a < this.length && this.words[a] < 0; a++)
        this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this.words[this.length] = 0, this._strip();
    }
    /*
     * Subtraction
     */
    isub(s) {
      if (T(h.isBN(s), "num", "bignum"), this.negative !== s.negative)
        this._iadd(this, s);
      else {
        const a = this.ucmp(s);
        if (a === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        a < 0 ? (this._isub(s, this), this.negative ^= 1) : this._isub(this, s);
      }
      return this;
    }
    isubn(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      return a && (s = -s), this.negative !== a ? this._iaddn(s) : this.length === 1 && this.words[0] < s ? (this.words[0] = s - this.words[0], this.negative ^= 1) : this._isubn(s), this;
    }
    sub(s) {
      return this.clone().isub(s);
    }
    subn(s) {
      return this.clone().isubn(s);
    }
    /*
     * Multiplication Engine
     */
    _mul(s, a) {
      if (T(h.isBN(s), "num", "bignum"), T(h.isBN(a), "out", "bignum"), this.length === 10 && s.length === 10)
        return L(this, s, a);
      const p = this.length + s.length;
      return p < 63 ? Se(this, s, a) : p < 1024 ? we(this, s, a) : Z(this, s, a);
    }
    /*
     * Multiplication
     */
    imul(s) {
      return this.mul(s)._move(this);
    }
    imuln(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      a && (s = -s);
      let p = 0;
      for (let v = 0; v < this.length; v++) {
        const C = this.words[v] * s, K = (C & 67108863) + (p & 67108863);
        p >>= 26, p += C / 67108864 | 0, p += K >>> 26, this.words[v] = K & 67108863;
      }
      return this.negative ^= a, p !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = p) : this._strip(), this;
    }
    mul(s) {
      T(h.isBN(s), "num", "bignum");
      const a = this.length + s.length, p = new h();
      p.words = new Array(a);
      for (let v = 0; v < a; v++)
        p.words[v] = 0;
      return this._mul(s, p);
    }
    muln(s) {
      return this.clone().imuln(s);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(s, a) {
      T(h.isBN(s), "num", "bignum"), T(a >>> 0 === a, "bits", "uint32");
      const p = this.mul(s), v = p.utestn(a - 1);
      return p.iushrn(a), this.negative ^ s.negative ? p.isubn(v) : p.iaddn(v);
    }
    /*
     * Division Engine
     */
    _div(s, a) {
      T(h.isBN(s), "num", "bignum"), V((a & c.ALL) === a), V(a !== c.NONE);
      const p = this, v = s;
      if (F(!v.isZero()), p.isZero())
        return [new h(0), new h(0)];
      const C = p.negative, K = v.negative;
      p.negative = 0, v.negative = 0;
      let O = null, $ = null;
      return p.ucmp(v) < 0 ? (a & c.QUO && (O = new h(0)), a & c.REM && ($ = p.clone())) : v.length === 1 ? (a & c.QUO && (O = p.quon(v.words[0])), a & c.REM && ($ = p.remn(v.words[0]))) : [O, $] = p._wordDiv(v, a), p.negative = C, v.negative = K, a & c.QUO && (O.negative = p.negative ^ v.negative, O._normalize()), a & c.REM && ($.negative = p.negative, $._normalize()), a & c.EUCLID && (a & c.QUO && (V((a & c.REM) !== 0), $.negative !== 0 && (v.negative !== 0 ? O.iaddn(1) : O.isubn(1))), a & c.REM && $.negative !== 0 && (v.negative !== 0 ? $.isub(v) : $.iadd(v))), [O, $];
    }
    _wordDiv(s, a) {
      let p = this.clone(), v = s, C = null, K;
      const O = v.words[v.length - 1] | 0, $ = 26 - me(O);
      $ !== 0 ? (v = v.clone(), p.iushln($), v.iushln($), K = v.words[v.length - 1] | 0) : K = O;
      const u = p.length - v.length;
      if (V(u >= 0), a & c.QUO) {
        C = new h(0), C.length = u + 1, C.words = new Array(C.length);
        for (let M = 0; M < C.length; M++)
          C.words[M] = 0;
      }
      const S = p.clone();
      S._ishlnsubmul(v, 1, u), S.negative === 0 && (C && (C.words[u] = 1), p = S);
      for (let M = u - 1; M >= 0; M--) {
        const Y = p.words[v.length + M], J = p.words[v.length + M - 1], X = (Y * 67108864 + J) / K | 0;
        let re = Math.min(X, 67108863);
        for (p._ishlnsubmul(v, re, M); p.negative !== 0; )
          re -= 1, p.negative = 0, p._ishlnsubmul(v, 1, M), p.ineg();
        C && (C.words[M] = re);
      }
      return C && C._strip(), a & c.REM && $ !== 0 && p.iushrn($), [C, p];
    }
    _ishlnsubmul(s, a, p) {
      let v = 0, C = 0;
      for (this._expand(s.length + p); C < s.length; C++) {
        const K = (this.words[C + p] | 0) + v, O = s.words[C] * a, $ = K - (O & 67108863);
        v = ($ >> 26) - (O / 67108864 | 0), this.words[C + p] = $ & 67108863;
      }
      for (; C < this.length - p; C++) {
        const K = (this.words[C + p] | 0) + v;
        v = K >> 26, this.words[C + p] = K & 67108863;
      }
      if (v === 0)
        return this._strip();
      V(v === -1), v = 0;
      for (let K = 0; K < this.length; K++) {
        const O = -(this.words[K] | 0) + v;
        v = O >> 26, this.words[K] = O & 67108863;
      }
      return this.negative = 1, this._strip();
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(s) {
      return this._div(s, c.BOTH);
    }
    /*
     * Truncation Division
     */
    iquo(s) {
      return this.quo(s)._move(this);
    }
    iquon(s) {
      T(ne(s), "num", "smi"), F(s !== 0);
      const a = s < 0 | 0;
      a && (s = -s);
      let p = 0;
      for (let v = this.length - 1; v >= 0; v--) {
        const C = (this.words[v] | 0) + p * 67108864;
        this.words[v] = C / s | 0, p = C % s;
      }
      return this.negative ^= a, this._strip();
    }
    quo(s) {
      return this._div(s, c.QUO)[0];
    }
    quon(s) {
      return this.clone().iquon(s);
    }
    /*
     * Truncation Modulo
     */
    irem(s) {
      return this.rem(s)._move(this);
    }
    iremn(s) {
      let a = this.remrn(s);
      return a < 0 && (a = -a), this.words[0] = a, this.length = 1, this._normalize();
    }
    rem(s) {
      return this._div(s, c.REM)[1];
    }
    remn(s) {
      return this.clone().iremn(s);
    }
    remrn(s) {
      T(ne(s), "num", "smi"), F(s !== 0), s < 0 && (s = -s);
      const a = (1 << 26) % s;
      let p = 0;
      for (let v = this.length - 1; v >= 0; v--)
        p = (a * p + (this.words[v] | 0)) % s;
      return this.negative !== 0 ? -p | 0 : p;
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(s) {
      return this._div(s, c.BOTH | c.EUCLID);
    }
    /*
     * Euclidean Division
     */
    idiv(s) {
      return this.div(s)._move(this);
    }
    idivn(s) {
      if (this.negative === 0)
        return this.iquon(s);
      const a = this.remrn(s);
      return this.iquon(s), a < 0 && (s < 0 ? this.iaddn(1) : this.isubn(1)), this;
    }
    div(s) {
      return this._div(s, c.BOTH | c.EUCLID)[0];
    }
    divn(s) {
      return this.clone().idivn(s);
    }
    /*
     * Euclidean Modulo
     */
    imod(s) {
      return this.ucmp(s) < 0 ? (this.negative !== 0 && (this._isub(s, this), this.negative = 0), this) : this.mod(s)._move(this);
    }
    imodn(s) {
      return this.words[0] = this.modrn(s), this.length = 1, this.negative = 0, this;
    }
    mod(s) {
      return this._div(s, c.REM | c.EUCLID)[1];
    }
    modn(s) {
      return this.clone().imodn(s);
    }
    modrn(s) {
      T(ne(s), "num", "smi");
      let a = this.remrn(s);
      return a < 0 && (s < 0 ? a -= s : a += s), a;
    }
    /*
     * Round Division
     */
    divRound(s) {
      const [a, p] = this.quorem(s);
      if (p.isZero())
        return a;
      const v = s.words[0] & 1;
      s.iushrn(1);
      const C = p.ucmp(s);
      return s.iushln(1), s.words[0] |= v, C < 0 || s.isOdd() && C === 0 ? a : this.negative ^ s.negative ? a.isubn(1) : a.iaddn(1);
    }
    /*
     * Exponentiation
     */
    ipow(s) {
      return this.pow(s)._move(this);
    }
    ipown(s) {
      return this.pown(s)._move(this);
    }
    pow(s) {
      T(h.isBN(s), "num", "bignum");
      let a = me(s.words[s.length - 1]), p = new h(1);
      for (let v = s.length - 1; v >= 0; v--) {
        const C = s.words[v];
        for (let K = a - 1; K >= 0; K--)
          p = p.sqr(), C >> K & 1 && (p = p.mul(this));
        a = 26;
      }
      return p;
    }
    pown(s) {
      if (T(ne(s), "num", "smi"), s < 0 && (s = -s), s === 0)
        return new h(1);
      if (s === 1)
        return this.clone();
      const a = me(s);
      let p = this;
      for (let v = a - 2; v >= 0; v--)
        p = p.sqr(), s >> v & 1 && (p = p.mul(this));
      return p;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    /*
     * Roots Engine
     */
    _rootrem(s, a) {
      if (T(s >>> 0 === s, "num", "uint32"), s === 0)
        throw new RangeError("Zeroth root.");
      if (~s & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new h(0)];
      let p = new h(0), v = h.shift(1, this.bitLength() / s + 1 | 0), C, K;
      if (this.negative !== 0 && v.ineg(), s === 2)
        do
          p = v, v = this.quo(p), v.iadd(p), v.iushrn(1);
        while (v.ucmp(p) < 0);
      else
        do
          p = v, v = p.pown(s - 1), v = this.quo(v), C = p.muln(s - 1), v.iadd(C), v = v.quon(s);
        while (v.ucmp(p) < 0);
      return a && (v = p.pown(s), K = this.sub(v)), [p, K];
    }
    /*
     * Roots
     */
    rootrem(s) {
      return this._rootrem(s, 1);
    }
    iroot(s) {
      return this.root(s)._move(this);
    }
    root(s) {
      return this._rootrem(s, 0)[0];
    }
    isPower(s) {
      if (T(s >>> 0 === s, "num", "uint32"), s === 0 || ~s & this.negative)
        return !1;
      const [, a] = this.rootrem(s);
      return a.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    /*
     * AND
     */
    iand(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      if (a === p)
        return a;
      if (!(a.negative | p.negative))
        return a.iuand(p);
      if ((a.negative & p.negative) === 1)
        return a.iaddn(1), p.iaddn(1), a.iuor(p), a.isubn(1), p.isubn(1), a;
      a.negative !== 0 && ([a, p] = [p.clone(), a]);
      const v = a.bitLength();
      return p.iaddn(1), p.inotn(v), a.iuand(p), p.inotn(v), p.isubn(1), a._move(this);
    }
    iandn(s) {
      return T(ne(s), "num", "smi"), this.negative | s < 0 ? this.iand(new h(s)) : (this.words[0] &= s, this.length = 1, this);
    }
    and(s) {
      return this.clone().iand(s);
    }
    andn(s) {
      return this.clone().iandn(s);
    }
    andrn(s) {
      if (T(ne(s), "num", "smi"), this.negative | s < 0) {
        const a = this.iand(new h(s));
        if (a.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return a.negative !== 0 ? -a.words[0] : a.words[0];
      }
      return this.words[0] & s;
    }
    /*
     * Unsigned AND
     */
    iuand(s) {
      T(h.isBN(s), "num", "bignum"), this.length = Math.min(this.length, s.length);
      for (let a = 0; a < this.length; a++)
        this.words[a] &= s.words[a];
      return this._strip();
    }
    iuandn(s) {
      return T(ne(s), "num", "smi"), this.words[0] &= Math.abs(s), this.length = 1, this._normalize();
    }
    uand(s) {
      return this.clone().iuand(s);
    }
    uandn(s) {
      return this.clone().iuandn(s);
    }
    uandrn(s) {
      T(ne(s), "num", "smi");
      const a = this.words[0] & Math.abs(s);
      return this.negative !== 0 ? -a | 0 : a;
    }
    /*
     * OR
     */
    ior(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      return a === p ? a : a.negative | p.negative ? (a.negative & p.negative) === 1 ? (a.iaddn(1), p.iaddn(1), a.iuand(p), a.isubn(1), p.isubn(1), a) : (p = p.clone(), a.negative !== 0 && ([a, p] = [p, a]), p.iaddn(1), a.inotn(p.bitLength()), p.iuand(a), p.isubn(1), p._move(this)) : a.iuor(p);
    }
    iorn(s) {
      return T(ne(s), "num", "smi"), this.negative | s < 0 ? this.ior(new h(s)) : (this.words[0] |= s, this);
    }
    or(s) {
      return this.clone().ior(s);
    }
    orn(s) {
      return this.clone().iorn(s);
    }
    /*
     * Unsigned OR
     */
    iuor(s) {
      T(h.isBN(s), "num", "bignum"), this._expand(s.length);
      for (let a = 0; a < s.length; a++)
        this.words[a] |= s.words[a];
      return this;
    }
    iuorn(s) {
      return T(ne(s), "num", "smi"), this.words[0] |= Math.abs(s), this;
    }
    uor(s) {
      return this.clone().iuor(s);
    }
    uorn(s) {
      return this.clone().iuorn(s);
    }
    /*
     * XOR
     */
    ixor(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      return a === p ? (a.words[0] = 0, a.length = 1, a.negative = 0, a) : a.negative | p.negative ? (a.negative & p.negative) === 1 ? (a.iaddn(1), p.iaddn(1), a.iuxor(p), a.ineg(), p.isubn(1), a) : (a.negative !== 0 && ([a, p] = [p.clone(), a]), p.iaddn(1), a.iuxor(p), a.iaddn(1), a.ineg(), p.isubn(1), a._move(this)) : a.iuxor(p);
    }
    ixorn(s) {
      return T(ne(s), "num", "smi"), this.negative | s < 0 ? this.ixor(new h(s)) : (this.words[0] ^= s, this);
    }
    xor(s) {
      return this.clone().ixor(s);
    }
    xorn(s) {
      return this.clone().ixorn(s);
    }
    /*
     * Unsigned XOR
     */
    iuxor(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      a.length < p.length && ([a, p] = [p, a]);
      let v = 0;
      for (; v < p.length; v++)
        this.words[v] = a.words[v] ^ p.words[v];
      if (a !== this)
        for (this._alloc(a.length); v < a.length; v++)
          this.words[v] = a.words[v];
      return this.length = a.length, this._strip();
    }
    iuxorn(s) {
      return T(ne(s), "num", "smi"), this.words[0] ^= Math.abs(s), this._normalize();
    }
    uxor(s) {
      return this.clone().iuxor(s);
    }
    uxorn(s) {
      return this.clone().iuxorn(s);
    }
    /*
     * NOT
     */
    inot() {
      return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(s) {
      T(s >>> 0 === s, "width", "uint32");
      const a = s % 26;
      let p = Math.ceil(s / 26), v = 0;
      for (this._expand(p), a > 0 && (p -= 1); v < p; v++)
        this.words[v] ^= 67108863;
      return a > 0 && (this.words[v] ^= (1 << a) - 1), this._strip();
    }
    notn(s) {
      return this.clone().inotn(s);
    }
    /*
     * Left Shift
     */
    ishl(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.ishln(s.toNumber());
    }
    ishln(s) {
      return this.iushln(s);
    }
    shl(s) {
      return this.clone().ishl(s);
    }
    shln(s) {
      return this.clone().ishln(s);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.iushln(s.toNumber());
    }
    iushln(s) {
      T(s >>> 0 === s, "bits", "uint32");
      const a = s % 26, p = (s - a) / 26, v = (1 << a) - 1 << 26 - a;
      if (a !== 0) {
        let C = 0;
        for (let K = 0; K < this.length; K++) {
          const O = this.words[K] & v, $ = (this.words[K] | 0) - O << a;
          this.words[K] = $ | C, C = O >>> 26 - a;
        }
        C !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = C);
      }
      if (p !== 0) {
        this._alloc(this.length + p);
        for (let C = this.length - 1; C >= 0; C--)
          this.words[C + p] = this.words[C];
        for (let C = 0; C < p; C++)
          this.words[C] = 0;
        this.length += p;
      }
      return this._strip();
    }
    ushl(s) {
      return this.clone().iushl(s);
    }
    ushln(s) {
      return this.clone().iushln(s);
    }
    /*
     * Right Shift Engine
     */
    _split(s, a) {
      const p = s % 26, v = Math.min((s - p) / 26, this.length), C = (1 << p) - 1;
      if (a) {
        a._alloc(v);
        for (let O = 0; O < v; O++)
          a.words[O] = this.words[O];
        a.length = v;
      }
      if (v !== 0)
        if (this.length > v) {
          this.length -= v;
          for (let O = 0; O < this.length; O++)
            this.words[O] = this.words[O + v];
        } else
          this.words[0] = 0, this.length = 1;
      let K = 0;
      if (p !== 0)
        for (let O = this.length - 1; O >= 0; O--) {
          const $ = this.words[O] | 0;
          this.words[O] = K << 26 - p | $ >>> p, K = $ & C;
        }
      return a && (K !== 0 ? (a._alloc(a.length + 1), a.words[a.length++] = K) : (a.length === 0 && (a.words[a.length++] = 0), a._strip())), this._strip();
    }
    /*
     * Right Shift
     */
    ishr(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.ishrn(s.toNumber());
    }
    ishrn(s) {
      return T(s >>> 0 === s, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(s), this.isubn(1), this) : this.iushrn(s);
    }
    shr(s) {
      return this.clone().ishr(s);
    }
    shrn(s) {
      return this.clone().ishrn(s);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.iushrn(s.toNumber());
    }
    iushrn(s) {
      return T(s >>> 0 === s, "bits", "uint32"), this._split(s, null);
    }
    ushr(s) {
      return this.clone().iushr(s);
    }
    ushrn(s) {
      return this.clone().iushrn(s);
    }
    /*
     * Bit Manipulation
     */
    setn(s, a) {
      return T(s >>> 0 === s, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(s, !a), this.isubn(1), this) : this.usetn(s, a);
    }
    usetn(s, a) {
      T(s >>> 0 === s, "bit", "uint32");
      const p = s % 26, v = (s - p) / 26;
      return this._expand(v + 1), a ? this.words[v] |= 1 << p : this.words[v] &= ~(1 << p), this._strip();
    }
    testn(s) {
      T(s >>> 0 === s, "bit", "uint32");
      const a = s % 26, p = (s - a) / 26;
      if (this.length <= p)
        return this.negative;
      const v = this.words[p], C = v >> a & 1;
      if (this.negative !== 0) {
        if (a > 0 && v & (1 << a) - 1)
          return C ^ 1;
        let K = p;
        for (; K--; )
          if (this.words[K] > 0)
            return C ^ 1;
      }
      return C;
    }
    utestn(s) {
      T(s >>> 0 === s, "bit", "uint32");
      const a = s % 26, p = (s - a) / 26;
      return this.length <= p ? 0 : this.words[p] >> a & 1;
    }
    imaskn(s) {
      return T(s >>> 0 === s, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(s + 1), this.ineg()), this.iumaskn(s);
    }
    maskn(s) {
      return this.clone().imaskn(s);
    }
    iumaskn(s) {
      T(s >>> 0 === s, "bits", "uint32");
      const a = s % 26;
      let p = (s - a) / 26;
      return this.length <= p ? this : (a !== 0 && (p += 1), this.length = Math.min(p, this.length), a !== 0 && (this.words[this.length - 1] &= (1 << a) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip());
    }
    umaskn(s) {
      return this.clone().iumaskn(s);
    }
    andln(s) {
      return this.words[0] & s;
    }
    bit(s) {
      return this.utestn(s);
    }
    bits(s, a) {
      T(s >>> 0 === s, "pos", "uint32"), T(a >>> 0 === a, "width", "uint32"), T(a <= 26, "width", "width");
      const p = s % 26, v = (s - p) / 26;
      if (v >= this.length)
        return 0;
      let C = this.words[v] >> p & (1 << a) - 1;
      if (p + a > 26 && v + 1 < this.length) {
        const K = p + a - 26, O = this.words[v + 1] & (1 << K) - 1;
        C |= O << 26 - p;
      }
      return C;
    }
    /*
     * Negation
     */
    ineg() {
      return this.isZero() || (this.negative ^= 1), this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.negative = 0, this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(s) {
      if (T(h.isBN(s), "num", "bignum"), this.negative !== s.negative)
        return s.negative - this.negative;
      const a = this.ucmp(s);
      return this.negative !== 0 ? -a | 0 : a;
    }
    cmpn(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      if (this.negative !== a)
        return a - this.negative;
      const p = this.ucmpn(s);
      return this.negative !== 0 ? -p | 0 : p;
    }
    eq(s) {
      return this.cmp(s) === 0;
    }
    eqn(s) {
      return this.cmpn(s) === 0;
    }
    gt(s) {
      return this.cmp(s) > 0;
    }
    gtn(s) {
      return this.cmpn(s) > 0;
    }
    gte(s) {
      return this.cmp(s) >= 0;
    }
    gten(s) {
      return this.cmpn(s) >= 0;
    }
    lt(s) {
      return this.cmp(s) < 0;
    }
    ltn(s) {
      return this.cmpn(s) < 0;
    }
    lte(s) {
      return this.cmp(s) <= 0;
    }
    lten(s) {
      return this.cmpn(s) <= 0;
    }
    sign() {
      return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(s) {
      if (T(h.isBN(s), "num", "bignum"), this.length < s.length)
        return -1;
      if (this.length > s.length)
        return 1;
      for (let a = this.length - 1; a >= 0; a--) {
        const p = this.words[a] | 0, v = s.words[a] | 0;
        if (p !== v)
          return (p > v) - (p < v);
      }
      return 0;
    }
    ucmpn(s) {
      if (T(ne(s), "num", "smi"), this.length > 1)
        return 1;
      const a = this.words[0] | 0;
      return s < 0 && (s = -s), (a > s) - (a < s);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(s) {
      const a = l ? h.red(s) : h.mont(s);
      return this.toRed(a).redLegendre();
    }
    jacobi(s) {
      if (T(h.isBN(s), "num", "bignum"), s.isZero() || s.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let a = this._cloneNormal(), p = s.clone(), v = 1;
      for (p.isNeg() && (a.isNeg() && (v = -1), p.ineg()), (a.isNeg() || a.ucmp(p) >= 0) && a.imod(p); !a.isZero(); ) {
        if (a._makeOdd() & 1) {
          const O = p.andln(7);
          (O === 3 || O === 5) && (v = -v);
        }
        a.ucmp(p) < 0 && ([a, p] = [p, a], a.andln(3) === 3 && p.andln(3) === 3 && (v = -v)), a._isub(a, p).iushrn(1);
        const K = p.andln(7);
        (K === 3 || K === 5) && (v = -v);
      }
      return p.cmpn(1) !== 0 ? 0 : v;
    }
    kronecker(s) {
      if (T(h.isBN(s), "num", "bignum"), this.isZero())
        return s.ucmpn(1) === 0 ? 1 : 0;
      if (s.isZero())
        return this.ucmpn(1) === 0 ? 1 : 0;
      if (!((this.words[0] | s.words[0]) & 1))
        return 0;
      const a = this, p = s.clone(), v = p._makeOdd(), C = [0, 1, 0, -1, 0, -1, 0, 1];
      let K = a.jacobi(p);
      return v & 1 && (K *= C[a.andln(7)]), K | 0;
    }
    igcd(s) {
      return this.gcd(s)._move(this);
    }
    gcd(s) {
      if (T(h.isBN(s), "num", "bignum"), this.isZero())
        return s.abs();
      if (s.isZero())
        return this.abs();
      let a = this.clone(), p = s.clone();
      a.negative = 0, p.negative = 0;
      const v = a._factor2(p);
      for (v !== 0 && (a.iushrn(v), p.iushrn(v)); ; ) {
        a._makeOdd(), p._makeOdd();
        const C = a.ucmp(p);
        if (C < 0)
          [a, p] = [p, a];
        else if (C === 0 || p.ucmpn(1) === 0)
          break;
        a._isub(a, p);
      }
      return p.iushln(v);
    }
    ilcm(s) {
      return this.lcm(s)._move(this);
    }
    lcm(s) {
      return T(h.isBN(s), "num", "bignum"), this.isZero() || s.isZero() ? new h(0) : this.quo(this.gcd(s)).mul(s).iabs();
    }
    egcd(s) {
      if (T(h.isBN(s), "num", "bignum"), this.isZero())
        return [
          new h(0),
          new h(s.sign()),
          s.abs()
        ];
      if (s.isZero())
        return [
          new h(this.sign()),
          new h(0),
          this.abs()
        ];
      const a = this.clone(), p = s.clone();
      a.negative = 0, p.negative = 0;
      const v = new h(1), C = new h(0), K = new h(0), O = new h(1), $ = a._factor2(p);
      $ > 0 && (a.iushrn($), p.iushrn($));
      const u = a.clone(), S = p.clone();
      for (; !a.isZero(); ) {
        let M = a._makeOdd(), Y = p._makeOdd();
        for (; M--; )
          (v.isOdd() || C.isOdd()) && (v.iadd(S), C.isub(u)), v.iushrn(1), C.iushrn(1);
        for (; Y--; )
          (K.isOdd() || O.isOdd()) && (K.iadd(S), O.isub(u)), K.iushrn(1), O.iushrn(1);
        a.cmp(p) >= 0 ? (a.isub(p), v.isub(K), C.isub(O)) : (p.isub(a), K.isub(v), O.isub(C));
      }
      return this.negative !== 0 && K.ineg(), s.negative !== 0 && O.ineg(), [K, O, p.iushln($)];
    }
    iinvert(s) {
      return this.invert(s)._move(this);
    }
    invert(s) {
      if (T(h.isBN(s), "num", "bignum"), ie(s.sign() > 0, "invert"), s.isOdd())
        return this._invertp(s);
      if (s.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [a, , p] = this.egcd(s);
      if (p.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return a.imod(s);
    }
    ifermat(s) {
      return this.fermat(s)._move(this);
    }
    fermat(s) {
      const a = l ? h.red(s) : h.mont(s);
      return this.toRed(a).redFermat().fromRed();
    }
    ipowm(s, a, p) {
      return this.powm(s, a, p)._move(this);
    }
    powm(s, a, p) {
      const v = !l && p ? h.mont(a) : h.red(a);
      return this.toRed(v).redPow(s).fromRed();
    }
    ipowmn(s, a, p) {
      return this.powmn(s, a, p)._move(this);
    }
    powmn(s, a, p) {
      const v = p ? h.mont(a) : h.red(a);
      return this.toRed(v).redPown(s).fromRed();
    }
    isqrtm(s) {
      return this.sqrtm(s)._move(this);
    }
    sqrtm(s) {
      T(h.isBN(s), "p", "bignum");
      let a;
      return s.andln(3) === 3 || s.andln(7) === 5 ? a = h.red(s) : a = h.mont(s), this.toRed(a).redSqrt().fromRed();
    }
    isqrtpq(s, a) {
      return this.sqrtpq(s, a)._move(this);
    }
    sqrtpq(s, a) {
      const p = this.sqrtm(s), v = this.sqrtm(a), [C, K] = s.egcd(a), O = v.mul(C).mul(s), $ = p.mul(K).mul(a), u = s.mul(a);
      return O.iadd($).imod(u);
    }
    /*
     * Primality Testing
     */
    isPrime(s, a, p) {
      return T(a >>> 0 === a, "reps", "uint32"), !(!this.isPrimeMR(s, a + 1, !0) || !this.isPrimeLucas(p));
    }
    isPrimeMR(s, a, p = !1) {
      T(a >>> 0 === a, "reps", "uint32"), T(a > 0, "reps", "integer"), T(typeof p == "boolean", "force2", "boolean");
      const v = this;
      if (v.cmpn(7) < 0)
        return v.cmpn(2) === 0 || v.cmpn(3) === 0 || v.cmpn(5) === 0;
      if (v.isEven())
        return !1;
      const C = v.subn(1), K = C.subn(2), O = C.zeroBits(), $ = C.ushrn(O), u = h.red(v), S = C.toRed(u), M = new h(1).toRed(u);
      e:
        for (let Y = 0; Y < a; Y++) {
          let J;
          Y === a - 1 && p ? J = new h(2) : (J = h.random(s, 0, K), J.iaddn(2));
          let X = J.toRed(u).redPow($);
          if (!(X.cmp(M) === 0 || X.cmp(S) === 0)) {
            for (let re = 1; re < O; re++) {
              if (X = X.redSqr(), X.cmp(S) === 0)
                continue e;
              if (X.cmp(M) === 0)
                return !1;
            }
            return !1;
          }
        }
      return !0;
    }
    isPrimeLucas(s = 0) {
      T(s >>> 0 === s, "limit", "uint32");
      const a = this;
      if (a.cmpn(1) <= 0)
        return !1;
      if (a.isEven())
        return a.cmpn(2) === 0;
      let p = 3;
      for (; ; ) {
        if (p > 1e4)
          throw new Error(`Cannot find (D/n) = -1 for ${a.toString(10)}.`);
        if (s !== 0 && p > s)
          return !1;
        const u = new h(p * p - 4).jacobi(a);
        if (u === -1)
          break;
        if (u === 0)
          return a.cmpn(p + 2) === 0;
        if (p === 40 && a.isSquare())
          return !1;
        p += 1;
      }
      const v = a.addn(1), C = v._makeOdd();
      let K = new h(2), O = new h(p);
      for (let $ = v.bitLength(); $ >= 0; $--)
        v.utestn($) ? (K = K.mul(O).isubn(p).imod(a), O = O.sqr().isubn(2).imod(a)) : (O = O.mul(K).isubn(p).imod(a), K = K.sqr().isubn(2).imod(a));
      if (K.cmpn(2) === 0 || K.cmp(a.subn(2)) === 0) {
        const $ = K.muln(p).imod(a), u = O.ushln(1).imod(a);
        if ($.cmp(u) === 0)
          return !0;
      }
      for (let $ = 0; $ < C - 1; $++) {
        if (K.isZero())
          return !0;
        if (K.cmpn(2) === 0)
          return !1;
        K = K.sqr().isubn(2).imod(a);
      }
      return !1;
    }
    /*
     * Twos Complement
     */
    toTwos(s) {
      return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
    }
    fromTwos(s) {
      return T(s >>> 0 === s, "width", "uint32"), ie(s > 0, "width"), this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
    }
    /*
     * Reduction Context
     */
    toRed(s) {
      if (T(s instanceof z, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return s.convertTo(this);
    }
    fromRed() {
      return N(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(s) {
      if (T(s instanceof z, "ctx", "reduction context"), this.red) {
        if (!s.m.eq(this.red.m) || s.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        ie(this.negative === 0, "red"), ie(this.ucmp(s.m) < 0, "red");
      return this.clone()._forceRed(s);
    }
    redIAdd(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIAdd"), this.red.iadd(this, s);
    }
    redAdd(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redAdd"), this.red.add(this, s);
    }
    redIAddn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIAddn"), this.red.iaddn(this, s);
    }
    redAddn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redAddn"), this.red.addn(this, s);
    }
    redISub(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redISub"), this.red.isub(this, s);
    }
    redSub(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redSub"), this.red.sub(this, s);
    }
    redISubn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redISubn"), this.red.isubn(this, s);
    }
    redSubn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redSubn"), this.red.subn(this, s);
    }
    redIMul(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIMul"), this.red.imul(this, s);
    }
    redMul(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redMul"), this.red.mul(this, s);
    }
    redIMuln(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIMuln"), this.red.imuln(this, s);
    }
    redMuln(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redMuln"), this.red.muln(this, s);
    }
    redIDiv(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIDiv"), this.red.idiv(this, s);
    }
    redDiv(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redDiv"), this.red.div(this, s);
    }
    redIDivn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIDivn"), this.red.idivn(this, s);
    }
    redDivn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redDivn"), this.red.divn(this, s);
    }
    redIPow(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIPow"), G(!s.red, "redIPow"), this.red.ipow(this, s);
    }
    redPow(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redPow"), G(!s.red, "redPow"), this.red.pow(this, s);
    }
    redIPown(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIPown"), this.red.ipown(this, s);
    }
    redPown(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redPown"), this.red.pown(this, s);
    }
    redISqr() {
      return N(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return N(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return N(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return N(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(s) {
      return N(this.red, "redIDivSqrt"), this.red.idivsqrt(this, s);
    }
    redDivSqrt(s) {
      return N(this.red, "redDivSqrt"), this.red.divsqrt(this, s);
    }
    redIsSquare() {
      return N(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIShl"), G(!s.red, "redIShl"), this.red.ishl(this, s);
    }
    redShl(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redShl"), G(!s.red, "redShl"), this.red.shl(this, s);
    }
    redIShln(s) {
      return T(s >>> 0 === s, "num", "uint32"), N(this.red, "redIShln"), this.red.ishln(this, s);
    }
    redShln(s) {
      return T(s >>> 0 === s, "num", "uint32"), N(this.red, "redShln"), this.red.shln(this, s);
    }
    redINeg() {
      return N(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return N(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redEq"), this.red.eq(this, s);
    }
    redEqn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redEqn"), this.red.eqn(this, s);
    }
    redIsHigh() {
      return N(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return N(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return N(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return N(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return N(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return N(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return N(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return N(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return N(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return N(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return N(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _move(s) {
      return s.words = this.words, s.length = this.length, s.negative = this.negative, s.red = this.red, s;
    }
    _alloc(s) {
      for (; this.words.length < s; )
        this.words.push(0);
      return this;
    }
    _expand(s) {
      for (this._alloc(s); this.length < s; )
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      return V(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }
    _check() {
      return V(this.length > 0), V(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && V(this.negative === 0), this) : (V(this.words[this.length - 1] !== 0), this);
    }
    _invertp(s) {
      if (T(h.isBN(s), "p", "bignum"), ie(s.sign() > 0, "invert"), V(s.isOdd()), s.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const a = this.clone(), p = s.clone(), v = new h(1), C = new h(0);
      for ((a.isNeg() || a.ucmp(p) >= 0) && a.imod(p); !a.isZero(); ) {
        let K = a._makeOdd(), O = p._makeOdd();
        for (; K--; )
          v.isOdd() && v._iadd(v, s), v.iushrn(1);
        for (; O--; )
          C.isOdd() && C._iadd(C, s), C.iushrn(1);
        a.ucmp(p) >= 0 ? (a._isub(a, p), v.ucmp(C) < 0 ? (v._isub(C, v), v._isub(s, v)) : v._isub(v, C)) : (p._isub(p, a), C.ucmp(v) < 0 ? (C._isub(v, C), C._isub(s, C)) : C._isub(C, v));
      }
      if (p.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return V(C.negative === 0), V(C.ucmp(s) < 0), C;
    }
    _makeOdd() {
      const s = this.zeroBits();
      return s > 0 && this.iushrn(s), s;
    }
    _factor2(s) {
      if ((this.words[0] | s.words[0]) & 1)
        return 0;
      const a = Math.min(this.length, s.length);
      let p = 0;
      for (let v = 0; v < a; v++) {
        const C = Ne(this.words[v] | s.words[v]);
        if (p += C, C !== 26)
          break;
      }
      return p;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(s) {
      return this.red = s, this;
    }
    /*
     * Helpers
     */
    clone() {
      const s = new h();
      s.words = new Array(this.length);
      for (let a = 0; a < this.length; a++)
        s.words[a] = this.words[a];
      return s.length = this.length, s.negative = this.negative, s.red = this.red, s;
    }
    inject(s) {
      T(h.isBN(s), "num", "bignum"), this._alloc(s.length);
      for (let a = 0; a < s.length; a++)
        this.words[a] = s.words[a];
      return this.length = s.length, this.negative = s.negative, this.red = s.red, this;
    }
    set(s, a) {
      return this.fromNumber(s, a);
    }
    swap(s) {
      T(h.isBN(s), "num", "bignum");
      const a = this, p = s;
      return [a.words, p.words] = [p.words, a.words], [a.length, p.length] = [p.length, a.length], [a.negative, p.negative] = [p.negative, a.negative], [a.red, p.red] = [p.red, a.red], a;
    }
    reverse() {
      const s = this.negative;
      return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = s, this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const s = this.words[this.length - 1], a = me(s);
      return (this.length - 1) * 26 + a;
    }
    zeroBits() {
      if (this.isZero() || this.isOdd())
        return 0;
      let s = 0;
      for (let a = 0; a < this.length; a++) {
        const p = Ne(this.words[a]);
        if (s += p, p !== 26)
          break;
      }
      return s;
    }
    isSafe() {
      return this.length <= 2 || this.length === 3 && this.words[2] === 1;
    }
    word(s) {
      return T(s >>> 0 === s, "pos", "uint32"), s >= this.length ? 0 : this.words[s];
    }
    [r]() {
      let s = "BN";
      return this.red && (s = "BN-R"), `<${s}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      let s = this.words[0];
      if (this.length === 2)
        s += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        s += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        throw new RangeError("Number can only safely store up to 53 bits.");
      return this.negative !== 0 ? -s : s;
    }
    toDouble() {
      let s = 0;
      for (let a = this.length - 1; a >= 0; a--)
        s = s * 67108864 + this.words[a];
      return this.negative !== 0 ? -s : s;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!l)
        throw new Error("BigInt is not supported!");
      const s = BigInt(52), a = BigInt(26);
      let p = this.length - 1, v = BigInt(0);
      for (; p >= 1; p -= 2) {
        const C = this.words[p] * 67108864, K = this.words[p - 1];
        v = v << s | BigInt(C + K);
      }
      return p >= 0 && (v = v << a | BigInt(this.words[0])), this.negative !== 0 ? -v : v;
    }
    toBool() {
      return !this.isZero();
    }
    toString(s, a) {
      if (s = he(s), a == null && (a = 0), a === 0 && (a = 1), T(s >>> 0 === s, "base", "uint32"), T(a >>> 0 === a, "padding", "uint32"), s < 2 || s > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      if (this._check(), s === 16) {
        let O = "", $ = 0, u = 0;
        for (let S = 0; S < this.length; S++) {
          const M = this.words[S], Y = ((M << $ | u) & 16777215).toString(16);
          u = M >>> 24 - $ & 16777215, u !== 0 || S !== this.length - 1 ? O = e[6 - Y.length] + Y + O : O = Y + O, $ += 2, $ >= 26 && ($ -= 26, S -= 1);
        }
        for (u !== 0 && (O = u.toString(16) + O); O.length % a !== 0; )
          O = "0" + O;
        return this.negative !== 0 && (O = "-" + O), O;
      }
      const p = t[s - 1], v = i[s - 1], C = this.clone();
      let K = "";
      for (C.negative = 0; !C.isZero(); ) {
        const O = C.remrn(v).toString(s);
        C.iquon(v), C.isZero() ? K = O + K : K = e[p - O.length] + O + K;
      }
      for (this.isZero() && (K = "0"); K.length % a !== 0; )
        K = "0" + K;
      return this.negative !== 0 && (K = "-" + K), K;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(s, a) {
      return this.toArrayLike(Array, s, a);
    }
    toBuffer(s, a) {
      return this.toArrayLike(Buffer, s, a);
    }
    toArrayLike(s, a, p) {
      a == null && (a = "be"), p == null && (p = 0), T(typeof s == "function", "ArrayType", "function"), T(a === "be" || a === "le", "endian", "endianness"), T(p >>> 0 === p, "length", "uint32"), this._check();
      const v = this.byteLength(), C = p || Math.max(1, v);
      if (v > C)
        throw new RangeError("Byte array longer than desired length.");
      const K = xe(s, C);
      if (a === "be") {
        let O = K.length - 1, $ = 0;
        for (let u = 0; u < this.length; u++) {
          const S = (u & 3) << 1, M = this.words[u] << S | $;
          K[O--] = M & 255, O >= 0 && (K[O--] = M >>> 8 & 255), O >= 0 && (K[O--] = M >>> 16 & 255), S === 6 ? (O >= 0 && (K[O--] = M >>> 24 & 255), $ = 0) : $ = M >>> 24;
        }
        if (O >= 0) {
          for (K[O--] = $; O >= 0; )
            K[O--] = 0;
          $ = 0;
        }
        V($ === 0);
      } else {
        let O = 0, $ = 0;
        for (let u = 0; u < this.length; u++) {
          const S = (u & 3) << 1, M = this.words[u] << S | $;
          K[O++] = M & 255, O < K.length && (K[O++] = M >>> 8 & 255), O < K.length && (K[O++] = M >>> 16 & 255), S === 6 ? (O < K.length && (K[O++] = M >>> 24 & 255), $ = 0) : $ = M >>> 24;
        }
        if (O < K.length) {
          for (K[O++] = $; O < K.length; )
            K[O++] = 0;
          $ = 0;
        }
        V($ === 0);
      }
      return K;
    }
    encode(s, a) {
      return this.toBuffer(s, a);
    }
    /*
     * Instantiation
     */
    of(s, a) {
      return this.fromNumber(s, a);
    }
    fromNumber(s, a) {
      a == null && (a = "be"), T(ce(s), "num", "integer"), T(a === "be" || a === "le", "endian", "endianness");
      const p = s < 0 | 0;
      return p && (s = -s), s < 67108864 ? (this.words[0] = s & 67108863, this.length = 1) : s < 4503599627370496 ? (this.words = [
        s & 67108863,
        s / 67108864 & 67108863
      ], this.length = 2) : (this.words = [
        s & 67108863,
        s / 67108864 & 67108863,
        1
      ], this.length = 3), this.negative = p, a === "le" && this.reverse(), this;
    }
    fromDouble(s, a) {
      a == null && (a = "be"), T(typeof s == "number", "num", "double"), T(a === "be" || a === "le", "endian", "endianness"), isFinite(s) || (s = 0);
      const p = s <= -1 | 0;
      for (s < 0 && (s = -s), s = Math.floor(s), this.words = []; s > 0; ) {
        const v = s % 67108864, C = (s - v) / 67108864;
        this.words.push(v), s = C;
      }
      return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = p, a === "le" && this.reverse(), this;
    }
    fromBigInt(s, a) {
      if (a == null && (a = "be"), T(typeof s == "bigint", "num", "bigint"), T(a === "be" || a === "le", "endian", "endianness"), !l)
        throw new Error("BigInt is not supported!");
      const p = s < BigInt(0) | 0;
      return this._fromHex(s.toString(16), p), this.negative = p, a === "le" && this.reverse(), this;
    }
    fromBool(s) {
      return T(typeof s == "boolean", "value", "boolean"), this.words[0] = s | 0, this.length = 1, this.negative = 0, this;
    }
    fromString(s, a, p) {
      if ((a === "le" || a === "be") && ([a, p] = [p, a]), a = he(a), p == null && (p = "be"), T(typeof s == "string", "string", "string"), T(a >>> 0 === a, "base", "uint32"), T(p === "be" || p === "le", "endian", "endianness"), a < 2 || a > 36)
        throw new Error("Base ranges between 2 and 36.");
      s = s.replace(/\s+/g, "");
      let v = 0;
      return s.length > 0 && s.charCodeAt(0) === 45 && (v = 1), a === 16 ? this._fromHex(s, v) : this._fromBase(s, a, v), this.negative = v, this._normalize(), p === "le" && this.reverse(), this;
    }
    _fromHex(s, a) {
      this.length = Math.max(2, Math.ceil((s.length - a) / 6)), this.words = new Array(this.length);
      for (let K = 0; K < this.length; K++)
        this.words[K] = 0;
      let p = 0, v = s.length - 6, C = 0;
      for (; v >= a; v -= 6) {
        const K = Je(s, v, v + 6);
        this.words[C] |= K << p & 67108863, this.words[C + 1] |= K >>> 26 - p & 4194303, p += 24, p >= 26 && (p -= 26, C += 1);
      }
      if (v + 6 !== a) {
        const K = Je(s, a, v + 6);
        this.words[C] |= K << p & 67108863, this.words[C + 1] |= K >>> 26 - p & 4194303;
      }
      return this._strip();
    }
    _fromBase(s, a, p) {
      this.words[0] = 0, this.length = 1, this.negative = 0;
      let v = 0, C = 1;
      for (; C <= 67108863; C *= a)
        v += 1;
      v -= 1, C = C / a | 0;
      const K = s.length - p, O = K % v, $ = Math.min(K, K - O) + p;
      let u = p;
      for (; u < $; u += v) {
        const S = Ze(s, u, u + v, a);
        this.imuln(C), this._iaddn(S);
      }
      if (O !== 0) {
        const S = Math.pow(a, O), M = Ze(s, u, s.length, a);
        this.imuln(S), this._iaddn(M);
      }
      return this;
    }
    fromJSON(s) {
      if (h.isBN(s))
        return s.red ? s.fromRed() : s.clone();
      if (Array.isArray(s)) {
        for (const a of s)
          T(typeof a == "string", "chunk", "string");
        s = s.join("");
      }
      return this.fromString(s, 16);
    }
    fromBN(s) {
      return this.inject(s);
    }
    fromArray(s, a) {
      return T(Array.isArray(s), "data", "array"), this.fromArrayLike(s, a);
    }
    fromBuffer(s, a) {
      return T(Buffer.isBuffer(s), "data", "buffer"), this.fromArrayLike(s, a);
    }
    fromArrayLike(s, a) {
      if (a == null && (a = "be"), T(s && s.length >>> 0 === s.length, "data", "array-like"), T(a === "be" || a === "le", "endian", "endianness"), s.length === 0)
        return this.words[0] = 0, this.length = 1, this.negative = 0, this;
      this.length = Math.max(2, Math.ceil(s.length / 3)), this.words = new Array(this.length), this.negative = 0;
      for (let O = 0; O < this.length; O++)
        this.words[O] = 0;
      const p = s.length % 3;
      let v = 0, C = 0, K = 0;
      if (a === "be") {
        for (let O = s.length - 1; O >= 2; O -= 3) {
          const $ = s[O] | s[O - 1] << 8 | s[O - 2] << 16;
          this.words[C] |= $ << v & 67108863, this.words[C + 1] = $ >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, C += 1);
        }
        switch (p) {
          case 2:
            K = s[1] | s[0] << 8;
            break;
          case 1:
            K = s[0];
            break;
        }
      } else {
        const O = s.length - p;
        for (let $ = 0; $ < O; $ += 3) {
          const u = s[$] | s[$ + 1] << 8 | s[$ + 2] << 16;
          this.words[C] |= u << v & 67108863, this.words[C + 1] = u >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, C += 1);
        }
        switch (p) {
          case 2:
            K = s[O] | s[O + 1] << 8;
            break;
          case 1:
            K = s[O];
            break;
        }
      }
      return p > 0 && (this.words[C] |= K << v & 67108863, this.words[C + 1] = K >>> 26 - v & 67108863), this._strip();
    }
    decode(s, a) {
      return this.fromBuffer(s, a);
    }
    from(s, a, p) {
      if (s == null)
        return this;
      if ((a === "le" || a === "be") && ([a, p] = [p, a]), typeof s == "number")
        return this.fromNumber(s, p);
      if (typeof s == "bigint")
        return this.fromBigInt(s, p);
      if (typeof s == "string")
        return this.fromString(s, a, p);
      if (typeof s == "object") {
        if (h.isBN(s))
          return this.fromBN(s, p);
        if (s.length >>> 0 === s.length)
          return this.fromArrayLike(s, p);
      }
      if (typeof s == "boolean")
        return this.fromBool(s);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...s) {
      let a = null;
      for (const p of s)
        T(h.isBN(p), "num", "bignum"), (!a || p.cmp(a) < 0) && (a = p);
      return a || new h(0);
    }
    static max(...s) {
      let a = null;
      for (const p of s)
        T(h.isBN(p), "num", "bignum"), (!a || p.cmp(a) > 0) && (a = p);
      return a || new h(0);
    }
    static cmp(s, a) {
      return T(h.isBN(s), "a", "bignum"), s.cmp(a);
    }
    static ucmp(s, a) {
      return T(h.isBN(s), "a", "bignum"), s.ucmp(a);
    }
    static red(s) {
      return new z(s);
    }
    static barrett(s) {
      return new E(s);
    }
    static mont(s) {
      return new H(s);
    }
    static _prime(s) {
      if (n[s])
        return n[s];
      let a;
      if (s === "p192")
        a = new I();
      else if (s === "p224")
        a = new B();
      else if (s === "p521")
        a = new y();
      else if (s === "k256")
        a = new A();
      else if (s === "p251")
        a = new _();
      else if (s === "p25519")
        a = new q();
      else if (s === "p448")
        a = new U();
      else
        throw new Error(`Unknown prime: "${s}".`);
      return n[s] = a, a;
    }
    static prime(s) {
      return h._prime(s).p.clone();
    }
    static pow(s, a) {
      return s === 2 ? h.shift(1, a) : new h().fromNumber(s).pown(a);
    }
    static shift(s, a) {
      return s === 1 ? new h(0).usetn(a, 1) : new h().fromNumber(s).ishln(a);
    }
    static mask(s) {
      return h.shift(1, s).isubn(1);
    }
    static randomBits(s, a) {
      if (T(s != null, "rng", "rng"), T(a >>> 0 === a, "bits", "uint32"), typeof s == "object") {
        T(typeof s.randomBytes == "function", "rng", "rng");
        const v = a + 7 >>> 3, C = v * 8, K = s.randomBytes(v);
        if (T(Buffer.isBuffer(K), "bytes", "buffer"), K.length !== v)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const O = h.fromBuffer(K);
        return C > a && O.iushrn(C - a), O;
      }
      T(typeof s == "function", "rng", "rng");
      const p = s(a);
      if (T(h.isBN(p), "num", "bignum"), ie(p.negative === 0, "RNG"), G(!p.red, "RNG"), p.bitLength() > a)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return p;
    }
    static random(s, a, p) {
      if (a = h.cast(a, 16), p = h.cast(p, 16), a.cmp(p) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const v = p.sub(a).iabs(), C = v.bitLength();
      if (C === 0)
        return a.clone();
      for (; ; ) {
        const K = h.randomBits(s, C);
        if (!(K.cmp(v) >= 0))
          return K.iadd(a), K;
      }
    }
    static of(s, a) {
      return new h().of(s, a);
    }
    static fromNumber(s, a) {
      return new h().fromNumber(s, a);
    }
    static fromDouble(s, a) {
      return new h().fromDouble(s, a);
    }
    static fromBigInt(s, a) {
      return new h().fromBigInt(s, a);
    }
    static fromBool(s) {
      return new h().fromBool(s);
    }
    static fromString(s, a, p) {
      return new h().fromString(s, a, p);
    }
    static fromJSON(s) {
      return new h().fromJSON(s);
    }
    static fromBN(s) {
      return new h().fromBN(s);
    }
    static fromArray(s, a) {
      return new h().fromArray(s, a);
    }
    static fromBuffer(s, a) {
      return new h().fromBuffer(s, a);
    }
    static fromArrayLike(s, a) {
      return new h().fromArrayLike(s, a);
    }
    static decode(s, a) {
      return new h().decode(s, a);
    }
    static from(s, a, p) {
      return new h().from(s, a, p);
    }
    static cast(s, a, p) {
      return h.isBN(s) ? s : new h(s, a, p);
    }
    static isBN(s) {
      return s instanceof h;
    }
  }
  h.BN = h, h.wordSize = 26, h.native = 0;
  class x {
    constructor(s, a) {
      this.name = s, this.p = new h(a, 16), this.n = this.p.bitLength(), this.k = h.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone();
    }
    ireduce(s) {
      const a = s.negative !== 0;
      let p = s.bitLength();
      for (V(p <= this.n * 2), s.negative = 0; p > this.n; )
        this.split(s, this.lo), this.imulK(s), s._iadd(s, this.lo), p = s.bitLength();
      const v = p < this.n ? -1 : s.ucmp(this.p);
      return v === 0 ? (s.words[0] = 0, s.length = 1) : v > 0 && s._isub(s, this.p), a && !s.isZero() && s._isub(this.p, s), s;
    }
    split(s, a) {
      s._split(this.n, a);
    }
    imulK(s) {
      return s.imul(this.k);
    }
    pm2(s) {
      throw new Error("Not implemented.");
    }
    fermat(s) {
      return this.pm2(s);
    }
  }
  class b extends x {
    constructor(s, a) {
      super(s, a);
    }
    pm3d4(s) {
      throw new Error("Not implemented.");
    }
    pp1d4(s) {
      throw new Error("Not implemented.");
    }
    sqrt(s) {
      const { red: a } = s, p = this.pp1d4(s);
      if (!a.sqr(p).eq(s))
        throw new W(p);
      return p;
    }
    divsqrt(s, a) {
      const { red: p } = s, v = p.sqr(s), C = p.mul(v, s), K = p.mul(C, v), O = p.mul(p.sqr(a), a), $ = this.pm3d4(p.mul(K, O)), u = p.mul(p.mul(C, a), $);
      if (p.mul(a, p.sqr(u)).eq(s))
        return u;
      throw new W(u);
    }
  }
  class g extends x {
    constructor(s, a, p) {
      super(s, a), this.sm1 = new h(p, 16);
    }
    pm5d8(s) {
      throw new Error("Not implemented.");
    }
    pp3d8(s) {
      throw new Error("Not implemented.");
    }
    sqrt(s) {
      const { red: a } = s, p = this.sm1._forceRed(a), v = this.pp3d8(s);
      if (a.sqr(v).eq(s))
        return v;
      const C = a.mul(v, p);
      if (a.sqr(C).eq(s))
        return C;
      throw new W(v);
    }
    divsqrt(s, a) {
      const { red: p } = s, v = this.sm1._forceRed(p), C = p.mul(p.sqr(a), a), K = p.mul(p.sqr(C), a), O = this.pm5d8(p.mul(s, K)), $ = p.mul(p.mul(s, C), O), u = p.mul(a, p.sqr($));
      if (u.eq(s))
        return $;
      const S = p.ineg(u);
      if (S.eq(s))
        return p.mul($, v);
      throw S.eq(p.mul(s, v)) ? new W(p.mul($, v)) : new W($);
    }
  }
  class w extends x {
    constructor(s, a, p) {
      super(s, a), this.g = new h(p, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(s) {
      throw new Error("Not implemented.");
    }
    powE(s) {
      throw new Error("Not implemented.");
    }
    sqrt(s) {
      const { red: a } = s;
      switch (a.jacobi(s)) {
        case -1:
          throw new W(s);
        case 0:
          return s.clone();
      }
      let p = this.g._forceRed(a), v = this.powE(s), C = this.powS(s), K = this.z;
      for (; ; ) {
        let O = C, $ = 0;
        for (; O.cmpn(1) !== 0 && $ < K; )
          O = a.sqr(O), $ += 1;
        if ($ === 0)
          break;
        V($ < K), O = a.sqrn(p, K - $ - 1), p = a.sqr(O), v = a.mul(v, O), C = a.mul(C, p), K = $;
      }
      return v;
    }
    divsqrt(s, a) {
      const { red: p } = s;
      if (a.isZero())
        throw new W(a);
      return this.sqrt(p.div(s, a));
    }
  }
  class I extends b {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(s) {
      const a = this.one.inject(s);
      return s.iushln(64)._iadd(s, a);
    }
    core(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 6, C), O = a.sqrnmul(K, 12, K), $ = a.sqrnmul(O, 6, C), u = a.sqrnmul($, 1, s), S = a.sqrnmul(u, 31, u), M = a.sqrnmul(S, 62, S), Y = a.sqrnmul(M, 3, v), J = a.sqrn(Y, 1);
      return a.sqrnmul(J, 62, S);
    }
    pm3d4(s) {
      return this.core(s);
    }
    pm2(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 2, p), C = a.sqrnmul(v, 4, v), K = a.sqrnmul(C, 8, C), O = a.sqrnmul(K, 16, K), $ = a.sqrnmul(O, 32, O), u = a.sqrnmul($, 64, $);
      return a.sqrn(u, 62);
    }
  }
  class B extends w {
    constructor() {
      super("p224", "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001", "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74");
    }
    imulK(s) {
      const a = this.one.inject(s);
      return s.iushln(96)._isub(s, a);
    }
    powS(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 2, p), C = a.sqrnmul(v, 4, v), K = a.sqrnmul(C, 8, C), O = a.sqrnmul(K, 16, K), $ = a.sqrnmul(O, 32, O);
      return a.sqrnmul($, 64, $);
    }
    powE(s) {
      const { red: a } = s;
      return a.sqrn(s, 127);
    }
    pm2(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 6, C), O = a.sqrnmul(K, 12, K), $ = a.sqrnmul(O, 24, O), u = a.sqrnmul($, 48, $), S = a.sqrnmul(u, 24, O), M = a.sqrnmul(S, 6, C), Y = a.sqrnmul(M, 1, s), J = a.sqrn(Y, 1);
      return a.sqrnmul(J, 96, u);
    }
  }
  class y extends b {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(s) {
      return s;
    }
    core(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 1, s), O = a.sqrnmul(K, 1, s), $ = a.sqrnmul(O, 8, O), u = a.sqrnmul($, 16, $), S = a.sqrnmul(u, 32, u), M = a.sqrnmul(S, 64, S), Y = a.sqrnmul(M, 128, M), J = a.sqrnmul(Y, 256, Y);
      return a.sqrnmul(J, 7, K);
    }
    pm3d4(s) {
      return this.core(s);
    }
    pm2(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s;
      return a.sqrn(s, 519);
    }
  }
  class A extends b {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(s, a) {
      const v = Math.min(s.length, 9);
      a._alloc(v + 1);
      for (let O = 0; O < v; O++)
        a.words[O] = s.words[O];
      if (a.length = v, s.length <= 9) {
        a._strip(), s.words[0] = 0, s.length = 1;
        return;
      }
      let C = s.words[9], K = 10;
      for (a.words[a.length++] = C & 4194303, a._strip(); K < s.length; K++) {
        const O = s.words[K] | 0;
        s.words[K - 10] = (O & 4194303) << 4 | C >>> 22, C = O;
      }
      C >>>= 22, s.words[K - 10] = C, C === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9, s._strip();
    }
    imulK(s) {
      s._expand(s.length + 2);
      let a = 0;
      for (let p = 0; p < s.length; p++) {
        const v = s.words[p];
        a += v * 977, s.words[p] = a & 67108863, a = v * 64 + Math.floor(a / 67108864);
      }
      return s.words[s.length - 1] === 0 && (s.length -= 1, s.words[s.length - 1] === 0 && (s.length -= 1)), s;
    }
    core(s, a) {
      const { red: p } = s, v = p.sqrnmul(a, 1, s), C = p.sqrnmul(v, 3, v), K = p.sqrnmul(C, 3, v), O = p.sqrnmul(K, 2, a), $ = p.sqrnmul(O, 11, O), u = p.sqrnmul($, 22, $), S = p.sqrnmul(u, 44, u), M = p.sqrnmul(S, 88, S), Y = p.sqrnmul(M, 44, u), J = p.sqrnmul(Y, 3, v), X = p.sqrn(J, 1), re = p.sqrnmul(X, 22, $);
      return p.sqrn(re, 4);
    }
    pm3d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1);
      return a.sqrnmul(K, 2, p);
    }
    pm2(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1), O = a.sqrnmul(K, 2, p), $ = a.sqrn(O, 1);
      return a.sqrnmul($, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 2, p);
      return a.sqrn(C, 2);
    }
  }
  class _ extends b {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(s) {
      if (s.isZero())
        return s;
      let a = 0;
      for (let p = 0; p < s.length; p++) {
        const v = s.words[p] * 9 + a;
        a = v >>> 26, s.words[p] = v & 67108863;
      }
      return a !== 0 && (s._alloc(s.length + 1), s.words[s.length++] = a), s;
    }
    core(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 6, C), O = a.sqrnmul(K, 12, K), $ = a.sqrnmul(O, 24, O), u = a.sqrnmul($, 48, $), S = a.sqrnmul(u, 96, u), M = a.sqrnmul(S, 48, $), Y = a.sqrnmul(M, 6, C);
      return a.sqrnmul(Y, 1, s);
    }
    pm3d4(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pm2(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1);
      return a.sqrnmul(K, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrnmul(p, 1, s);
      return a.sqrn(v, 1);
    }
  }
  class q extends g {
    constructor() {
      super("p25519", "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed", "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0");
    }
    imulK(s) {
      let a = 0;
      for (let p = 0; p < s.length; p++) {
        const v = s.words[p] * 19 + a;
        a = v >>> 26, s.words[p] = v & 67108863;
      }
      return a !== 0 && (s._alloc(s.length + 1), s.words[s.length++] = a), s;
    }
    core(s, a) {
      const { red: p } = s, v = p.sqrnmul(a, 2, a), C = p.sqrnmul(v, 1, s), K = p.sqrnmul(C, 5, C), O = p.sqrnmul(K, 10, K), $ = p.sqrnmul(O, 20, O), u = p.sqrnmul($, 10, K), S = p.sqrnmul(u, 50, u), M = p.sqrnmul(S, 100, S);
      return p.sqrnmul(M, 50, u);
    }
    pm5d8(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrn(v, 1);
      return a.sqrnmul(C, 1, s);
    }
    pm2(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrn(v, 1), K = a.sqrnmul(C, 1, s), O = a.sqrn(K, 1);
      return a.sqrnmul(O, 2, p);
    }
    pp3d8(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s);
      return a.sqrn(C, 1);
    }
  }
  class U extends b {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(s) {
      const a = this.one.inject(s);
      return s.iushln(224)._iadd(s, a);
    }
    core(s, a) {
      const { red: p } = s, v = p.sqrnmul(a, 1, s), C = p.sqrnmul(v, 3, v), K = p.sqrnmul(C, 3, v), O = p.sqrnmul(K, 2, a), $ = p.sqrnmul(O, 11, O), u = p.sqrnmul($, 22, $), S = p.sqrnmul(u, 44, u), M = p.sqrnmul(S, 88, S), Y = p.sqrnmul(M, 44, u);
      return p.sqrnmul(Y, 2, a);
    }
    pm3d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1);
      return a.sqrnmul(K, 222, v);
    }
    pm2(s) {
      const { red: a } = s, p = this.pm3d4(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 2, p);
      return a.sqrn(C, 222);
    }
  }
  class z {
    constructor(s) {
      let a = null;
      typeof s == "string" && (a = h._prime(s), s = a.p), T(h.isBN(s), "m", "bignum"), G(!s.red, "reduction"), ie(s.sign() > 0, "reduction"), this.m = s, this.prime = a, this.mb = null, this.sm1 = null;
    }
    _verify1(s) {
      ie(s.negative === 0, "red"), N(s.red != null, "red");
    }
    _verify2(s, a) {
      ie((s.negative | a.negative) === 0, "red"), N(s.red != null && s.red === a.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5)
        if (this.prime)
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        else {
          const s = new h(2).toRed(this), a = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(s, a);
        }
      return this;
    }
    convertTo(s) {
      const a = s.mod(this.m);
      return a.red = this, a;
    }
    convertFrom(s) {
      const a = s.clone();
      return a.red = null, a;
    }
    intTo(s) {
      return s;
    }
    intFrom(s) {
      return s;
    }
    imod(s) {
      return this.prime ? this.prime.ireduce(s)._forceRed(this) : s.imod(this.m)._forceRed(this);
    }
    iadd(s, a) {
      return this._verify2(s, a), s._iadd(s, a), s.ucmp(this.m) >= 0 && s._isub(s, this.m), s;
    }
    add(s, a) {
      return s.length < a.length ? this.iadd(a.clone(), s) : this.iadd(s.clone(), a);
    }
    iaddn(s, a) {
      return this._verify1(s), a < 0 ? this.isubn(s, -a) : (this.m.length === 1 && (a %= this.m.words[0]), s._iaddn(a), s.ucmp(this.m) >= 0 && s._isub(s, this.m), s);
    }
    addn(s, a) {
      return this.iaddn(s.clone(), a);
    }
    isub(s, a) {
      this._verify2(s, a);
      const p = s.ucmp(a);
      return p === 0 ? (s.words[0] = 0, s.length = 1, s) : (p < 0 ? (s._isub(a, s), s._isub(this.m, s)) : s._isub(s, a), s);
    }
    sub(s, a) {
      return this.isub(s.clone(), a);
    }
    isubn(s, a) {
      return this._verify1(s), a < 0 ? this.iaddn(s, -a) : (this.m.length === 1 && (a %= this.m.words[0]), s.length === 1 && s.words[0] < a ? (s.words[0] = a - s.words[0], s._isub(this.m, s)) : s._isubn(a), s);
    }
    subn(s, a) {
      return this.isubn(s.clone(), a);
    }
    imul(s, a) {
      return this._verify2(s, a), this.imod(s.imul(a));
    }
    mul(s, a) {
      return this._verify2(s, a), this.imod(s.mul(a));
    }
    imuln(s, a) {
      if (this._verify1(s), s.isZero())
        return s;
      if (a === 0)
        return s.words[0] = 0, s.length = 1, s;
      const p = a < 0;
      if (p && (a = -a), this.m.length === 1 && (a %= this.m.words[0]), s.imuln(a), a <= 16)
        for (; s.ucmp(this.m) >= 0; )
          s._isub(s, this.m);
      else
        this.imod(s);
      return p && this.ineg(s), s;
    }
    muln(s, a) {
      return this.imuln(s.clone(), a);
    }
    idiv(s, a) {
      return this.div(s, a)._move(s);
    }
    div(s, a) {
      return this.mul(s, this.invert(a));
    }
    idivn(s, a) {
      return this.divn(s, a)._move(s);
    }
    divn(s, a) {
      return this.div(s, this.convertTo(new h(a)));
    }
    ipow(s, a) {
      return this.pow(s, a)._move(s);
    }
    pow(s, a) {
      return this._verify1(s), a.isNeg() && (s = this.invert(s)), a.length === 1 ? this.pown(s, a.words[0]) : l && !this.prime ? this.powInt(s, a) : this.powNum(s, a);
    }
    powNum(s, a) {
      const p = new h(1).toRed(this), v = new Array(d), C = this.sqr(s);
      v[0] = s;
      for (let $ = 1; $ < d; $++)
        v[$] = this.mul(v[$ - 1], C);
      let K = a.bitLength(), O = p;
      for (; K >= o; ) {
        let $ = o, u = a.bits(K - $, $);
        if (u < d) {
          O = this.sqr(O), K -= 1;
          continue;
        }
        for (; !(u & 1); )
          $ -= 1, u >>= 1;
        O === p ? O = v[u >> 1].clone() : (O = this.sqrn(O, $), O = this.mul(O, v[u >> 1])), K -= $;
      }
      if (K > 0) {
        const $ = a.bits(0, K);
        for (; K--; )
          O = this.sqr(O), $ >> K & 1 && (O = this.mul(O, s));
      }
      return O;
    }
    powInt(s, a) {
      this.mb === null && (this.mb = this.m.toBigInt());
      const p = this.intFrom(s.toBigInt()), v = ht(p, a, this.mb), C = this.intTo(v);
      return h.fromBigInt(C)._forceRed(this);
    }
    sqrn(s, a) {
      for (; a--; )
        s = this.sqr(s);
      return s;
    }
    sqrnmul(s, a, p) {
      return this.mul(this.sqrn(s, a), p);
    }
    ipown(s, a) {
      return this.pown(s, a)._move(s);
    }
    pown(s, a) {
      if (this._verify1(s), a < 0 && (s = this.invert(s), a = -a), a === 0)
        return new h(1).toRed(this);
      if (a === 1)
        return s.clone();
      const p = me(a);
      let v = s;
      for (let C = p - 2; C >= 0; C--)
        v = this.sqr(v), a >> C & 1 && (v = this.mul(v, s));
      return v;
    }
    isqr(s) {
      return this.imul(s, s);
    }
    sqr(s) {
      return this.mul(s, s);
    }
    isqrt(s) {
      return this.sqrt(s)._move(s);
    }
    sqrt(s) {
      return this._verify1(s), this.prime ? this.prime.sqrt(s) : this.m.andln(3) === 3 ? this.sqrt3mod4(s) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(s) : this.sqrt5mod8(s) : this.sqrt0(s);
    }
    sqrt3mod4(s) {
      const a = this.m.addn(1).iushrn(2), p = this.pow(s, a);
      if (!this.sqr(p).eq(s))
        throw new W(p);
      return p;
    }
    sqrt5mod8(s) {
      const a = new h(1).toRed(this), p = this.m.ushrn(3), v = this.add(s, s), C = this.pow(v, p), K = this.mul(v, this.sqr(C)), O = this.mul(this.mul(C, s), this.isub(K, a));
      if (!this.sqr(O).eq(s))
        throw new W(O);
      return O;
    }
    sqrt5mod8sm1(s) {
      const a = this.m.addn(3).iushrn(3), p = this.pow(s, a);
      if (this.sqr(p).eq(s))
        return p;
      const v = this.mul(p, this.sm1);
      if (this.sqr(v).eq(s))
        return v;
      throw new W(p);
    }
    sqrt0(s) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(s)) {
        case -1:
          throw new W(s);
        case 0:
          return s.clone();
      }
      const a = new h(1).toRed(this), p = this.m.subn(1), v = p._makeOdd(), C = new h(2).toRed(this);
      for (; this.jacobi(C) !== -1; )
        this.iadd(C, a);
      let K = this.pow(C, p), O = this.pow(s, p), $ = this.pow(s, p.iaddn(1).iushrn(1)), u = v;
      for (; ; ) {
        let S = O, M = 0;
        for (; !S.eq(a) && M < u; )
          S = this.sqr(S), M += 1;
        if (M === 0)
          break;
        V(M < u), S = this.sqrn(K, u - M - 1), K = this.sqr(S), $ = this.mul($, S), O = this.mul(O, K), u = M;
      }
      return $;
    }
    idivsqrt(s, a) {
      return this.divsqrt(s, a)._move(s);
    }
    divsqrt(s, a) {
      if (this._verify2(s, a), s.isZero() && a.isZero())
        throw new W(a);
      if (this.prime)
        return this.prime.divsqrt(s, a);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(s, a);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(s, a);
      if (a.isZero())
        throw new W(a);
      return this.sqrt(this.div(s, a));
    }
    divsqrt3mod4(s, a) {
      const p = this.m.subn(3).iushrn(2), v = this.sqr(s), C = this.mul(v, s), K = this.mul(C, v), O = this.mul(this.sqr(a), a), $ = this.pow(this.mul(K, O), p), u = this.mul(this.mul(C, a), $);
      if (this.mul(a, this.sqr(u)).eq(s))
        return u;
      throw new W(u);
    }
    divsqrt5mod8(s, a) {
      const p = this.m.subn(5).iushrn(3), v = this.mul(this.sqr(a), a), C = this.mul(this.sqr(v), a), K = this.pow(this.mul(s, C), p), O = this.mul(this.mul(s, v), K), $ = this.mul(a, this.sqr(O));
      if ($.eq(s))
        return O;
      const u = this.ineg($);
      if (u.eq(s))
        return this.mul(O, this.sm1);
      throw u.eq(this.mul(s, this.sm1)) ? new W(this.mul(O, this.sm1)) : new W(O);
    }
    isSquare(s) {
      return this.m.isOdd() ? this.jacobi(s) >= 0 : this.kronecker(s) >= 0;
    }
    ishl(s, a) {
      return this._verify1(s), this.imod(s.iushl(a));
    }
    shl(s, a) {
      return this.ishl(s.clone(), a);
    }
    ishln(s, a) {
      if (this._verify1(s), s.iushln(a), a <= 4)
        for (; s.ucmp(this.m) >= 0; )
          s._isub(s, this.m);
      else
        this.imod(s);
      return s;
    }
    shln(s, a) {
      return this.ishln(s.clone(), a);
    }
    ineg(s) {
      return this._verify1(s), s.isZero() || s._isub(this.m, s), s;
    }
    neg(s) {
      return this.ineg(s.clone());
    }
    eq(s, a) {
      return this._verify2(s, a), s.ucmp(a) === 0;
    }
    eqn(s, a) {
      if (this._verify1(s), this.m.length === 1)
        return a %= this.m.words[0], a < 0 && (a += this.m.words[0]), s.ucmpn(a) === 0;
      if (a < 0) {
        this.m._isubn(-a);
        const p = s.ucmp(this.m);
        return this.m._iaddn(-a), p === 0;
      }
      return s.ucmpn(a) === 0;
    }
    isHigh(s) {
      return !this.isLow(s);
    }
    isLow(s) {
      return this._verify1(s), s.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(s) {
      return this._verify1(s), s.isOdd();
    }
    isEven(s) {
      return this._verify1(s), s.isEven();
    }
    legendre(s) {
      if (this._verify1(s), this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const a = this.m.subn(1).iushrn(1), p = this.pow(s, a);
      if (p.isZero())
        return 0;
      const v = new h(1).toRed(this);
      if (p.eq(v))
        return 1;
      if (p.eq(this.ineg(v)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(s) {
      return this._verify1(s), s.jacobi(this.m);
    }
    kronecker(s) {
      return this._verify1(s), s.kronecker(this.m);
    }
    iinvert(s) {
      return this.invert(s)._move(s);
    }
    invert(s) {
      return this._verify1(s), s.invert(this.m)._forceRed(this);
    }
    ifermat(s) {
      return this.fermat(s)._move(s);
    }
    fermat(s) {
      if (this._verify1(s), s.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      return this.prime ? this.prime.fermat(s) : this.pow(s, this.m.subn(2));
    }
    invertAll(s) {
      T(Array.isArray(s), "elems", "array");
      for (const C of s)
        T(h.isBN(C), "elem", "bignum"), this._verify1(C);
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const a = s.length, p = new Array(a);
      if (a === 0)
        return p;
      let v = new h(1).toRed(this);
      for (let C = 0; C < a; C++) {
        if (s[C].isZero()) {
          p[C] = s[C].clone();
          continue;
        }
        p[C] = v, v = this.mul(v, s[C]);
      }
      v = this.invert(v);
      for (let C = a - 1; C >= 0; C--)
        s[C].isZero() || (p[C] = this.mul(v, p[C]), v = this.mul(v, s[C]));
      return p;
    }
    [r]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`;
    }
  }
  class E extends z {
    constructor(s) {
      super(s), this.prime = null, this.n = this.m.bitLength(), this.n % 26 !== 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = h.shift(1, this.k).div(this.m);
    }
    convertTo(s) {
      return s.length > this.w ? super.convertTo(s) : this.imod(s.clone());
    }
    _shift(s) {
      let a = 0, p = this.w;
      for (; p < s.length; )
        s.words[a++] = s.words[p++];
      a === 0 && (s.words[a++] = 0), s.length = a;
    }
    imod(s) {
      const a = s.negative;
      V(s.length <= this.w), s.negative = 0;
      const p = s.mul(this.b);
      return this._shift(p), s._isub(s, p.mul(this.m)), s.ucmp(this.m) >= 0 && s._isub(s, this.m), a && !s.isZero() && s._isub(this.m, s), s.red = this, s;
    }
  }
  class H extends z {
    constructor(s) {
      super(s), this.prime = null, this.n = this.m.length * 26, this.r = h.shift(1, this.n), this.r2 = h.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null;
    }
    get mont() {
      return !0;
    }
    convertTo(s) {
      return s.isNeg() || s.ucmp(this.m) >= 0 ? this.imod(s.ushln(this.n)) : this.mul(s, this.r2);
    }
    convertFrom(s) {
      const a = this.mul(s, new h(1));
      return a.red = null, a;
    }
    intTo(s) {
      return (s << BigInt(this.n)) % this.mb;
    }
    intFrom(s) {
      return this.rib === null && (this.rib = this.ri.toBigInt()), s * this.rib % this.mb;
    }
    iaddn(s, a) {
      return this.iadd(s, this.convertTo(new h(a)));
    }
    isubn(s, a) {
      return this.isub(s, this.convertTo(new h(a)));
    }
    imul(s, a) {
      return this.mul(s, a)._move(s);
    }
    mul(s, a) {
      if (s.isZero() || a.isZero())
        return new h(0)._forceRed(this);
      const p = s.mul(a), v = p.umaskn(this.n).mul(this.mi).iumaskn(this.n), C = p.iadd(v.mul(this.m)).iushrn(this.n);
      return C.ucmp(this.m) >= 0 && C._isub(C, this.m), C._forceRed(this);
    }
    imuln(s, a) {
      if (this._verify1(s), s.isZero())
        return s;
      if (a === 0)
        return s.words[0] = 0, s.length = 1, s;
      const p = a < 0;
      p && (a = -a), this.m.length === 1 && (a %= this.m.words[0]);
      const v = me(a);
      if (v > 5)
        this.imul(s, this.convertTo(new h(a)));
      else if (a & a - 1) {
        const C = s.clone();
        for (let K = v - 2; K >= 0; K--)
          this.iadd(s, s), a >> K & 1 && this.iadd(s, C);
      } else
        for (let C = 0; C < v - 1; C++)
          this.iadd(s, s);
      return p && this.ineg(s), s;
    }
    eqn(s, a) {
      return this._verify1(s), a === 0 ? s.isZero() : s.ucmp(this.convertTo(new h(a))) === 0;
    }
    isLow(s) {
      return this._verify1(s), this.convertFrom(s).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(s) {
      return this._verify1(s), this.convertFrom(s).isOdd();
    }
    isEven(s) {
      return this._verify1(s), this.convertFrom(s).isEven();
    }
    invert(s) {
      return this._verify1(s), this.imod(s.invert(this.m).mul(this.r2));
    }
  }
  function k(oe, s, a) {
    const p = new oe(s);
    return oe.captureStackTrace && oe.captureStackTrace(p, a), p;
  }
  function V(oe, s) {
    if (!oe)
      throw k(Error, s || "Assertion failed.", V);
  }
  function T(oe, s, a) {
    if (!oe) {
      const p = `"${s}" must be a(n) ${a}.`;
      throw k(TypeError, p, T);
    }
  }
  function ie(oe, s) {
    if (!oe) {
      const a = `"${s}" only works with positive numbers.`;
      throw k(RangeError, a, ie);
    }
  }
  function N(oe, s) {
    if (!oe) {
      const a = `"${s}" only works with red numbers.`;
      throw k(TypeError, a, N);
    }
  }
  function G(oe, s) {
    if (!oe) {
      const a = `"${s}" only works with normal numbers.`;
      throw k(TypeError, a, G);
    }
  }
  function F(oe) {
    if (!oe)
      throw k(RangeError, "Cannot divide by zero.", F);
  }
  class W extends Error {
    constructor(s) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = s.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, W);
    }
  }
  function ce(oe) {
    return Number.isSafeInteger(oe);
  }
  function ne(oe) {
    return ce(oe) && oe >= -67108863 && oe <= 67108863;
  }
  function xe(oe, s) {
    return oe.allocUnsafeSlow ? oe.allocUnsafeSlow(s) : new oe(s);
  }
  function he(oe) {
    if (oe == null)
      return 10;
    if (typeof oe == "number")
      return oe;
    switch (oe) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function me(oe) {
    if (Math.clz32)
      return 32 - Math.clz32(oe);
    let s = oe, a = 0;
    return s >= 4096 && (a += 13, s >>>= 13), s >= 64 && (a += 7, s >>>= 7), s >= 8 && (a += 4, s >>>= 4), s >= 2 && (a += 2, s >>>= 2), a + s;
  }
  function Ne(oe) {
    if (oe === 0)
      return 26;
    let s = oe, a = 0;
    return s & 8191 || (a += 13, s >>>= 13), s & 127 || (a += 7, s >>>= 7), s & 15 || (a += 4, s >>>= 4), s & 3 || (a += 2, s >>>= 2), s & 1 || (a += 1), a;
  }
  function Je(oe, s, a) {
    const p = Math.min(oe.length, a);
    let v = 0, C = 0;
    for (let K = s; K < p; K++) {
      const O = oe.charCodeAt(K) - 48;
      v <<= 4;
      let $;
      O >= 49 && O <= 54 ? $ = O - 49 + 10 : O >= 17 && O <= 22 ? $ = O - 17 + 10 : $ = O, v |= $, C |= $;
    }
    if (C & -16)
      throw new Error("Invalid string.");
    return v;
  }
  function Ze(oe, s, a, p) {
    const v = Math.min(oe.length, a);
    let C = 0;
    for (let K = s; K < v; K++) {
      const O = oe.charCodeAt(K) - 48;
      C *= p;
      let $;
      if (O >= 49 ? $ = O - 49 + 10 : O >= 17 ? $ = O - 17 + 10 : $ = O, O < 0 || O > 207 || $ >= p)
        throw new Error("Invalid string.");
      C += $;
    }
    return C;
  }
  function ht(oe, s, a) {
    const p = BigInt(1), v = new Array(d), C = oe * oe % a;
    v[0] = oe;
    for (let $ = 1; $ < d; $++)
      v[$] = v[$ - 1] * C % a;
    let K = s.bitLength(), O = p;
    for (; K >= o; ) {
      let $ = o, u = s.bits(K - $, $);
      if (u < d) {
        O = O * O % a, K -= 1;
        continue;
      }
      for (; !(u & 1); )
        $ -= 1, u >>= 1;
      O === p ? O = v[u >> 1] : (O = dt(O, $, a), O = O * v[u >> 1] % a), K -= $;
    }
    if (K > 0) {
      const $ = s.bits(0, K);
      for (; K--; )
        O = O * O % a, $ >> K & 1 && (O = O * oe % a);
    }
    return O;
  }
  function dt(oe, s, a) {
    for (let p = 0; p < s; p++)
      oe = oe * oe % a;
    return oe;
  }
  function Se(oe, s, a) {
    const p = oe.length + s.length;
    a.negative = oe.negative ^ s.negative, a._alloc(p), a.length = p;
    const v = oe.words[0], C = s.words[0], K = v * C, O = K & 67108863;
    let $ = K / 67108864 | 0, u = 1;
    for (a.words[0] = O; u < a.length - 1; u++) {
      let S = $ >>> 26, M = $ & 67108863;
      const Y = Math.max(0, u - oe.length + 1), J = Math.min(u, s.length - 1);
      for (let X = Y; X <= J; X++) {
        const re = u - X, ae = oe.words[re], de = s.words[X], ge = ae * de + M;
        S += ge / 67108864 | 0, M = ge & 67108863;
      }
      a.words[u] = M | 0, $ = S | 0;
    }
    return $ !== 0 ? a.words[u] = $ | 0 : a.length -= 1, a._strip();
  }
  function we(oe, s, a) {
    const p = oe.length + s.length;
    a.negative = oe.negative ^ s.negative, a._alloc(p), a.length = p;
    let v = 0, C = 0, K = 0;
    for (; K < a.length - 1; K++) {
      let O = C;
      C = 0;
      let $ = v & 67108863;
      const u = Math.max(0, K - oe.length + 1), S = Math.min(K, s.length - 1);
      for (let M = u; M <= S; M++) {
        const Y = K - M, J = oe.words[Y], X = s.words[M], re = J * X;
        let ae = re & 67108863;
        O = O + (re / 67108864 | 0) | 0, ae = ae + $ | 0, $ = ae & 67108863, O = O + (ae >>> 26) | 0, C += O >>> 26, O &= 67108863;
      }
      a.words[K] = $, v = O, O = C;
    }
    return v !== 0 ? a.words[K] = v : a.length -= 1, a._strip();
  }
  function Z(oe, s, a) {
    if (!l || oe.length + s.length > 82595519)
      return we(oe, s, a);
    const p = BigInt(0), v = BigInt(67108863), C = BigInt(26);
    let K = oe.toBigInt() * s.toBigInt();
    const O = K < p | 0;
    O && (K = -K);
    let $ = 0;
    for (; K > p; )
      a.words[$++] = Number(K & v), K >>= C;
    return $ === 0 && (a.words[$++] = 0), a.length = $, a.negative = O, a;
  }
  function L(oe, s, a) {
    const p = oe.words, v = s.words, C = a.words, K = p[0] | 0, O = K & 8191, $ = K >>> 13, u = p[1] | 0, S = u & 8191, M = u >>> 13, Y = p[2] | 0, J = Y & 8191, X = Y >>> 13, re = p[3] | 0, ae = re & 8191, de = re >>> 13, ge = p[4] | 0, Be = ge & 8191, ve = ge >>> 13, Oe = p[5] | 0, Ie = Oe & 8191, Re = Oe >>> 13, ft = p[6] | 0, Ye = ft & 8191, Fe = ft >>> 13, Le = p[7] | 0, He = Le & 8191, et = Le >>> 13, xr = p[8] | 0, tt = xr & 8191, it = xr >>> 13, Ht = p[9] | 0, Qe = Ht & 8191, st = Ht >>> 13, s0 = v[0] | 0, ct = s0 & 8191, Xe = s0 >>> 13, qr = v[1] | 0, bt = qr & 8191, Ge = qr >>> 13, I0 = v[2] | 0, pt = I0 & 8191, ke = I0 >>> 13, le = v[3] | 0, ot = le & 8191, St = le >>> 13, Di = v[4] | 0, Bt = Di & 8191, vt = Di >>> 13, Li = v[5] | 0, Et = Li & 8191, It = Li >>> 13, Ki = v[6] | 0, At = Ki & 8191, _t = Ki >>> 13, $i = v[7] | 0, Mt = $i & 8191, lt = $i >>> 13, ii = v[8] | 0, at = ii & 8191, nt = ii >>> 13, Hi = v[9] | 0, Nt = Hi & 8191, Ot = Hi >>> 13;
    let Ke = 0, j, R, Q;
    a.negative = oe.negative ^ s.negative, a._alloc(20), a.length = 19, j = Math.imul(O, ct), R = Math.imul(O, Xe), R = R + Math.imul($, ct) | 0, Q = Math.imul($, Xe);
    let C0 = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (C0 >>> 26) | 0, C0 &= 67108863, j = Math.imul(S, ct), R = Math.imul(S, Xe), R = R + Math.imul(M, ct) | 0, Q = Math.imul(M, Xe), j = j + Math.imul(O, bt) | 0, R = R + Math.imul(O, Ge) | 0, R = R + Math.imul($, bt) | 0, Q = Q + Math.imul($, Ge) | 0;
    let T0 = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (T0 >>> 26) | 0, T0 &= 67108863, j = Math.imul(J, ct), R = Math.imul(J, Xe), R = R + Math.imul(X, ct) | 0, Q = Math.imul(X, Xe), j = j + Math.imul(S, bt) | 0, R = R + Math.imul(S, Ge) | 0, R = R + Math.imul(M, bt) | 0, Q = Q + Math.imul(M, Ge) | 0, j = j + Math.imul(O, pt) | 0, R = R + Math.imul(O, ke) | 0, R = R + Math.imul($, pt) | 0, Q = Q + Math.imul($, ke) | 0;
    let D0 = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (D0 >>> 26) | 0, D0 &= 67108863, j = Math.imul(ae, ct), R = Math.imul(ae, Xe), R = R + Math.imul(de, ct) | 0, Q = Math.imul(de, Xe), j = j + Math.imul(J, bt) | 0, R = R + Math.imul(J, Ge) | 0, R = R + Math.imul(X, bt) | 0, Q = Q + Math.imul(X, Ge) | 0, j = j + Math.imul(S, pt) | 0, R = R + Math.imul(S, ke) | 0, R = R + Math.imul(M, pt) | 0, Q = Q + Math.imul(M, ke) | 0, j = j + Math.imul(O, ot) | 0, R = R + Math.imul(O, St) | 0, R = R + Math.imul($, ot) | 0, Q = Q + Math.imul($, St) | 0;
    let P = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (P >>> 26) | 0, P &= 67108863, j = Math.imul(Be, ct), R = Math.imul(Be, Xe), R = R + Math.imul(ve, ct) | 0, Q = Math.imul(ve, Xe), j = j + Math.imul(ae, bt) | 0, R = R + Math.imul(ae, Ge) | 0, R = R + Math.imul(de, bt) | 0, Q = Q + Math.imul(de, Ge) | 0, j = j + Math.imul(J, pt) | 0, R = R + Math.imul(J, ke) | 0, R = R + Math.imul(X, pt) | 0, Q = Q + Math.imul(X, ke) | 0, j = j + Math.imul(S, ot) | 0, R = R + Math.imul(S, St) | 0, R = R + Math.imul(M, ot) | 0, Q = Q + Math.imul(M, St) | 0, j = j + Math.imul(O, Bt) | 0, R = R + Math.imul(O, vt) | 0, R = R + Math.imul($, Bt) | 0, Q = Q + Math.imul($, vt) | 0;
    let f = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (f >>> 26) | 0, f &= 67108863, j = Math.imul(Ie, ct), R = Math.imul(Ie, Xe), R = R + Math.imul(Re, ct) | 0, Q = Math.imul(Re, Xe), j = j + Math.imul(Be, bt) | 0, R = R + Math.imul(Be, Ge) | 0, R = R + Math.imul(ve, bt) | 0, Q = Q + Math.imul(ve, Ge) | 0, j = j + Math.imul(ae, pt) | 0, R = R + Math.imul(ae, ke) | 0, R = R + Math.imul(de, pt) | 0, Q = Q + Math.imul(de, ke) | 0, j = j + Math.imul(J, ot) | 0, R = R + Math.imul(J, St) | 0, R = R + Math.imul(X, ot) | 0, Q = Q + Math.imul(X, St) | 0, j = j + Math.imul(S, Bt) | 0, R = R + Math.imul(S, vt) | 0, R = R + Math.imul(M, Bt) | 0, Q = Q + Math.imul(M, vt) | 0, j = j + Math.imul(O, Et) | 0, R = R + Math.imul(O, It) | 0, R = R + Math.imul($, Et) | 0, Q = Q + Math.imul($, It) | 0;
    let m = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (m >>> 26) | 0, m &= 67108863, j = Math.imul(Ye, ct), R = Math.imul(Ye, Xe), R = R + Math.imul(Fe, ct) | 0, Q = Math.imul(Fe, Xe), j = j + Math.imul(Ie, bt) | 0, R = R + Math.imul(Ie, Ge) | 0, R = R + Math.imul(Re, bt) | 0, Q = Q + Math.imul(Re, Ge) | 0, j = j + Math.imul(Be, pt) | 0, R = R + Math.imul(Be, ke) | 0, R = R + Math.imul(ve, pt) | 0, Q = Q + Math.imul(ve, ke) | 0, j = j + Math.imul(ae, ot) | 0, R = R + Math.imul(ae, St) | 0, R = R + Math.imul(de, ot) | 0, Q = Q + Math.imul(de, St) | 0, j = j + Math.imul(J, Bt) | 0, R = R + Math.imul(J, vt) | 0, R = R + Math.imul(X, Bt) | 0, Q = Q + Math.imul(X, vt) | 0, j = j + Math.imul(S, Et) | 0, R = R + Math.imul(S, It) | 0, R = R + Math.imul(M, Et) | 0, Q = Q + Math.imul(M, It) | 0, j = j + Math.imul(O, At) | 0, R = R + Math.imul(O, _t) | 0, R = R + Math.imul($, At) | 0, Q = Q + Math.imul($, _t) | 0;
    let D = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (D >>> 26) | 0, D &= 67108863, j = Math.imul(He, ct), R = Math.imul(He, Xe), R = R + Math.imul(et, ct) | 0, Q = Math.imul(et, Xe), j = j + Math.imul(Ye, bt) | 0, R = R + Math.imul(Ye, Ge) | 0, R = R + Math.imul(Fe, bt) | 0, Q = Q + Math.imul(Fe, Ge) | 0, j = j + Math.imul(Ie, pt) | 0, R = R + Math.imul(Ie, ke) | 0, R = R + Math.imul(Re, pt) | 0, Q = Q + Math.imul(Re, ke) | 0, j = j + Math.imul(Be, ot) | 0, R = R + Math.imul(Be, St) | 0, R = R + Math.imul(ve, ot) | 0, Q = Q + Math.imul(ve, St) | 0, j = j + Math.imul(ae, Bt) | 0, R = R + Math.imul(ae, vt) | 0, R = R + Math.imul(de, Bt) | 0, Q = Q + Math.imul(de, vt) | 0, j = j + Math.imul(J, Et) | 0, R = R + Math.imul(J, It) | 0, R = R + Math.imul(X, Et) | 0, Q = Q + Math.imul(X, It) | 0, j = j + Math.imul(S, At) | 0, R = R + Math.imul(S, _t) | 0, R = R + Math.imul(M, At) | 0, Q = Q + Math.imul(M, _t) | 0, j = j + Math.imul(O, Mt) | 0, R = R + Math.imul(O, lt) | 0, R = R + Math.imul($, Mt) | 0, Q = Q + Math.imul($, lt) | 0;
    let ee = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (ee >>> 26) | 0, ee &= 67108863, j = Math.imul(tt, ct), R = Math.imul(tt, Xe), R = R + Math.imul(it, ct) | 0, Q = Math.imul(it, Xe), j = j + Math.imul(He, bt) | 0, R = R + Math.imul(He, Ge) | 0, R = R + Math.imul(et, bt) | 0, Q = Q + Math.imul(et, Ge) | 0, j = j + Math.imul(Ye, pt) | 0, R = R + Math.imul(Ye, ke) | 0, R = R + Math.imul(Fe, pt) | 0, Q = Q + Math.imul(Fe, ke) | 0, j = j + Math.imul(Ie, ot) | 0, R = R + Math.imul(Ie, St) | 0, R = R + Math.imul(Re, ot) | 0, Q = Q + Math.imul(Re, St) | 0, j = j + Math.imul(Be, Bt) | 0, R = R + Math.imul(Be, vt) | 0, R = R + Math.imul(ve, Bt) | 0, Q = Q + Math.imul(ve, vt) | 0, j = j + Math.imul(ae, Et) | 0, R = R + Math.imul(ae, It) | 0, R = R + Math.imul(de, Et) | 0, Q = Q + Math.imul(de, It) | 0, j = j + Math.imul(J, At) | 0, R = R + Math.imul(J, _t) | 0, R = R + Math.imul(X, At) | 0, Q = Q + Math.imul(X, _t) | 0, j = j + Math.imul(S, Mt) | 0, R = R + Math.imul(S, lt) | 0, R = R + Math.imul(M, Mt) | 0, Q = Q + Math.imul(M, lt) | 0, j = j + Math.imul(O, at) | 0, R = R + Math.imul(O, nt) | 0, R = R + Math.imul($, at) | 0, Q = Q + Math.imul($, nt) | 0;
    let te = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (te >>> 26) | 0, te &= 67108863, j = Math.imul(Qe, ct), R = Math.imul(Qe, Xe), R = R + Math.imul(st, ct) | 0, Q = Math.imul(st, Xe), j = j + Math.imul(tt, bt) | 0, R = R + Math.imul(tt, Ge) | 0, R = R + Math.imul(it, bt) | 0, Q = Q + Math.imul(it, Ge) | 0, j = j + Math.imul(He, pt) | 0, R = R + Math.imul(He, ke) | 0, R = R + Math.imul(et, pt) | 0, Q = Q + Math.imul(et, ke) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Ye, St) | 0, R = R + Math.imul(Fe, ot) | 0, Q = Q + Math.imul(Fe, St) | 0, j = j + Math.imul(Ie, Bt) | 0, R = R + Math.imul(Ie, vt) | 0, R = R + Math.imul(Re, Bt) | 0, Q = Q + Math.imul(Re, vt) | 0, j = j + Math.imul(Be, Et) | 0, R = R + Math.imul(Be, It) | 0, R = R + Math.imul(ve, Et) | 0, Q = Q + Math.imul(ve, It) | 0, j = j + Math.imul(ae, At) | 0, R = R + Math.imul(ae, _t) | 0, R = R + Math.imul(de, At) | 0, Q = Q + Math.imul(de, _t) | 0, j = j + Math.imul(J, Mt) | 0, R = R + Math.imul(J, lt) | 0, R = R + Math.imul(X, Mt) | 0, Q = Q + Math.imul(X, lt) | 0, j = j + Math.imul(S, at) | 0, R = R + Math.imul(S, nt) | 0, R = R + Math.imul(M, at) | 0, Q = Q + Math.imul(M, nt) | 0, j = j + Math.imul(O, Nt) | 0, R = R + Math.imul(O, Ot) | 0, R = R + Math.imul($, Nt) | 0, Q = Q + Math.imul($, Ot) | 0;
    let se = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, j = Math.imul(Qe, bt), R = Math.imul(Qe, Ge), R = R + Math.imul(st, bt) | 0, Q = Math.imul(st, Ge), j = j + Math.imul(tt, pt) | 0, R = R + Math.imul(tt, ke) | 0, R = R + Math.imul(it, pt) | 0, Q = Q + Math.imul(it, ke) | 0, j = j + Math.imul(He, ot) | 0, R = R + Math.imul(He, St) | 0, R = R + Math.imul(et, ot) | 0, Q = Q + Math.imul(et, St) | 0, j = j + Math.imul(Ye, Bt) | 0, R = R + Math.imul(Ye, vt) | 0, R = R + Math.imul(Fe, Bt) | 0, Q = Q + Math.imul(Fe, vt) | 0, j = j + Math.imul(Ie, Et) | 0, R = R + Math.imul(Ie, It) | 0, R = R + Math.imul(Re, Et) | 0, Q = Q + Math.imul(Re, It) | 0, j = j + Math.imul(Be, At) | 0, R = R + Math.imul(Be, _t) | 0, R = R + Math.imul(ve, At) | 0, Q = Q + Math.imul(ve, _t) | 0, j = j + Math.imul(ae, Mt) | 0, R = R + Math.imul(ae, lt) | 0, R = R + Math.imul(de, Mt) | 0, Q = Q + Math.imul(de, lt) | 0, j = j + Math.imul(J, at) | 0, R = R + Math.imul(J, nt) | 0, R = R + Math.imul(X, at) | 0, Q = Q + Math.imul(X, nt) | 0, j = j + Math.imul(S, Nt) | 0, R = R + Math.imul(S, Ot) | 0, R = R + Math.imul(M, Nt) | 0, Q = Q + Math.imul(M, Ot) | 0;
    let ue = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (ue >>> 26) | 0, ue &= 67108863, j = Math.imul(Qe, pt), R = Math.imul(Qe, ke), R = R + Math.imul(st, pt) | 0, Q = Math.imul(st, ke), j = j + Math.imul(tt, ot) | 0, R = R + Math.imul(tt, St) | 0, R = R + Math.imul(it, ot) | 0, Q = Q + Math.imul(it, St) | 0, j = j + Math.imul(He, Bt) | 0, R = R + Math.imul(He, vt) | 0, R = R + Math.imul(et, Bt) | 0, Q = Q + Math.imul(et, vt) | 0, j = j + Math.imul(Ye, Et) | 0, R = R + Math.imul(Ye, It) | 0, R = R + Math.imul(Fe, Et) | 0, Q = Q + Math.imul(Fe, It) | 0, j = j + Math.imul(Ie, At) | 0, R = R + Math.imul(Ie, _t) | 0, R = R + Math.imul(Re, At) | 0, Q = Q + Math.imul(Re, _t) | 0, j = j + Math.imul(Be, Mt) | 0, R = R + Math.imul(Be, lt) | 0, R = R + Math.imul(ve, Mt) | 0, Q = Q + Math.imul(ve, lt) | 0, j = j + Math.imul(ae, at) | 0, R = R + Math.imul(ae, nt) | 0, R = R + Math.imul(de, at) | 0, Q = Q + Math.imul(de, nt) | 0, j = j + Math.imul(J, Nt) | 0, R = R + Math.imul(J, Ot) | 0, R = R + Math.imul(X, Nt) | 0, Q = Q + Math.imul(X, Ot) | 0;
    let be = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, j = Math.imul(Qe, ot), R = Math.imul(Qe, St), R = R + Math.imul(st, ot) | 0, Q = Math.imul(st, St), j = j + Math.imul(tt, Bt) | 0, R = R + Math.imul(tt, vt) | 0, R = R + Math.imul(it, Bt) | 0, Q = Q + Math.imul(it, vt) | 0, j = j + Math.imul(He, Et) | 0, R = R + Math.imul(He, It) | 0, R = R + Math.imul(et, Et) | 0, Q = Q + Math.imul(et, It) | 0, j = j + Math.imul(Ye, At) | 0, R = R + Math.imul(Ye, _t) | 0, R = R + Math.imul(Fe, At) | 0, Q = Q + Math.imul(Fe, _t) | 0, j = j + Math.imul(Ie, Mt) | 0, R = R + Math.imul(Ie, lt) | 0, R = R + Math.imul(Re, Mt) | 0, Q = Q + Math.imul(Re, lt) | 0, j = j + Math.imul(Be, at) | 0, R = R + Math.imul(Be, nt) | 0, R = R + Math.imul(ve, at) | 0, Q = Q + Math.imul(ve, nt) | 0, j = j + Math.imul(ae, Nt) | 0, R = R + Math.imul(ae, Ot) | 0, R = R + Math.imul(de, Nt) | 0, Q = Q + Math.imul(de, Ot) | 0;
    let Ae = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, j = Math.imul(Qe, Bt), R = Math.imul(Qe, vt), R = R + Math.imul(st, Bt) | 0, Q = Math.imul(st, vt), j = j + Math.imul(tt, Et) | 0, R = R + Math.imul(tt, It) | 0, R = R + Math.imul(it, Et) | 0, Q = Q + Math.imul(it, It) | 0, j = j + Math.imul(He, At) | 0, R = R + Math.imul(He, _t) | 0, R = R + Math.imul(et, At) | 0, Q = Q + Math.imul(et, _t) | 0, j = j + Math.imul(Ye, Mt) | 0, R = R + Math.imul(Ye, lt) | 0, R = R + Math.imul(Fe, Mt) | 0, Q = Q + Math.imul(Fe, lt) | 0, j = j + Math.imul(Ie, at) | 0, R = R + Math.imul(Ie, nt) | 0, R = R + Math.imul(Re, at) | 0, Q = Q + Math.imul(Re, nt) | 0, j = j + Math.imul(Be, Nt) | 0, R = R + Math.imul(Be, Ot) | 0, R = R + Math.imul(ve, Nt) | 0, Q = Q + Math.imul(ve, Ot) | 0;
    let $e = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, j = Math.imul(Qe, Et), R = Math.imul(Qe, It), R = R + Math.imul(st, Et) | 0, Q = Math.imul(st, It), j = j + Math.imul(tt, At) | 0, R = R + Math.imul(tt, _t) | 0, R = R + Math.imul(it, At) | 0, Q = Q + Math.imul(it, _t) | 0, j = j + Math.imul(He, Mt) | 0, R = R + Math.imul(He, lt) | 0, R = R + Math.imul(et, Mt) | 0, Q = Q + Math.imul(et, lt) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Ye, nt) | 0, R = R + Math.imul(Fe, at) | 0, Q = Q + Math.imul(Fe, nt) | 0, j = j + Math.imul(Ie, Nt) | 0, R = R + Math.imul(Ie, Ot) | 0, R = R + Math.imul(Re, Nt) | 0, Q = Q + Math.imul(Re, Ot) | 0;
    let Rt = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, j = Math.imul(Qe, At), R = Math.imul(Qe, _t), R = R + Math.imul(st, At) | 0, Q = Math.imul(st, _t), j = j + Math.imul(tt, Mt) | 0, R = R + Math.imul(tt, lt) | 0, R = R + Math.imul(it, Mt) | 0, Q = Q + Math.imul(it, lt) | 0, j = j + Math.imul(He, at) | 0, R = R + Math.imul(He, nt) | 0, R = R + Math.imul(et, at) | 0, Q = Q + Math.imul(et, nt) | 0, j = j + Math.imul(Ye, Nt) | 0, R = R + Math.imul(Ye, Ot) | 0, R = R + Math.imul(Fe, Nt) | 0, Q = Q + Math.imul(Fe, Ot) | 0;
    let Jt = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, j = Math.imul(Qe, Mt), R = Math.imul(Qe, lt), R = R + Math.imul(st, Mt) | 0, Q = Math.imul(st, lt), j = j + Math.imul(tt, at) | 0, R = R + Math.imul(tt, nt) | 0, R = R + Math.imul(it, at) | 0, Q = Q + Math.imul(it, nt) | 0, j = j + Math.imul(He, Nt) | 0, R = R + Math.imul(He, Ot) | 0, R = R + Math.imul(et, Nt) | 0, Q = Q + Math.imul(et, Ot) | 0;
    let mr = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (mr >>> 26) | 0, mr &= 67108863, j = Math.imul(Qe, at), R = Math.imul(Qe, nt), R = R + Math.imul(st, at) | 0, Q = Math.imul(st, nt), j = j + Math.imul(tt, Nt) | 0, R = R + Math.imul(tt, Ot) | 0, R = R + Math.imul(it, Nt) | 0, Q = Q + Math.imul(it, Ot) | 0;
    let Xr = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, j = Math.imul(Qe, Nt), R = Math.imul(Qe, Ot), R = R + Math.imul(st, Nt) | 0, Q = Math.imul(st, Ot);
    let si = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    return Ke = (Q + (R >>> 13) | 0) + (si >>> 26) | 0, si &= 67108863, C[0] = C0, C[1] = T0, C[2] = D0, C[3] = P, C[4] = f, C[5] = m, C[6] = D, C[7] = ee, C[8] = te, C[9] = se, C[10] = ue, C[11] = be, C[12] = Ae, C[13] = $e, C[14] = Rt, C[15] = Jt, C[16] = mr, C[17] = Xr, C[18] = si, Ke !== 0 && (C[19] = Ke, a.length += 1), a;
  }
  return Math.imul || (L = Se), h.Red = z, Ka = h, Ka;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
(function(r) {
  if (process.env.BCRYPTO_FORCE_BIGINT || process.env.NODE_BACKEND !== "js")
    try {
      if (r.exports = bm(), !r.exports.native)
        throw new Error();
    } catch {
      r.exports = T2();
    }
  else
    r.exports = T2();
})(B8);
var J0 = B8.exports, yo = {}, pu = { exports: {} }, an = {}, mu = { exports: {} };
/*!
 * salsa20.js - salsa20 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Salsa20
 *   https://cr.yp.to/snuffle.html
 *   https://cr.yp.to/snuffle/spec.pdf
 *   https://cr.yp.to/snuffle/812.pdf
 *   http://www.ecrypt.eu.org/stream/salsa20pf.html
 */
var $a, D2;
function pm() {
  if (D2)
    return $a;
  D2 = 1;
  const r = _e, e = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  class t {
    /**
     * Create a Salsa20 context.
     * @constructor
     */
    constructor() {
      this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, e && (this.bytes = Buffer.alloc(64));
    }
    /**
     * Initialize salsa20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */
    init(l, h, x) {
      if (x == null && (x = 0), r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), r(Number.isSafeInteger(x)), l.length !== 16 && l.length !== 32)
        throw new RangeError("Invalid key size.");
      if (h.length >= 24 && (l = t.derive(l, h.slice(0, 16)), h = h.slice(16)), this.state[0] = 1634760805, this.state[1] = c(l, 0), this.state[2] = c(l, 4), this.state[3] = c(l, 8), this.state[4] = c(l, 12), this.state[5] = l.length < 32 ? 824206446 : 857760878, h.length === 8)
        this.state[6] = c(h, 0), this.state[7] = c(h, 4), this.state[8] = x >>> 0, this.state[9] = x / 4294967296 >>> 0;
      else if (h.length === 12)
        this.state[6] = c(h, 0), this.state[7] = c(h, 4), this.state[8] = c(h, 8), this.state[9] = x >>> 0;
      else if (h.length === 16)
        this.state[6] = c(h, 0), this.state[7] = c(h, 4), this.state[8] = c(h, 8), this.state[9] = c(h, 12);
      else
        throw new RangeError("Invalid nonce size.");
      return this.state[10] = l.length < 32 ? 2036477238 : 2036477234, this.state[11] = c(l, 16 % l.length), this.state[12] = c(l, 20 % l.length), this.state[13] = c(l, 24 % l.length), this.state[14] = c(l, 28 % l.length), this.state[15] = 1797285236, this.pos = 0, this;
    }
    /**
     * Encrypt/decrypt data.
     * @param {Buffer} data - Will be mutated.
     * @returns {Buffer}
     */
    encrypt(l) {
      if (r(Buffer.isBuffer(l)), this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let h = 0; h < l.length; h++)
        this.pos & 63 || (this._block(), this.pos = 0), l[h] ^= this.bytes[this.pos++];
      return l;
    }
    /**
     * Stir the stream.
     */
    _block() {
      for (let l = 0; l < 16; l++)
        this.stream[l] = this.state[l];
      for (let l = 0; l < 10; l++)
        i(this.stream, 0, 4, 8, 12), i(this.stream, 5, 9, 13, 1), i(this.stream, 10, 14, 2, 6), i(this.stream, 15, 3, 7, 11), i(this.stream, 0, 1, 2, 3), i(this.stream, 5, 6, 7, 4), i(this.stream, 10, 11, 8, 9), i(this.stream, 15, 12, 13, 14);
      for (let l = 0; l < 16; l++)
        this.stream[l] += this.state[l];
      if (e)
        for (let l = 0; l < 16; l++)
          o(this.bytes, this.stream[l], l * 4);
      this.state[8] += 1, this.state[8] === 0 && (this.state[9] += 1);
    }
    /**
     * Destroy context.
     */
    destroy() {
      for (let l = 0; l < 16; l++)
        this.state[l] = 0, this.stream[l] = 0;
      if (e)
        for (let l = 0; l < 64; l++)
          this.bytes[l] = 0;
      return this.pos = -1, this;
    }
    /**
     * Derive key with XSalsa20.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @returns {Buffer}
     */
    static derive(l, h) {
      if (r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), l.length !== 16 && l.length !== 32)
        throw new RangeError("Invalid key size.");
      if (h.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const x = new Uint32Array(16);
      x[0] = 1634760805, x[1] = c(l, 0), x[2] = c(l, 4), x[3] = c(l, 8), x[4] = c(l, 12), x[5] = l.length < 32 ? 824206446 : 857760878, x[6] = c(h, 0), x[7] = c(h, 4), x[8] = c(h, 8), x[9] = c(h, 12), x[10] = l.length < 32 ? 2036477238 : 2036477234, x[11] = c(l, 16 % l.length), x[12] = c(l, 20 % l.length), x[13] = c(l, 24 % l.length), x[14] = c(l, 28 % l.length), x[15] = 1797285236;
      for (let g = 0; g < 10; g++)
        i(x, 0, 4, 8, 12), i(x, 5, 9, 13, 1), i(x, 10, 14, 2, 6), i(x, 15, 3, 7, 11), i(x, 0, 1, 2, 3), i(x, 5, 6, 7, 4), i(x, 10, 11, 8, 9), i(x, 15, 12, 13, 14);
      const b = Buffer.alloc(32);
      return o(b, x[0], 0), o(b, x[5], 4), o(b, x[10], 8), o(b, x[15], 12), o(b, x[6], 16), o(b, x[7], 20), o(b, x[8], 24), o(b, x[9], 28), b;
    }
  }
  t.native = 0;
  function i(d, l, h, x, b) {
    d[h] ^= n(d[l] + d[b], 7), d[x] ^= n(d[h] + d[l], 9), d[b] ^= n(d[x] + d[h], 13), d[l] ^= n(d[b] + d[x], 18);
  }
  function n(d, l) {
    return d << l | d >>> 32 - l;
  }
  function c(d, l) {
    return d[l++] + d[l++] * 256 + d[l++] * 65536 + d[l] * 16777216;
  }
  function o(d, l, h) {
    return d[h++] = l, l >>>= 8, d[h++] = l, l >>>= 8, d[h++] = l, l >>>= 8, d[h++] = l, h;
  }
  return $a = t, $a;
}
/*!
 * salsa20.js - salsa20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ha, L2;
function mm() {
  if (L2)
    return Ha;
  L2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor() {
      this._handle = e.salsa20_create();
    }
    init(n, c, o) {
      return o == null && (o = 0), r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Number.isSafeInteger(o)), e.salsa20_init(this._handle, n, c, o), this;
    }
    encrypt(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.salsa20_crypt(this._handle, n), n;
    }
    destroy() {
      return r(this instanceof t), e.salsa20_destroy(this._handle), this;
    }
    static derive(n, c) {
      return r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.salsa20_derive(n, c);
    }
  }
  return t.native = 2, Ha = t, Ha;
}
/*!
 * salsa20.js - salsa20 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? mu.exports = pm() : mu.exports = mm();
var v8 = mu.exports, gu = { exports: {} };
/*!
 * poly1305.js - poly1305 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Fa, K2;
function gm() {
  if (K2)
    return Fa;
  K2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor() {
      this._handle = e.poly1305_create();
    }
    init(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.poly1305_init(this._handle, n), this;
    }
    update(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.poly1305_update(this._handle, n), this;
    }
    final() {
      return r(this instanceof t), e.poly1305_final(this._handle);
    }
    destroy() {
      return r(this instanceof t), e.poly1305_destroy(this._handle), this;
    }
    verify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.poly1305_verify(this._handle, n);
    }
  }
  return t.native = 2, Fa = t, Fa;
}
/*!
 * poly1305.js - poly1305 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? gu.exports = c8() : gu.exports = gm();
var E8 = gu.exports;
/*!
 * secretbox.js - nacl secretbox for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://nacl.cr.yp.to/secretbox.html
 *   https://github.com/golang/crypto/tree/master/nacl
 *   https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox.go
 *   https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/secretbox/example_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/box.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/box_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/example_test.go
 */
var $2;
function wm() {
  if ($2)
    return an;
  $2 = 1;
  const r = _e, e = v8, t = E8, i = Buffer.alloc(16, 0);
  function n(l, h, x) {
    r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(h.length === 32), r(x.length === 24);
    const b = Buffer.alloc(32, 0), g = Buffer.alloc(16 + l.length), w = g.slice(16), I = new e(), B = new t();
    return l.copy(g, 16), I.init(h, x), I.encrypt(b), I.encrypt(w), B.init(b), B.update(w), B.final().copy(g, 0), g;
  }
  function c(l, h, x) {
    if (r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(h.length === 32), r(x.length === 24), l.length < 16)
      throw new Error("Invalid secret box size.");
    const b = Buffer.alloc(32, 0), g = Buffer.from(l), w = g.slice(0, 16), I = g.slice(16), B = new e(), y = new t();
    if (B.init(h, x), B.encrypt(b), y.init(b), y.update(I), !y.verify(w))
      throw new Error("Invalid secret box tag.");
    return B.encrypt(I), I;
  }
  function o(l, h) {
    const x = d(l, h);
    return e.derive(x, i);
  }
  function d(l, h) {
    if (r(Buffer.isBuffer(l)), h == null) {
      if (l.length !== 32)
        throw new RangeError("Invalid secret size for secret box.");
      return l;
    }
    let x;
    if (typeof h.digest == "function")
      x = h.digest(l);
    else if (typeof h == "function")
      x = h(l);
    else
      throw new Error("Invalid key derivation function.");
    if (r(Buffer.isBuffer(x)), x.length < 32)
      throw new RangeError("Key is too small for secret box.");
    return x.slice(0, 32);
  }
  return an.native = 0, an.seal = n, an.open = c, an.derive = o, an;
}
var hn = {};
/*!
 * secretbox.js - nacl secretbox for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var H2;
function ym() {
  if (H2)
    return hn;
  H2 = 1;
  const r = _e, e = Dt();
  function t(o, d, l) {
    return r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), e.secretbox_seal(o, d, l);
  }
  function i(o, d, l) {
    return r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), e.secretbox_open(o, d, l);
  }
  function n(o, d) {
    const l = c(o, d);
    return e.secretbox_derive(l);
  }
  function c(o, d) {
    if (r(Buffer.isBuffer(o)), d == null)
      return o;
    let l;
    return typeof d.digest == "function" ? l = d.digest(o) : typeof d == "function" ? l = d(o) : r(!1), r(Buffer.isBuffer(l)), l.slice(0, 32);
  }
  return hn.native = 2, hn.seal = t, hn.open = i, hn.derive = n, hn;
}
/*!
 * secretbox.js - secretbox for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? pu.exports = wm() : pu.exports = ym();
var Lf = pu.exports;
/*!
 * random.js - random for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var B0 = a8, wu = { exports: {} }, b0 = {};
/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */
var F2;
function So() {
  if (F2)
    return b0;
  F2 = 1;
  const { custom: r } = Y1(), e = J0, t = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  }, i = [
    -3,
    -1,
    -5,
    -7,
    0,
    7,
    5,
    1,
    3
    // 1 1
  ];
  let n = 0;
  class c {
    constructor(u, S, M) {
      this.Point = null, this.id = null, this.uid = n++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(u, S, M);
    }
    _init(u, S, M) {
      L(typeof u == "function"), L(typeof S == "string"), L(M && typeof M == "object"), L(M.red == null || M.red instanceof e.Red), L(M.p != null, "Must pass a prime."), L(M.id == null || typeof M.id == "string"), L(M.ossl == null || typeof M.ossl == "string"), L(M.endian == null || typeof M.endian == "string"), L(M.hash == null || typeof M.hash == "string"), L(M.prefix == null || typeof M.prefix == "string"), L(M.context == null || typeof M.context == "boolean"), L(M.prime == null || typeof M.prime == "string"), L(M.torsion == null || Array.isArray(M.torsion)), this.Point = u, this.id = M.id || null, this.ossl = M.ossl || null, this.type = S, this.endian = M.endian || (S === "short" ? "be" : "le"), this.hash = M.hash || null, this.prefix = M.prefix ? Buffer.from(M.prefix, "binary") : null, this.context = M.context || !1, this.prime = M.prime || null, this.p = e.fromJSON(M.p), M.red ? this.red = M.red : (this.red = M.prime ? e.red(M.prime) : e.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, this.fieldBits & 7 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = e.fromJSON(M.n || "0"), this.h = e.fromJSON(M.h || "1"), this.q = this.n.mul(this.h), this.z = e.fromJSON(M.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.three = new e(3).toRed(this.red), this.four = new e(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
      for (let Y = 0; Y < this.torsion.length; Y++)
        this.torsion[Y] = this.point();
      return this.endo = null, this.hi = null, this._scale = K(this._scale, this), this.isIsomorphic = K(this.isIsomorphic, this), this.isIsogenous = K(this.isIsogenous, this), L(this.p.sign() > 0 && this.p.isOdd()), L(this.n.sign() >= 0), L(this.h.sign() > 0 && this.h.cmpn(255) <= 0), L(this.endian === "be" || this.endian === "le"), this;
    }
    _finalize(u) {
      if (L(u && typeof u == "object"), this.g = u.g ? this.pointFromJSON(u.g) : this.point(), u.torsion) {
        L(u.torsion.length === this.torsion.length);
        for (let S = 0; S < this.torsion.length; S++)
          this.torsion[S] = this.pointFromJSON(u.torsion[S]);
      }
      return this;
    }
    _findTorsion() {
      L(!this.n.isZero());
      const u = this.h.word(0), S = this.one.redNeg(), M = [this.point()], Y = /* @__PURE__ */ new Set();
      let J = u;
      for (; M.length < J; ) {
        let X;
        S.redIAdd(this.one);
        try {
          X = this.pointFromX(S.clone());
        } catch {
          continue;
        }
        try {
          X = X.mul(this.n);
        } catch {
          J = 2;
          continue;
        }
        if (!X.isInfinity()) {
          X.normalize();
          for (const re of [X, X.neg()]) {
            const ae = re.key();
            Y.has(ae) || (M.push(re), Y.add(ae));
          }
        }
      }
      for (M.sort((X, re) => X.cmp(re)); M.length < u; )
        M.push(this.point());
      return M;
    }
    _fixedMul(u, S) {
      L(u instanceof o), L(S instanceof e), L(u.pre && u.pre.windows);
      const { width: M, points: Y } = u._getWindows(0, 0), J = 1 << M, re = (S.bitLength() + M - 1) / M >>> 0;
      let ae = this.jpoint();
      for (let de = 0; de < re; de++) {
        const ge = S.bits(de * M, M);
        ae = ae.add(Y[de * J + ge]);
      }
      return S.isNeg() && (ae = ae.neg()), ae;
    }
    _fixedNafMul(u, S) {
      L(u instanceof o), L(S instanceof e), L(u.pre && u.pre.doubles);
      const { step: M, points: Y } = u._getDoubles(0, 0), J = Se(S, 2, S.bitLength() + 1, M), X = ((1 << M + 1) - (M % 2 === 0 ? 2 : 1)) / 3;
      let re = this.jpoint(), ae = this.jpoint();
      for (let de = X; de > 0; de--) {
        for (let ge = 0; ge < J.length; ge++) {
          const Be = J[ge];
          Be === de ? ae = ae.add(Y[ge]) : Be === -de && (ae = ae.sub(Y[ge]));
        }
        re = re.add(ae);
      }
      return re;
    }
    _wnafMul(u, S, M) {
      L(S instanceof o), L(M instanceof e);
      const { width: Y, points: J } = S._safeNAF(u), X = dt(M, Y, M.bitLength() + 1);
      let re = this.jpoint();
      for (let ae = X.length - 1; ae >= 0; ae--) {
        const de = X[ae];
        ae !== X.length - 1 && (re = re.dbl()), de > 0 ? re = re.add(J[de - 1 >> 1]) : de < 0 && (re = re.sub(J[-de - 1 >> 1]));
      }
      return re;
    }
    _wnafMulAdd(u, S, M) {
      L(u >>> 0 === u), L(Array.isArray(S)), L(Array.isArray(M)), L(S.length === M.length);
      const Y = S.length, J = new Array(Y), X = new Array(Y);
      let re = 0;
      for (let ve = 0; ve < Y; ve++) {
        const Oe = S[ve], Ie = M[ve];
        if (L(Oe instanceof o), L(Ie instanceof e), ve > 0 && Oe.type !== S[ve - 1].type)
          throw new Error("Cannot mix points.");
        J[ve] = null, X[ve] = null, re = Math.max(re, Ie.bitLength() + 1);
      }
      let ae = null, de = null, ge = 0;
      for (let ve = 0; ve < Y; ve++) {
        const Oe = S[ve], Ie = M[ve], Re = Oe._getNAF(0);
        if (Re) {
          J[ge] = Re.points, X[ge] = dt(Ie, Re.width, re), ge += 1;
          continue;
        }
        if (!ae) {
          ae = Oe, de = Ie;
          continue;
        }
        J[ge] = ae._getJNAF(Oe), X[ge] = Z(de, Ie, re), ae = null, de = null, ge += 1;
      }
      if (ae) {
        const ve = ae._safeNAF(u);
        J[ge] = ve.points, X[ge] = dt(de, ve.width, re), ge += 1;
      }
      let Be = this.jpoint();
      for (let ve = re - 1; ve >= 0; ve--) {
        ve !== re - 1 && (Be = Be.dbl());
        for (let Oe = 0; Oe < ge; Oe++) {
          const Ie = X[Oe][ve];
          Ie > 0 ? Be = Be.add(J[Oe][Ie - 1 >> 1]) : Ie < 0 && (Be = Be.sub(J[Oe][-Ie - 1 >> 1]));
        }
      }
      return Be;
    }
    _endoWnafMulAdd(u, S) {
      throw new Error("Not implemented.");
    }
    _scale(u, S) {
      switch (L(u instanceof c), L(u.p.eq(this.p)), u.type) {
        case "short":
          return this._scaleShort(u, S);
        case "mont":
          return this._scaleMont(u, S);
        case "edwards":
          return this._scaleEdwards(u, S);
        default:
          throw new Error("Not implemented.");
      }
    }
    _scaleShort(u, S) {
      throw new Error("Not implemented.");
    }
    _scaleMont(u, S) {
      throw new Error("Not implemented.");
    }
    _scaleEdwards(u, S) {
      throw new Error("Not implemented.");
    }
    isElliptic() {
      throw new Error("Not implemented.");
    }
    jinv() {
      throw new Error("Not implemented.");
    }
    isComplete() {
      return !1;
    }
    precompute(u) {
      return L(!this.g.isInfinity(), "Must have base point."), L(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), u), this;
    }
    scalar(u, S, M) {
      const Y = new e(u, S, M);
      return L(!Y.red), this.n.isZero() ? Y : Y.imod(this.n);
    }
    field(u, S, M) {
      const Y = e.cast(u, S, M);
      return Y.red ? Y.forceRed(this.red) : Y.toRed(this.red);
    }
    point(u, S) {
      throw new Error("Not implemented.");
    }
    jpoint(u, S, M) {
      throw new Error("Not implemented.");
    }
    xpoint(u, S) {
      throw new Error("Not implemented.");
    }
    cpoint(u, S, M, Y) {
      if (L(u instanceof e), L(S instanceof e), L(M instanceof e), L(Y instanceof e), S.isZero() || Y.isZero())
        return this.point();
      const J = S.redMul(Y).redInvert(), X = u.redMul(Y).redMul(J), re = M.redMul(S).redMul(J);
      return this.point(X, re);
    }
    solveX2(u) {
      throw new Error("Not implemented.");
    }
    solveX(u) {
      return this.solveX2(u).redSqrt();
    }
    solveY2(u) {
      throw new Error("Not implemented.");
    }
    solveY(u) {
      return this.solveY2(u).redSqrt();
    }
    validate(u) {
      throw new Error("Not implemented.");
    }
    pointFromX(u, S) {
      throw new Error("Not implemented.");
    }
    pointFromY(u, S) {
      throw new Error("Not implemented.");
    }
    isIsomorphic(u) {
      throw new Error("Not implemented.");
    }
    isIsogenous(u) {
      throw new Error("Not implemented.");
    }
    pointFromShort(u) {
      throw new Error("Not implemented.");
    }
    pointFromMont(u, S) {
      throw new Error("Not implemented.");
    }
    pointFromEdwards(u) {
      throw new Error("Not implemented.");
    }
    pointFromUniform(u) {
      throw new Error("Not implemented.");
    }
    pointToUniform(u) {
      throw new Error("Not implemented.");
    }
    pointFromHash(u, S = !1) {
      if (L(Buffer.isBuffer(u)), L(typeof S == "boolean"), u.length !== this.fieldSize * 2)
        throw new Error("Invalid hash size.");
      const M = u.slice(0, this.fieldSize), Y = u.slice(this.fieldSize), J = this.decodeUniform(M), X = this.decodeUniform(Y), re = this.pointFromUniform(J), ae = this.pointFromUniform(X), de = re.add(ae);
      return S ? de.mulH() : de;
    }
    pointToHash(u, S, M) {
      L(u instanceof this.Point), L(S >>> 0 === S);
      const Y = S % this.torsion.length, J = u.add(this.torsion[Y]);
      for (; ; ) {
        const X = this.randomField(M), re = this.pointFromUniform(X);
        if (re.neg().eq(re))
          continue;
        const ae = J.sub(re), de = C(M);
        let ge;
        try {
          ge = this.pointToUniform(ae, de & 15);
        } catch (Oe) {
          if (Oe.message === "Invalid point.")
            continue;
          throw Oe;
        }
        const Be = this.encodeUniform(X, de >>> 8), ve = this.encodeUniform(ge, de >>> 16);
        return Buffer.concat([Be, ve]);
      }
    }
    randomScalar(u) {
      const S = this.n.isZero() ? this.p : this.n;
      return e.random(u, 1, S);
    }
    randomField(u) {
      return e.random(u, 1, this.p).toRed(this.red);
    }
    randomPoint(u) {
      let S;
      for (; ; ) {
        const M = this.randomField(u), Y = (C(u) & 1) !== 0;
        try {
          S = this.pointFromX(M, Y);
        } catch {
          continue;
        }
        return L(S.validate()), S.mulH();
      }
    }
    mulAll(u, S) {
      return this.jmulAll(u, S);
    }
    jmulAll(u, S) {
      return L(Array.isArray(u)), L(u.length === 0 || u[0] instanceof o), this.endo && u.length > 0 && u[0].type === t.AFFINE ? this._endoWnafMulAdd(u, S) : this._wnafMulAdd(5, u, S);
    }
    mulH(u) {
      return L(u instanceof e), this.imulH(u.clone());
    }
    imulH(u) {
      L(u instanceof e), L(!u.red);
      const S = this.h.word(0);
      if (!(S & S - 1)) {
        const M = this.h.bitLength();
        return u.iushln(M - 1).imod(this.n);
      }
      return u.imuln(S).imod(this.n);
    }
    normalizeAll(u) {
      L(Array.isArray(u));
      const S = u.length, M = new Array(S);
      for (let X = 0; X < S; X++) {
        const re = u[X];
        if (L(re instanceof o), L(re.curve === this), re.type === t.AFFINE) {
          M[X] = this.one;
          continue;
        }
        M[X] = re.z;
      }
      const Y = this.red.invertAll(M), J = new Array(S);
      for (let X = 0; X < S; X++)
        J[X] = u[X].scale(Y[X]);
      return J;
    }
    affinizeAll(u) {
      return this.normalizeAll(u);
    }
    clamp(u) {
      L(Buffer.isBuffer(u)), L(u.length === this.scalarSize), L(this.scalarSize <= this.fieldSize);
      let S = this.fieldBits & 7 || 8, M = 0, Y = this.scalarSize - 1;
      return this.endian === "be" && ([M, Y] = [Y, M]), this.scalarSize < this.fieldSize && (S = 8), u[M] &= -this.h.word(0) & 255, u[Y] &= (1 << S) - 1, u[Y] |= 1 << S - 1, u;
    }
    splitHash(u) {
      L(Buffer.isBuffer(u)), L(u.length === this.adjustedSize * 2), L(this.scalarSize <= this.adjustedSize);
      let S = 0;
      this.endian === "be" && (S = this.adjustedSize - this.scalarSize);
      const M = u.slice(S, S + this.scalarSize), Y = u.slice(this.adjustedSize);
      return this.clamp(M), [M, Y];
    }
    encodeField(u) {
      return L(u instanceof e), L(!u.red), u.encode(this.endian, this.fieldSize);
    }
    decodeField(u) {
      if (L(Buffer.isBuffer(u)), u.length !== this.fieldSize)
        throw new Error("Invalid field element size.");
      return e.decode(u, this.endian);
    }
    encodeAdjusted(u) {
      return L(u instanceof e), L(!u.red), u.encode(this.endian, this.adjustedSize);
    }
    decodeAdjusted(u) {
      if (L(Buffer.isBuffer(u)), u.length !== this.adjustedSize)
        throw new Error("Invalid field element size.");
      return e.decode(u, this.endian);
    }
    encodeScalar(u) {
      return L(u instanceof e), L(!u.red), u.encode(this.endian, this.scalarSize);
    }
    decodeScalar(u) {
      if (L(Buffer.isBuffer(u)), u.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      return e.decode(u, this.endian);
    }
    encodeClamped(u) {
      return this.clamp(this.encodeScalar(u));
    }
    decodeClamped(u) {
      if (L(Buffer.isBuffer(u)), u.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      const S = this.clamp(Buffer.from(u));
      return e.decode(S, this.endian);
    }
    encodeUniform(u, S) {
      L(u instanceof e), L(S >>> 0 === S);
      const M = this.endian === "le" ? this.fieldSize - 1 : 0, Y = u.fromRed().encode(this.endian, this.fieldSize);
      return Y[M] |= S & ~this.mask & 255, Y;
    }
    decodeUniform(u) {
      if (L(Buffer.isBuffer(u)), u.length !== this.fieldSize)
        throw new Error("Invalid field size.");
      const S = e.decode(u, this.endian);
      return S.iumaskn(this.fieldBits), S.toRed(this.red);
    }
    encodePoint(u, S) {
      return L(u instanceof o), u.encode(S);
    }
    decodePoint(u) {
      throw new Error("Not implemented.");
    }
    encodeX(u) {
      throw new Error("Not implemented.");
    }
    decodeX(u) {
      throw new Error("Not implemented.");
    }
    decodeEven(u) {
      throw new Error("Not implemented.");
    }
    decodeSquare(u) {
      throw new Error("Not implemented.");
    }
    toShort() {
      throw new Error("Not implemented.");
    }
    toMont(u) {
      throw new Error("Not implemented.");
    }
    toEdwards(u) {
      throw new Error("Not implemented.");
    }
    pointToJSON(u, S) {
      return L(u instanceof o), u.toJSON(S);
    }
    pointFromJSON(u) {
      throw new Error("Not implemented.");
    }
    toJSON(u) {
      let S, M, Y, J, X;
      return this.type === "edwards" && (S = this.prefix ? this.prefix.toString() : null, M = this.context), this.n.isZero() || (Y = this.n.toJSON()), this.z.isZero() || (J = this.z.fromRed(), this.z.redIsHigh() && J.isub(this.p), J = J.toString(16)), this.endo && (X = this.endo.toJSON()), {
        id: this.id,
        ossl: this.ossl,
        type: this.type,
        endian: this.endian,
        hash: this.hash,
        prefix: S,
        context: M,
        prime: this.prime,
        p: this.p.toJSON(),
        a: void 0,
        b: void 0,
        d: void 0,
        n: Y,
        h: this.h.toString(16),
        s: void 0,
        z: J,
        c: void 0,
        g: this.g.toJSON(u),
        endo: X
      };
    }
    static fromJSON(u) {
      return new this(u);
    }
  }
  class o {
    constructor(u, S) {
      L(u instanceof c), L(S >>> 0 === S), this.curve = u, this.type = S, this.pre = null;
    }
    _init() {
      throw new Error("Not implemented.");
    }
    _safeNAF(u) {
      if (L(u >>> 0 === u), this.pre && this.pre.naf)
        return this.pre.naf;
      if (u === 0)
        return null;
      const S = 1 << u - 2, M = new Array(S), Y = this.toJ(), J = S === 1 ? null : Y.dbl();
      M[0] = Y;
      for (let X = 1; X < S; X++)
        M[X] = M[X - 1].add(J);
      return new y(u, M);
    }
    _getNAF(u) {
      if (L(u >>> 0 === u), this.pre && this.pre.naf)
        return this.pre.naf;
      if (u === 0)
        return null;
      const S = this._safeNAF(u).points, M = this.curve.affinizeAll(S);
      return new y(u, M);
    }
    _getWindows(u, S) {
      if (L(u >>> 0 === u), L(S >>> 0 === S), this.pre && this.pre.windows)
        return this.pre.windows;
      if (u === 0)
        return null;
      const M = 1 << u, Y = (S + u - 1) / u >>> 0, J = new Array(Y * M);
      let X = this.toJ();
      for (let ae = 0; ae < Y; ae++) {
        J[ae * M] = this.curve.jpoint();
        for (let de = 1; de < M; de++)
          J[ae * M + de] = J[ae * M + de - 1].add(X);
        X = X.dblp(u);
      }
      const re = this.curve.affinizeAll(J);
      return new A(u, S, re);
    }
    _getDoubles(u, S) {
      if (L(u >>> 0 === u), L(S >>> 0 === S), this.pre && this.pre.doubles)
        return this.pre.doubles;
      if (u === 0)
        return null;
      const M = Math.ceil(S / u) + 1, Y = new Array(M);
      let J = this.toJ(), X = 0;
      Y[X++] = J;
      for (let ae = 0; ae < S; ae += u) {
        for (let de = 0; de < u; de++)
          J = J.dbl();
        Y[X++] = J;
      }
      L(X === M);
      const re = this.curve.affinizeAll(Y);
      return new _(u, re);
    }
    _getBeta() {
      return null;
    }
    _getBlinding(u) {
      if (this.pre && this.pre.blinding)
        return this.pre.blinding;
      if (!u || this.curve.n.isZero())
        return null;
      const S = this.curve.randomScalar(u), M = this.mul(S);
      return new q(S, M);
    }
    _hasWindows(u) {
      if (L(u instanceof e), !this.pre || !this.pre.windows)
        return !1;
      const { width: S, bits: M } = this.pre.windows, Y = (M + S - 1) / S >>> 0;
      return u.bitLength() <= Y * S;
    }
    _hasDoubles(u) {
      if (L(u instanceof e), !this.pre || !this.pre.doubles)
        return !1;
      const { step: S, points: M } = this.pre.doubles, Y = u.bitLength() + 1;
      return M.length >= Math.ceil(Y / S) + 1;
    }
    _getJNAF(u) {
      return L(u instanceof o), L(u.type === this.type), [
        this,
        this.add(u),
        this.sub(u),
        u
        // 7
      ];
    }
    _blind(u, S) {
      if (L(u instanceof e), L(!u.red), this.pre && this.pre.blinding) {
        const { blind: Y, unblind: J } = this.pre.blinding, X = u.sub(Y);
        return [this, X, J];
      }
      if (!S)
        return [this, u, null];
      if (this.pre) {
        if (this.curve.n.isZero())
          return [this, u, null];
        const X = this.curve.randomScalar(S).mul(this.curve.n).iadd(u);
        return [this, X, null];
      }
      return [this.randomize(S), u, null];
    }
    clone() {
      throw new Error("Not implemented.");
    }
    precompute(u, S) {
      return L(u >>> 0 === u), this.pre || (this.pre = new B()), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, u + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(S)), this;
    }
    validate() {
      return this.curve.validate(this);
    }
    normalize() {
      return this;
    }
    scale(u) {
      throw new Error("Not implemented.");
    }
    randomize(u) {
      const S = this.curve.randomField(u);
      return this.scale(S);
    }
    neg() {
      throw new Error("Not implemented.");
    }
    add(u) {
      throw new Error("Not implemented.");
    }
    sub(u) {
      return L(u instanceof o), this.add(u.neg());
    }
    dbl() {
      throw new Error("Not implemented.");
    }
    dblp(u) {
      L(u >>> 0 === u);
      let S = this;
      for (let M = 0; M < u; M++)
        S = S.dbl();
      return S;
    }
    diffAddDbl(u, S) {
      throw new Error("Not implemented.");
    }
    getX() {
      throw new Error("Not implemented.");
    }
    getY() {
      throw new Error("Not implemented.");
    }
    eq(u) {
      throw new Error("Not implemented.");
    }
    cmp(u) {
      throw new Error("Not implemented.");
    }
    isInfinity() {
      throw new Error("Not implemented.");
    }
    isOrder2() {
      throw new Error("Not implemented.");
    }
    isOdd() {
      throw new Error("Not implemented.");
    }
    isEven() {
      throw new Error("Not implemented.");
    }
    isSquare() {
      throw new Error("Not implemented.");
    }
    eqX(u) {
      throw new Error("Not implemented.");
    }
    eqR(u) {
      throw new Error("Not implemented.");
    }
    isSmall() {
      return this.isInfinity() ? !1 : this.jmulH().isInfinity();
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity();
    }
    order() {
      const { h: u, n: S } = this.curve;
      let M = this.toJ(), Y = new e(1);
      for (; !M.isInfinity(); ) {
        if (Y.iaddn(1), Y.cmp(u) > 0) {
          Y = S.clone();
          break;
        }
        M = M.add(this);
      }
      return Y;
    }
    mul(u) {
      return this.jmul(u);
    }
    muln(u) {
      return this.jmuln(u);
    }
    mulBlind(u, S) {
      return this.jmulBlind(u, S);
    }
    mulAdd(u, S, M) {
      return this.jmulAdd(u, S, M);
    }
    mulH() {
      return this.jmulH();
    }
    div(u) {
      return this.jdiv(u);
    }
    divn(u) {
      return this.jdivn(u);
    }
    divH() {
      return this.jdivH();
    }
    jmul(u) {
      return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve.endo && this.type === t.AFFINE ? this.curve._endoWnafMulAdd([this], [u]) : this.curve._wnafMul(5, this, u);
    }
    jmuln(u) {
      return L((u | 0) === u), this.jmul(new e(u));
    }
    jmulBlind(u, S = null) {
      const [M, Y, J] = this._blind(u, S), X = M.jmul(Y);
      return J ? X.add(J) : X;
    }
    jmulAdd(u, S, M) {
      return this.curve.endo && this.type === t.AFFINE ? this.curve._endoWnafMulAdd([this, S], [u, M]) : this.curve._wnafMulAdd(5, [this, S], [u, M]);
    }
    jmulH() {
      const u = this.curve.h.word(0);
      if (!(u & u - 1)) {
        const S = this.curve.h.bitLength();
        return this.toJ().dblp(S - 1);
      }
      return this.jmul(this.curve.h);
    }
    jdiv(u) {
      return L(u instanceof e), L(!u.red), this.jmul(u.invert(this.curve.n));
    }
    jdivn(u) {
      return L(!this.curve.n.isZero()), this.curve.h.cmpn(u) === 0 ? this.jdivH() : this.jdiv(new e(u));
    }
    jdivH() {
      return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi));
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const u = this.getX().toString(16), S = this.getY().toString(16);
      return `${this.curve.uid}:${u},${S}`;
    }
    encode(u) {
      throw new Error("Not implemented.");
    }
    static decode(u, S) {
      throw new Error("Not implemented.");
    }
    encodeX() {
      throw new Error("Not implemented.");
    }
    static decodeX(u, S) {
      throw new Error("Not implemented.");
    }
    static decodeEven(u, S) {
      throw new Error("Not implemented.");
    }
    static decodeSquare(u, S) {
      throw new Error("Not implemented.");
    }
    toJSON(u) {
      throw new Error("Not implemented.");
    }
    static fromJSON(u, S) {
      throw new Error("Not implemented.");
    }
    [r]() {
      return "<Point>";
    }
  }
  class d extends c {
    constructor(u) {
      super(l, "short", u), this.a = e.fromJSON(u.a).toRed(this.red), this.b = e.fromJSON(u.b).toRed(this.red), this.c = e.fromJSON(u.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(u);
    }
    _finalize(u) {
      return super._finalize(u), u.endo != null ? this.endo = U.fromJSON(this, u.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this;
    }
    static _isomorphism(u, S, M, Y) {
      if (L(u instanceof e), L(S instanceof e), L(M instanceof e), L(Y == null || typeof Y == "boolean"), L(!u.isZero() || !S.isZero()), M.isZero())
        throw new Error("Invalid coefficient.");
      if (u.isZero()) {
        const Be = M, ve = Be.redDiv(S), Oe = v(ve);
        return L(Oe.redJacobi() === 1), [u.clone(), Be.clone()];
      }
      if (S.isZero()) {
        const Be = M, Oe = Be.redDiv(u).redSqrt();
        if (Oe.redJacobi() !== 1 && Oe.redINeg(), Oe.redJacobi() !== 1)
          throw new Error("Invalid `a` coefficient.");
        return [Be.clone(), S.clone()];
      }
      const J = M, X = J.redDiv(u), re = X.redSqrt();
      if (Y != null ? re.redIsOdd() !== Y && re.redINeg() : re.redJacobi() !== 1 && re.redINeg(), re.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      const ae = X.redMul(re), de = u.redMul(X), ge = S.redMul(ae);
      return L(de.eq(J)), [de, ge];
    }
    _short(u, S) {
      return d._isomorphism(this.a, this.b, u, S);
    }
    _mont(u, S) {
      const [M, Y] = this._findRS(S), J = Y.redInvert(), X = M.redMuln(3).redMul(J);
      return u != null ? x._isomorphism(X, J, u) : [X, J];
    }
    _edwards(u, S) {
      const [M, Y] = this._findRS(S), J = M.redMuln(3), X = Y.redMuln(2), re = J.redAdd(X), ae = J.redSub(X);
      return u != null ? w._isomorphism(re, ae, u) : [re, ae];
    }
    _findRS(u) {
      L(u == null || typeof u == "boolean"), L(this.h.word(0) >= 4), L(!this.n.isZero());
      const S = this.one.redNeg();
      let M;
      for (; ; ) {
        S.redIAdd(this.one);
        try {
          M = this.pointFromX(S.clone());
        } catch {
          continue;
        }
        if (M = M.mul(this.n), !M.isInfinity() && M.y.isZero())
          break;
      }
      const Y = M.x, X = Y.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
      return u != null && X.redIsOdd() !== u && X.redINeg(), [Y, X];
    }
    _scale0(u, S) {
      if (L(this.a.isZero() === u.isZero()), L(this.b.isZero() === S.isZero()), this.a.isZero()) {
        const ae = this.b.redDiv(this.field(S)), de = v(ae), ge = de.redSqrt(), Be = de.redMul(ge);
        return L(Be.redSqr().eq(ae)), L(!ge.isZero()), [de, Be];
      }
      if (this.b.isZero()) {
        const ae = this.a.redDiv(this.field(u)), de = ae.redSqrt();
        de.redJacobi() !== 1 && de.redINeg();
        const ge = de.redSqrt(), Be = de.redMul(ge);
        return L(Be.redMul(ge).eq(ae)), L(!ge.isZero()), [de, Be];
      }
      const M = this.a.redDiv(this.field(u)), Y = this.b.redDiv(this.field(S)), J = M.redSqrt();
      M.redMul(J).eq(Y) || J.redINeg(), L(M.redMul(J).eq(Y));
      const X = J.redSqrt(), re = J.redMul(X);
      return L(!X.isZero()), [J, re];
    }
    _scale1(u, S) {
      const M = this.g.x.redDiv(this.field(u)), Y = this.g.y.redDiv(this.field(S)), J = M.redSqrt();
      return M.redMul(J).eq(Y) || J.redINeg(), L(M.redMul(J).eq(Y)), L(!J.isZero()), [M, Y];
    }
    _scaleShort(u) {
      return L(u instanceof d), this.g.isInfinity() || u.g.isInfinity() ? this._scale0(u.a, u.b) : this._scale1(u.g.x, u.g.y);
    }
    _scaleMont(u) {
      if (L(u instanceof x), this.g.isInfinity() || u.g.isInfinity()) {
        const [X, re] = u._short();
        return this._scale0(X, re);
      }
      const { x: S, y: M } = u.g, Y = S.redAdd(u.a3).redMul(u.bi), J = M.redMul(u.bi);
      return this._scale1(Y, J);
    }
    _scaleEdwards(u) {
      if (L(u instanceof w), this.g.isInfinity() || u.g.isInfinity()) {
        const [Le, He] = u._short();
        return this._scale0(Le, He);
      }
      const { x: S, y: M, z: Y } = u.g, J = u.a.redMuln(5), X = u.d.redMuln(5), re = u.d.redSub(u.a), ae = X.redSub(u.a), de = u.d.redSub(J), ge = M.redAdd(Y), Be = M.redSub(Y), ve = ae.redMul(M).redIAdd(de.redMul(Y)), Oe = Be.redMuln(12), Ie = re.redMul(ge).redMul(Y), Re = Be.redMul(S).redIMuln(4), ft = Oe.redMul(Re).redInvert(), Ye = ve.redMul(Re).redMul(ft), Fe = Ie.redMul(Oe).redMul(ft);
      return this._scale1(Ye, Fe);
    }
    _getEndomorphism(u = 0) {
      if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
        return null;
      const [S, M] = this._getEndoRoots(this.p), Y = [S, M][u & 1].toRed(this.red), [J, X] = this._getEndoRoots(this.n), re = this.point(this.g.x.redMul(Y), this.g.y);
      let ae;
      this.g.mul(J).eq(re) ? ae = J : (L(this.g.mul(X).eq(re)), ae = X);
      const de = this._getEndoBasis(ae), ge = this._getEndoPrecomp(de);
      return new U(Y, ae, de, ge);
    }
    _getEndoRoots(u) {
      const S = u === this.p ? this.red : e.mont(u), M = new e(2).toRed(S), Y = new e(3).toRed(S), J = M.redInvert(), X = Y.redNeg().redSqrt().redMul(J), re = X.redNeg(), ae = X.redSub(J).fromRed(), de = re.redSub(J).fromRed();
      return [ae, de].sort(e.cmp);
    }
    _getEndoBasis(u) {
      const [S, M, Y, J, X, re] = this._egcdSqrt(u), ae = Y, de = J.neg(), ge = S.sqr().iadd(M.sqr()), Be = X.sqr().iadd(re.sqr());
      let ve, Oe;
      return ge.cmp(Be) <= 0 ? (ve = S, Oe = M.neg()) : (ve = X, Oe = re.neg()), [
        new z(ae, de),
        new z(ve, Oe)
      ];
    }
    _egcdSqrt(u) {
      L(u instanceof e), L(!u.red), L(u.sign() > 0), L(this.n.sign() > 0);
      const S = this.n.ushrn(this.n.bitLength() >>> 1);
      let M = u, Y = this.n.clone(), J = new e(1), X = new e(0), re = new e(0), ae = new e(1), de, ge, Be, ve, Oe = 0, Ie = 0, Re;
      for (; !M.isZero() && Oe < 2; ) {
        const Fe = Y.quo(M), Le = Y.sub(Fe.mul(M)), He = re.sub(Fe.mul(J)), et = ae.sub(Fe.mul(X));
        Ie === 0 && Le.cmp(S) < 0 && (de = Re, ge = J, Be = Le, ve = He, Ie = 1), Re = Le, Y = M, M = Le, re = J, J = He, ae = X, X = et, Oe += Ie;
      }
      return L(Ie !== 0, "Could not find r < sqrt(n)."), [
        de,
        ge,
        Be,
        ve,
        re,
        J
      ];
    }
    _getEndoPrecomp(u) {
      L(Array.isArray(u)), L(u.length === 2), L(u[0] instanceof z), L(u[1] instanceof z);
      const [S, M] = u, Y = S.a.mul(M.b).isub(S.b.mul(M.a)), J = Y.bitLength(), X = J >= 160;
      L(Y.eq(this.n));
      let re = J + Math.ceil(J / 2) + 1, ae, de;
      for (X && (re -= re & 63); re > J && (ae = M.b.ushln(re).divRound(Y), de = S.b.ushln(re).divRound(Y), !(ae.ucmp(Y) < 0 && de.ucmp(Y) < 0)); )
        X ? re -= 64 : re -= 1;
      if (re <= J)
        throw new Error("Could not calculate g1 and g2.");
      return [re, ae, de];
    }
    _endoSplit(u) {
      L(u instanceof e), L(!u.red), L(!this.n.isZero());
      const [S, M] = this.endo.basis, Y = M.b.mul(u).divRound(this.n), J = S.b.neg().mul(u).divRound(this.n), X = Y.mul(S.a), re = J.mul(M.a), ae = Y.ineg().mul(S.b), de = J.mul(M.b), ge = u.sub(X).isub(re), Be = ae.isub(de);
      return [ge, Be];
    }
    _endoBeta(u) {
      return L(u instanceof l), [u, u._getBeta()];
    }
    _endoWnafMulAdd(u, S) {
      L(Array.isArray(u)), L(Array.isArray(S)), L(u.length === S.length), L(this.endo != null);
      const M = u.length, Y = new Array(M * 2), J = new Array(M * 2);
      for (let X = 0; X < M; X++) {
        const [re, ae] = this._endoBeta(u[X]), [de, ge] = this._endoSplit(S[X]);
        Y[X * 2 + 0] = re, J[X * 2 + 0] = de, Y[X * 2 + 1] = ae, J[X * 2 + 1] = ge;
      }
      return this._wnafMulAdd(5, Y, J);
    }
    _sswu(u) {
      const { b: S, z: M, ai: Y, zi: J, one: X } = this, re = M.redSqr(), ae = S.redNeg().redMul(Y), de = S.redMul(J).redMul(Y), ge = u.redSqr(), Be = ge.redSqr(), ve = re.redMul(Be).redIAdd(M.redMul(ge)), Oe = ve.isZero() ? ve : ve.redInvert(), Ie = Oe.isZero() ? de : ae.redMul(X.redAdd(Oe)), Re = M.redMul(ge).redMul(Ie), ft = this.solveY2(Ie), Ye = this.solveY2(Re), Fe = ft.redIsSquare() | 0, Le = [Ie, Re][Fe ^ 1], He = [ft, Ye][Fe ^ 1].redSqrt();
      return He.redIsOdd() !== u.redIsOdd() && He.redINeg(), this.point(Le, He);
    }
    _sswui(u, S) {
      const { a: M, b: Y, z: J } = this, { x: X, y: re } = u, ae = S & 3, de = M.redSqr().redMul(X.redSqr()), ge = M.redMul(Y).redMul(X).redIMuln(2), Be = Y.redSqr().redMuln(3), ve = M.redMul(X).redIAdd(Y), Oe = de.redISub(ge).redISub(Be).redSqrt(), Ie = ve.redSub(Oe).redINeg(), Re = ve.redAdd(Oe).redINeg(), ft = ve.redMul(J).redIMuln(2), Ye = Y.redMul(J).redIMuln(2), Fe = [Ie, Re][ae & 1], Le = [ft, Ye][ae >>> 1], He = Fe.redDivSqrt(Le);
      return He.redIsOdd() !== re.redIsOdd() && He.redINeg(), He;
    }
    _svdwf(u) {
      const { c: S, z: M, zi: Y, i2: J, i3: X } = this, re = this.solveY2(M), ae = X.redMul(Y.redSqr()), de = u.redSqr(), ge = de.redSqr(), Be = de.redAdd(re), ve = de.redMul(Be), Oe = ve.isZero() ? ve : ve.redInvert(), Ie = ge.redMul(Oe).redMul(S), Re = Be.redSqr().redMul(Be), ft = S.redSub(M).redMul(J).redISub(Ie), Ye = Ie.redSub(S.redAdd(M).redMul(J)), Fe = M.redSub(Re.redMul(Oe).redMul(ae)), Le = this.solveY2(ft), He = this.solveY2(Ye), et = this.solveY2(Fe), xr = Le.redJacobi() | 1, tt = He.redJacobi() | 1, it = s((xr - 1) * tt, 3), Ht = [ft, Ye, Fe][it], Qe = [Le, He, et][it];
      return [Ht, Qe];
    }
    _svdw(u) {
      const [S, M] = this._svdwf(u), Y = M.redSqrt();
      return Y.redIsOdd() !== u.redIsOdd() && Y.redINeg(), this.point(S, Y);
    }
    _svdwi(u, S) {
      const { b: M, c: Y, z: J, zero: X, two: re } = this, { x: ae, y: de } = u, ge = S & 3, Be = J.redSqr(), ve = Be.redMul(J), Oe = Be.redSqr(), Ie = ve.redAdd(M), Re = Ie.redMuln(2), ft = ae.redSqr(), Ye = ae.redMuln(2).redIAdd(J), Fe = ae.redMul(Be), Le = Y.redSub(Ye), He = Y.redAdd(Ye), et = ft.redMul(Be).redIAdd(Oe).redIMuln(9), xr = ae.redMul(ve).redIMuln(18), tt = Ie.redMul(ae.redSub(J)).redIMuln(12), Ht = (ge >= 2 ? et.redISub(xr).redIAdd(tt).redSqrt() : X).redMul(J), Qe = ve.redISub(Fe).redIMuln(3).redISub(Re), st = Ie.redMul(Le), s0 = Ie.redMul(He), ct = Qe.redAdd(Ht), Xe = Qe.redSub(Ht), qr = re, bt = [st, s0, ct, Xe][ge], Ge = [He, Le, qr, qr][ge], I0 = bt.redDivSqrt(Ge), [pt] = this._svdwf(I0);
      if (!pt.eq(ae))
        throw new Error("Invalid point.");
      return I0.redIsOdd() !== de.redIsOdd() && I0.redINeg(), I0;
    }
    isElliptic() {
      const { a: u, b: S } = this, Y = u.redSqr().redMul(u);
      return !S.redSqr().redMuln(27).redIAdd(Y.redMuln(4)).isZero();
    }
    jinv() {
      const { a: u, b: S } = this, Y = u.redSqr().redMul(u), J = S.redSqr(), X = Y.redMuln(4), re = X.redMuln(1728), ae = J.redMuln(27).redIAdd(X);
      if (ae.isZero())
        throw new Error("Curve is not elliptic.");
      return re.redDiv(ae).fromRed();
    }
    point(u, S) {
      return new l(this, u, S);
    }
    jpoint(u, S, M) {
      return new h(this, u, S, M);
    }
    solveX(u) {
      if (L(u instanceof e), !this.a.isZero())
        throw new Error("Not implemented.");
      const M = u.redSqr().redSub(this.b);
      return p(M);
    }
    solveY2(u) {
      L(u instanceof e);
      const M = u.redSqr().redMul(u).redIAdd(this.b);
      return this.zeroA || (this.threeA ? M.redIAdd(u.redMuln(-3)) : M.redIAdd(this.a.redMul(u))), M;
    }
    validate(u) {
      if (L(u instanceof l), u.inf)
        return !0;
      const { x: S, y: M } = u, Y = this.solveY2(S);
      return M.redSqr().eq(Y);
    }
    pointFromX(u, S = null) {
      L(u instanceof e), L(S == null || typeof S == "boolean"), u.red || (u = u.toRed(this.red));
      const M = this.solveY(u);
      if (S != null) {
        if (this.h.cmpn(1) > 0 && M.isZero() && S)
          throw new Error("Invalid point.");
        M.redIsOdd() !== S && M.redINeg();
      }
      return this.point(u, M);
    }
    pointFromY(u, S = 0) {
      L(u instanceof e), L(S >>> 0 === S), u.red || (u = u.toRed(this.red));
      const M = this.solveX(u);
      if (S >= M.length)
        throw new Error("Invalid X coordinate index.");
      const Y = M[S];
      return this.point(Y, u);
    }
    isIsomorphic(u) {
      if (L(u instanceof c), !u.p.eq(this.p))
        return !1;
      let S, M;
      try {
        [S, M] = this._scale(u);
      } catch {
        return !1;
      }
      if (u.type === "short") {
        const Y = this.field(u.a).redMul(S.redSqr()), J = this.field(u.b).redMul(M.redSqr());
        return this.a.eq(Y) && this.b.eq(J);
      }
      if (u.type === "mont") {
        const { a3: Y, bi: J } = u, X = this.field(Y.redMul(J)).redMul(S);
        return this.solveY2(X).isZero();
      }
      if (u.type === "edwards") {
        const Y = this.field(u.ad6).redMul(S);
        return this.solveY2(Y).isZero();
      }
      return !1;
    }
    isIsogenous(u) {
      return L(u instanceof c), !1;
    }
    pointFromShort(u) {
      if (L(u instanceof l), this.isIsomorphic(u.curve)) {
        if (u.isInfinity())
          return this.point();
        const [S, M] = this._scale(u.curve), Y = this.field(u.x), J = this.field(u.y), X = Y.redMul(S), re = J.redMul(M);
        return this.point(X, re);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(u) {
      if (L(u instanceof b), this.isIsomorphic(u.curve)) {
        if (u.isInfinity())
          return this.point();
        const { a3: S, bi: M } = u.curve, [Y, J] = this._scale(u.curve), X = u.x.redAdd(S).redMul(M), re = u.y.redMul(M);
        return this.point(this.field(X).redMul(Y), this.field(re).redMul(J));
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(u) {
      if (L(u instanceof I), this.isIsomorphic(u.curve)) {
        const { a: S, d: M, ad6: Y } = u.curve, [J, X] = this._scale(u.curve);
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero()) {
          const et = this.field(Y).redMul(J);
          return this.point(et, this.zero);
        }
        const { x: re, y: ae, z: de } = u, ge = S.redMuln(5), Be = M.redMuln(5), ve = M.redSub(S), Oe = Be.redSub(S), Ie = M.redSub(ge), Re = ae.redAdd(de), ft = ae.redSub(de), Ye = Oe.redMul(ae).redIAdd(Ie.redMul(de)), Fe = ft.redMuln(12), Le = ve.redMul(Re).redMul(de), He = ft.redMul(re).redIMuln(4);
        return this.cpoint(this.field(Ye).redMul(J), this.field(Fe), this.field(Le).redMul(X), this.field(He));
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(u) {
      if (L(u instanceof e), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (!this.a.isZero())
        return this._sswu(u);
      if (!this.c.isZero())
        return this._svdw(u);
      throw new Error("Not implemented.");
    }
    pointToUniform(u, S) {
      if (L(u instanceof l), L(S >>> 0 === S), this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (u.isInfinity())
        throw new Error("Invalid point.");
      const M = (S >>> 4 & 15) % this.torsion.length, Y = u.add(this.torsion[M]);
      return oe(() => {
        if (!this.a.isZero())
          return this._sswui(Y, S);
        if (!this.c.isZero())
          return this._svdwi(Y, S);
        throw new Error("Not implemented.");
      });
    }
    mulAll(u, S) {
      return super.mulAll(u, S).toP();
    }
    affinizeAll(u) {
      const S = this.normalizeAll(u);
      for (let M = 0; M < S.length; M++)
        S[M] = S[M].toP();
      return S;
    }
    decodePoint(u) {
      return l.decode(this, u);
    }
    encodeX(u) {
      return L(u instanceof o), u.encodeX();
    }
    decodeEven(u) {
      return l.decodeEven(this, u);
    }
    decodeSquare(u) {
      return l.decodeSquare(this, u);
    }
    toShort(u, S, M = null) {
      const [Y, J] = this._short(u, S), X = new d({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        b: J,
        n: this.n,
        h: this.h
      });
      if (M != null) {
        const [, re] = X._scale(this);
        re.redIsOdd() !== M && re.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromShort(this.g));
      for (let re = 0; re < this.h.word(0); re++)
        X.torsion[re] = X.pointFromShort(this.torsion[re]);
      return X;
    }
    toMont(u, S, M = null) {
      const [Y, J] = this._mont(u, S), X = new x({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        b: J,
        n: this.n,
        h: this.h
      });
      if (M != null) {
        const [, re] = this._scale(X);
        re.redIsOdd() !== M && re.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromShort(this.g));
      for (let re = 0; re < this.h.word(0); re++)
        X.torsion[re] = X.pointFromShort(this.torsion[re]);
      return X;
    }
    toEdwards(u, S, M = null) {
      const [Y, J] = this._edwards(u, S), X = new w({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        d: J,
        n: this.n,
        h: this.h
      });
      if (M != null) {
        const [, re] = this._scale(X);
        re.redIsOdd() !== M && re.redINeg();
      }
      if (this.g.isInfinity() || (X.g = X.pointFromShort(this.g), X.g.normalize()), X.isComplete())
        for (let re = 0; re < this.h.word(0); re++)
          X.torsion[re] = X.pointFromShort(this.torsion[re]), X.torsion[re].normalize();
      return X;
    }
    pointFromJSON(u) {
      return l.fromJSON(this, u);
    }
    toJSON(u) {
      const S = super.toJSON(u);
      return S.a = this.a.fromRed().toJSON(), S.b = this.b.fromRed().toJSON(), this.c.isZero() || (S.c = this.c.fromRed().toJSON()), S;
    }
  }
  class l extends o {
    constructor(u, S, M) {
      L(u instanceof d), super(u, t.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, S != null && this._init(S, M);
    }
    _init(u, S) {
      L(u instanceof e), L(S instanceof e), this.x = u, this.y = S, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    _getBeta() {
      if (!this.curve.endo)
        return null;
      if (this.pre && this.pre.beta)
        return this.pre.beta;
      const u = this.x.redMul(this.curve.endo.beta), S = this.curve.point(u, this.y);
      return this.pre && (S.pre = this.pre.map((M) => {
        const Y = M.x.redMul(this.curve.endo.beta);
        return this.curve.point(Y, M.y);
      }), this.pre.beta = S), S;
    }
    _getJNAF(u) {
      if (L(u instanceof l), this.inf || u.inf)
        return super._getJNAF(u);
      const S = [
        this,
        null,
        null,
        u
        // 7
      ];
      return this.y.eq(u.y) ? (S[1] = this.add(u), S[2] = this.toJ().sub(u)) : this.y.eq(u.y.redNeg()) ? (S[1] = this.toJ().add(u), S[2] = this.sub(u)) : (S[1] = this.toJ().add(u), S[2] = this.toJ().sub(u)), S;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(u) {
      return this.toJ().scale(u);
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(u) {
      if (L(u instanceof l), this.inf)
        return u;
      if (u.inf)
        return this;
      if (this.x.eq(u.x))
        return this.y.eq(u.y) ? this.dbl() : this.curve.point();
      if (this.y.eq(u.y)) {
        const re = this.x.redNeg().redISub(u.x), ae = this.y.redNeg();
        return this.curve.point(re, ae);
      }
      const S = this.x.redSub(u.x), Y = this.y.redSub(u.y).redDiv(S), J = Y.redSqr().redISub(this.x).redISub(u.x), X = Y.redMul(this.x.redSub(J)).redISub(this.y);
      return this.curve.point(J, X);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const S = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), M = this.y.redMuln(2), Y = S.redDiv(M), J = Y.redSqr().redISub(this.x).redISub(this.x), X = Y.redMul(this.x.redSub(J)).redISub(this.y);
      return this.curve.point(J, X);
    }
    dblp(u) {
      return this.toJ().dblp(u).toP();
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(u) {
      return L(u instanceof l), this === u ? !0 : this.inf ? u.inf : u.inf ? !1 : this.x.eq(u.x) && this.y.eq(u.y);
    }
    cmp(u) {
      return L(u instanceof l), this.inf && !u.inf ? -1 : !this.inf && u.inf ? 1 : this.inf && u.inf ? 0 : this.order().cmp(u.order()) || this.getX().cmp(u.getX()) || this.getY().cmp(u.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    isSquare() {
      return this.inf ? !1 : this.y.redJacobi() !== -1;
    }
    eqX(u) {
      return L(u instanceof e), L(!u.red), this.inf ? !1 : this.getX().eq(u);
    }
    eqR(u) {
      return L(u instanceof e), L(!u.red), L(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(u);
    }
    mul(u) {
      return super.mul(u).toP();
    }
    muln(u) {
      return super.muln(u).toP();
    }
    mulBlind(u, S) {
      return super.mulBlind(u, S).toP();
    }
    mulAdd(u, S, M) {
      return super.mulAdd(u, S, M).toP();
    }
    mulH() {
      return super.mulH().toP();
    }
    div(u) {
      return super.div(u).toP();
    }
    divn(u) {
      return super.divn(u).toP();
    }
    divH() {
      return super.divH().toP();
    }
    toP() {
      return this;
    }
    toJ() {
      return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one);
    }
    encode(u) {
      u == null && (u = !0), L(typeof u == "boolean");
      const { fieldSize: S } = this.curve;
      if (this.inf)
        throw new Error("Invalid point.");
      if (u) {
        const X = Buffer.alloc(1 + S), re = this.curve.encodeField(this.getX());
        return X[0] = 2 | this.y.redIsOdd(), re.copy(X, 1), X;
      }
      const M = Buffer.alloc(1 + S * 2), Y = this.curve.encodeField(this.getX()), J = this.curve.encodeField(this.getY());
      return M[0] = 4, Y.copy(M, 1), J.copy(M, 1 + S), M;
    }
    static decode(u, S) {
      L(u instanceof d), L(Buffer.isBuffer(S));
      const M = u.fieldSize;
      if (S.length < 1 + M)
        throw new Error("Not a point.");
      const Y = S[0];
      switch (Y) {
        case 2:
        case 3: {
          if (S.length !== 1 + M)
            throw new Error("Invalid point size for compressed.");
          const J = u.decodeField(S.slice(1, 1 + M));
          if (J.cmp(u.p) >= 0)
            throw new Error("Invalid point.");
          const X = u.pointFromX(J, Y === 3);
          return L(!X.isInfinity()), X;
        }
        case 4:
        case 6:
        case 7: {
          if (S.length !== 1 + M * 2)
            throw new Error("Invalid point size for uncompressed.");
          const J = u.decodeField(S.slice(1, 1 + M)), X = u.decodeField(S.slice(1 + M, 1 + 2 * M));
          if (J.cmp(u.p) >= 0 || X.cmp(u.p) >= 0)
            throw new Error("Invalid point.");
          if (Y !== 4 && Y !== (6 | X.isOdd()))
            throw new Error("Invalid hybrid encoding.");
          const re = u.point(J, X);
          if (!re.validate())
            throw new Error("Invalid point.");
          return L(!re.isInfinity()), re;
        }
        default:
          throw new Error("Unknown point format.");
      }
    }
    encodeX() {
      return this.curve.encodeField(this.getX());
    }
    static decodeEven(u, S) {
      L(u instanceof d);
      const M = u.decodeField(S);
      if (M.cmp(u.p) >= 0)
        throw new Error("Invalid point.");
      return u.pointFromX(M, !1);
    }
    static decodeSquare(u, S) {
      L(u instanceof d);
      const M = u.decodeField(S);
      if (M.cmp(u.p) >= 0)
        throw new Error("Invalid point.");
      return u.pointFromX(M);
    }
    toJSON(u) {
      if (this.inf)
        return [];
      const S = this.getX().toJSON(), M = this.getY().toJSON();
      return u === !0 && this.pre ? [S, M, this.pre.toJSON()] : [S, M];
    }
    toPretty() {
      if (this.inf)
        return [];
      const u = this.curve.fieldSize * 2, S = O(this.getX(), u), M = O(this.getY(), u);
      return [S, M];
    }
    static fromJSON(u, S) {
      if (L(u instanceof d), L(Array.isArray(S)), L(S.length === 0 || S.length === 2 || S.length === 3), S.length === 0)
        return u.point();
      const M = e.fromJSON(S[0]), Y = e.fromJSON(S[1]), J = u.point(M, Y);
      return S.length > 2 && S[2] != null && (J.pre = B.fromJSON(J, S[2])), J;
    }
    [r]() {
      return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class h extends o {
    constructor(u, S, M, Y) {
      L(u instanceof d), super(u, t.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, S != null && this._init(S, M, Y);
    }
    _init(u, S, M) {
      L(u instanceof e), L(S instanceof e), L(M == null || M instanceof e), this.x = u, this.y = S, this.z = M || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one);
    }
    clone() {
      return this.curve.jpoint(this.x, this.y, this.z);
    }
    validate() {
      const { a: u, b: S } = this.curve;
      if (this.isInfinity())
        return !0;
      if (this.zOne)
        return this.curve.validate(this.toP());
      const M = this.y.redSqr(), Y = this.x.redSqr().redMul(this.x), J = this.z.redSqr(), X = J.redSqr(), re = X.redMul(J), ae = Y.redIAdd(S.redMul(re));
      return this.curve.zeroA || (this.curve.threeA ? ae.redIAdd(X.redIMuln(-3).redMul(this.x)) : ae.redIAdd(u.redMul(X).redMul(this.x))), M.eq(ae);
    }
    normalize() {
      if (this.zOne)
        return this;
      if (this.isInfinity())
        return this;
      const u = this.z.redInvert(), S = u.redSqr();
      return this.x = this.x.redMul(S), this.y = this.y.redMul(S).redMul(u), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(u) {
      if (L(u instanceof e), this.isInfinity())
        return this.curve.jpoint();
      const S = u.redSqr(), M = this.x.redMul(S), Y = this.y.redMul(S).redMul(u), J = this.z.redMul(u);
      return this.curve.jpoint(M, Y, J);
    }
    neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }
    add(u) {
      return L(u instanceof o), u.type === t.AFFINE ? this._mixedAdd(u) : this._add(u);
    }
    _add(u) {
      return L(u instanceof h), this.isInfinity() ? u : u.isInfinity() ? this : this.zOne ? u._addJA(this) : u.zOne ? this._addJA(u) : this._addJJ(u);
    }
    _mixedAdd(u) {
      return L(u instanceof l), this.isInfinity() ? u.toJ() : u.isInfinity() ? this : this._addJA(u);
    }
    _addJJ(u) {
      const S = this.z.redSqr(), M = u.z.redSqr(), Y = this.x.redMul(M), J = u.x.redMul(S), X = this.y.redMul(u.z).redMul(M), re = u.y.redMul(this.z).redMul(S), ae = J.redISub(Y), de = re.redISub(X);
      if (ae.isZero())
        return de.isZero() ? this.dbl() : this.curve.jpoint();
      const ge = ae.redSqr(), Be = ae.redMul(ge), ve = Y.redMul(ge), Oe = de.redSqr().redISub(Be).redISub(ve).redISub(ve), Ie = de.redMul(ve.redISub(Oe)).redISub(X.redMul(Be)), Re = this.z.redMul(u.z).redMul(ae);
      return this.curve.jpoint(Oe, Ie, Re);
    }
    _addJA(u) {
      const S = this.z.redSqr(), M = u.x.redMul(S), Y = u.y.redMul(this.z).redMul(S), J = M.redISub(this.x), X = Y.redISub(this.y).redIMuln(2);
      if (J.isZero())
        return X.isZero() ? this.dbl() : this.curve.jpoint();
      const re = J.redMuln(2).redSqr(), ae = J.redMul(re), de = this.x.redMul(re), ge = X.redSqr().redISub(ae).redISub(de).redISub(de), Be = X.redMul(de.redISub(ge)).redISub(this.y.redMul(ae).redIMuln(2)), ve = this.z.redMul(J).redIMuln(2);
      return this.curve.jpoint(ge, Be, ve);
    }
    dbl() {
      return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ();
    }
    _dblJ() {
      const u = this.x.redSqr(), S = this.y.redSqr(), M = this.z.redSqr(), Y = this.x.redMul(S).redIMuln(4), J = u.redIMuln(3).redIAdd(this.curve.a.redMul(M.redSqr())), X = J.redSqr().redISub(Y).redISub(Y), re = X, ae = J.redMul(Y.redISub(X)).redISub(S.redSqr().redIMuln(8)), de = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(re, ae, de);
    }
    _dbl0() {
      const u = this.x.redSqr(), S = this.y.redSqr(), M = S.redSqr(), J = S.redIAdd(this.x).redSqr().redISub(u).redISub(M).redIMuln(2), X = u.redIMuln(3), ae = X.redSqr().redISub(J).redISub(J), de = X.redMul(J.redISub(ae)).redISub(M.redIMuln(8)), ge = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(ae, de, ge);
    }
    _dbl3() {
      const u = this.z.redSqr(), S = this.y.redSqr(), M = this.x.redMul(S), Y = this.x.redSub(u), J = this.x.redAdd(u), X = Y.redMul(J).redIMuln(3), re = M.redIMuln(4), ae = re.redMuln(2), de = S.redSqr().redIMuln(8), ge = X.redSqr().redISub(ae), Be = this.y.redAdd(this.z).redSqr().redISub(S).redISub(u), ve = X.redMul(re.redISub(ge)).redISub(de);
      return this.curve.jpoint(ge, ve, Be);
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.y.fromRed();
    }
    eq(u) {
      if (L(u instanceof h), this === u)
        return !0;
      if (this.isInfinity())
        return u.isInfinity();
      if (u.isInfinity())
        return !1;
      if (this.z.eq(u.z))
        return this.x.eq(u.x) && this.y.eq(u.y);
      const S = this.z.redSqr(), M = u.z.redSqr(), Y = this.x.redMul(M), J = u.x.redMul(S);
      if (!Y.eq(J))
        return !1;
      const X = S.redMul(this.z), re = M.redMul(u.z), ae = this.y.redMul(re), de = u.y.redMul(X);
      return ae.eq(de);
    }
    cmp(u) {
      L(u instanceof h);
      const S = this.isInfinity(), M = u.isInfinity();
      return S && !M ? -1 : !S && M ? 1 : S && M ? 0 : this.order().cmp(u.order()) || this.getX().cmp(u.getX()) || this.getY().cmp(u.getY());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd());
    }
    isEven() {
      return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven());
    }
    isSquare() {
      return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1;
    }
    eqX(u) {
      if (L(u instanceof e), L(!u.red), this.isInfinity())
        return !1;
      const S = this.z.redSqr(), M = u.toRed(this.curve.red).redMul(S);
      return this.x.eq(M);
    }
    eqR(u) {
      if (L(u instanceof e), L(!u.red), !this.curve.smallGap)
        return this.toP().eqR(u);
      if (this.isInfinity() || u.cmp(this.curve.p) >= 0)
        return !1;
      const S = this.z.redSqr(), M = u.toRed(this.curve.red).redMul(S);
      if (this.x.eq(M))
        return !0;
      if (this.curve.highOrder || u.cmp(this.curve.pmodn) >= 0)
        return !1;
      const Y = this.curve.redN.redMul(S);
      return M.redIAdd(Y), this.x.eq(M);
    }
    toP() {
      return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y));
    }
    toJ() {
      return this;
    }
    encode(u) {
      return this.toP().encode(u);
    }
    static decode(u, S) {
      return l.decode(u, S).toJ();
    }
    encodeX() {
      return this.toP().encodeX();
    }
    static decodeEven(u, S) {
      return l.decodeEven(u, S).toJ();
    }
    static decodeSquare(u, S) {
      return l.decodeSquare(u, S).toJ();
    }
    toJSON(u) {
      return this.toP().toJSON(u);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(u, S) {
      return l.fromJSON(u, S).toJ();
    }
    [r]() {
      return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class x extends c {
    constructor(u) {
      super(b, "mont", u), this.a = e.fromJSON(u.a).toRed(this.red), this.b = e.fromJSON(u.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(u);
    }
    static _isomorphism(u, S, M) {
      L(u instanceof e), L(S instanceof e), L(M instanceof e);
      const Y = u.clone(), J = M.clone();
      if (S.redDiv(M).redJacobi() !== 1)
        throw new Error("Invalid `b` coefficient.");
      return [Y, J];
    }
    _short(u, S) {
      const { a: M, b: Y, three: J } = this, X = M.redSqr(), re = X.redMul(M), ae = Y.redSqr(), de = ae.redMul(Y), ge = J.redSub(X), Be = ae.redMuln(3), ve = re.redMuln(2).redISub(M.redMuln(9)), Oe = de.redMuln(27), Ie = ge.redDiv(Be), Re = ve.redDiv(Oe);
      return u != null ? d._isomorphism(Ie, Re, u, S) : [Ie, Re];
    }
    _mont(u) {
      return x._isomorphism(this.a, this.b, u);
    }
    _edwards(u, S = !1) {
      L(typeof S == "boolean");
      const { two: M, bi: Y } = this, J = this.a.redAdd(M).redMul(Y), X = this.a.redSub(M).redMul(Y);
      return S && J.swap(X), u != null ? w._isomorphism(J, X, u) : [J, X];
    }
    _scaleShort(u) {
      L(u instanceof d);
      const [S, M] = u._scale(this);
      return [
        this.field(S.redInvert()),
        this.field(M.redInvert())
      ];
    }
    _scaleMont(u) {
      return L(u instanceof x), this.g.isInfinity() || u.g.isInfinity() ? this.field(u.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(u.g.y));
    }
    _scaleEdwards(u, S) {
      L(u instanceof w);
      const M = u._scale(this, S);
      return this.field(M);
    }
    _solveY0(u) {
      L(u instanceof e);
      const S = this.a0, M = this.b0, Y = u.redSqr();
      return Y.redMul(u).redIAdd(S.redMul(Y)).redIAdd(M.redMul(u));
    }
    _elligator2(u) {
      const S = this.a0.redNeg(), M = this.one.redAdd(this.z.redMul(u.redSqr()));
      M.isZero() && M.inject(this.one);
      const Y = S.redMul(M.redInvert()), J = Y.redNeg().redISub(this.a0), X = this._solveY0(Y), re = this._solveY0(J), ae = X.redIsSquare() | 0, de = [Y, J][ae ^ 1], ge = [X, re][ae ^ 1].redSqrt();
      ge.redIsOdd() !== u.redIsOdd() && ge.redINeg();
      const Be = this.b.redMul(de), ve = this.b.redMul(ge);
      return this.point(Be, ve);
    }
    _invert2(u, S) {
      const { x: M, y: Y } = u, J = S & 1, X = M.redMul(this.bi), re = Y.redMul(this.bi), ae = X.redAdd(this.a0), de = X, ge = [ae, de][J].redINeg(), Be = [de, ae][J].redMul(this.z), ve = ge.redDivSqrt(Be);
      return ve.redIsOdd() !== re.redIsOdd() && ve.redINeg(), ve;
    }
    isElliptic() {
      const u = this.a.redSqr();
      return !this.b.redMul(u.redSub(this.four)).isZero();
    }
    jinv() {
      const { a: u, three: S, four: M } = this, Y = u.redSqr(), X = Y.redSub(S).redPown(3).redIMuln(256), re = Y.redSub(M);
      if (re.isZero())
        throw new Error("Curve is not elliptic.");
      return X.redDiv(re).fromRed();
    }
    point(u, S) {
      return new b(this, u, S);
    }
    jpoint(u, S, M) {
      return L(u == null && S == null && M == null), this.point();
    }
    xpoint(u, S) {
      return new g(this, u, S);
    }
    solveY2(u) {
      L(u instanceof e);
      const S = u.redSqr();
      return S.redMul(u).redIAdd(this.a.redMul(S)).redIAdd(u).redMul(this.bi);
    }
    validate(u) {
      if (L(u instanceof b), u.isInfinity())
        return !0;
      const { x: S, y: M } = u, Y = this.solveY2(S);
      return M.redSqr().eq(Y);
    }
    pointFromX(u, S = null) {
      L(u instanceof e), L(S == null || typeof S == "boolean"), u.red || (u = u.toRed(this.red));
      const M = this.solveY(u);
      if (S != null) {
        if (M.isZero() && S)
          throw new Error("Invalid point.");
        M.redIsOdd() !== S && M.redINeg();
      }
      return this.point(u, M);
    }
    isIsomorphic(u, S) {
      if (L(u instanceof c), !u.p.eq(this.p))
        return !1;
      if (u.type === "mont") {
        const M = this.field(u.a), Y = this.field(u.b);
        return !this.a.eq(M) || this.b.isZero() ? !1 : Y.redDiv(this.b).redJacobi() === 1;
      }
      return u.isIsomorphic(this, S);
    }
    isIsogenous(u) {
      return L(u instanceof c), u.type === "mont" ? !1 : u.isIsogenous(this);
    }
    pointFromShort(u) {
      if (L(u instanceof l), this.isIsomorphic(u.curve)) {
        if (u.isInfinity())
          return this.point();
        const { a3: S, b: M } = this, [Y, J] = this._scale(u.curve), X = this.field(u.x).redMul(Y), re = this.field(u.y).redMul(J), ae = M.redMul(X).redISub(S), de = M.redMul(re);
        return this.point(ae, de);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(u) {
      if (L(u instanceof b), this.isIsomorphic(u.curve)) {
        if (u.isInfinity())
          return this.point();
        const S = this._scale(u.curve), M = this.field(u.x), Y = this.field(u.y), J = M, X = S.redMul(Y);
        return this.point(J, X);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(u) {
      L(u instanceof I), L(u.curve.p.eq(this.p));
      const S = this.field(u.x), M = this.field(u.y), Y = this.field(u.z);
      if (this.isIsogenous(u.curve)) {
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero())
          return this.point(this.zero, this.zero);
        const J = Y.redSqr().redIMuln(2), X = M.redSqr(), re = S.redSqr(), ae = J.redISub(re).redISub(X).redMul(M), de = re.redMul(S);
        return this.cpoint(X, re, ae, de);
      }
      if (this.isIsomorphic(u.curve, !0)) {
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero())
          return this.point(this.zero, this.zero);
        const J = this._scale(u.curve, !0), X = M.redAdd(Y), re = M.redSub(Y), ae = J.redMul(Y).redMul(X), de = S.redMul(re);
        return this.cpoint(X, re, ae, de);
      }
      if (this.isIsomorphic(u.curve, !1)) {
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero())
          return this.point(this.zero, this.zero);
        const J = this._scale(u.curve, !1), X = Y.redAdd(M), re = Y.redSub(M), ae = J.redMul(Y).redMul(X), de = S.redMul(re);
        return this.cpoint(X, re, ae, de);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(u) {
      if (L(u instanceof e), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      return this._elligator2(u);
    }
    pointToUniform(u, S) {
      if (L(u instanceof b), L(S >>> 0 === S), this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      if (u.isInfinity())
        throw new Error("Invalid point.");
      const M = (S >>> 4 & 15) % this.torsion.length, Y = u.add(this.torsion[M]);
      return oe(() => this._invert2(Y, S));
    }
    decodePoint(u, S) {
      return b.decode(this, u, S);
    }
    encodeX(u) {
      return L(u instanceof g), u.encode();
    }
    decodeX(u) {
      return g.decode(this, u);
    }
    toShort(u, S, M = null) {
      const [Y, J] = this._short(u, S), X = new d({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        b: J,
        n: this.n,
        h: this.h
      });
      if (M != null) {
        const [, re] = X._scale(this);
        re.redIsOdd() !== M && re.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromMont(this.g));
      for (let re = 0; re < this.h.word(0); re++)
        X.torsion[re] = X.pointFromMont(this.torsion[re]);
      return X;
    }
    toMont(u, S = null) {
      const [M, Y] = this._mont(u), J = new x({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: M,
        b: Y,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (S != null) {
        const X = J._scale(this);
        X.redIsOdd() !== S && X.redINeg();
      }
      this.g.isInfinity() || (J.g = J.pointFromMont(this.g));
      for (let X = 0; X < this.h.word(0); X++)
        J.torsion[X] = J.pointFromMont(this.torsion[X]);
      return J;
    }
    toEdwards(u, S, M = null) {
      const [Y, J] = this._edwards(u, S), X = new w({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        d: J,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (M != null) {
        const re = X._scale(this, S);
        re.redIsOdd() !== M && re.redINeg();
      }
      if (this.g.isInfinity() || (X.g = X.pointFromMont(this.g), X.g.normalize()), X.isComplete())
        for (let re = 0; re < this.h.word(0); re++)
          X.torsion[re] = X.pointFromMont(this.torsion[re]), X.torsion[re].normalize();
      return X;
    }
    pointFromJSON(u) {
      return b.fromJSON(this, u);
    }
    toJSON(u) {
      const S = super.toJSON(u);
      return S.a = this.a.fromRed().toJSON(), S.b = this.b.fromRed().toJSON(), S;
    }
  }
  class b extends o {
    constructor(u, S, M) {
      L(u instanceof x), super(u, t.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, S != null && this._init(S, M);
    }
    _init(u, S) {
      L(u instanceof e), L(S instanceof e), this.x = u, this.y = S, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
    }
    clone() {
      return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
    }
    scale(u) {
      return this.clone();
    }
    randomize(u) {
      return this.clone();
    }
    neg() {
      return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
    }
    add(u) {
      if (L(u instanceof b), this.inf)
        return u;
      if (u.inf)
        return this;
      if (this.x.eq(u.x))
        return this.y.eq(u.y) ? this.dbl() : this.curve.point();
      const S = u.x.redSub(this.x), Y = u.y.redSub(this.y).redDiv(S), X = this.curve.b.redMul(Y.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(u.x), re = Y.redMul(this.x.redSub(X)).redISub(this.y);
      return this.curve.point(X, re);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const u = this.x.redSqr().redIMuln(3), S = this.curve.a.redMul(this.x).redIMuln(2), M = u.redIAdd(S).redIAdd(this.curve.one), Y = this.curve.b.redMul(this.y).redIMuln(2), J = M.redDiv(Y), re = this.curve.b.redMul(J.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), ae = J.redMul(this.x.redSub(re)).redISub(this.y);
      return this.curve.point(re, ae);
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(u) {
      return L(u instanceof b), this === u ? !0 : this.inf ? u.inf : u.inf ? !1 : this.x.eq(u.x) && this.y.eq(u.y);
    }
    cmp(u) {
      return L(u instanceof b), this.inf && !u.inf ? -1 : !this.inf && u.inf ? 1 : this.inf && u.inf ? 0 : this.order().cmp(u.order()) || this.getX().cmp(u.getX()) || this.getY().cmp(u.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      return this.inf ? !1 : this.y.isZero();
    }
    isOdd() {
      return this.inf ? !1 : this.y.redIsOdd();
    }
    isEven() {
      return this.inf ? !1 : this.y.redIsEven();
    }
    toP() {
      return this;
    }
    toJ() {
      return this;
    }
    toX() {
      return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one);
    }
    encode() {
      return this.toX().encode();
    }
    static decode(u, S, M) {
      return L(u instanceof x), u.decodeX(S).toP(M);
    }
    toJSON(u) {
      if (this.inf)
        return [];
      const S = this.getX().toJSON(), M = this.getY().toJSON();
      return [S, M];
    }
    toPretty() {
      if (this.inf)
        return [];
      const u = this.curve.fieldSize * 2, S = O(this.getX(), u), M = O(this.getY(), u);
      return [S, M];
    }
    static fromJSON(u, S) {
      if (L(u instanceof x), L(Array.isArray(S)), L(S.length === 0 || S.length === 2 || S.length === 3), S.length === 0)
        return u.point();
      const M = e.fromJSON(S[0]), Y = e.fromJSON(S[1]);
      return u.point(M, Y);
    }
    [r]() {
      return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  }
  class g extends o {
    constructor(u, S, M) {
      L(u instanceof x), super(u, t.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, S != null && this._init(S, M);
    }
    _init(u, S) {
      L(u instanceof e), L(S == null || S instanceof e), this.x = u, this.z = S || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red));
    }
    clone() {
      return this.curve.xpoint(this.x, this.z);
    }
    precompute(u, S) {
      return this;
    }
    validate() {
      if (this.isInfinity())
        return !0;
      const { x: u, z: S } = this, M = u.redSqr(), Y = M.redMul(u), J = S.redSqr(), X = this.curve.a.redMul(M).redMul(S);
      return Y.redIAdd(X).redIAdd(u.redMul(J)).redMul(this.curve.bi).redMul(S).redJacobi() !== -1;
    }
    normalize() {
      return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this);
    }
    scale(u) {
      if (L(u instanceof e), this.isInfinity())
        return this.curve.xpoint();
      const S = this.x.redMul(u), M = this.z.redMul(u);
      return this.curve.xpoint(S, M);
    }
    neg() {
      return this;
    }
    dbl() {
      const S = this.x.redAdd(this.z).redSqr(), Y = this.x.redSub(this.z).redSqr(), J = S.redSub(Y), X = S.redMul(Y), re = J.redMul(Y.redIAdd(this.curve.a24.redMul(J)));
      return this.curve.xpoint(X, re);
    }
    diffAddDbl(u, S) {
      L(u instanceof g), L(S instanceof g);
      const M = u.x.redAdd(u.z), Y = M.redSqr(), J = u.x.redSub(u.z), X = J.redSqr(), re = Y.redSub(X), ae = S.x.redAdd(S.z), ge = S.x.redSub(S.z).redMul(M), Be = ae.redMul(J), ve = this.z.redMul(ge.redAdd(Be).redSqr()), Oe = this.x.redMul(ge.redISub(Be).redSqr()), Ie = Y.redMul(X), Re = re.redMul(X.redIAdd(this.curve.a24.redMul(re)));
      return [
        this.curve.xpoint(Ie, Re),
        this.curve.xpoint(ve, Oe)
      ];
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      return this.normalize(), this.x.fromRed();
    }
    getY(u) {
      return this.toP(u).getY();
    }
    eq(u) {
      if (L(u instanceof g), this === u)
        return !0;
      if (this.isInfinity())
        return u.isInfinity();
      if (u.isInfinity())
        return !1;
      if (this.z.eq(u.z))
        return this.x.eq(u.x);
      const S = this.x.redMul(u.z), M = u.x.redMul(this.z);
      return S.eq(M);
    }
    cmp(u) {
      L(u instanceof g);
      const S = this.isInfinity(), M = u.isInfinity();
      return S && !M ? -1 : !S && M ? 1 : S && M ? 0 : this.order().cmp(u.order()) || this.getX().cmp(u.getX());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return !1;
    }
    isEven() {
      return !1;
    }
    hasTorsion() {
      return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion();
    }
    order() {
      try {
        return this.toP().order();
      } catch {
        return new e(1);
      }
    }
    jmul(u) {
      L(u instanceof e), L(!u.red);
      const S = u.bitLength();
      let M = this.curve.xpoint(), Y = this;
      for (let J = S - 1; J >= 0; J--)
        u.bit(J) === 0 ? [M, Y] = this.diffAddDbl(M, Y) : [Y, M] = this.diffAddDbl(Y, M);
      return M;
    }
    jmulBlind(u, S) {
      return S ? this.randomize(S).jmul(u) : this.jmul(u);
    }
    jmulAdd(u, S, M) {
      throw new Error("Not implemented.");
    }
    toP(u = null) {
      return L(u == null || typeof u == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, u));
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const u = this.getX().toString(16);
      return `${this.curve.uid}:${u}`;
    }
    encode() {
      return this.curve.encodeField(this.getX());
    }
    static decode(u, S) {
      L(u instanceof x);
      const M = u.decodeField(S);
      M.iumaskn(u.fieldBits);
      const Y = u.xpoint(M, u.one);
      return L(!Y.isInfinity()), Y;
    }
    toJSON(u) {
      return this.toP().toJSON(u);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(u, S) {
      return b.fromJSON(u, S).toX();
    }
    [r]() {
      return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class w extends c {
    constructor(u) {
      super(I, "edwards", u), this.a = e.fromJSON(u.a).toRed(this.red), this.d = e.fromJSON(u.d).toRed(this.red), this.s = e.fromJSON(u.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(u);
    }
    static _isomorphism(u, S, M) {
      L(u instanceof e), L(S instanceof e), L(M instanceof e);
      const Y = M.clone(), J = M.redMul(S).redDiv(u);
      if (u.redDiv(M).redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [Y, J];
    }
    _short(u, S) {
      const { a: M, d: Y } = this, J = M.redSqr(), X = J.redMul(M), re = Y.redSqr(), ae = re.redMul(Y), de = M.redMul(Y).redIMuln(14), ge = J.redMul(Y), Be = M.redMul(re), ve = ge.redIAdd(Be).redIMuln(33), Oe = J.redAdd(de).redIAdd(re).redDivn(-48), Ie = ve.redISub(X).redISub(ae).redDivn(864);
      return u != null ? d._isomorphism(Oe, Ie, u, S) : [Oe, Ie];
    }
    _mont(u, S = !1) {
      L(typeof S == "boolean");
      let M, Y;
      S ? (M = this.d.redAdd(this.a), Y = this.d.redSub(this.a)) : (M = this.a.redAdd(this.d), Y = this.a.redSub(this.d));
      const J = Y.redInvert(), X = M.redMuln(2).redMul(J), re = J.redMuln(4);
      return u != null ? x._isomorphism(X, re, u) : [X, re];
    }
    _edwards(u) {
      return w._isomorphism(this.a, this.d, u);
    }
    _scaleShort(u) {
      L(u instanceof d);
      const [S, M] = u._scale(this);
      return [
        this.field(S.redInvert()),
        this.field(M.redInvert())
      ];
    }
    _scaleMont(u, S = !1) {
      if (L(u instanceof x), L(typeof S == "boolean"), this.g.isInfinity() || u.g.isInfinity()) {
        const [Y] = u._edwards(null, S);
        return this.field(Y).redDivSqrt(this.a);
      }
      const M = u.g.x.redDiv(u.g.y);
      return this.g.x.redDiv(this.field(M));
    }
    _scaleEdwards(u) {
      return L(u instanceof w), this.g.isInfinity() || u.g.isInfinity() ? this.field(u.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(u.g.x));
    }
    _mulA(u) {
      return L(u instanceof e), this.oneA ? u.clone() : this.mOneA ? u.redNeg() : this.a.redMul(u);
    }
    _mulD(u) {
      return L(u instanceof e), this.smallD ? u.redMuln(this.smi) : this.d.redMul(u);
    }
    _elligator1(u) {
      const { s: S, si: M, i2: Y, one: J, two: X } = this, re = M.redSqr().redIMuln(2), ae = S.redSqr().redMul(Y), de = ae.redSqr(), ge = re.redAdd(ae), Be = ge.redSqr().redISub(X), ve = re.redSub(J), Oe = J.redSub(u), Ie = J.redAdd(u), Re = Ie.isZero() ? Ie : Oe.redDiv(Ie), ft = Re.redSqr(), Ye = ft.redMul(Re), Le = Ye.redMul(ft).redAdd(Be.redMul(Ye)).redIAdd(Re), He = this.field(Le.redJacobi()), et = this.field(ft.redAdd(de).redJacobi()), xr = He.redMul(et), tt = He.redMul(Re), it = He.redMul(Le).redSqrt().redMul(xr), Ht = J.redAdd(tt), Qe = ge.redMul(tt), st = Ht.redSqr(), s0 = ve.redMul(S).redMul(tt).redMul(Ht), ct = Re.isZero() ? this.one : it, Xe = Qe.redSub(st), qr = Qe.redAdd(st);
      return this.cpoint(s0, ct, Xe, qr);
    }
    _invert1(u, S) {
      const { s: M, si: Y, i2: J, one: X } = this, { x: re, y: ae, z: de } = u, ge = S & 1, Be = Y.redSqr().redIMuln(2), ve = M.redSqr().redMul(J), Oe = ve.redSqr(), Ie = Be.redAdd(ve), Re = Be.redSub(X), ft = ae.redSub(de), Ye = ae.redAdd(de).redIMuln(2), Fe = Ye.isZero() ? Ye : ft.redDiv(Ye), Le = X.redAdd(Fe.redMul(Ie)), xr = Le.redSqr().redISub(X).redSqrt().redSub(Le), tt = X.redAdd(xr), Ht = Re.redMul(M).redMul(xr).redMul(tt).redMul(re.redMul(de)), Qe = xr.redSqr().redIAdd(Oe), s0 = this.field(Ht.redMul(Qe).redJacobi()).redMul(xr), ct = X.redSub(s0), Xe = X.redAdd(s0), qr = Xe.isZero() ? Xe : ct.redDiv(Xe);
      return qr.redIsOdd() !== !!ge && qr.redINeg(), qr;
    }
    _alt() {
      return this.alt || (this.alt = this.toMont()), this.alt;
    }
    isElliptic() {
      const u = this.a.redMul(this.d), S = this.a.redSub(this.d);
      return !u.redMul(S).isZero();
    }
    jinv() {
      const { a: u, d: S } = this, M = u.redMul(S), Y = u.redSub(S).redPown(4), J = u.redSqr(), X = S.redSqr(), ae = J.redAdd(M.redMuln(14)).redIAdd(X).redPown(3).redIMuln(16), de = M.redMul(Y);
      if (de.isZero())
        throw new Error("Curve is not elliptic.");
      return ae.redDiv(de).fromRed();
    }
    isComplete() {
      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
    }
    point(u, S, M, Y) {
      return new I(this, u, S, M, Y);
    }
    jpoint(u, S, M) {
      return L(u == null && S == null && M == null), this.point();
    }
    cpoint(u, S, M, Y) {
      L(u instanceof e), L(S instanceof e), L(M instanceof e), L(Y instanceof e);
      const J = u.redMul(Y), X = M.redMul(S), re = S.redMul(Y), ae = u.redMul(M);
      return this.point(J, X, re, ae);
    }
    solveX2(u) {
      L(u instanceof e);
      const S = u.redSqr(), M = this._mulD(S).redISub(this.a);
      return S.redISub(this.one).redDiv(M);
    }
    solveX(u) {
      const S = u.redSqr(), M = this._mulD(S).redISub(this.a);
      return S.redISub(this.one).redDivSqrt(M);
    }
    solveY2(u) {
      L(u instanceof e);
      const S = u.redSqr(), M = this._mulA(S).redISub(this.one), Y = this._mulD(S).redISub(this.one);
      return M.redDiv(Y);
    }
    solveY(u) {
      const S = u.redSqr(), M = this._mulA(S).redISub(this.one), Y = this._mulD(S).redISub(this.one);
      return M.redDivSqrt(Y);
    }
    validate(u) {
      if (L(u instanceof I), u.zOne) {
        const Be = u.x.redSqr(), ve = u.y.redSqr(), Oe = this._mulD(Be).redMul(ve), Ie = this._mulA(Be).redIAdd(ve), Re = this.one.redAdd(Oe), ft = u.t, Ye = u.x.redMul(u.y);
        return Ie.eq(Re) && ft.eq(Ye);
      }
      const S = u.x.redSqr(), M = u.y.redSqr(), Y = u.z.redSqr(), J = Y.redSqr(), X = this._mulD(S).redMul(M), re = this._mulA(S).redIAdd(M).redMul(Y), ae = J.redIAdd(X), de = u.t.redMul(u.z), ge = u.x.redMul(u.y);
      return re.eq(ae) && de.eq(ge);
    }
    pointFromX(u, S = null) {
      L(u instanceof e), L(S == null || typeof S == "boolean"), u.red || (u = u.toRed(this.red));
      const M = this.solveY(u);
      if (S != null) {
        if (M.isZero() && S)
          throw new Error("Invalid point.");
        M.redIsOdd() !== S && M.redINeg();
      }
      return this.point(u, M);
    }
    pointFromY(u, S = null) {
      L(u instanceof e), L(S == null || typeof S == "boolean"), u.red || (u = u.toRed(this.red));
      const M = this.solveX(u);
      if (S != null) {
        if (M.isZero() && S)
          throw new Error("Invalid point.");
        M.redIsOdd() !== S && M.redINeg();
      }
      return this.point(M, u);
    }
    isIsomorphic(u, S = !1) {
      if (L(u instanceof c), L(typeof S == "boolean"), !u.p.eq(this.p))
        return !1;
      if (u.type === "short")
        return u.isIsomorphic(this);
      if (u.type === "mont") {
        const M = this.field(u.a);
        let Y, J;
        return S ? (Y = this.d.redAdd(this.a), J = this.d.redSub(this.a)) : (Y = this.a.redAdd(this.d), J = this.a.redSub(this.d)), M.redMul(J).eq(Y.redIMuln(2));
      }
      if (u.type === "edwards") {
        const M = this.field(u.a), Y = this.field(u.d);
        return this.a.redMul(Y).eq(M.redMul(this.d));
      }
      return !1;
    }
    isIsogenous(u) {
      if (L(u instanceof c), !u.p.eq(this.p))
        return !1;
      if (u.type === "mont") {
        if (!this.a.eq(this.one))
          return !1;
        const S = this.field(u.a), M = this.field(u.b), Y = this.two.redSub(this.d.redMuln(4));
        return S.eq(Y) && M.eq(this.one);
      }
      if (u.type === "edwards") {
        const S = this.field(u.a), M = this.field(u.d);
        return S.eq(this.a.redNeg()) && M.eq(this.d.redSub(this.a));
      }
      return !1;
    }
    pointFromShort(u) {
      if (L(u instanceof l), this.isIsomorphic(u.curve)) {
        if (u.isInfinity())
          return this.point();
        if (u.y.isZero())
          return this.point(this.zero, this.one.redNeg());
        const { a: S, d: M } = this, [Y, J] = this._scale(u.curve), X = S.redMuln(5), re = M.redMuln(5), ae = this.field(u.x).redMul(Y), de = this.field(u.y).redMul(J), ge = ae.redMuln(6), Be = ae.redMuln(12), ve = ge.redSub(S).redISub(M), Oe = de.redMuln(6), Ie = Be.redSub(X).redIAdd(M), Re = Be.redAdd(S).redISub(re);
        return this.cpoint(ve, Oe, Ie, Re);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(u) {
      L(u instanceof b), L(u.curve.p.eq(this.p));
      const S = this.field(u.x), M = this.field(u.y);
      if (this.isIsogenous(u.curve)) {
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero())
          return this.point();
        const Y = S.redSqr(), J = Y.redMul(S), X = J.redMul(S), re = X.redMul(S), ae = M.redSqr(), de = M.redMuln(4), ge = Y.redSub(this.one), Be = Y.redMuln(2), ve = ae.redMuln(4), Oe = J.redIMuln(2), Ie = S.redMul(ae).redIMuln(4), Re = Y.redMul(ae).redIMuln(2), ft = ae.redIMuln(2), Ye = de.redMul(ge), Fe = X.redISub(Be).redIAdd(ve).redIAdd(this.one), Le = re.redSub(Oe).redISub(Ie).redIAdd(S).redINeg(), He = re.redISub(Re).redISub(Oe).redISub(ft).redIAdd(S);
        return this.cpoint(Ye, Fe, Le, He).divn(4);
      }
      if (this.isIsomorphic(u.curve, !0)) {
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const J = this._scale(u.curve, !0).redMul(S), X = M, re = S.redAdd(this.one), ae = S.redSub(this.one);
        return this.cpoint(J, X, re, ae);
      }
      if (this.isIsomorphic(u.curve, !1)) {
        if (u.isInfinity())
          return this.point();
        if (u.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const J = this._scale(u.curve, !1).redMul(S), X = M, re = S.redSub(this.one), ae = S.redAdd(this.one);
        return this.cpoint(J, X, re, ae);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(u) {
      L(u instanceof I), L(u.curve.p.eq(this.p));
      const S = this.field(u.curve.a), M = this.field(u.x), Y = this.field(u.y), J = this.field(u.z), X = this.field(u.t);
      if (this.isIsogenous(u.curve)) {
        const re = M.redMul(Y), ae = M.redSqr(), de = Y.redSqr(), ge = J.redSqr(), Be = S.redMul(ae), ve = re.redIMuln(2), Oe = de.redSub(Be), Ie = de.redAdd(Be), Re = ge.redIMuln(2).redISub(Ie), ft = this.cpoint(ve, Oe, Ie, Re);
        return this.twisted ? ft : ft.divn(4);
      }
      if (this.isIsomorphic(u.curve)) {
        const re = this._scale(u.curve), ae = re.redMul(M), de = Y, ge = J, Be = re.redMul(X);
        return this.point(ae, de, ge, Be);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(u, S = null) {
      L(u instanceof e), L(u.red === this.red), L(S == null || S instanceof x), S || (S = this._alt());
      const M = S.field(u), Y = S.pointFromUniform(M);
      return this.pointFromMont(Y);
    }
    pointToUniform(u, S, M = null) {
      L(u instanceof I), L(S >>> 0 === S), L(M == null || M instanceof x), M || (M = this._alt());
      const Y = (S >> 4 & 15) % this.torsion.length, J = u.add(this.torsion[Y]), X = M.pointFromEdwards(J), re = M.pointToUniform(X, S & 15);
      return this.field(re);
    }
    pointFromHash(u, S, M = null) {
      L(M == null || M instanceof x), M || (M = this._alt());
      const Y = M.pointFromHash(u, S);
      return this.pointFromMont(Y);
    }
    pointToHash(u, S, M, Y = null) {
      L(u instanceof I), L(S >>> 0 === S), L(Y == null || Y instanceof x), Y || (Y = this._alt());
      const J = S % this.torsion.length, X = u.add(this.torsion[J]), re = Y.pointFromEdwards(X);
      return Y.pointToHash(re, 0, M);
    }
    decodePoint(u) {
      return I.decode(this, u);
    }
    toShort(u, S, M = null) {
      const [Y, J] = this._short(u, S), X = new d({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        b: J,
        n: this.n,
        h: this.h
      });
      if (M != null) {
        const [, re] = X._scale(this);
        re.redIsOdd() !== M && re.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromEdwards(this.g));
      for (let re = 0; re < this.h.word(0); re++)
        X.torsion[re] = X.pointFromEdwards(this.torsion[re]);
      return X;
    }
    toMont(u, S, M = null) {
      const [Y, J] = this._mont(u, S), X = new x({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: Y,
        b: J,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (M != null) {
        const re = this._scale(X, S);
        re.redIsOdd() !== M && re.redINeg();
      }
      this.g.isInfinity() || (X.g = X.pointFromEdwards(this.g));
      for (let re = 0; re < this.h.word(0); re++)
        X.torsion[re] = X.pointFromEdwards(this.torsion[re]);
      return X;
    }
    toEdwards(u, S = null) {
      const [M, Y] = this._edwards(u), J = new w({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a: M,
        d: Y,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (S != null) {
        const X = J._scale(this);
        X.redIsOdd() !== S && X.redINeg();
      }
      if (this.g.isInfinity() || (J.g = J.pointFromEdwards(this.g), J.g.normalize()), J.isComplete())
        for (let X = 0; X < this.h.word(0); X++)
          J.torsion[X] = J.pointFromEdwards(this.torsion[X]), J.torsion[X].normalize();
      return J;
    }
    pointFromJSON(u) {
      return I.fromJSON(this, u);
    }
    toJSON(u) {
      const S = super.toJSON(u);
      return S.a = this.a.fromRed().toJSON(), S.d = this.d.fromRed().toJSON(), this.s.isZero() || (S.s = this.s.fromRed().toJSON()), S;
    }
  }
  class I extends o {
    constructor(u, S, M, Y, J) {
      L(u instanceof w), super(u, t.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, S != null && this._init(S, M, Y, J);
    }
    _init(u, S, M, Y) {
      L(u instanceof e), L(S instanceof e), L(M == null || M instanceof e), L(Y == null || Y instanceof e), this.x = u, this.y = S, this.z = M || this.curve.one, this.t = Y || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)));
    }
    _check() {
      if (this.z.isZero())
        throw new Error("Invalid point.");
    }
    clone() {
      return this.curve.point(this.x, this.y, this.z, this.t);
    }
    normalize() {
      if (this.zOne)
        return this;
      const u = this.z.redInvert();
      return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t = this.t.redMul(u), this.z = this.curve.one, this.zOne = !0, this;
    }
    scale(u) {
      L(u instanceof e);
      const S = this.x.redMul(u), M = this.y.redMul(u), Y = this.z.redMul(u), J = this.t.redMul(u);
      return this.curve.point(S, M, Y, J);
    }
    neg() {
      const u = this.x.redNeg(), S = this.y, M = this.z, Y = this.t.redNeg();
      return this.curve.point(u, S, M, Y);
    }
    add(u) {
      return L(u instanceof I), this.isInfinity() ? u : u.isInfinity() ? this : this.zOne ? u._add(this) : this._add(u);
    }
    _add(u) {
      return this.curve.mOneA ? this._addM1(u) : this._addA(u);
    }
    _addM1(u) {
      const S = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), M = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), Y = this.t.redMul(this.curve.k).redMul(u.t), J = u.zOne ? this.z.redAdd(this.z) : this.z.redMul(u.z).redIMuln(2), X = M.redSub(S), re = J.redSub(Y), ae = J.redIAdd(Y), de = M.redIAdd(S), ge = X.redMul(re), Be = ae.redMul(de), ve = X.redMul(de), Oe = re.redMul(ae);
      return this.curve.point(ge, Be, Oe, ve);
    }
    _addA(u) {
      const S = this.x.redMul(u.x), M = this.y.redMul(u.y), Y = this.curve._mulD(this.t).redMul(u.t), J = u.zOne ? this.z.clone() : this.z.redMul(u.z), re = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(S).redISub(M), ae = J.redSub(Y), de = J.redIAdd(Y), ge = M.redISub(this.curve._mulA(S)), Be = re.redMul(ae), ve = de.redMul(ge), Oe = re.redMul(ge), Ie = ae.redMul(de);
      return this.curve.point(Be, ve, Ie, Oe);
    }
    dbl() {
      return this.isInfinity() ? this : this._dbl();
    }
    _dbl() {
      const u = this.x.redSqr(), S = this.y.redSqr(), M = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2), Y = this.curve._mulA(u), J = this.x.redAdd(this.y).redSqr().redISub(u).redISub(S), X = Y.redAdd(S), re = X.redSub(M), ae = Y.redISub(S), de = J.redMul(re), ge = X.redMul(ae), Be = J.redMul(ae), ve = re.redMul(X);
      return this.curve.point(de, ge, ve, Be);
    }
    getX() {
      return this.normalize(), this.x.fromRed();
    }
    getY() {
      return this.normalize(), this.y.fromRed();
    }
    eq(u) {
      if (L(u instanceof I), L(!this.z.isZero()), L(!u.z.isZero()), this === u)
        return !0;
      if (this.z.eq(u.z))
        return this.x.eq(u.x) && this.y.eq(u.y);
      const S = this.x.redMul(u.z), M = u.x.redMul(this.z);
      if (!S.eq(M))
        return !1;
      const Y = this.y.redMul(u.z), J = u.y.redMul(this.z);
      return Y.eq(J);
    }
    cmp(u) {
      return L(u instanceof I), this.order().cmp(u.order()) || this.getY().cmp(u.getY()) || this.getX().cmp(u.getX());
    }
    isInfinity() {
      return L(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1;
    }
    isOrder2() {
      return this.isInfinity() ? !1 : this.x.isZero();
    }
    isOdd() {
      return this.normalize(), this.x.redIsOdd();
    }
    isEven() {
      return this.normalize(), this.x.redIsEven();
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    encode() {
      const u = this.getY();
      return u.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(u);
    }
    static decode(u, S) {
      L(u instanceof w);
      const M = u.decodeAdjusted(S), Y = M.testn(u.signBit) !== 0;
      if (M.setn(u.signBit, 0), M.cmp(u.p) >= 0)
        throw new Error("Invalid point.");
      return u.pointFromY(M, Y);
    }
    toJSON(u) {
      if (this.isInfinity())
        return [];
      const S = this.getX().toJSON(), M = this.getY().toJSON();
      return u === !0 && this.pre ? [S, M, this.pre.toJSON()] : [S, M];
    }
    toPretty() {
      const u = this.curve.fieldSize * 2, S = O(this.getX(), u), M = O(this.getY(), u);
      return [S, M];
    }
    static fromJSON(u, S) {
      if (L(u instanceof w), L(Array.isArray(S)), L(S.length === 0 || S.length === 2 || S.length === 3), S.length === 0)
        return u.point();
      const M = e.fromJSON(S[0]), Y = e.fromJSON(S[1]), J = u.point(M, Y);
      return S.length > 2 && S[2] != null && (J.pre = B.fromJSON(J, S[2])), J;
    }
    [r]() {
      return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  }
  class B {
    constructor() {
      this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null;
    }
    map(u) {
      L(typeof u == "function");
      const S = new this.constructor();
      return this.naf && (S.naf = this.naf.map(u)), this.doubles && (S.doubles = this.doubles.map(u)), S;
    }
    toJSON() {
      return {
        naf: this.naf ? this.naf.toJSON() : null,
        windows: this.windows ? this.windows.toJSON() : null,
        doubles: this.doubles ? this.doubles.toJSON() : null,
        blinding: this.blinding ? this.blinding.toJSON() : void 0
      };
    }
    fromJSON(u, S) {
      return L(u instanceof o), L(S && typeof S == "object"), S.naf != null && (this.naf = y.fromJSON(u, S.naf)), S.windows != null && (this.windows = A.fromJSON(u, S.windows)), S.doubles != null && (this.doubles = _.fromJSON(u, S.doubles)), S.blinding != null && (this.blinding = q.fromJSON(u, S.blinding)), this;
    }
    static fromJSON(u, S) {
      return new this().fromJSON(u, S);
    }
  }
  class y {
    constructor(u, S) {
      this.width = u, this.points = S;
    }
    map(u) {
      L(typeof u == "function");
      const { width: S } = this, M = [];
      for (const Y of this.points)
        M.push(u(Y));
      return new this.constructor(S, M);
    }
    toJSON() {
      return {
        width: this.width,
        points: this.points.slice(1).map((u) => u.toJSON())
      };
    }
    static fromJSON(u, S) {
      L(u instanceof o), L(S && typeof S == "object"), L(S.width >>> 0 === S.width), L(Array.isArray(S.points));
      const { curve: M } = u, { width: Y } = S, J = [u];
      for (const X of S.points)
        J.push(M.pointFromJSON(X));
      return new this(Y, J);
    }
  }
  class A {
    constructor(u, S, M) {
      this.width = u, this.bits = S, this.points = M;
    }
    toJSON() {
      return {
        width: this.width,
        bits: this.bits,
        points: this.points.slice(1).map((u) => u.toJSON())
      };
    }
    static fromJSON(u, S) {
      L(u instanceof o), L(S && typeof S == "object"), L(S.width >>> 0 === S.width), L(S.bits >>> 0 === S.bits), L(Array.isArray(S.points));
      const { curve: M } = u, { width: Y, bits: J } = S, X = [u];
      for (const re of S.points)
        X.push(M.pointFromJSON(re));
      return new this(Y, J, X);
    }
  }
  class _ {
    constructor(u, S) {
      this.step = u, this.points = S;
    }
    map(u) {
      L(typeof u == "function");
      const { step: S } = this, M = [];
      for (const Y of this.points)
        M.push(u(Y));
      return new this.constructor(S, M);
    }
    toJSON() {
      return {
        step: this.step,
        points: this.points.slice(1).map((u) => u.toJSON())
      };
    }
    static fromJSON(u, S) {
      L(u instanceof o), L(S && typeof S == "object"), L(S.step >>> 0 === S.step), L(Array.isArray(S.points));
      const { curve: M } = u, { step: Y } = S, J = [u];
      for (const X of S.points)
        J.push(M.pointFromJSON(X));
      return new this(Y, J);
    }
  }
  class q {
    constructor(u, S) {
      this.blind = u, this.unblind = S;
    }
    toJSON() {
      return {
        blind: this.blind.toJSON(),
        unblind: this.unblind.toJSON()
      };
    }
    static fromJSON(u, S) {
      L(u instanceof o), L(S && typeof S == "object");
      const { curve: M } = u, Y = e.fromJSON(S.blind), J = M.pointFromJSON(S.unblind);
      return new this(Y, J);
    }
  }
  class U {
    constructor(u, S, M, Y) {
      this.beta = u, this.lambda = S, this.basis = M, this.pre = Y;
    }
    toJSON() {
      return {
        beta: this.beta.fromRed().toJSON(),
        lambda: this.lambda.toJSON(),
        basis: [
          this.basis[0].toJSON(),
          this.basis[1].toJSON()
        ],
        pre: [
          this.pre[0],
          this.pre[1].toJSON(),
          this.pre[2].toJSON()
        ]
      };
    }
    static fromJSON(u, S) {
      L(u instanceof c), L(S && typeof S == "object"), L(Array.isArray(S.basis)), L(Array.isArray(S.pre)), L(S.basis.length === 2), L(S.pre.length === 3), L(S.pre[0] >>> 0 === S.pre[0]);
      const M = e.fromJSON(S.beta).toRed(u.red), Y = e.fromJSON(S.lambda), J = [
        z.fromJSON(S.basis[0]),
        z.fromJSON(S.basis[1])
      ], X = [
        S.pre[0],
        e.fromJSON(S.pre[1]),
        e.fromJSON(S.pre[2])
      ];
      return new this(M, Y, J, X);
    }
  }
  class z {
    constructor(u, S) {
      this.a = u, this.b = S;
    }
    toJSON() {
      return {
        a: this.a.toJSON(),
        b: this.b.toJSON()
      };
    }
    static fromJSON(u) {
      L(u && typeof u == "object");
      const S = e.fromJSON(u.a), M = e.fromJSON(u.b);
      return new this(S, M);
    }
  }
  class E extends d {
    constructor(u) {
      super({
        id: "P192",
        ossl: "prime192v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p192",
        // 2^192 - 2^64 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff fffffffc"
        ],
        b: [
          "64210519 e59c80e7 0fa7e9ab 72243049",
          "feb8deec c146b9b1"
        ],
        n: [
          "ffffffff ffffffff ffffffff 99def836",
          "146bc9b1 b4d22831"
        ],
        h: "1",
        // Icart
        z: "-5",
        g: [
          [
            "188da80e b03090f6 7cbf20eb 43a18800",
            "f4ff0afd 82ff1012"
          ],
          [
            "07192b95 ffc8da78 631011ed 6b24cdd5",
            "73f977a1 1e794811"
          ],
          u
        ]
      });
    }
  }
  class H extends d {
    constructor(u) {
      super({
        id: "P224",
        ossl: "secp224r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p224",
        // 2^224 - 2^96 + 1 (1 mod 16)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "00000000 00000000 00000001"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff fffffffe"
        ],
        b: [
          "b4050a85 0c04b3ab f5413256 5044b0b7",
          "d7bfd8ba 270b3943 2355ffb4"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffff16a2",
          "e0b8f03e 13dd2945 5c5c2a3d"
        ],
        h: "1",
        // SSWU
        z: "1f",
        g: [
          [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
            "56c21122 343280d6 115c1d21"
          ],
          [
            "bd376388 b5f723fb 4c22dfe6 cd4375a0",
            "5a074764 44d58199 85007e34"
          ],
          u
        ]
      });
    }
  }
  class k extends d {
    constructor(u) {
      super({
        id: "P256",
        ossl: "prime256v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
        p: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff fffffffc"
        ],
        b: [
          "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
          "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
        ],
        n: [
          "ffffffff 00000000 ffffffff ffffffff",
          "bce6faad a7179e84 f3b9cac2 fc632551"
        ],
        h: "1",
        // SSWU
        z: "-a",
        g: [
          [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
            "77037d81 2deb33a0 f4a13945 d898c296"
          ],
          [
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
            "2bce3357 6b315ece cbb64068 37bf51f5"
          ],
          u
        ]
      });
    }
  }
  class V extends d {
    constructor(u) {
      super({
        id: "P384",
        ossl: "secp384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 ffffffff"
        ],
        // -3 mod p
        a: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 fffffffc"
        ],
        b: [
          "b3312fa7 e23ee7e4 988e056b e3f82d19",
          "181d9c6e fe814112 0314088f 5013875a",
          "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff c7634d81 f4372ddf",
          "581a0db2 48b0a77a ecec196a ccc52973"
        ],
        h: "1",
        // Icart
        z: "-c",
        g: [
          [
            "aa87ca22 be8b0537 8eb1c71e f320ad74",
            "6e1d3b62 8ba79b98 59f741e0 82542a38",
            "5502f25d bf55296c 3a545e38 72760ab7"
          ],
          [
            "3617de4a 96262c6f 5d9e98bf 9292dc29",
            "f8f41dbd 289a147c e9da3113 b5f0b8c0",
            "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ],
          u
        ]
      });
    }
  }
  class T extends d {
    constructor(u) {
      super({
        id: "P521",
        ossl: "secp521r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: "p521",
        // 2^521 - 1 (= 3 mod 4)
        p: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff"
        ],
        // -3 mod p
        a: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffc"
        ],
        b: [
          "00000051 953eb961 8e1c9a1f 929a21a0",
          "b68540ee a2da725b 99b315f3 b8b48991",
          "8ef109e1 56193951 ec7e937b 1652c0bd",
          "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
          "6b503f00"
        ],
        n: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffa 51868783 bf2f966b 7fcc0148",
          "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
          "91386409"
        ],
        h: "1",
        // SSWU
        z: "-4",
        g: [
          [
            "000000c6 858e06b7 0404e9cd 9e3ecb66",
            "2395b442 9c648139 053fb521 f828af60",
            "6b4d3dba a14b5e77 efe75928 fe1dc127",
            "a2ffa8de 3348b3c1 856a429b f97e7e31",
            "c2e5bd66"
          ],
          [
            "00000118 39296a78 9a3bc004 5c8a5fb4",
            "2c7d1bd9 98f54449 579b4468 17afbd17",
            "273e662c 97ee7299 5ef42640 c550b901",
            "3fad0761 353c7086 a272c240 88be9476",
            "9fd16650"
          ],
          u
        ]
      });
    }
  }
  class ie extends d {
    constructor(u) {
      super({
        id: "SECP256K1",
        ossl: "secp256k1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "k256",
        // 2^256 - 2^32 - 977 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe fffffc2f"
        ],
        a: "0",
        b: "7",
        n: [
          "ffffffff ffffffff ffffffff fffffffe",
          "baaedce6 af48a03b bfd25e8c d0364141"
        ],
        h: "1",
        // SVDW
        z: "1",
        // sqrt(-3)
        c: [
          "0a2d2ba9 3507f1df 233770c2 a797962c",
          "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
        ],
        g: [
          [
            "79be667e f9dcbbac 55a06295 ce870b07",
            "029bfcdb 2dce28d9 59f2815b 16f81798"
          ],
          [
            "483ada77 26a3c465 5da4fbfc 0e1108a8",
            "fd17b448 a6855419 9c47d08f fb10d4b8"
          ],
          u
        ],
        // Precomputed endomorphism.
        endo: {
          beta: [
            "7ae96a2b 657c0710 6e64479e ac3434e9",
            "9cf04975 12f58995 c1396c28 719501ee"
          ],
          lambda: [
            "5363ad4c c05c30e0 a5261c02 8812645a",
            "122e22ea 20816678 df02967c 1b23bd72"
          ],
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          pre: [
            384,
            [
              "3086d221 a7d46bcd e86c90e4 9284eb15",
              "3daa8a14 71e8ca7f e893209a 45dbb031"
            ],
            [
              "-",
              "e4437ed6 010e8828 6f547fa9 0abfe4c4",
              "221208ac 9df506c6 1571b4ae 8ac47f71"
            ]
          ]
        }
      });
    }
  }
  class N extends d {
    constructor(u) {
      super({
        id: "BRAINPOOLP256",
        ossl: "brainpoolP256r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        // (= 3 mod 4)
        p: [
          "a9fb57db a1eea9bc 3e660a90 9d838d72",
          "6e3bf623 d5262028 2013481d 1f6e5377"
        ],
        a: [
          "7d5a0975 fc2c3057 eef67530 417affe7",
          "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
        ],
        b: [
          "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
          "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
        ],
        n: [
          "a9fb57db a1eea9bc 3e660a90 9d838d71",
          "8c397aa3 b561a6f7 901e0e82 974856a7"
        ],
        h: "1",
        // Icart
        z: "-2",
        g: [
          [
            "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
            "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
          ],
          [
            "547ef835 c3dac4fd 97f8461a 14611dc9",
            "c2774513 2ded8e54 5c1d54c7 2f046997"
          ],
          u
        ]
      });
    }
  }
  class G extends d {
    constructor(u) {
      super({
        id: "BRAINPOOLP384",
        ossl: "brainpoolP384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        // (= 3 mod 4)
        p: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b4 12b1da19 7fb71123",
          "acd3a729 901d1a71 87470013 3107ec53"
        ],
        a: [
          "7bc382c6 3d8c150c 3c72080a ce05afa0",
          "c2bea28e 4fb22787 139165ef ba91f90f",
          "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
        ],
        b: [
          "04a8c7dd 22ce2826 8b39b554 16f0447c",
          "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
          "7cb43902 95dbc994 3ab78696 fa504c11"
        ],
        n: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b3 1f166e6c ac0425a7",
          "cf3ab6af 6b7fc310 3b883202 e9046565"
        ],
        h: "1",
        // SSWU
        z: "-5",
        g: [
          [
            "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
            "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
            "e826e034 36d646aa ef87b2e2 47d4af1e"
          ],
          [
            "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
            "62b70b29 feec5864 e19c054f f9912928",
            "0e464621 77918111 42820341 263c5315"
          ],
          u
        ]
      });
    }
  }
  class F extends d {
    constructor(u) {
      super({
        id: "BRAINPOOLP512",
        ossl: "brainpoolP512r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: null,
        // (= 3 mod 4)
        p: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330871",
          "7d4d9b00 9bc66842 aecda12a e6a380e6",
          "2881ff2f 2d82c685 28aa6056 583a48f3"
        ],
        a: [
          "7830a331 8b603b89 e2327145 ac234cc5",
          "94cbdd8d 3df91610 a83441ca ea9863bc",
          "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
          "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
        ],
        b: [
          "3df91610 a83441ca ea9863bc 2ded5d5a",
          "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
          "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
          "984050b7 5ebae5dd 2809bd63 8016f723"
        ],
        n: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330870",
          "553e5c41 4ca92619 41866119 7fac1047",
          "1db1d381 085ddadd b5879682 9ca90069"
        ],
        h: "1",
        // Icart
        z: "7",
        g: [
          [
            "81aee4bd d82ed964 5a21322e 9c4c6a93",
            "85ed9f70 b5d916c1 b43b62ee f4d0098e",
            "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
            "7c6d5047 406a5e68 8b352209 bcb9f822"
          ],
          [
            "7dde385d 566332ec c0eabfa9 cf7822fd",
            "f209f700 24a57b1a a000c55b 881f8111",
            "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
            "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
          ],
          u
        ]
      });
    }
  }
  class W extends x {
    constructor() {
      super({
        id: "X25519",
        ossl: "X25519",
        type: "mont",
        endian: "le",
        hash: "SHA512",
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        // 486662
        a: "76d06",
        b: "1",
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000009"
          ],
          // See: https://www.rfc-editor.org/errata/eid4730
          [
            "5f51e65e 475f794b 1fe122d3 88b72eb3",
            "6dc2b281 92839e4d d6163a5d 81312c14"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
              "635a11c7 284a9363 e9a248ef 9c884415"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "141b0b68 06563d50 3de05885 280b5910",
              "9ca5ee38 d7b56c9c 165db710 6377bbd8"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "68c59389 3d458e64 31c6ca00 45fb5015",
              "20a44346 8eaa68dd 0f103842 048065b7"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "173a6c76 c2ba719b ce3935ff ba04afea",
              "df5bbcb9 71559722 f0efc7bd fb7f9a36"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "3931c129 569e83a5 29482c14 e628b457",
              "933bfc29 ed801b4d 68871483 92507b1a"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
              "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
            ]
          ]
        ]
      });
    }
  }
  class ce extends x {
    constructor() {
      super({
        id: "X448",
        ossl: "X448",
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // 156326
        a: "262a6",
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000005"
          ],
          [
            "7d235d12 95f5b1f6 6c98ab6e 58326fce",
            "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
            "b8027e23 46430d21 1312c4b1 50677af7",
            "6fd7223d 457b5b1a"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "ba4d3a08 29b6112f 8812e51b a0bb2abe",
              "bc1cb08e b48e5569 36ba50fd d2e7d68a",
              "f8cb3216 0522425b 3f990812 abbe635a",
              "d37a21e1 7551b193"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
              "43e34f71 4b71aa96 c945af01 2d182975",
              "0734cde9 faddbda4 c066f7ed 54419ca5",
              "2c85de1e 8aae4e6c"
            ]
          ]
        ]
      });
    }
  }
  class ne extends x {
    constructor() {
      super({
        id: "MONT448",
        ossl: null,
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        // -78160 / -39082 mod p
        a: [
          "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
          "5d93f8d2 22746997 60ccffc6 49961ed6",
          "c5b05fca c24864ed 6fb59697 931b78da",
          "84ddecd8 ca2b5cfb"
        ],
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
            "48e88aee 009a2a24 e795687e c28e125a",
            "3e6730a6 0d46367b aa7fe99d 152128dc",
            "41321bc7 7817f059"
          ],
          [
            "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
            "e786ff33 b6a53d30 98746425 82e66f09",
            "4433dae7 7244a6e2 6b11e905 7228f483",
            "556c41a5 913f55fe"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
              "22e75c18 3c589857 b71924e5 73c2f9ce",
              "e18da5f2 466e2f39 3c2eedf0 f105a60a",
              "b40c717d 4f1e1fd7"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "4136d02f 925d530d 4b1d9e17 8310f2cb",
              "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
              "1e725a0d b991d0c6 c3d1120f 0efa59f5",
              "4bf38e82 b0e1e028"
            ]
          ]
        ]
      });
    }
  }
  class xe extends w {
    constructor(u) {
      super({
        id: "ED25519",
        ossl: "ED25519",
        type: "edwards",
        endian: "le",
        hash: "SHA512",
        prefix: "SigEd25519 no Ed25519 collisions",
        context: !1,
        prime: "p25519",
        // 2^255 - 19 (= 5 mod 8)
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "-1",
        // -121665 / 121666 mod p
        d: [
          "52036cee 2b6ffe73 8cc74079 7779e898",
          "00700a4d 4141d8ab 75eb4dca 135978a3"
        ],
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        // Elligator 2
        z: "2",
        g: [
          [
            "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
            "692cc760 9525a7b2 c9562d60 8f25d51a"
          ],
          // 4/5
          [
            "66666666 66666666 66666666 66666666",
            "66666666 66666666 66666666 66666658"
          ],
          u
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "7fffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff ffffffff ffffffec"
            ]
          ],
          [
            [
              "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
              "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "547cdb7f b03e20f4 d4b2ff66 c2042858",
              "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ]
        ]
      });
    }
  }
  class he extends w {
    constructor(u) {
      super({
        id: "ISO448",
        ossl: null,
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // 39082 / 39081 mod p
        d: [
          "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
          "ad461572 42a50f37 809b1da3 412a12e7",
          "9ccc9c81 264cfe9a d0809970 58fb61c4",
          "243cc32d baa156b9"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "79a70b2b 70400553 ae7c9df4 16c792c6",
            "1128751a c9296924 0c25a07d 728bdc93",
            "e21f7787 ed697224 9de732f3 8496cd11",
            "69871309 3e9c04fc"
          ],
          // Note: the RFC has this wrong.
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff 80000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          u
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  class me extends w {
    constructor(u) {
      super({
        id: "ED448",
        ossl: "ED448",
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: !0,
        prime: "p448",
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        // -39081 mod p
        d: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffff6756"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        // Elligator 2
        z: "-1",
        g: [
          [
            "4f1970c6 6bed0ded 221d15a6 22bf36da",
            "9e146570 470f1767 ea6de324 a3d3a464",
            "12ae1af7 2ab66511 433b80e1 8b00938e",
            "2626a82b c70cc05e"
          ],
          [
            "693f4671 6eb6bc24 88762037 56c9c762",
            "4bea7373 6ca39840 87789c1e 05a0c2d7",
            "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
            "9808795b f230fa14"
          ],
          u
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  }
  const Ne = {
    __proto__: null,
    P192: E,
    P224: H,
    P256: k,
    P384: V,
    P521: T,
    SECP256K1: ie,
    BRAINPOOLP256: N,
    BRAINPOOLP384: G,
    BRAINPOOLP512: F,
    X25519: W,
    X448: ce,
    MONT448: ne,
    ED25519: xe,
    ISO448: he,
    ED448: me
  }, Je = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };
  function Ze($, ...u) {
    L(typeof $ == "string");
    const S = $.toUpperCase();
    let M = Je[S];
    if (!M) {
      const Y = Ne[S];
      if (!Y)
        throw new Error(`Curve not found: "${$}".`);
      M = new Y(...u), Je[S] = M;
    }
    return M;
  }
  function ht($, u) {
    L(typeof $ == "string"), L(typeof u == "function");
    const S = $.toUpperCase();
    if (Ne[S])
      throw new Error(`Curve already registered: "${$}".`);
    Ne[S] = u, Je[S] = null;
  }
  function dt($, u, S) {
    L($ instanceof e), L(!$.red), L(u >>> 0 === u), L(S >>> 0 === S);
    const M = new Array(S), Y = $.bitLength() + 1, J = $.sign() | 1;
    L(Y <= S);
    for (let de = 0; de < S; de++)
      M[de] = 0;
    let X = 0, re = 0, ae;
    for (; X < Y; ) {
      if ($.bit(X) === re) {
        X += 1;
        continue;
      }
      ae = $.bits(X, u) + re, re = ae >> u - 1 & 1, ae -= re << u, M[X] = J * ae, X += u;
    }
    return L(re === 0), M;
  }
  function Se($, u, S, M) {
    L(M >>> 0 === M);
    const Y = dt($, u, S), J = Math.ceil(Y.length / M), X = new Array(J);
    let re = 0;
    for (let ae = 0; ae < Y.length; ae += M) {
      let de = 0;
      for (let ge = ae + M - 1; ge >= ae; ge--)
        de = (de << 1) + Y[ge];
      X[re++] = de;
    }
    return L(re === J), X;
  }
  function we($, u, S) {
    L($ instanceof e), L(u instanceof e), L(!$.red), L(!u.red), L(S >>> 0 === S);
    const M = [new Array(S), new Array(S)], Y = Math.max($.bitLength(), u.bitLength()) + 1, J = $.sign() | 1, X = u.sign() | 1;
    L(Y <= S);
    let re = 0, ae = 0;
    for (let de = 0; de < Y; de++) {
      const ge = $.bits(de, 3), Be = u.bits(de, 3);
      let ve = (ge & 3) + re & 3, Oe = (Be & 3) + ae & 3, Ie = 0, Re = 0;
      if (ve === 3 && (ve = -1), Oe === 3 && (Oe = -1), ve & 1) {
        const ft = (ge & 7) + re & 7;
        (ft === 3 || ft === 5) && Oe === 2 ? Ie = -ve : Ie = ve;
      }
      if (Oe & 1) {
        const ft = (Be & 7) + ae & 7;
        (ft === 3 || ft === 5) && ve === 2 ? Re = -Oe : Re = Oe;
      }
      M[0][de] = Ie * J, M[1][de] = Re * X, 2 * re === 1 + Ie && (re = 1 - re), 2 * ae === 1 + Re && (ae = 1 - ae);
    }
    for (let de = Y; de < S; de++)
      M[0][de] = 0, M[1][de] = 0;
    return M;
  }
  function Z($, u, S) {
    const M = we($, u, S), Y = new Array(S);
    for (let J = 0; J < S; J++) {
      const X = M[0][J], re = M[1][J];
      Y[J] = i[(X + 1) * 3 + (re + 1)];
    }
    return Y;
  }
  function L($, u) {
    if (!$) {
      const S = new Error(u || "Assertion failed");
      throw Error.captureStackTrace && Error.captureStackTrace(S, L), S;
    }
  }
  function oe($) {
    L(typeof $ == "function");
    try {
      return $();
    } catch (u) {
      throw u.message === "X is not a square mod P." || u.message === "Not invertible." ? new Error("Invalid point.") : u;
    }
  }
  function s($, u) {
    let S = $ % u;
    return S < 0 && (u < 0 ? S -= u : S += u), S;
  }
  function a($) {
    L($ instanceof e), L($.red);
    const u = $.red.m;
    if (u.cmpn(3) <= 0)
      return $.clone();
    if (u.modrn(3) === 2) {
      const M = u.ushln(1).isubn(1).idivn(3);
      return $.redPow(M);
    }
    const S = u.modrn(9);
    if (S === 4) {
      const M = u.ushln(1).iaddn(1).idivn(9), Y = $.redPow(M);
      if (!Y.redSqr().redMul(Y).eq($))
        throw new Error("X is not a cube mod P.");
      return Y;
    }
    if (S === 7) {
      const M = u.addn(2).idivn(9), Y = $.redPow(M);
      if (!Y.redSqr().redMul(Y).eq($))
        throw new Error("X is not a cube mod P.");
      return Y;
    }
    throw new Error("Not implemented.");
  }
  function p($) {
    const u = a($);
    if ($.red.m.modrn(3) === 1) {
      const S = new e(2).toRed($.red), M = new e(3).toRed($.red), Y = S.redInvert(), J = M.redNeg().redSqrt().redMul(Y), X = J.redNeg(), re = J.redSub(Y), ae = X.redSub(Y), de = u.redMul(re), ge = u.redMul(ae);
      return [u, de, ge];
    }
    return [u];
  }
  function v($) {
    for (const u of p($))
      if (u.redJacobi() >= 0)
        return u;
    throw new Error("X^(1/3) is not a square mod P.");
  }
  function C($) {
    return e.randomBits($, 32).toNumber();
  }
  function K($, u) {
    const S = /* @__PURE__ */ new WeakMap();
    return function(Y, J) {
      const X = J & 1, re = S.get(Y);
      if (re && re[X] !== null)
        return re[X];
      const ae = $.call(u, Y, J);
      return S.has(Y) || S.set(Y, [null, null]), S.get(Y)[X] = ae, ae;
    };
  }
  function O($, u) {
    L($ instanceof e), L(u >>> 0 === u), u & 7 && (u += 8 - (u & 7));
    const S = $.toString(16, u), M = [], Y = [];
    L((S.length & 7) === 0);
    for (let J = 0; J < S.length; J += 8)
      M.push(S.slice(J, J + 8));
    for (let J = 0; J < M.length; J += 4)
      Y.push(M.slice(J, J + 4).join(" "));
    return Y;
  }
  return b0.Curve = c, b0.Point = o, b0.ShortCurve = d, b0.ShortPoint = l, b0.JPoint = h, b0.MontCurve = x, b0.MontPoint = b, b0.XPoint = g, b0.EdwardsCurve = w, b0.EdwardsPoint = I, b0.curves = Ne, b0.curve = Ze, b0.register = ht, b0;
}
/*!
 * ecdh.js - ECDH for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://cr.yp.to/ecdh.html
 *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
 *   https://tools.ietf.org/html/rfc7748
 */
var Va, V2;
function I8() {
  if (V2)
    return Va;
  V2 = 1;
  const r = _e, e = J0, t = So(), i = B0;
  class n {
    constructor(o, d, l) {
      r(typeof o == "string"), r(!d || typeof d == "string"), this.id = o, this.type = "ecdh", this.eid = d || null, this._pre = l || null, this._curve = null, this._edwards = null, this.native = 0;
    }
    get curve() {
      return this._curve || (this._curve = t.curve(this.id)), this._curve;
    }
    get edwards() {
      return this.eid && !this._edwards && (this._edwards = t.curve(this.eid, this._pre), this._edwards.precompute(i), this._pre = null), this._edwards;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const o = i.randomBytes(this.curve.scalarSize);
      return this.curve.clamp(o);
    }
    privateKeyVerify(o) {
      return r(Buffer.isBuffer(o)), o.length === this.curve.scalarSize;
    }
    privateKeyExport(o, d) {
      const l = this.publicKeyCreate(o), { x: h, y: x } = this.publicKeyExport(l, d);
      return {
        d: Buffer.from(o),
        x: h,
        y: x
      };
    }
    privateKeyImport(o) {
      r(o && typeof o == "object");
      const d = e.decode(o.d, this.curve.endian);
      if (d.byteLength() > this.curve.scalarSize)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(d);
    }
    publicKeyCreate(o) {
      const d = this.curve.decodeClamped(o);
      if (this.edwards && this.edwards.g.pre) {
        const x = this.edwards.g.mulBlind(d);
        return this.curve.pointFromEdwards(x).encode();
      }
      return this.curve.g.toX().mulBlind(d, i).encode();
    }
    publicKeyConvert(o, d) {
      if (r(d == null || typeof d == "boolean"), !this.edwards)
        throw new Error("No equivalent edwards curve.");
      const l = this.curve.decodePoint(o), h = this.edwards.pointFromMont(l);
      return d != null && h.isOdd() !== d ? h.neg().encode() : h.encode();
    }
    publicKeyFromUniform(o) {
      const d = this.curve.decodeUniform(o);
      return this.curve.pointFromUniform(d).encode();
    }
    publicKeyToUniform(o, d = i.randomInt()) {
      const l = this.curve.decodePoint(o), h = this.curve.pointToUniform(l, d);
      return this.curve.encodeUniform(h, d >>> 8);
    }
    publicKeyFromHash(o, d = !1) {
      return this.curve.pointFromHash(o, d).encode();
    }
    publicKeyToHash(o, d = i.randomInt()) {
      const l = this.curve.decodePoint(o);
      return this.curve.pointToHash(l, d, i);
    }
    publicKeyVerify(o) {
      r(Buffer.isBuffer(o));
      let d;
      try {
        d = this.curve.decodeX(o);
      } catch {
        return !1;
      }
      return d.validate();
    }
    publicKeyIsSmall(o) {
      r(Buffer.isBuffer(o));
      let d;
      try {
        d = this.curve.decodeX(o);
      } catch {
        return !1;
      }
      return d.validate() ? d.isSmall() : !1;
    }
    publicKeyHasTorsion(o) {
      r(Buffer.isBuffer(o));
      let d;
      try {
        d = this.curve.decodeX(o);
      } catch {
        return !1;
      }
      return d.validate() ? d.hasTorsion() : !1;
    }
    publicKeyExport(o, d) {
      const { x: l, y: h } = this.curve.decodePoint(o, d);
      return {
        x: this.curve.encodeField(l.fromRed()),
        y: this.curve.encodeField(h.fromRed())
      };
    }
    publicKeyImport(o) {
      r(o && typeof o == "object");
      const d = e.decode(o.x, this.curve.endian);
      if (d.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (o.y != null) {
        const h = e.decode(o.y, this.curve.endian);
        if (h.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const x = this.curve.point(d, h);
        if (!x.validate())
          throw new Error("Invalid point.");
        return x.encode();
      }
      return this.curve.pointFromX(d).encode();
    }
    derive(o, d) {
      const l = this.curve.decodeX(o), h = this.curve.decodeClamped(d);
      return l.mulBlind(h, i).encode();
    }
  }
  return Va = n, Va;
}
const Sm = {
  width: 9,
  points: [
    [
      "67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c",
      "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"
    ],
    [
      "49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233",
      "5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"
    ],
    [
      "14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107",
      "31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"
    ],
    [
      "357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c",
      "7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"
    ],
    [
      "14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb",
      "2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"
    ],
    [
      "107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed",
      "12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"
    ],
    [
      "4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1",
      "12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"
    ],
    [
      "7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a",
      "6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"
    ],
    [
      "1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472",
      "3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"
    ],
    [
      "6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716",
      "6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"
    ],
    [
      "2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95",
      "23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"
    ],
    [
      "794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455",
      "71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"
    ],
    [
      "163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079",
      "631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"
    ],
    [
      "39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d",
      "4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"
    ],
    [
      "38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9",
      "42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"
    ],
    [
      "5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1",
      "54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"
    ],
    [
      "7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb",
      "01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"
    ],
    [
      "05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3",
      "6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"
    ],
    [
      "624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3",
      "5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"
    ],
    [
      "1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9",
      "5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"
    ],
    [
      "396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101",
      "7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"
    ],
    [
      "53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50",
      "2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"
    ],
    [
      "34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368",
      "299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"
    ],
    [
      "5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618",
      "680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"
    ],
    [
      "27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb",
      "0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"
    ],
    [
      "0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a",
      "42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"
    ],
    [
      "4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a",
      "5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"
    ],
    [
      "1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817",
      "0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"
    ],
    [
      "4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc",
      "503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"
    ],
    [
      "3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6",
      "62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"
    ],
    [
      "649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a",
      "1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"
    ],
    [
      "3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56",
      "15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"
    ],
    [
      "2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1",
      "08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"
    ],
    [
      "642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385",
      "21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"
    ],
    [
      "38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef",
      "458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"
    ],
    [
      "372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db",
      "32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"
    ],
    [
      "1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77",
      "42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"
    ],
    [
      "38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5",
      "1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"
    ],
    [
      "176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7",
      "7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"
    ],
    [
      "042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6",
      "42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"
    ],
    [
      "1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108",
      "1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"
    ],
    [
      "613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5",
      "3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"
    ],
    [
      "27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9",
      "16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"
    ],
    [
      "769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2",
      "22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"
    ],
    [
      "795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d",
      "756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"
    ],
    [
      "644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46",
      "173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"
    ],
    [
      "5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110",
      "4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"
    ],
    [
      "296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848",
      "0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"
    ],
    [
      "408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f",
      "4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"
    ],
    [
      "07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07",
      "6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"
    ],
    [
      "2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873",
      "215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"
    ],
    [
      "1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a",
      "5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"
    ],
    [
      "5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97",
      "69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"
    ],
    [
      "24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb",
      "6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"
    ],
    [
      "64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538",
      "513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"
    ],
    [
      "47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e",
      "7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"
    ],
    [
      "4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f",
      "4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"
    ],
    [
      "3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5",
      "689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"
    ],
    [
      "61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10",
      "63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"
    ],
    [
      "03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414",
      "74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"
    ],
    [
      "0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9",
      "1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"
    ],
    [
      "797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe",
      "5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"
    ],
    [
      "735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd",
      "384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"
    ],
    [
      "6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac",
      "61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"
    ],
    [
      "5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773",
      "7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"
    ],
    [
      "31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8",
      "1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"
    ],
    [
      "424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0",
      "34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"
    ],
    [
      "33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247",
      "37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"
    ],
    [
      "5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb",
      "382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"
    ],
    [
      "3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036",
      "09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"
    ],
    [
      "62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973",
      "5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"
    ],
    [
      "0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3",
      "6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"
    ],
    [
      "6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e",
      "74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"
    ],
    [
      "4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f",
      "41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"
    ],
    [
      "65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741",
      "67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"
    ],
    [
      "1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8",
      "7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"
    ],
    [
      "2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71",
      "7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"
    ],
    [
      "1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6",
      "153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"
    ],
    [
      "0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129",
      "7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"
    ],
    [
      "01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4",
      "60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"
    ],
    [
      "79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150",
      "53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"
    ],
    [
      "220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498",
      "05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"
    ],
    [
      "1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18",
      "22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"
    ],
    [
      "35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b",
      "155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"
    ],
    [
      "3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd",
      "379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"
    ],
    [
      "6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf",
      "1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"
    ],
    [
      "7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123",
      "34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"
    ],
    [
      "354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf",
      "7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"
    ],
    [
      "1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850",
      "2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"
    ],
    [
      "533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d",
      "6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"
    ],
    [
      "4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b",
      "1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"
    ],
    [
      "3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265",
      "025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"
    ],
    [
      "5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6",
      "5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"
    ],
    [
      "2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9",
      "2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"
    ],
    [
      "79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1",
      "6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"
    ],
    [
      "57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63",
      "14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"
    ],
    [
      "6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523",
      "2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"
    ],
    [
      "749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9",
      "7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"
    ],
    [
      "340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1",
      "64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"
    ],
    [
      "4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109",
      "3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"
    ],
    [
      "34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb",
      "7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"
    ],
    [
      "820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e",
      "756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"
    ],
    [
      "0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3",
      "34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"
    ],
    [
      "5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b",
      "54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"
    ],
    [
      "755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc",
      "0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"
    ],
    [
      "5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b",
      "6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"
    ],
    [
      "1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46",
      "5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"
    ],
    [
      "4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d",
      "45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"
    ],
    [
      "63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91",
      "46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"
    ],
    [
      "5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87",
      "3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"
    ],
    [
      "62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec",
      "562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"
    ],
    [
      "14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556",
      "447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"
    ],
    [
      "1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6",
      "52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"
    ],
    [
      "5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3",
      "41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"
    ],
    [
      "4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607",
      "3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"
    ],
    [
      "62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08",
      "4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"
    ],
    [
      "4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757",
      "2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"
    ],
    [
      "5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3",
      "547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"
    ],
    [
      "424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015",
      "74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"
    ],
    [
      "54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd",
      "6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"
    ],
    [
      "732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb",
      "1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"
    ],
    [
      "74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb",
      "501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"
    ],
    [
      "04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7",
      "71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"
    ],
    [
      "2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794",
      "2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"
    ],
    [
      "555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6",
      "6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"
    ],
    [
      "4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6",
      "2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"
    ],
    [
      "5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16",
      "315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"
    ]
  ]
}, Bm = {
  step: 4,
  points: [
    [
      "23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8",
      "709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"
    ],
    [
      "5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556",
      "0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"
    ],
    [
      "7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea",
      "59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"
    ],
    [
      "5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565",
      "2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"
    ],
    [
      "06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed",
      "07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"
    ],
    [
      "0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77",
      "21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"
    ],
    [
      "1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b",
      "0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"
    ],
    [
      "4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb",
      "6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"
    ],
    [
      "2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0",
      "7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"
    ],
    [
      "0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5",
      "3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"
    ],
    [
      "52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e",
      "7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"
    ],
    [
      "52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52",
      "50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"
    ],
    [
      "6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4",
      "727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"
    ],
    [
      "71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4",
      "39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"
    ],
    [
      "57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5",
      "6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"
    ],
    [
      "6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202",
      "0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"
    ],
    [
      "71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226",
      "3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"
    ],
    [
      "1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f",
      "779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"
    ],
    [
      "22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc",
      "631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"
    ],
    [
      "608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4",
      "3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"
    ],
    [
      "3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02",
      "0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"
    ],
    [
      "69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5",
      "3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"
    ],
    [
      "1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622",
      "295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"
    ],
    [
      "51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0",
      "35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"
    ],
    [
      "3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845",
      "7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"
    ],
    [
      "1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f",
      "0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"
    ],
    [
      "49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac",
      "3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"
    ],
    [
      "4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b",
      "6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"
    ],
    [
      "6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb",
      "2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"
    ],
    [
      "4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424",
      "314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"
    ],
    [
      "0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586",
      "47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"
    ],
    [
      "4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824",
      "5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"
    ],
    [
      "53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534",
      "5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"
    ],
    [
      "7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6",
      "1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"
    ],
    [
      "78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe",
      "0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"
    ],
    [
      "2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91",
      "7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"
    ],
    [
      "0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7",
      "16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"
    ],
    [
      "1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a",
      "7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"
    ],
    [
      "31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46",
      "77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"
    ],
    [
      "543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031",
      "0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"
    ],
    [
      "0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a",
      "187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"
    ],
    [
      "7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a",
      "0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"
    ],
    [
      "472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b",
      "10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"
    ],
    [
      "04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a",
      "3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"
    ],
    [
      "2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e",
      "653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"
    ],
    [
      "0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325",
      "3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"
    ],
    [
      "0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128",
      "1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"
    ],
    [
      "1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d",
      "61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"
    ],
    [
      "469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d",
      "0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"
    ],
    [
      "5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb",
      "505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"
    ],
    [
      "11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1",
      "43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"
    ],
    [
      "3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb",
      "2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"
    ],
    [
      "0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398",
      "54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"
    ],
    [
      "1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c",
      "299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"
    ],
    [
      "25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35",
      "179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"
    ],
    [
      "75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f",
      "696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"
    ],
    [
      "5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a",
      "10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"
    ],
    [
      "7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07",
      "604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"
    ],
    [
      "2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26",
      "68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"
    ],
    [
      "28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787",
      "552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"
    ],
    [
      "59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b",
      "3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"
    ],
    [
      "5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f",
      "67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"
    ],
    [
      "6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec",
      "5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"
    ],
    [
      "53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699",
      "404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"
    ]
  ]
}, A8 = {
  naf: Sm,
  doubles: Bm
};
/*!
 * x25519.js - x25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Curve25519
 *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
 *   https://tools.ietf.org/html/rfc7748#section-5
 */
var Ga, G2;
function vm() {
  if (G2)
    return Ga;
  G2 = 1;
  const r = I8(), e = A8;
  return Ga = new r("X25519", "ED25519", e), Ga;
}
/*!
 * ecdh.js - ECDH for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://cr.yp.to/ecdh.html
 *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
 *   https://tools.ietf.org/html/rfc7748
 */
var Ya, Y2;
function _8() {
  if (Y2)
    return Ya;
  Y2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n) {
      r(e.curves.mont[n] != null), this.id = n, this.type = "ecdh", this.native = 2, this._ctx = null;
    }
    get _handle() {
      return this._ctx || (this._ctx = e.curve("mont", this.id)), this._ctx;
    }
    get size() {
      return r(this instanceof t), e.mont_curve_field_size(this._handle);
    }
    get bits() {
      return r(this instanceof t), e.mont_curve_field_bits(this._handle);
    }
    privateKeyGenerate() {
      return r(this instanceof t), e.ecdh_privkey_generate(this._handle, e.entropy());
    }
    privateKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdh_privkey_verify(this._handle, n);
    }
    privateKeyExport(n, c) {
      r(this instanceof t), r(Buffer.isBuffer(n)), c = e.ternary(c);
      const o = e.ecdh_pubkey_create(this._handle, n), [d, l] = e.ecdh_pubkey_export(this._handle, o, c);
      return {
        d: e.copy(n),
        x: d,
        y: l
      };
    }
    privateKeyImport(n) {
      return r(this instanceof t), r(n && typeof n == "object"), r(Buffer.isBuffer(n.d)), e.ecdh_privkey_import(this._handle, n.d);
    }
    publicKeyCreate(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdh_pubkey_create(this._handle, n);
    }
    publicKeyConvert(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), c = e.ternary(c), e.ecdh_pubkey_convert(this._handle, n, c);
    }
    publicKeyFromUniform(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdh_pubkey_from_uniform(this._handle, n);
    }
    publicKeyToUniform(n, c = e.hint()) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c >>> 0 === c), e.ecdh_pubkey_to_uniform(this._handle, n, c);
    }
    publicKeyFromHash(n, c = !1) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.ecdh_pubkey_from_hash(this._handle, n, c);
    }
    publicKeyToHash(n, c = e.hint()) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c >>> 0 === c), e.ecdh_pubkey_to_hash(this._handle, n, c, e.entropy());
    }
    publicKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdh_pubkey_verify(this._handle, n);
    }
    publicKeyIsSmall(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdh_pubkey_is_small(this._handle, n);
    }
    publicKeyHasTorsion(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdh_pubkey_has_torsion(this._handle, n);
    }
    publicKeyExport(n, c) {
      r(this instanceof t), r(Buffer.isBuffer(n)), c = e.ternary(c);
      const [o, d] = e.ecdh_pubkey_export(this._handle, n, c);
      return { x: o, y: d };
    }
    publicKeyImport(n) {
      r(this instanceof t), r(n && typeof n == "object");
      let { x: c, y: o } = n;
      return c == null && (c = e.NULL), o == null && (o = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.ecdh_pubkey_import(this._handle, c, o);
    }
    derive(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdh_derive(this._handle, n, c);
    }
  }
  return Ya = t, Ya;
}
/*!
 * x25519.js - x25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ja, J2;
function Em() {
  if (J2)
    return Ja;
  J2 = 1;
  const r = _8();
  return Ja = new r("X25519"), Ja;
}
/*!
 * x25519.js - x25519 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? wu.exports = vm() : wu.exports = Em();
var M8 = wu.exports;
/*!
 * box.js - nacl secretbox for bcrypto (crypto_secretbox_xsalsa20poly1305)
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://nacl.cr.yp.to/secretbox.html
 *   https://github.com/golang/crypto/blob/master/nacl/box/box.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/box_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/example_test.go
 */
const Im = M0, Rf = Lf, Am = B0, Dc = M8;
function _m(r, e, t = null) {
  t == null && (t = Dc.privateKeyGenerate());
  const i = Dc.publicKeyCreate(t), n = Dc.derive(e, t), c = Rf.derive(n), o = Am.randomBytes(24), d = Rf.seal(r, c, o);
  return Buffer.concat([i, o, d]);
}
function Mm(r, e) {
  if (Im(Buffer.isBuffer(r)), r.length < 32 + 24)
    throw new Error("Invalid secret box size.");
  const t = r.slice(0, 32), i = r.slice(32, 32 + 24), n = r.slice(32 + 24), c = Dc.derive(t, e), o = Rf.derive(c);
  return Rf.open(n, o, i);
}
yo.native = Rf.native;
yo.seal = _m;
yo.open = Mm;
var yu = { exports: {} };
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Xa, X2;
function Nm() {
  if (X2)
    return Xa;
  X2 = 1;
  const r = _e, e = Dt();
  class t {
    constructor() {
      this._handle = e.chacha20_create();
    }
    init(n, c, o) {
      return o == null && (o = 0), r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Number.isSafeInteger(o)), e.chacha20_init(this._handle, n, c, o), this;
    }
    encrypt(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.chacha20_crypt(this._handle, n), n;
    }
    destroy() {
      return r(this instanceof t), e.chacha20_destroy(this._handle), this;
    }
    static derive(n, c) {
      return r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.chacha20_derive(n, c);
    }
  }
  return t.native = 2, Xa = t, Xa;
}
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? yu.exports = f8() : yu.exports = Nm();
var N8 = yu.exports, Su = { exports: {} }, qs = {};
/*!
 * arc2.js - ARC2 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RC2
 *   https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go
 *   https://en.wikipedia.org/wiki/RC2
 *   https://www.ietf.org/rfc/rfc2268.txt
 *   http://people.csail.mit.edu/rivest/pubs/KRRR98.pdf
 */
var Za, Z2;
function Om() {
  if (Z2)
    return Za;
  Z2 = 1;
  const r = _e, e = new Uint8Array([
    217,
    120,
    249,
    196,
    25,
    221,
    181,
    237,
    40,
    233,
    253,
    121,
    74,
    160,
    216,
    157,
    198,
    126,
    55,
    131,
    43,
    118,
    83,
    142,
    98,
    76,
    100,
    136,
    68,
    139,
    251,
    162,
    23,
    154,
    89,
    245,
    135,
    179,
    79,
    19,
    97,
    69,
    109,
    141,
    9,
    129,
    125,
    50,
    189,
    143,
    64,
    235,
    134,
    183,
    123,
    11,
    240,
    149,
    33,
    34,
    92,
    107,
    78,
    130,
    84,
    214,
    101,
    147,
    206,
    96,
    178,
    28,
    115,
    86,
    192,
    20,
    167,
    140,
    241,
    220,
    18,
    117,
    202,
    31,
    59,
    190,
    228,
    209,
    66,
    61,
    212,
    48,
    163,
    60,
    182,
    38,
    111,
    191,
    14,
    218,
    70,
    105,
    7,
    87,
    39,
    242,
    29,
    155,
    188,
    148,
    67,
    3,
    248,
    17,
    199,
    246,
    144,
    239,
    62,
    231,
    6,
    195,
    213,
    47,
    200,
    102,
    30,
    215,
    8,
    232,
    234,
    222,
    128,
    82,
    238,
    247,
    132,
    170,
    114,
    172,
    53,
    77,
    106,
    42,
    150,
    26,
    210,
    113,
    90,
    21,
    73,
    116,
    75,
    159,
    208,
    94,
    4,
    24,
    164,
    236,
    194,
    224,
    65,
    110,
    15,
    81,
    203,
    204,
    36,
    145,
    175,
    80,
    161,
    244,
    112,
    57,
    153,
    124,
    58,
    133,
    35,
    184,
    180,
    122,
    252,
    2,
    54,
    91,
    37,
    85,
    151,
    49,
    45,
    93,
    250,
    152,
    227,
    138,
    146,
    174,
    5,
    223,
    41,
    16,
    103,
    108,
    186,
    201,
    211,
    0,
    230,
    207,
    225,
    158,
    168,
    44,
    99,
    22,
    1,
    63,
    88,
    226,
    137,
    169,
    13,
    56,
    52,
    27,
    171,
    51,
    255,
    176,
    187,
    72,
    12,
    95,
    185,
    177,
    205,
    46,
    197,
    243,
    219,
    71,
    229,
    165,
    156,
    119,
    10,
    166,
    32,
    104,
    254,
    127,
    193,
    173
  ]);
  class t {
    constructor(d = -1, l = -1) {
      r(d === -1 || d >>> 0 === d), r(l === -1 || l >>> 0 === l), r(d === -1 || d === 40 || d === 64 || d === 128), r(l === -1 || l <= 1024), this.bits = d, this.ekb = l, this.k = new Uint16Array(64), this.r = new Uint16Array(4);
    }
    get blockSize() {
      return 8;
    }
    init(d) {
      r(Buffer.isBuffer(d)), this.bits === -1 ? r(d.length >= 1 && d.length <= 128) : r(d.length * 8 === this.bits);
      let l = this.ekb;
      l === -1 && (l = d.length * 8);
      const h = Buffer.alloc(128, 0);
      for (let x = 0; x < d.length; x++)
        h[x] = d[x];
      for (let x = d.length; x < 128; x++)
        h[x] = e[h[x - d.length] + h[x - 1] & 255];
      if (h[0] = e[h[0]], l > 0 && l < 1024) {
        const x = l + 7 >>> 3;
        let b = 128 - x, g = e[h[b] & 255 >> (7 & -l)];
        for (h[b] = g; b--; )
          g = e[g ^ h[b + x]], h[b] = g;
      }
      for (let x = 0; x < 64; x++)
        this.k[x] = n(h, x * 2);
      return this;
    }
    encrypt(d, l, h, x) {
      const b = this.r;
      b[0] = n(h, x + 0), b[1] = n(h, x + 2), b[2] = n(h, x + 4), b[3] = n(h, x + 6);
      let g = 0;
      for (; g <= 16; )
        b[0] += this.k[g], b[0] += b[3] & b[2], b[0] += ~b[3] & b[1], b[0] = i(b[0], 1), g += 1, b[1] += this.k[g], b[1] += b[0] & b[3], b[1] += ~b[0] & b[2], b[1] = i(b[1], 2), g += 1, b[2] += this.k[g], b[2] += b[1] & b[0], b[2] += ~b[1] & b[3], b[2] = i(b[2], 3), g += 1, b[3] += this.k[g], b[3] += b[2] & b[1], b[3] += ~b[2] & b[0], b[3] = i(b[3], 5), g += 1;
      for (b[0] += this.k[b[3] & 63], b[1] += this.k[b[0] & 63], b[2] += this.k[b[1] & 63], b[3] += this.k[b[2] & 63]; g <= 40; )
        b[0] += this.k[g], b[0] += b[3] & b[2], b[0] += ~b[3] & b[1], b[0] = i(b[0], 1), g += 1, b[1] += this.k[g], b[1] += b[0] & b[3], b[1] += ~b[0] & b[2], b[1] = i(b[1], 2), g += 1, b[2] += this.k[g], b[2] += b[1] & b[0], b[2] += ~b[1] & b[3], b[2] = i(b[2], 3), g += 1, b[3] += this.k[g], b[3] += b[2] & b[1], b[3] += ~b[2] & b[0], b[3] = i(b[3], 5), g += 1;
      for (b[0] += this.k[b[3] & 63], b[1] += this.k[b[0] & 63], b[2] += this.k[b[1] & 63], b[3] += this.k[b[2] & 63]; g <= 60; )
        b[0] += this.k[g], b[0] += b[3] & b[2], b[0] += ~b[3] & b[1], b[0] = i(b[0], 1), g += 1, b[1] += this.k[g], b[1] += b[0] & b[3], b[1] += ~b[0] & b[2], b[1] = i(b[1], 2), g += 1, b[2] += this.k[g], b[2] += b[1] & b[0], b[2] += ~b[1] & b[3], b[2] = i(b[2], 3), g += 1, b[3] += this.k[g], b[3] += b[2] & b[1], b[3] += ~b[2] & b[0], b[3] = i(b[3], 5), g += 1;
      c(d, b[0], l + 0), c(d, b[1], l + 2), c(d, b[2], l + 4), c(d, b[3], l + 6);
    }
    decrypt(d, l, h, x) {
      const b = this.r;
      b[0] = n(h, x + 0), b[1] = n(h, x + 2), b[2] = n(h, x + 4), b[3] = n(h, x + 6);
      let g = 63;
      for (; g >= 44; )
        b[3] = i(b[3], 16 - 5), b[3] -= this.k[g], b[3] -= b[2] & b[1], b[3] -= ~b[2] & b[0], g -= 1, b[2] = i(b[2], 16 - 3), b[2] -= this.k[g], b[2] -= b[1] & b[0], b[2] -= ~b[1] & b[3], g -= 1, b[1] = i(b[1], 16 - 2), b[1] -= this.k[g], b[1] -= b[0] & b[3], b[1] -= ~b[0] & b[2], g -= 1, b[0] = i(b[0], 16 - 1), b[0] -= this.k[g], b[0] -= b[3] & b[2], b[0] -= ~b[3] & b[1], g -= 1;
      for (b[3] -= this.k[b[2] & 63], b[2] -= this.k[b[1] & 63], b[1] -= this.k[b[0] & 63], b[0] -= this.k[b[3] & 63]; g >= 20; )
        b[3] = i(b[3], 16 - 5), b[3] -= this.k[g], b[3] -= b[2] & b[1], b[3] -= ~b[2] & b[0], g -= 1, b[2] = i(b[2], 16 - 3), b[2] -= this.k[g], b[2] -= b[1] & b[0], b[2] -= ~b[1] & b[3], g -= 1, b[1] = i(b[1], 16 - 2), b[1] -= this.k[g], b[1] -= b[0] & b[3], b[1] -= ~b[0] & b[2], g -= 1, b[0] = i(b[0], 16 - 1), b[0] -= this.k[g], b[0] -= b[3] & b[2], b[0] -= ~b[3] & b[1], g -= 1;
      for (b[3] -= this.k[b[2] & 63], b[2] -= this.k[b[1] & 63], b[1] -= this.k[b[0] & 63], b[0] -= this.k[b[3] & 63]; g >= 0; )
        b[3] = i(b[3], 16 - 5), b[3] -= this.k[g], b[3] -= b[2] & b[1], b[3] -= ~b[2] & b[0], g -= 1, b[2] = i(b[2], 16 - 3), b[2] -= this.k[g], b[2] -= b[1] & b[0], b[2] -= ~b[1] & b[3], g -= 1, b[1] = i(b[1], 16 - 2), b[1] -= this.k[g], b[1] -= b[0] & b[3], b[1] -= ~b[0] & b[2], g -= 1, b[0] = i(b[0], 16 - 1), b[0] -= this.k[g], b[0] -= b[3] & b[2], b[0] -= ~b[3] & b[1], g -= 1;
      c(d, b[0], l + 0), c(d, b[1], l + 2), c(d, b[2], l + 4), c(d, b[3], l + 6);
    }
    destroy() {
      for (let d = 0; d < 64; d++)
        this.k[d] = 0;
      for (let d = 0; d < 4; d++)
        this.r[d] = 0;
      return this;
    }
  }
  function i(o, d) {
    return o >>> 16 - d | o << d;
  }
  function n(o, d) {
    return o[d++] + o[d] * 256;
  }
  function c(o, d, l) {
    return o[l++] = d, o[l++] = d >>> 8, l;
  }
  return Za = t, Za;
}
/*!
 * camellia.js - camellia128/192/256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on aead/camellia:
 *   Copyright (c) 2016, Andreas Auernhammer (MIT License).
 *   https://github.com/aead/camellia
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Camellia_(cipher)
 *   https://tools.ietf.org/html/rfc3713
 *   https://github.com/aead/camellia/blob/master/camellia.go
 */
var Wa, W2;
function Pm() {
  if (W2)
    return Wa;
  W2 = 1;
  const r = _e, e = new Uint32Array([
    2694735487,
    1003262091,
    3061508184,
    1286239154,
    3337565999,
    3914302142,
    1426019237,
    4057165596,
    283453434,
    3731369245,
    2958461122,
    3018244605
  ]), t = new Uint32Array([
    1886416896,
    2189591040,
    741092352,
    3974949888,
    3014898432,
    656877312,
    3233857536,
    3857048832,
    3840205824,
    2240120064,
    1465341696,
    892679424,
    3941263872,
    202116096,
    2930683392,
    1094795520,
    589505280,
    4025478912,
    1802201856,
    2475922176,
    1162167552,
    421075200,
    2779096320,
    555819264,
    3991792896,
    235802112,
    1330597632,
    1313754624,
    488447232,
    1701143808,
    2459079168,
    3183328512,
    2256963072,
    3099113472,
    2947526400,
    2408550144,
    2088532992,
    3958106880,
    522133248,
    3469659648,
    1044266496,
    808464384,
    3705461760,
    1600085760,
    1583242752,
    3318072576,
    185273088,
    437918208,
    2795939328,
    3789676800,
    960051456,
    3402287616,
    3587560704,
    1195853568,
    1566399744,
    1027423488,
    3654932736,
    16843008,
    1515870720,
    3604403712,
    1364283648,
    1448498688,
    1819044864,
    1296911616,
    2341178112,
    218959104,
    2593823232,
    1717986816,
    4227595008,
    3435973632,
    2964369408,
    757935360,
    1953788928,
    303174144,
    724249344,
    538976256,
    4042321920,
    2981212416,
    2223277056,
    2576980224,
    3755990784,
    1280068608,
    3419130624,
    3267543552,
    875836416,
    2122219008,
    1987474944,
    84215040,
    1835887872,
    3082270464,
    2846468352,
    825307392,
    3520188672,
    387389184,
    67372032,
    3621246720,
    336860160,
    1482184704,
    976894464,
    1633771776,
    3739147776,
    454761216,
    286331136,
    471604224,
    842150400,
    252645120,
    2627509248,
    370546176,
    1397969664,
    404232192,
    4076007936,
    572662272,
    4278124032,
    1145324544,
    3486502656,
    2998055424,
    3284386560,
    3048584448,
    2054846976,
    2442236160,
    606348288,
    134744064,
    3907577856,
    2829625344,
    1616928768,
    4244438016,
    1768515840,
    1347440640,
    2863311360,
    3503345664,
    2694881280,
    2105376e3,
    2711724288,
    2307492096,
    1650614784,
    2543294208,
    1414812672,
    1532713728,
    505290240,
    2509608192,
    3772833792,
    4294967040,
    1684300800,
    3537031680,
    269488128,
    3301229568,
    0,
    1212696576,
    2745410304,
    4160222976,
    1970631936,
    3688618752,
    2324335104,
    50529024,
    3873891840,
    3671775744,
    151587072,
    1061109504,
    3722304768,
    2492765184,
    2273806080,
    1549556736,
    2206434048,
    33686016,
    3452816640,
    1246382592,
    2425393152,
    858993408,
    1936945920,
    1734829824,
    4143379968,
    4092850944,
    2644352256,
    2139062016,
    3217014528,
    3806519808,
    1381126656,
    2610666240,
    3638089728,
    640034304,
    3368601600,
    926365440,
    3334915584,
    993737472,
    2172748032,
    2526451200,
    1869573888,
    1263225600,
    320017152,
    3200171520,
    1667457792,
    774778368,
    3924420864,
    2038003968,
    2812782336,
    2358021120,
    2678038272,
    1852730880,
    3166485504,
    2391707136,
    690563328,
    4126536960,
    4193908992,
    3065427456,
    791621376,
    4261281024,
    3031741440,
    1499027712,
    2021160960,
    2560137216,
    101058048,
    1785358848,
    3890734848,
    1179010560,
    1903259904,
    3132799488,
    3570717696,
    623191296,
    2880154368,
    1111638528,
    2290649088,
    2728567296,
    2374864128,
    4210752e3,
    1920102912,
    117901056,
    3115956480,
    1431655680,
    4177065984,
    4008635904,
    2896997376,
    168430080,
    909522432,
    1229539584,
    707406336,
    1751672832,
    1010580480,
    943208448,
    4059164928,
    2762253312,
    1077952512,
    673720320,
    3553874688,
    2071689984,
    3149642496,
    3385444608,
    1128481536,
    3250700544,
    353703168,
    3823362816,
    2913840384,
    4109693952,
    2004317952,
    3351758592,
    2155905024,
    2661195264
  ]), i = new Uint32Array([
    14737632,
    328965,
    5789784,
    14277081,
    6776679,
    5131854,
    8487297,
    13355979,
    13224393,
    723723,
    11447982,
    6974058,
    14013909,
    1579032,
    6118749,
    8553090,
    4605510,
    14671839,
    14079702,
    2565927,
    9079434,
    3289650,
    4934475,
    4342338,
    14408667,
    1842204,
    10395294,
    10263708,
    3815994,
    13290186,
    2434341,
    8092539,
    855309,
    7434609,
    6250335,
    2039583,
    16316664,
    14145495,
    4079166,
    10329501,
    8158332,
    6316128,
    12171705,
    12500670,
    12369084,
    9145227,
    1447446,
    3421236,
    5066061,
    12829635,
    7500402,
    9803157,
    11250603,
    9342606,
    12237498,
    8026746,
    11776947,
    131586,
    11842740,
    11382189,
    10658466,
    11316396,
    14211288,
    10132122,
    1513239,
    1710618,
    3487029,
    13421772,
    16250871,
    10066329,
    6381921,
    5921370,
    15263976,
    2368548,
    5658198,
    4210752,
    14803425,
    6513507,
    592137,
    3355443,
    12566463,
    10000536,
    9934743,
    8750469,
    6842472,
    16579836,
    15527148,
    657930,
    14342874,
    7303023,
    5460819,
    6447714,
    10724259,
    3026478,
    526344,
    11513775,
    2631720,
    11579568,
    7631988,
    12763842,
    12434877,
    3552822,
    2236962,
    3684408,
    6579300,
    1973790,
    3750201,
    2894892,
    10921638,
    3158064,
    15066597,
    4473924,
    16645629,
    8947848,
    10461087,
    6645093,
    8882055,
    7039851,
    16053492,
    2302755,
    4737096,
    1052688,
    13750737,
    5329233,
    12632256,
    16382457,
    13816530,
    10526880,
    5592405,
    10592673,
    4276545,
    16448250,
    4408131,
    1250067,
    12895428,
    3092271,
    11053224,
    11974326,
    3947580,
    2829099,
    12698049,
    16777215,
    13158600,
    10855845,
    2105376,
    9013641,
    0,
    9474192,
    4671303,
    15724527,
    15395562,
    12040119,
    1381653,
    394758,
    13487565,
    11908533,
    1184274,
    8289918,
    12303291,
    2697513,
    986895,
    12105912,
    460551,
    263172,
    10197915,
    9737364,
    2171169,
    6710886,
    15132390,
    13553358,
    15592941,
    15198183,
    3881787,
    16711422,
    8355711,
    12961221,
    10790052,
    3618615,
    11645361,
    5000268,
    9539985,
    7237230,
    9276813,
    7763574,
    197379,
    2960685,
    14606046,
    9868950,
    2500134,
    8224125,
    13027014,
    6052956,
    13882323,
    15921906,
    5197647,
    1644825,
    4144959,
    14474460,
    7960953,
    1907997,
    5395026,
    15461355,
    15987699,
    7171437,
    6184542,
    16514043,
    6908265,
    11711154,
    15790320,
    3223857,
    789516,
    13948116,
    13619151,
    9211020,
    14869218,
    7697781,
    11119017,
    4868682,
    5723991,
    8684676,
    1118481,
    4539717,
    1776411,
    16119285,
    15000804,
    921102,
    7566195,
    11184810,
    15856113,
    14540253,
    5855577,
    1315860,
    7105644,
    9605778,
    5526612,
    13684944,
    7895160,
    7368816,
    14935011,
    4802889,
    8421504,
    5263440,
    10987431,
    16185078,
    7829367,
    9671571,
    8816262,
    8618883,
    2763306,
    13092807,
    5987163,
    15329769,
    15658734,
    9408399,
    65793,
    4013373
  ]), n = new Uint32Array([
    939538488,
    1090535745,
    369104406,
    1979741814,
    3640711641,
    2466288531,
    1610637408,
    4060148466,
    1912631922,
    3254829762,
    2868947883,
    2583730842,
    1962964341,
    100664838,
    1459640151,
    2684395680,
    2432733585,
    4144035831,
    3036722613,
    3372272073,
    2717950626,
    2348846220,
    3523269330,
    2415956112,
    4127258358,
    117442311,
    2801837991,
    654321447,
    2382401166,
    2986390194,
    1224755529,
    3724599006,
    1124090691,
    1543527516,
    3607156695,
    3338717127,
    1040203326,
    4110480885,
    2399178639,
    1728079719,
    520101663,
    402659352,
    1845522030,
    2936057775,
    788541231,
    3791708898,
    2231403909,
    218107149,
    1392530259,
    4026593520,
    2617285788,
    1694524773,
    3925928682,
    2734728099,
    2919280302,
    2650840734,
    3959483628,
    2147516544,
    754986285,
    1795189611,
    2818615464,
    721431339,
    905983542,
    2785060518,
    3305162181,
    2248181382,
    1291865421,
    855651123,
    4244700669,
    1711302246,
    1476417624,
    2516620950,
    973093434,
    150997257,
    2499843477,
    268439568,
    2013296760,
    3623934168,
    1107313218,
    3422604492,
    4009816047,
    637543974,
    3842041317,
    1627414881,
    436214298,
    1056980799,
    989870907,
    2181071490,
    3053500086,
    3674266587,
    3556824276,
    2550175896,
    3892373736,
    2332068747,
    33554946,
    3942706155,
    167774730,
    738208812,
    486546717,
    2952835248,
    1862299503,
    2365623693,
    2281736328,
    234884622,
    419436825,
    2264958855,
    1308642894,
    184552203,
    2835392937,
    201329676,
    2030074233,
    285217041,
    2130739071,
    570434082,
    3875596263,
    1493195097,
    3774931425,
    3657489114,
    1023425853,
    3355494600,
    301994514,
    67109892,
    1946186868,
    1409307732,
    805318704,
    2113961598,
    3019945140,
    671098920,
    1426085205,
    1744857192,
    1342197840,
    3187719870,
    3489714384,
    3288384708,
    822096177,
    3405827019,
    704653866,
    2902502829,
    251662095,
    3389049546,
    1879076976,
    4278255615,
    838873650,
    1761634665,
    134219784,
    1644192354,
    0,
    603989028,
    3506491857,
    4211145723,
    3120609978,
    3976261101,
    1157645637,
    2164294017,
    1929409395,
    1828744557,
    2214626436,
    2667618207,
    3993038574,
    1241533002,
    3271607235,
    771763758,
    3238052289,
    16777473,
    3858818790,
    620766501,
    1207978056,
    2566953369,
    3103832505,
    3003167667,
    2063629179,
    4177590777,
    3456159438,
    3204497343,
    3741376479,
    1895854449,
    687876393,
    3439381965,
    1811967084,
    318771987,
    1677747300,
    2600508315,
    1660969827,
    2634063261,
    3221274816,
    1258310475,
    3070277559,
    2768283045,
    2298513801,
    1593859935,
    2969612721,
    385881879,
    4093703412,
    3154164924,
    3540046803,
    1174423110,
    3472936911,
    922761015,
    1577082462,
    1191200583,
    2483066004,
    4194368250,
    4227923196,
    1526750043,
    2533398423,
    4261478142,
    1509972570,
    2885725356,
    1006648380,
    1275087948,
    50332419,
    889206069,
    4076925939,
    587211555,
    3087055032,
    1560304989,
    1778412138,
    2449511058,
    3573601749,
    553656609,
    1140868164,
    1358975313,
    3321939654,
    2097184125,
    956315961,
    2197848963,
    3691044060,
    2852170410,
    2080406652,
    1996519287,
    1442862678,
    83887365,
    452991771,
    2751505572,
    352326933,
    872428596,
    503324190,
    469769244,
    4160813304,
    1375752786,
    536879136,
    335549460,
    3909151209,
    3170942397,
    3707821533,
    3825263844,
    2701173153,
    3758153952,
    2315291274,
    4043370993,
    3590379222,
    2046851706,
    3137387451,
    3808486371,
    1073758272,
    1325420367
  ]), c = new Uint32Array([
    1886388336,
    741081132,
    3014852787,
    3233808576,
    3840147684,
    1465319511,
    3941204202,
    2930639022,
    589496355,
    1802174571,
    1162149957,
    2779054245,
    3991732461,
    1330577487,
    488439837,
    2459041938,
    2256928902,
    2947481775,
    2088501372,
    522125343,
    1044250686,
    3705405660,
    1583218782,
    185270283,
    2795896998,
    960036921,
    3587506389,
    1566376029,
    3654877401,
    1515847770,
    1364262993,
    1819017324,
    2341142667,
    2593783962,
    4227531003,
    2964324528,
    1953759348,
    724238379,
    4042260720,
    2223243396,
    3755933919,
    3419078859,
    875823156,
    1987444854,
    1835860077,
    2846425257,
    3520135377,
    67371012,
    336855060,
    976879674,
    3739091166,
    286326801,
    842137650,
    2627469468,
    1397948499,
    4075946226,
    4278059262,
    3486449871,
    3284336835,
    2054815866,
    606339108,
    3907518696,
    1616904288,
    1768489065,
    2863268010,
    2694840480,
    2711683233,
    1650589794,
    1414791252,
    505282590,
    3772776672,
    1684275300,
    269484048,
    0,
    2745368739,
    1970602101,
    2324299914,
    3873833190,
    151584777,
    3722248413,
    2273771655,
    2206400643,
    3452764365,
    2425356432,
    1936916595,
    4143317238,
    2644312221,
    3216965823,
    1381105746,
    3638034648,
    3368550600,
    3334865094,
    2172715137,
    1869545583,
    320012307,
    1667432547,
    3924361449,
    2812739751,
    2677997727,
    3166437564,
    690552873,
    4193845497,
    791609391,
    3031695540,
    2021130360,
    101056518,
    3890675943,
    1903231089,
    3570663636,
    2880110763,
    2290614408,
    2374828173,
    1920073842,
    3115909305,
    4177002744,
    2896953516,
    909508662,
    707395626,
    1010565180,
    4059103473,
    1077936192,
    3553820883,
    3149594811,
    1128464451,
    353697813,
    2913796269,
    2004287607,
    2155872384,
    2189557890,
    3974889708,
    656867367,
    3856990437,
    2240086149,
    892665909,
    202113036,
    1094778945,
    4025417967,
    2475884691,
    421068825,
    555810849,
    235798542,
    1313734734,
    1701118053,
    3183280317,
    3099066552,
    2408513679,
    3958046955,
    3469607118,
    808452144,
    1600061535,
    3318022341,
    437911578,
    3789619425,
    3402236106,
    1195835463,
    1027407933,
    16842753,
    3604349142,
    1448476758,
    1296891981,
    218955789,
    1717960806,
    3435921612,
    757923885,
    303169554,
    538968096,
    2981167281,
    2576941209,
    1280049228,
    3267494082,
    2122186878,
    84213765,
    3082223799,
    825294897,
    387383319,
    3621191895,
    1482162264,
    1633747041,
    454754331,
    471597084,
    252641295,
    370540566,
    404226072,
    572653602,
    1145307204,
    2998010034,
    3048538293,
    2442199185,
    134742024,
    2829582504,
    4244373756,
    1347420240,
    3503292624,
    2105344125,
    2307457161,
    2543255703,
    1532690523,
    2509570197,
    4294902015,
    3536978130,
    3301179588,
    1212678216,
    4160159991,
    3688562907,
    50528259,
    3671720154,
    1061093439,
    2492727444,
    1549533276,
    33685506,
    1246363722,
    858980403,
    1734803559,
    4092788979,
    2139029631,
    3806462178,
    2610626715,
    640024614,
    926351415,
    993722427,
    2526412950,
    1263206475,
    3200123070,
    774766638,
    2037973113,
    2357985420,
    1852702830,
    2391670926,
    4126474485,
    3065381046,
    4261216509,
    1499005017,
    2560098456,
    1785331818,
    1178992710,
    3132752058,
    623181861,
    1111621698,
    2728525986,
    4210688250,
    117899271,
    1431634005,
    4008575214,
    168427530,
    1229520969,
    1751646312,
    943194168,
    2762211492,
    673710120,
    2071658619,
    3385393353,
    3250651329,
    3823304931,
    4109631732,
    3351707847,
    2661154974
  ]);
  class o {
    constructor() {
      this.key = new Uint32Array(52), this.block = new Uint32Array(4);
    }
    get blockSize() {
      return 16;
    }
    init(A) {
      return r(Buffer.isBuffer(A)), r(A.length === 16), this.keySchedule(A), this;
    }
    keySchedule(A) {
      const _ = this.block, q = this.key;
      return _[0] = I(A, 0), _[1] = I(A, 4), _[2] = I(A, 8), _[3] = I(A, 12), g(q, 0, 1, 2, 3, _, 0, 1, 2, 3), h(_, 0, 1, 2, 3, e[0], e[1]), h(_, 2, 3, 0, 1, e[2], e[3]), w(_, 0, 1, 2, 3, q, 0, 1, 2, 3), h(_, 0, 1, 2, 3, e[4], e[5]), h(_, 2, 3, 0, 1, e[6], e[7]), g(q, 4, 5, 6, 7, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 15), g(q, 12, 13, 14, 15, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 15), g(q, 16, 17, 18, 19, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 15), b(q, 24, 25, _, 0, 1), x(_, 0, 1, 2, 3, 15), g(q, 28, 29, 30, 31, _, 0, 1, 2, 3), x(_, 1, 2, 3, 0, 2), g(q, 40, 41, 42, 43, _, 1, 2, 3, 0), x(_, 1, 2, 3, 0, 17), g(q, 48, 49, 50, 51, _, 1, 2, 3, 0), g(_, 0, 1, 2, 3, q, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 15), g(q, 8, 9, 10, 11, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 30), g(q, 20, 21, 22, 23, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 15), b(q, 26, 27, _, 2, 3), x(_, 0, 1, 2, 3, 17), g(q, 32, 33, 34, 35, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 17), g(q, 36, 37, 38, 39, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 17), g(q, 44, 45, 46, 47, _, 0, 1, 2, 3), this;
    }
    encrypt(A, _, q, U) {
      const z = this.block, E = this.key;
      z[0] = I(q, U + 0), z[1] = I(q, U + 4), z[2] = I(q, U + 8), z[3] = I(q, U + 12), w(z, 0, 1, 2, 3, E, 0, 1, 2, 3), h(z, 0, 1, 2, 3, E[4], E[5]), h(z, 2, 3, 0, 1, E[6], E[7]), h(z, 0, 1, 2, 3, E[8], E[9]), h(z, 2, 3, 0, 1, E[10], E[11]), h(z, 0, 1, 2, 3, E[12], E[13]), h(z, 2, 3, 0, 1, E[14], E[15]);
      let H = z[0] & E[16];
      z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[19], z[0] ^= z[1] | E[17], H = z[2] & E[18], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[20], E[21]), h(z, 2, 3, 0, 1, E[22], E[23]), h(z, 0, 1, 2, 3, E[24], E[25]), h(z, 2, 3, 0, 1, E[26], E[27]), h(z, 0, 1, 2, 3, E[28], E[29]), h(z, 2, 3, 0, 1, E[30], E[31]), H = z[0] & E[32], z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[35], z[0] ^= z[1] | E[33], H = z[2] & E[34], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[36], E[37]), h(z, 2, 3, 0, 1, E[38], E[39]), h(z, 0, 1, 2, 3, E[40], E[41]), h(z, 2, 3, 0, 1, E[42], E[43]), h(z, 0, 1, 2, 3, E[44], E[45]), h(z, 2, 3, 0, 1, E[46], E[47]), w(z, 2, 3, 0, 1, E, 48, 49, 50, 51), B(A, z[2], _ + 0), B(A, z[3], _ + 4), B(A, z[0], _ + 8), B(A, z[1], _ + 12);
    }
    decrypt(A, _, q, U) {
      const z = this.block, E = this.key;
      z[0] = I(q, U + 0), z[1] = I(q, U + 4), z[2] = I(q, U + 8), z[3] = I(q, U + 12), w(z, 3, 2, 1, 0, E, 51, 50, 49, 48), h(z, 0, 1, 2, 3, E[46], E[47]), h(z, 2, 3, 0, 1, E[44], E[45]), h(z, 0, 1, 2, 3, E[42], E[43]), h(z, 2, 3, 0, 1, E[40], E[41]), h(z, 0, 1, 2, 3, E[38], E[39]), h(z, 2, 3, 0, 1, E[36], E[37]);
      let H = z[0] & E[34];
      return z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[33], z[0] ^= z[1] | E[35], H = z[2] & E[32], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[30], E[31]), h(z, 2, 3, 0, 1, E[28], E[29]), h(z, 0, 1, 2, 3, E[26], E[27]), h(z, 2, 3, 0, 1, E[24], E[25]), h(z, 0, 1, 2, 3, E[22], E[23]), h(z, 2, 3, 0, 1, E[20], E[21]), H = z[0] & E[18], z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[17], z[0] ^= z[1] | E[19], H = z[2] & E[16], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[14], E[15]), h(z, 2, 3, 0, 1, E[12], E[13]), h(z, 0, 1, 2, 3, E[10], E[11]), h(z, 2, 3, 0, 1, E[8], E[9]), h(z, 0, 1, 2, 3, E[6], E[7]), h(z, 2, 3, 0, 1, E[4], E[5]), w(z, 1, 0, 3, 2, E, 3, 2, 1, 0), B(A, z[2], _ + 0), B(A, z[3], _ + 4), B(A, z[0], _ + 8), B(A, z[1], _ + 12), this;
    }
    destroy() {
      for (let A = 0; A < 52; A++)
        this.key[A] = 0;
      for (let A = 0; A < 4; A++)
        this.block[A] = 0;
      return this;
    }
  }
  class d {
    constructor() {
      this.key = new Uint32Array(68), this.block = new Uint32Array(4);
    }
    get blockSize() {
      return 16;
    }
    init(A) {
      return r(Buffer.isBuffer(A)), r(A.length === 24 || A.length === 32), this.keySchedule(A), this;
    }
    keySchedule(A) {
      const _ = this.block, q = this.key;
      return q[0] = I(A, 0), q[1] = I(A, 4), q[2] = I(A, 8), q[3] = I(A, 12), q[8] = I(A, 16), q[9] = I(A, 20), A.length === 24 ? (q[10] = ~q[8], q[11] = ~q[9]) : (q[10] = I(A, 24), q[11] = I(A, 28)), _[0] = q[8] ^ q[0], _[1] = q[9] ^ q[1], _[2] = q[10] ^ q[2], _[3] = q[11] ^ q[3], h(_, 0, 1, 2, 3, e[0], e[1]), h(_, 2, 3, 0, 1, e[2], e[3]), w(_, 0, 1, 2, 3, q, 0, 1, 2, 3), h(_, 0, 1, 2, 3, e[4], e[5]), h(_, 2, 3, 0, 1, e[6], e[7]), g(q, 12, 13, 14, 15, _, 0, 1, 2, 3), w(_, 0, 1, 2, 3, q, 8, 9, 10, 11), h(_, 0, 1, 2, 3, e[8], e[9]), h(_, 2, 3, 0, 1, e[10], e[11]), g(q, 4, 5, 6, 7, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 30), g(q, 20, 21, 22, 23, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 30), g(q, 40, 41, 42, 43, _, 0, 1, 2, 3), x(_, 1, 2, 3, 0, 19), g(q, 64, 65, 66, 67, _, 1, 2, 3, 0), g(_, 0, 1, 2, 3, q, 8, 9, 10, 11), x(_, 0, 1, 2, 3, 15), g(q, 8, 9, 10, 11, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 15), g(q, 16, 17, 18, 19, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 30), g(q, 36, 37, 38, 39, _, 0, 1, 2, 3), x(_, 1, 2, 3, 0, 2), g(q, 52, 53, 54, 55, _, 1, 2, 3, 0), g(_, 0, 1, 2, 3, q, 12, 13, 14, 15), x(_, 0, 1, 2, 3, 15), g(q, 12, 13, 14, 15, _, 0, 1, 2, 3), x(_, 0, 1, 2, 3, 30), g(q, 28, 29, 30, 31, _, 0, 1, 2, 3), g(q, 48, 49, 50, 51, _, 1, 2, 3, 0), x(_, 1, 2, 3, 0, 17), g(q, 56, 57, 58, 59, _, 1, 2, 3, 0), g(_, 0, 1, 2, 3, q, 0, 1, 2, 3), x(_, 1, 2, 3, 0, 13), g(q, 24, 25, 26, 27, _, 1, 2, 3, 0), x(_, 1, 2, 3, 0, 15), g(q, 32, 33, 34, 35, _, 1, 2, 3, 0), x(_, 1, 2, 3, 0, 17), g(q, 44, 45, 46, 47, _, 1, 2, 3, 0), x(_, 2, 3, 0, 1, 2), g(q, 60, 61, 62, 63, _, 2, 3, 0, 1), this;
    }
    encrypt(A, _, q, U) {
      const z = this.block, E = this.key;
      z[0] = I(q, U + 0), z[1] = I(q, U + 4), z[2] = I(q, U + 8), z[3] = I(q, U + 12), w(z, 0, 1, 2, 3, E, 0, 1, 2, 3), h(z, 0, 1, 2, 3, E[4], E[5]), h(z, 2, 3, 0, 1, E[6], E[7]), h(z, 0, 1, 2, 3, E[8], E[9]), h(z, 2, 3, 0, 1, E[10], E[11]), h(z, 0, 1, 2, 3, E[12], E[13]), h(z, 2, 3, 0, 1, E[14], E[15]);
      let H = z[0] & E[16];
      return z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[19], z[0] ^= z[1] | E[17], H = z[2] & E[18], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[20], E[21]), h(z, 2, 3, 0, 1, E[22], E[23]), h(z, 0, 1, 2, 3, E[24], E[25]), h(z, 2, 3, 0, 1, E[26], E[27]), h(z, 0, 1, 2, 3, E[28], E[29]), h(z, 2, 3, 0, 1, E[30], E[31]), H = z[0] & E[32], z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[35], z[0] ^= z[1] | E[33], H = z[2] & E[34], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[36], E[37]), h(z, 2, 3, 0, 1, E[38], E[39]), h(z, 0, 1, 2, 3, E[40], E[41]), h(z, 2, 3, 0, 1, E[42], E[43]), h(z, 0, 1, 2, 3, E[44], E[45]), h(z, 2, 3, 0, 1, E[46], E[47]), H = z[0] & E[48], z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[51], z[0] ^= z[1] | E[49], H = z[2] & E[50], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[52], E[53]), h(z, 2, 3, 0, 1, E[54], E[55]), h(z, 0, 1, 2, 3, E[56], E[57]), h(z, 2, 3, 0, 1, E[58], E[59]), h(z, 0, 1, 2, 3, E[60], E[61]), h(z, 2, 3, 0, 1, E[62], E[63]), w(z, 2, 3, 0, 1, E, 64, 65, 66, 67), B(A, z[2], _ + 0), B(A, z[3], _ + 4), B(A, z[0], _ + 8), B(A, z[1], _ + 12), this;
    }
    decrypt(A, _, q, U) {
      const z = this.block, E = this.key;
      z[0] = I(q, U + 0), z[1] = I(q, U + 4), z[2] = I(q, U + 8), z[3] = I(q, U + 12), w(z, 3, 2, 1, 0, E, 67, 66, 65, 64), h(z, 0, 1, 2, 3, E[62], E[63]), h(z, 2, 3, 0, 1, E[60], E[61]), h(z, 0, 1, 2, 3, E[58], E[59]), h(z, 2, 3, 0, 1, E[56], E[57]), h(z, 0, 1, 2, 3, E[54], E[55]), h(z, 2, 3, 0, 1, E[52], E[53]);
      let H = z[0] & E[50];
      return z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[49], z[0] ^= z[1] | E[51], H = z[2] & E[48], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[46], E[47]), h(z, 2, 3, 0, 1, E[44], E[45]), h(z, 0, 1, 2, 3, E[42], E[43]), h(z, 2, 3, 0, 1, E[40], E[41]), h(z, 0, 1, 2, 3, E[38], E[39]), h(z, 2, 3, 0, 1, E[36], E[37]), H = z[0] & E[34], z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[33], z[0] ^= z[1] | E[35], H = z[2] & E[32], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[30], E[31]), h(z, 2, 3, 0, 1, E[28], E[29]), h(z, 0, 1, 2, 3, E[26], E[27]), h(z, 2, 3, 0, 1, E[24], E[25]), h(z, 0, 1, 2, 3, E[22], E[23]), h(z, 2, 3, 0, 1, E[20], E[21]), H = z[0] & E[18], z[1] ^= H << 1 | H >>> 32 - 1, z[2] ^= z[3] | E[17], z[0] ^= z[1] | E[19], H = z[2] & E[16], z[3] ^= H << 1 | H >>> 32 - 1, h(z, 0, 1, 2, 3, E[14], E[15]), h(z, 2, 3, 0, 1, E[12], E[13]), h(z, 0, 1, 2, 3, E[10], E[11]), h(z, 2, 3, 0, 1, E[8], E[9]), h(z, 0, 1, 2, 3, E[6], E[7]), h(z, 2, 3, 0, 1, E[4], E[5]), w(z, 1, 0, 3, 2, E, 3, 2, 1, 0), B(A, z[2], _ + 0), B(A, z[3], _ + 4), B(A, z[0], _ + 8), B(A, z[1], _ + 12), this;
    }
    destroy() {
      for (let A = 0; A < 68; A++)
        this.key[A] = 0;
      for (let A = 0; A < 4; A++)
        this.block[A] = 0;
      return this;
    }
  }
  class l {
    constructor(A) {
      switch (r(A >>> 0 === A), this.bits = A, this.ctx = null, A) {
        case 128:
          this.ctx = new o();
          break;
        case 192:
        case 256:
          this.ctx = new d();
          break;
        default:
          throw new Error("Invalid key size.");
      }
    }
    get blockSize() {
      return this.ctx.blockSize;
    }
    init(A) {
      return r(Buffer.isBuffer(A)), r(A.length === this.bits >>> 3), this.ctx.init(A), this;
    }
    encrypt(A, _, q, U) {
      return this.ctx.encrypt(A, _, q, U), this;
    }
    decrypt(A, _, q, U) {
      return this.ctx.decrypt(A, _, q, U), this;
    }
    destroy() {
      return this.ctx.destroy(), this;
    }
  }
  function h(y, A, _, q, U, z, E) {
    let H;
    z ^= y[A], E ^= y[_], H = c[z >>> 0 & 255] ^ n[z >>> 8 & 255] ^ i[z >>> 16 & 255] ^ t[z >>> 24 & 255], y[U] ^= H >>> 8 | H << 32 - 8, H ^= t[E >>> 0 & 255] ^ c[E >>> 8 & 255] ^ n[E >>> 16 & 255] ^ i[E >>> 24 & 255], y[q] ^= H, y[U] ^= H;
  }
  function x(y, A, _, q, U, z) {
    const E = y[A] >>> 32 - z;
    y[A] = y[A] << z | y[_] >>> 32 - z, y[_] = y[_] << z | y[q] >>> 32 - z, y[q] = y[q] << z | y[U] >>> 32 - z, y[U] = y[U] << z | E;
  }
  function b(y, A, _, q, U, z) {
    y[A] = q[U], y[_] = q[z];
  }
  function g(y, A, _, q, U, z, E, H, k, V) {
    y[A] = z[E], y[_] = z[H], y[q] = z[k], y[U] = z[V];
  }
  function w(y, A, _, q, U, z, E, H, k, V) {
    y[A] ^= z[E], y[_] ^= z[H], y[q] ^= z[k], y[U] ^= z[V];
  }
  function I(y, A) {
    return y[A++] * 16777216 + y[A++] * 65536 + y[A++] * 256 + y[A];
  }
  function B(y, A, _) {
    return y[_++] = A >>> 24, y[_++] = A >>> 16, y[_++] = A >>> 8, y[_++] = A >>> 0, _;
  }
  return Wa = l, Wa;
}
/*!
 * cast5.js - CAST5 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/CAST-128
 *   https://tools.ietf.org/html/rfc2144
 *   https://github.com/golang/crypto/blob/master/cast5/cast5.go
 */
var ja, j2;
function Rm() {
  if (j2)
    return ja;
  j2 = 1;
  const r = _e, e = [
    new Uint32Array([
      821772500,
      2678128395,
      1810681135,
      1059425402,
      505495343,
      2617265619,
      1610868032,
      3483355465,
      3218386727,
      2294005173,
      3791863952,
      2563806837,
      1852023008,
      365126098,
      3269944861,
      584384398,
      677919599,
      3229601881,
      4280515016,
      2002735330,
      1136869587,
      3744433750,
      2289869850,
      2731719981,
      2714362070,
      879511577,
      1639411079,
      575934255,
      717107937,
      2857637483,
      576097850,
      2731753936,
      1725645e3,
      2810460463,
      5111599,
      767152862,
      2543075244,
      1251459544,
      1383482551,
      3052681127,
      3089939183,
      3612463449,
      1878520045,
      1510570527,
      2189125840,
      2431448366,
      582008916,
      3163445557,
      1265446783,
      1354458274,
      3529918736,
      3202711853,
      3073581712,
      3912963487,
      3029263377,
      1275016285,
      4249207360,
      2905708351,
      3304509486,
      1442611557,
      3585198765,
      2712415662,
      2731849581,
      3248163920,
      2283946226,
      208555832,
      2766454743,
      1331405426,
      1447828783,
      3315356441,
      3108627284,
      2957404670,
      2981538698,
      3339933917,
      1669711173,
      286233437,
      1465092821,
      1782121619,
      3862771680,
      710211251,
      980974943,
      1651941557,
      430374111,
      2051154026,
      704238805,
      4128970897,
      3144820574,
      2857402727,
      948965521,
      3333752299,
      2227686284,
      718756367,
      2269778983,
      2731643755,
      718440111,
      2857816721,
      3616097120,
      1113355533,
      2478022182,
      410092745,
      1811985197,
      1944238868,
      2696854588,
      1415722873,
      1682284203,
      1060277122,
      1998114690,
      1503841958,
      82706478,
      2315155686,
      1068173648,
      845149890,
      2167947013,
      1768146376,
      1993038550,
      3566826697,
      3390574031,
      940016341,
      3355073782,
      2328040721,
      904371731,
      1205506512,
      4094660742,
      2816623006,
      825647681,
      85914773,
      2857843460,
      1249926541,
      1417871568,
      3287612,
      3211054559,
      3126306446,
      1975924523,
      1353700161,
      2814456437,
      2438597621,
      1800716203,
      722146342,
      2873936343,
      1151126914,
      4160483941,
      2877670899,
      458611604,
      2866078500,
      3483680063,
      770352098,
      2652916994,
      3367839148,
      3940505011,
      3585973912,
      3809620402,
      718646636,
      2504206814,
      2914927912,
      3631288169,
      2857486607,
      2860018678,
      575749918,
      2857478043,
      718488780,
      2069512688,
      3548183469,
      453416197,
      1106044049,
      3032691430,
      52586708,
      3378514636,
      3459808877,
      3211506028,
      1785789304,
      218356169,
      3571399134,
      3759170522,
      1194783844,
      1523787992,
      3007827094,
      1975193539,
      2555452411,
      1341901877,
      3045838698,
      3776907964,
      3217423946,
      2802510864,
      2889438986,
      1057244207,
      1636348243,
      3761863214,
      1462225785,
      2632663439,
      481089165,
      718503062,
      24497053,
      3332243209,
      3344655856,
      3655024856,
      3960371065,
      1195698900,
      2971415156,
      3710176158,
      2115785917,
      4027663609,
      3525578417,
      2524296189,
      2745972565,
      3564906415,
      1372086093,
      1452307862,
      2780501478,
      1476592880,
      3389271281,
      18495466,
      2378148571,
      901398090,
      891748256,
      3279637769,
      3157290713,
      2560960102,
      1447622437,
      4284372637,
      216884176,
      2086908623,
      1879786977,
      3588903153,
      2242455666,
      2938092967,
      3559082096,
      2810645491,
      758861177,
      1121993112,
      215018983,
      642190776,
      4169236812,
      1196255959,
      2081185372,
      3508738393,
      941322904,
      4124243163,
      2877523539,
      1848581667,
      2205260958,
      3180453958,
      2589345134,
      3694731276,
      550028657,
      2519456284,
      3789985535,
      2973870856,
      2093648313,
      443148163,
      46942275,
      2734146937,
      1117713533,
      1115362972,
      1523183689,
      3717140224,
      1551984063
    ]),
    new Uint32Array([
      522195092,
      4010518363,
      1776537470,
      960447360,
      4267822970,
      4005896314,
      1435016340,
      1929119313,
      2913464185,
      1310552629,
      3579470798,
      3724818106,
      2579771631,
      1594623892,
      417127293,
      2715217907,
      2696228731,
      1508390405,
      3994398868,
      3925858569,
      3695444102,
      4019471449,
      3129199795,
      3770928635,
      3520741761,
      990456497,
      4187484609,
      2783367035,
      21106139,
      3840405339,
      631373633,
      3783325702,
      532942976,
      396095098,
      3548038825,
      4267192484,
      2564721535,
      2011709262,
      2039648873,
      620404603,
      3776170075,
      2898526339,
      3612357925,
      4159332703,
      1645490516,
      223693667,
      1567101217,
      3362177881,
      1029951347,
      3470931136,
      3570957959,
      1550265121,
      119497089,
      972513919,
      907948164,
      3840628539,
      1613718692,
      3594177948,
      465323573,
      2659255085,
      654439692,
      2575596212,
      2699288441,
      3127702412,
      277098644,
      624404830,
      4100943870,
      2717858591,
      546110314,
      2403699828,
      3655377447,
      1321679412,
      4236791657,
      1045293279,
      4010672264,
      895050893,
      2319792268,
      494945126,
      1914543101,
      2777056443,
      3894764339,
      2219737618,
      311263384,
      4275257268,
      3458730721,
      669096869,
      3584475730,
      3835122877,
      3319158237,
      3949359204,
      2005142349,
      2713102337,
      2228954793,
      3769984788,
      569394103,
      3855636576,
      1425027204,
      108000370,
      2736431443,
      3671869269,
      3043122623,
      1750473702,
      2211081108,
      762237499,
      3972989403,
      2798899386,
      3061857628,
      2943854345,
      867476300,
      964413654,
      1591880597,
      1594774276,
      2179821409,
      552026980,
      3026064248,
      3726140315,
      2283577634,
      3110545105,
      2152310760,
      582474363,
      1582640421,
      1383256631,
      2043843868,
      3322775884,
      1217180674,
      463797851,
      2763038571,
      480777679,
      2718707717,
      2289164131,
      3118346187,
      214354409,
      200212307,
      3810608407,
      3025414197,
      2674075964,
      3997296425,
      1847405948,
      1342460550,
      510035443,
      4080271814,
      815934613,
      833030224,
      1620250387,
      1945732119,
      2703661145,
      3966000196,
      1388869545,
      3456054182,
      2687178561,
      2092620194,
      562037615,
      1356438536,
      3409922145,
      3261847397,
      1688467115,
      2150901366,
      631725691,
      3840332284,
      549916902,
      3455104640,
      394546491,
      837744717,
      2114462948,
      751520235,
      2221554606,
      2415360136,
      3999097078,
      2063029875,
      803036379,
      2702586305,
      821456707,
      3019566164,
      360699898,
      4018502092,
      3511869016,
      3677355358,
      2402471449,
      812317050,
      49299192,
      2570164949,
      3259169295,
      2816732080,
      3331213574,
      3101303564,
      2156015656,
      3705598920,
      3546263921,
      143268808,
      3200304480,
      1638124008,
      3165189453,
      3341807610,
      578956953,
      2193977524,
      3638120073,
      2333881532,
      807278310,
      658237817,
      2969561766,
      1641658566,
      11683945,
      3086995007,
      148645947,
      1138423386,
      4158756760,
      1981396783,
      2401016740,
      3699783584,
      380097457,
      2680394679,
      2803068651,
      3334260286,
      441530178,
      4016580796,
      1375954390,
      761952171,
      891809099,
      2183123478,
      157052462,
      3683840763,
      1592404427,
      341349109,
      2438483839,
      1417898363,
      644327628,
      2233032776,
      2353769706,
      2201510100,
      220455161,
      1815641738,
      182899273,
      2995019788,
      3627381533,
      3702638151,
      2890684138,
      1052606899,
      588164016,
      1681439879,
      4038439418,
      2405343923,
      4229449282,
      167996282,
      1336969661,
      1688053129,
      2739224926,
      1543734051,
      1046297529,
      1138201970,
      2121126012,
      115334942,
      1819067631,
      1902159161,
      1941945968,
      2206692869,
      1159982321
    ]),
    new Uint32Array([
      2381300288,
      637164959,
      3952098751,
      3893414151,
      1197506559,
      916448331,
      2350892612,
      2932787856,
      3199334847,
      4009478890,
      3905886544,
      1373570990,
      2450425862,
      4037870920,
      3778841987,
      2456817877,
      286293407,
      124026297,
      3001279700,
      1028597854,
      3115296800,
      4208886496,
      2691114635,
      2188540206,
      1430237888,
      1218109995,
      3572471700,
      308166588,
      570424558,
      2187009021,
      2455094765,
      307733056,
      1310360322,
      3135275007,
      1384269543,
      2388071438,
      863238079,
      2359263624,
      2801553128,
      3380786597,
      2831162807,
      1470087780,
      1728663345,
      4072488799,
      1090516929,
      532123132,
      2389430977,
      1132193179,
      2578464191,
      3051079243,
      1670234342,
      1434557849,
      2711078940,
      1241591150,
      3314043432,
      3435360113,
      3091448339,
      1812415473,
      2198440252,
      267246943,
      796911696,
      3619716990,
      38830015,
      1526438404,
      2806502096,
      374413614,
      2943401790,
      1489179520,
      1603809326,
      1920779204,
      168801282,
      260042626,
      2358705581,
      1563175598,
      2397674057,
      1356499128,
      2217211040,
      514611088,
      2037363785,
      2186468373,
      4022173083,
      2792511869,
      2913485016,
      1173701892,
      4200428547,
      3896427269,
      1334932762,
      2455136706,
      602925377,
      2835607854,
      1613172210,
      41346230,
      2499634548,
      2457437618,
      2188827595,
      41386358,
      4172255629,
      1313404830,
      2405527007,
      3801973774,
      2217704835,
      873260488,
      2528884354,
      2478092616,
      4012915883,
      2555359016,
      2006953883,
      2463913485,
      575479328,
      2218240648,
      2099895446,
      660001756,
      2341502190,
      3038761536,
      3888151779,
      3848713377,
      3286851934,
      1022894237,
      1620365795,
      3449594689,
      1551255054,
      15374395,
      3570825345,
      4249311020,
      4151111129,
      3181912732,
      310226346,
      1133119310,
      530038928,
      136043402,
      2476768958,
      3107506709,
      2544909567,
      1036173560,
      2367337196,
      1681395281,
      1758231547,
      3641649032,
      306774401,
      1575354324,
      3716085866,
      1990386196,
      3114533736,
      2455606671,
      1262092282,
      3124342505,
      2768229131,
      4210529083,
      1833535011,
      423410938,
      660763973,
      2187129978,
      1639812e3,
      3508421329,
      3467445492,
      310289298,
      272797111,
      2188552562,
      2456863912,
      310240523,
      677093832,
      1013118031,
      901835429,
      3892695601,
      1116285435,
      3036471170,
      1337354835,
      243122523,
      520626091,
      277223598,
      4244441197,
      4194248841,
      1766575121,
      594173102,
      316590669,
      742362309,
      3536858622,
      4176435350,
      3838792410,
      2501204839,
      1229605004,
      3115755532,
      1552908988,
      2312334149,
      979407927,
      3959474601,
      1148277331,
      176638793,
      3614686272,
      2083809052,
      40992502,
      1340822838,
      2731552767,
      3535757508,
      3560899520,
      1354035053,
      122129617,
      7215240,
      2732932949,
      3118912700,
      2718203926,
      2539075635,
      3609230695,
      3725561661,
      1928887091,
      2882293555,
      1988674909,
      2063640240,
      2491088897,
      1459647954,
      4189817080,
      2302804382,
      1113892351,
      2237858528,
      1927010603,
      4002880361,
      1856122846,
      1594404395,
      2944033133,
      3855189863,
      3474975698,
      1643104450,
      4054590833,
      3431086530,
      1730235576,
      2984608721,
      3084664418,
      2131803598,
      4178205752,
      267404349,
      1617849798,
      1616132681,
      1462223176,
      736725533,
      2327058232,
      551665188,
      2945899023,
      1749386277,
      2575514597,
      1611482493,
      674206544,
      2201269090,
      3642560800,
      728599968,
      1680547377,
      2620414464,
      1388111496,
      453204106,
      4156223445,
      1094905244,
      2754698257,
      2201108165,
      3757000246,
      2704524545,
      3922940700,
      3996465027
    ]),
    new Uint32Array([
      2645754912,
      532081118,
      2814278639,
      3530793624,
      1246723035,
      1689095255,
      2236679235,
      4194438865,
      2116582143,
      3859789411,
      157234593,
      2045505824,
      4245003587,
      1687664561,
      4083425123,
      605965023,
      672431967,
      1336064205,
      3376611392,
      214114848,
      4258466608,
      3232053071,
      489488601,
      605322005,
      3998028058,
      264917351,
      1912574028,
      756637694,
      436560991,
      202637054,
      135989450,
      85393697,
      2152923392,
      3896401662,
      2895836408,
      2145855233,
      3535335007,
      115294817,
      3147733898,
      1922296357,
      3464822751,
      4117858305,
      1037454084,
      2725193275,
      2127856640,
      1417604070,
      1148013728,
      1827919605,
      642362335,
      2929772533,
      909348033,
      1346338451,
      3547799649,
      297154785,
      1917849091,
      4161712827,
      2883604526,
      3968694238,
      1469521537,
      3780077382,
      3375584256,
      1763717519,
      136166297,
      4290970789,
      1295325189,
      2134727907,
      2798151366,
      1566297257,
      3672928234,
      2677174161,
      2672173615,
      965822077,
      2780786062,
      289653839,
      1133871874,
      3491843819,
      35685304,
      1068898316,
      418943774,
      672553190,
      642281022,
      2346158704,
      1954014401,
      3037126780,
      4079815205,
      2030668546,
      3840588673,
      672283427,
      1776201016,
      359975446,
      3750173538,
      555499703,
      2769985273,
      1324923,
      69110472,
      152125443,
      3176785106,
      3822147285,
      1340634837,
      798073664,
      1434183902,
      15393959,
      216384236,
      1303690150,
      3881221631,
      3711134124,
      3960975413,
      106373927,
      2578434224,
      1455997841,
      1801814300,
      1578393881,
      1854262133,
      3188178946,
      3258078583,
      2302670060,
      1539295533,
      3505142565,
      3078625975,
      2372746020,
      549938159,
      3278284284,
      2620926080,
      181285381,
      2865321098,
      3970029511,
      68876850,
      488006234,
      1728155692,
      2608167508,
      836007927,
      2435231793,
      919367643,
      3339422534,
      3655756360,
      1457871481,
      40520939,
      1380155135,
      797931188,
      234455205,
      2255801827,
      3990488299,
      397000196,
      739833055,
      3077865373,
      2871719860,
      4022553888,
      772369276,
      390177364,
      3853951029,
      557662966,
      740064294,
      1640166671,
      1699928825,
      3535942136,
      622006121,
      3625353122,
      68743880,
      1742502,
      219489963,
      1664179233,
      1577743084,
      1236991741,
      410585305,
      2366487942,
      823226535,
      1050371084,
      3426619607,
      3586839478,
      212779912,
      4147118561,
      1819446015,
      1911218849,
      530248558,
      3486241071,
      3252585495,
      2886188651,
      3410272728,
      2342195030,
      20547779,
      2982490058,
      3032363469,
      3631753222,
      312714466,
      1870521650,
      1493008054,
      3491686656,
      615382978,
      4103671749,
      2534517445,
      1932181,
      2196105170,
      278426614,
      6369430,
      3274544417,
      2913018367,
      697336853,
      2143000447,
      2946413531,
      701099306,
      1558357093,
      2805003052,
      3500818408,
      2321334417,
      3567135975,
      216290473,
      3591032198,
      23009561,
      1996984579,
      3735042806,
      2024298078,
      3739440863,
      569400510,
      2339758983,
      3016033873,
      3097871343,
      3639523026,
      3844324983,
      3256173865,
      795471839,
      2951117563,
      4101031090,
      4091603803,
      3603732598,
      971261452,
      534414648,
      428311343,
      3389027175,
      2844869880,
      694888862,
      1227866773,
      2456207019,
      3043454569,
      2614353370,
      3749578031,
      3676663836,
      459166190,
      4132644070,
      1794958188,
      51825668,
      2252611902,
      3084671440,
      2036672799,
      3436641603,
      1099053433,
      2469121526,
      3059204941,
      1323291266,
      2061838604,
      1018778475,
      2233344254,
      2553501054,
      334295216,
      3556750194,
      1065731521,
      183467730
    ]),
    new Uint32Array([
      2127105028,
      745436345,
      2601412319,
      2788391185,
      3093987327,
      500390133,
      1155374404,
      389092991,
      150729210,
      3891597772,
      3523549952,
      1935325696,
      716645080,
      946045387,
      2901812282,
      1774124410,
      3869435775,
      4039581901,
      3293136918,
      3438657920,
      948246080,
      363898952,
      3867875531,
      1286266623,
      1598556673,
      68334250,
      630723836,
      1104211938,
      1312863373,
      613332731,
      2377784574,
      1101634306,
      441780740,
      3129959883,
      1917973735,
      2510624549,
      3238456535,
      2544211978,
      3308894634,
      1299840618,
      4076074851,
      1756332096,
      3977027158,
      297047435,
      3790297736,
      2265573040,
      3621810518,
      1311375015,
      1667687725,
      47300608,
      3299642885,
      2474112369,
      201668394,
      1468347890,
      576830978,
      3594690761,
      3742605952,
      1958042578,
      1747032512,
      3558991340,
      1408974056,
      3366841779,
      682131401,
      1033214337,
      1545599232,
      4265137049,
      206503691,
      103024618,
      2855227313,
      1337551222,
      2428998917,
      2963842932,
      4015366655,
      3852247746,
      2796956967,
      3865723491,
      3747938335,
      247794022,
      3755824572,
      702416469,
      2434691994,
      397379957,
      851939612,
      2314769512,
      218229120,
      1380406772,
      62274761,
      214451378,
      3170103466,
      2276210409,
      3845813286,
      28563499,
      446592073,
      1693330814,
      3453727194,
      29968656,
      3093872512,
      220656637,
      2470637031,
      77972100,
      1667708854,
      1358280214,
      4064765667,
      2395616961,
      325977563,
      4277240721,
      4220025399,
      3605526484,
      3355147721,
      811859167,
      3069544926,
      3962126810,
      652502677,
      3075892249,
      4132761541,
      3498924215,
      1217549313,
      3250244479,
      3858715919,
      3053989961,
      1538642152,
      2279026266,
      2875879137,
      574252750,
      3324769229,
      2651358713,
      1758150215,
      141295887,
      2719868960,
      3515574750,
      4093007735,
      4194485238,
      1082055363,
      3417560400,
      395511885,
      2966884026,
      179534037,
      3646028556,
      3738688086,
      1092926436,
      2496269142,
      257381841,
      3772900718,
      1636087230,
      1477059743,
      2499234752,
      3811018894,
      2675660129,
      3285975680,
      90732309,
      1684827095,
      1150307763,
      1723134115,
      3237045386,
      1769919919,
      1240018934,
      815675215,
      750138730,
      2239792499,
      1234303040,
      1995484674,
      138143821,
      675421338,
      1145607174,
      1936608440,
      3238603024,
      2345230278,
      2105974004,
      323969391,
      779555213,
      3004902369,
      2861610098,
      1017501463,
      2098600890,
      2628620304,
      2940611490,
      2682542546,
      1171473753,
      3656571411,
      3687208071,
      4091869518,
      393037935,
      159126506,
      1662887367,
      1147106178,
      391545844,
      3452332695,
      1891500680,
      3016609650,
      1851642611,
      546529401,
      1167818917,
      3194020571,
      2848076033,
      3953471836,
      575554290,
      475796850,
      4134673196,
      450035699,
      2351251534,
      844027695,
      1080539133,
      86184846,
      1554234488,
      3692025454,
      1972511363,
      2018339607,
      1491841390,
      1141460869,
      1061690759,
      4244549243,
      2008416118,
      2351104703,
      2868147542,
      1598468138,
      722020353,
      1027143159,
      212344630,
      1387219594,
      1725294528,
      3745187956,
      2500153616,
      458938280,
      4129215917,
      1828119673,
      544571780,
      3503225445,
      2297937496,
      1241802790,
      267843827,
      2694610800,
      1397140384,
      1558801448,
      3782667683,
      1806446719,
      929573330,
      2234912681,
      400817706,
      616011623,
      4121520928,
      3603768725,
      1761550015,
      1968522284,
      4053731006,
      4192232858,
      4005120285,
      872482584,
      3140537016,
      3894607381,
      2287405443,
      1963876937,
      3663887957,
      1584857e3,
      2975024454,
      1833426440,
      4025083860
    ]),
    new Uint32Array([
      4143615901,
      749497569,
      1285769319,
      3795025788,
      2514159847,
      23610292,
      3974978748,
      844452780,
      3214870880,
      3751928557,
      2213566365,
      1676510905,
      448177848,
      3730751033,
      4086298418,
      2307502392,
      871450977,
      3222878141,
      4110862042,
      3831651966,
      2735270553,
      1310974780,
      2043402188,
      1218528103,
      2736035353,
      4274605013,
      2702448458,
      3936360550,
      2693061421,
      162023535,
      2827510090,
      687910808,
      23484817,
      3784910947,
      3371371616,
      779677500,
      3503626546,
      3473927188,
      4157212626,
      3500679282,
      4248902014,
      2466621104,
      3899384794,
      1958663117,
      925738300,
      1283408968,
      3669349440,
      1840910019,
      137959847,
      2679828185,
      1239142320,
      1315376211,
      1547541505,
      1690155329,
      739140458,
      3128809933,
      3933172616,
      3876308834,
      905091803,
      1548541325,
      4040461708,
      3095483362,
      144808038,
      451078856,
      676114313,
      2861728291,
      2469707347,
      993665471,
      373509091,
      2599041286,
      4025009006,
      4170239449,
      2149739950,
      3275793571,
      3749616649,
      2794760199,
      1534877388,
      572371878,
      2590613551,
      1753320020,
      3467782511,
      1405125690,
      4270405205,
      633333386,
      3026356924,
      3475123903,
      632057672,
      2846462855,
      1404951397,
      3882875879,
      3915906424,
      195638627,
      2385783745,
      3902872553,
      1233155085,
      3355999740,
      2380578713,
      2702246304,
      2144565621,
      3663341248,
      3894384975,
      2502479241,
      4248018925,
      3094885567,
      1594115437,
      572884632,
      3385116731,
      767645374,
      1331858858,
      1475698373,
      3793881790,
      3532746431,
      1321687957,
      619889600,
      1121017241,
      3440213920,
      2070816767,
      2833025776,
      1933951238,
      4095615791,
      890643334,
      3874130214,
      859025556,
      360630002,
      925594799,
      1764062180,
      3920222280,
      4078305929,
      979562269,
      2810700344,
      4087740022,
      1949714515,
      546639971,
      1165388173,
      3069891591,
      1495988560,
      922170659,
      1291546247,
      2107952832,
      1813327274,
      3406010024,
      3306028637,
      4241950635,
      153207855,
      2313154747,
      1608695416,
      1150242611,
      1967526857,
      721801357,
      1220138373,
      3691287617,
      3356069787,
      2112743302,
      3281662835,
      1111556101,
      1778980689,
      250857638,
      2298507990,
      673216130,
      2846488510,
      3207751581,
      3562756981,
      3008625920,
      3417367384,
      2198807050,
      529510932,
      3547516680,
      3426503187,
      2364944742,
      102533054,
      2294910856,
      1617093527,
      1204784762,
      3066581635,
      1019391227,
      1069574518,
      1317995090,
      1691889997,
      3661132003,
      510022745,
      3238594800,
      1362108837,
      1817929911,
      2184153760,
      805817662,
      1953603311,
      3699844737,
      120799444,
      2118332377,
      207536705,
      2282301548,
      4120041617,
      145305846,
      2508124933,
      3086745533,
      3261524335,
      1877257368,
      2977164480,
      3160454186,
      2503252186,
      4221677074,
      759945014,
      254147243,
      2767453419,
      3801518371,
      629083197,
      2471014217,
      907280572,
      3900796746,
      940896768,
      2751021123,
      2625262786,
      3161476951,
      3661752313,
      3260732218,
      1425318020,
      2977912069,
      1496677566,
      3988592072,
      2140652971,
      3126511541,
      3069632175,
      977771578,
      1392695845,
      1698528874,
      1411812681,
      1369733098,
      1343739227,
      3620887944,
      1142123638,
      67414216,
      3102056737,
      3088749194,
      1626167401,
      2546293654,
      3941374235,
      697522451,
      33404913,
      143560186,
      2595682037,
      994885535,
      1247667115,
      3859094837,
      2699155541,
      3547024625,
      4114935275,
      2968073508,
      3199963069,
      2732024527,
      1237921620,
      951448369,
      1898488916,
      1211705605,
      2790989240,
      2233243581,
      3598044975
    ]),
    new Uint32Array([
      2246066201,
      858518887,
      1714274303,
      3485882003,
      713916271,
      2879113490,
      3730835617,
      539548191,
      36158695,
      1298409750,
      419087104,
      1358007170,
      749914897,
      2989680476,
      1261868530,
      2995193822,
      2690628854,
      3443622377,
      3780124940,
      3796824509,
      2976433025,
      4259637129,
      1551479e3,
      512490819,
      1296650241,
      951993153,
      2436689437,
      2460458047,
      144139966,
      3136204276,
      310820559,
      3068840729,
      643875328,
      1969602020,
      1680088954,
      2185813161,
      3283332454,
      672358534,
      198762408,
      896343282,
      276269502,
      3014846926,
      84060815,
      197145886,
      376173866,
      3943890818,
      3813173521,
      3545068822,
      1316698879,
      1598252827,
      2633424951,
      1233235075,
      859989710,
      2358460855,
      3503838400,
      3409603720,
      1203513385,
      1193654839,
      2792018475,
      2060853022,
      207403770,
      1144516871,
      3068631394,
      1121114134,
      177607304,
      3785736302,
      326409831,
      1929119770,
      2983279095,
      4183308101,
      3474579288,
      3200513878,
      3228482096,
      119610148,
      1170376745,
      3378393471,
      3163473169,
      951863017,
      3337026068,
      3135789130,
      2907618374,
      1183797387,
      2015970143,
      4045674555,
      2182986399,
      2952138740,
      3928772205,
      384012900,
      2454997643,
      10178499,
      2879818989,
      2596892536,
      111523738,
      2995089006,
      451689641,
      3196290696,
      235406569,
      1441906262,
      3890558523,
      3013735005,
      4158569349,
      1644036924,
      376726067,
      1006849064,
      3664579700,
      2041234796,
      1021632941,
      1374734338,
      2566452058,
      371631263,
      4007144233,
      490221539,
      206551450,
      3140638584,
      1053219195,
      1853335209,
      3412429660,
      3562156231,
      735133835,
      1623211703,
      3104214392,
      2738312436,
      4096837757,
      3366392578,
      3110964274,
      3956598718,
      3196820781,
      2038037254,
      3877786376,
      2339753847,
      300912036,
      3766732888,
      2372630639,
      1516443558,
      4200396704,
      1574567987,
      4069441456,
      4122592016,
      2699739776,
      146372218,
      2748961456,
      2043888151,
      35287437,
      2596680554,
      655490400,
      1132482787,
      110692520,
      1031794116,
      2188192751,
      1324057718,
      1217253157,
      919197030,
      686247489,
      3261139658,
      1028237775,
      3135486431,
      3059715558,
      2460921700,
      986174950,
      2661811465,
      4062904701,
      2752986992,
      3709736643,
      367056889,
      1353824391,
      731860949,
      1650113154,
      1778481506,
      784341916,
      357075625,
      3608602432,
      1074092588,
      2480052770,
      3811426202,
      92751289,
      877911070,
      3600361838,
      1231880047,
      480201094,
      3756190983,
      3094495953,
      434011822,
      87971354,
      363687820,
      1717726236,
      1901380172,
      3926403882,
      2481662265,
      400339184,
      1490350766,
      2661455099,
      1389319756,
      2558787174,
      784598401,
      1983468483,
      30828846,
      3550527752,
      2716276238,
      3841122214,
      1765724805,
      1955612312,
      1277890269,
      1333098070,
      1564029816,
      2704417615,
      1026694237,
      3287671188,
      1260819201,
      3349086767,
      1016692350,
      1582273796,
      1073413053,
      1995943182,
      694588404,
      1025494639,
      3323872702,
      3551898420,
      4146854327,
      453260480,
      1316140391,
      1435673405,
      3038941953,
      3486689407,
      1622062951,
      403978347,
      817677117,
      950059133,
      4246079218,
      3278066075,
      1486738320,
      1417279718,
      481875527,
      2549965225,
      3933690356,
      760697757,
      1452955855,
      3897451437,
      1177426808,
      1702951038,
      4085348628,
      2447005172,
      1084371187,
      3516436277,
      3068336338,
      1073369276,
      1027665953,
      3284188590,
      1230553676,
      1368340146,
      2226246512,
      267243139,
      2274220762,
      4070734279,
      2497715176,
      2423353163,
      2504755875
    ]),
    new Uint32Array([
      3793104909,
      3151888380,
      2817252029,
      895778965,
      2005530807,
      3871412763,
      237245952,
      86829237,
      296341424,
      3851759377,
      3974600970,
      2475086196,
      709006108,
      1994621201,
      2972577594,
      937287164,
      3734691505,
      168608556,
      3189338153,
      2225080640,
      3139713551,
      3033610191,
      3025041904,
      77524477,
      185966941,
      1208824168,
      2344345178,
      1721625922,
      3354191921,
      1066374631,
      1927223579,
      1971335949,
      2483503697,
      1551748602,
      2881383779,
      2856329572,
      3003241482,
      48746954,
      1398218158,
      2050065058,
      313056748,
      4255789917,
      393167848,
      1912293076,
      940740642,
      3465845460,
      3091687853,
      2522601570,
      2197016661,
      1727764327,
      364383054,
      492521376,
      1291706479,
      3264136376,
      1474851438,
      1685747964,
      2575719748,
      1619776915,
      1814040067,
      970743798,
      1561002147,
      2925768690,
      2123093554,
      1880132620,
      3151188041,
      697884420,
      2550985770,
      2607674513,
      2659114323,
      110200136,
      1489731079,
      997519150,
      1378877361,
      3527870668,
      478029773,
      2766872923,
      1022481122,
      431258168,
      1112503832,
      897933369,
      2635587303,
      669726182,
      3383752315,
      918222264,
      163866573,
      3246985393,
      3776823163,
      114105080,
      1903216136,
      761148244,
      3571337562,
      1690750982,
      3166750252,
      1037045171,
      1888456500,
      2010454850,
      642736655,
      616092351,
      365016990,
      1185228132,
      4174898510,
      1043824992,
      2023083429,
      2241598885,
      3863320456,
      3279669087,
      3674716684,
      108438443,
      2132974366,
      830746235,
      606445527,
      4173263986,
      2204105912,
      1844756978,
      2532684181,
      4245352700,
      2969441100,
      3796921661,
      1335562986,
      4061524517,
      2720232303,
      2679424040,
      634407289,
      885462008,
      3294724487,
      3933892248,
      2094100220,
      339117932,
      4048830727,
      3202280980,
      1458155303,
      2689246273,
      1022871705,
      2464987878,
      3714515309,
      353796843,
      2822958815,
      4256850100,
      4052777845,
      551748367,
      618185374,
      3778635579,
      4020649912,
      1904685140,
      3069366075,
      2670879810,
      3407193292,
      2954511620,
      4058283405,
      2219449317,
      3135758300,
      1120655984,
      3447565834,
      1474845562,
      3577699062,
      550456716,
      3466908712,
      2043752612,
      881257467,
      869518812,
      2005220179,
      938474677,
      3305539448,
      3850417126,
      1315485940,
      3318264702,
      226533026,
      965733244,
      321539988,
      1136104718,
      804158748,
      573969341,
      3708209826,
      937399083,
      3290727049,
      2901666755,
      1461057207,
      4013193437,
      4066861423,
      3242773476,
      2421326174,
      1581322155,
      3028952165,
      786071460,
      3900391652,
      3918438532,
      1485433313,
      4023619836,
      3708277595,
      3678951060,
      953673138,
      1467089153,
      1930354364,
      1533292819,
      2492563023,
      1346121658,
      1685000834,
      1965281866,
      3765933717,
      4190206607,
      2052792609,
      3515332758,
      690371149,
      3125873887,
      2180283551,
      2903598061,
      3933952357,
      436236910,
      289419410,
      14314871,
      1242357089,
      2904507907,
      1616633776,
      2666382180,
      585885352,
      3471299210,
      2699507360,
      1432659641,
      277164553,
      3354103607,
      770115018,
      2303809295,
      3741942315,
      3177781868,
      2853364978,
      2269453327,
      3774259834,
      987383833,
      1290892879,
      225909803,
      1741533526,
      890078084,
      1496906255,
      1111072499,
      916028167,
      243534141,
      1252605537,
      2204162171,
      531204876,
      290011180,
      3916834213,
      102027703,
      237315147,
      209093447,
      1486785922,
      220223953,
      2758195998,
      4175039106,
      82940208,
      3127791296,
      2569425252,
      518464269,
      1353887104,
      3941492737,
      2377294467,
      3935040926
    ])
  ], t = [
    {
      a: [
        new Uint8Array([4, 0, 13, 15, 12, 14, 8]),
        new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 10]),
        new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]),
        new Uint8Array([7, 1, 16 + 10, 16 + 9, 16 + 11, 16 + 8, 11])
      ],
      b: [
        new Uint8Array([16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2]),
        new Uint8Array([16 + 10, 16 + 11, 16 + 5, 16 + 4, 16 + 6]),
        new Uint8Array([16 + 12, 16 + 13, 16 + 3, 16 + 2, 16 + 9]),
        new Uint8Array([16 + 14, 16 + 15, 16 + 1, 16 + 0, 16 + 12])
      ]
    },
    {
      a: [
        new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]),
        new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]),
        new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]),
        new Uint8Array([3, 7, 10, 9, 11, 8, 16 + 3])
      ],
      b: [
        new Uint8Array([3, 2, 12, 13, 8]),
        new Uint8Array([1, 0, 14, 15, 13]),
        new Uint8Array([7, 6, 8, 9, 3]),
        new Uint8Array([5, 4, 10, 11, 7])
      ]
    },
    {
      a: [
        new Uint8Array([4, 0, 13, 15, 12, 14, 8]),
        new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 10]),
        new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]),
        new Uint8Array([7, 1, 16 + 10, 16 + 9, 16 + 11, 16 + 8, 11])
      ],
      b: [
        new Uint8Array([16 + 3, 16 + 2, 16 + 12, 16 + 13, 16 + 9]),
        new Uint8Array([16 + 1, 16 + 0, 16 + 14, 16 + 15, 16 + 12]),
        new Uint8Array([16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2]),
        new Uint8Array([16 + 5, 16 + 4, 16 + 10, 16 + 11, 16 + 6])
      ]
    },
    {
      a: [
        new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]),
        new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]),
        new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]),
        new Uint8Array([3, 7, 10, 9, 11, 8, 16 + 3])
      ],
      b: [
        new Uint8Array([8, 9, 7, 6, 3]),
        new Uint8Array([10, 11, 5, 4, 7]),
        new Uint8Array([12, 13, 3, 2, 8]),
        new Uint8Array([14, 15, 1, 0, 13])
      ]
    }
  ], i = new Uint8Array([6, 7, 4, 5]);
  class n {
    constructor() {
      this.masking = new Uint32Array(16), this.rotate = new Uint8Array(16);
    }
    get blockSize() {
      return 8;
    }
    init(b) {
      return r(Buffer.isBuffer(b)), r(b.length === 16), this.keySchedule(b), this;
    }
    destroy() {
      for (let b = 0; b < 16; b++)
        this.masking[b] = 0;
      for (let b = 0; b < 16; b++)
        this.rotate[b] = 0;
      return this;
    }
    keySchedule(b) {
      const g = new Uint32Array(8), w = new Uint32Array(32);
      for (let y = 0; y < 4; y++)
        g[y] = l(b, y * 4);
      let I = 0, B;
      for (let y = 0; y < 2; y++)
        for (const A of t) {
          for (let _ = 0; _ < 4; _++) {
            const q = A.a[_];
            B = g[q[1]] ^ e[4][g[q[2] >>> 2] >>> 24 - 8 * (q[2] & 3) & 255] ^ e[5][g[q[3] >>> 2] >>> 24 - 8 * (q[3] & 3) & 255] ^ e[6][g[q[4] >>> 2] >>> 24 - 8 * (q[4] & 3) & 255] ^ e[7][g[q[5] >>> 2] >>> 24 - 8 * (q[5] & 3) & 255], B ^= e[i[_]][g[q[6] >>> 2] >>> 24 - 8 * (q[6] & 3) & 255], g[q[0]] = B;
          }
          for (let _ = 0; _ < 4; _++) {
            const q = A.b[_];
            B = e[4][g[q[0] >>> 2] >>> 24 - 8 * (q[0] & 3) & 255] ^ e[5][g[q[1] >>> 2] >>> 24 - 8 * (q[1] & 3) & 255] ^ e[6][g[q[2] >>> 2] >>> 24 - 8 * (q[2] & 3) & 255] ^ e[7][g[q[3] >>> 2] >>> 24 - 8 * (q[3] & 3) & 255], B ^= e[4 + _][g[q[4] >>> 2] >>> 24 - 8 * (q[4] & 3) & 255], w[I] = B, I += 1;
          }
        }
      for (let y = 0; y < 16; y++)
        this.masking[y] = w[y], this.rotate[y] = w[16 + y] & 31;
      return this;
    }
    encrypt(b, g, w, I) {
      let B = l(w, I), y = l(w, I + 4);
      return [B, y] = [y, B ^ c(y, this.masking[0], this.rotate[0])], [B, y] = [y, B ^ o(y, this.masking[1], this.rotate[1])], [B, y] = [y, B ^ d(y, this.masking[2], this.rotate[2])], [B, y] = [y, B ^ c(y, this.masking[3], this.rotate[3])], [B, y] = [y, B ^ o(y, this.masking[4], this.rotate[4])], [B, y] = [y, B ^ d(y, this.masking[5], this.rotate[5])], [B, y] = [y, B ^ c(y, this.masking[6], this.rotate[6])], [B, y] = [y, B ^ o(y, this.masking[7], this.rotate[7])], [B, y] = [y, B ^ d(y, this.masking[8], this.rotate[8])], [B, y] = [y, B ^ c(y, this.masking[9], this.rotate[9])], [B, y] = [y, B ^ o(y, this.masking[10], this.rotate[10])], [B, y] = [y, B ^ d(y, this.masking[11], this.rotate[11])], [B, y] = [y, B ^ c(y, this.masking[12], this.rotate[12])], [B, y] = [y, B ^ o(y, this.masking[13], this.rotate[13])], [B, y] = [y, B ^ d(y, this.masking[14], this.rotate[14])], [B, y] = [y, B ^ c(y, this.masking[15], this.rotate[15])], h(b, y, g), h(b, B, g + 4), this;
    }
    decrypt(b, g, w, I) {
      let B = l(w, I), y = l(w, I + 4);
      return [B, y] = [y, B ^ c(y, this.masking[15], this.rotate[15])], [B, y] = [y, B ^ d(y, this.masking[14], this.rotate[14])], [B, y] = [y, B ^ o(y, this.masking[13], this.rotate[13])], [B, y] = [y, B ^ c(y, this.masking[12], this.rotate[12])], [B, y] = [y, B ^ d(y, this.masking[11], this.rotate[11])], [B, y] = [y, B ^ o(y, this.masking[10], this.rotate[10])], [B, y] = [y, B ^ c(y, this.masking[9], this.rotate[9])], [B, y] = [y, B ^ d(y, this.masking[8], this.rotate[8])], [B, y] = [y, B ^ o(y, this.masking[7], this.rotate[7])], [B, y] = [y, B ^ c(y, this.masking[6], this.rotate[6])], [B, y] = [y, B ^ d(y, this.masking[5], this.rotate[5])], [B, y] = [y, B ^ o(y, this.masking[4], this.rotate[4])], [B, y] = [y, B ^ c(y, this.masking[3], this.rotate[3])], [B, y] = [y, B ^ d(y, this.masking[2], this.rotate[2])], [B, y] = [y, B ^ o(y, this.masking[1], this.rotate[1])], [B, y] = [y, B ^ c(y, this.masking[0], this.rotate[0])], h(b, y, g), h(b, B, g + 4), this;
    }
  }
  function c(x, b, g) {
    const w = b + x, I = w << g | w >>> 32 - g;
    return (e[0][I >>> 24 & 255] ^ e[1][I >>> 16 & 255]) - e[2][I >>> 8 & 255] + e[3][I >>> 0 & 255];
  }
  function o(x, b, g) {
    const w = b ^ x, I = w << g | w >>> 32 - g;
    return e[0][I >>> 24 & 255] - e[1][I >>> 16 & 255] + e[2][I >>> 8 & 255] ^ e[3][I >>> 0 & 255];
  }
  function d(x, b, g) {
    const w = b - x, I = w << g | w >>> 32 - g;
    return (e[0][I >>> 24 & 255] + e[1][I >>> 16 & 255] ^ e[2][I >>> 8 & 255]) - e[3][I >>> 0 & 255];
  }
  function l(x, b) {
    return x[b++] * 16777216 + x[b++] * 65536 + x[b++] * 256 + x[b];
  }
  function h(x, b, g) {
    return x[g++] = b >>> 24, x[g++] = b >>> 16, x[g++] = b >>> 8, x[g++] = b, g;
  }
  return ja = n, ja;
}
var nf = {};
/*!
 * des.js - DES for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/des.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/des.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Data_Encryption_Standard
 *   https://github.com/indutny/des.js/tree/master/lib/des
 */
var Q2;
function km() {
  if (Q2)
    return nf;
  Q2 = 1;
  const r = _e, e = new Uint8Array([
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ]), t = new Uint8Array([
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ]), i = new Uint8Array([
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ]), n = new Uint8Array([
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ]);
  class c {
    constructor() {
      this.block = new Uint32Array(2), this.keys = new Uint32Array(32);
    }
    get blockSize() {
      return 8;
    }
    init(q) {
      return r(Buffer.isBuffer(q)), r(q.length === 8), this.derive(q);
    }
    encrypt(q, U, z, E) {
      return this.crypt(q, U, z, E, !0);
    }
    decrypt(q, U, z, E) {
      return this.crypt(q, U, z, E, !1);
    }
    destroy() {
      for (let q = 0; q < 2; q++)
        this.block[q] = 0;
      for (let q = 0; q < 32; q++)
        this.keys[q] = 0;
      return this;
    }
    derive(q) {
      let U = y(q, 0), z = y(q, 4);
      x(U, z, this.block, 0), U = this.block[0], z = this.block[1];
      for (let E = 0; E < 32; E += 2) {
        const H = n[E >>> 1];
        U = b(U, H), z = b(z, H), g(U, z, this.keys, E);
      }
      return this;
    }
    crypt(q, U, z, E, H) {
      let k = y(z, E), V = y(z, E + 4);
      return l(k, V, this.block, 0), k = this.block[0], V = this.block[1], H ? this.encipher(k, V, this.block, 0) : this.decipher(k, V, this.block, 0), k = this.block[0], V = this.block[1], A(q, k, U), A(q, V, U + 4), this;
    }
    encipher(q, U, z, E) {
      let H = q, k = U;
      for (let V = 0; V < 32; V += 2) {
        let T = this.keys[V], ie = this.keys[V + 1];
        w(k, this.block, 0), T ^= this.block[0], ie ^= this.block[1];
        const N = I(T, ie), G = B(N), F = k;
        k = (H ^ G) >>> 0, H = F;
      }
      return h(k, H, z, E), this;
    }
    decipher(q, U, z, E) {
      let H = U, k = q;
      for (let V = 32 - 2; V >= 0; V -= 2) {
        let T = this.keys[V], ie = this.keys[V + 1];
        w(H, this.block, 0), T ^= this.block[0], ie ^= this.block[1];
        const N = I(T, ie), G = B(N), F = H;
        H = (k ^ G) >>> 0, k = F;
      }
      return h(H, k, z, E), this;
    }
  }
  class o {
    constructor() {
      this.x = new c(), this.y = new c();
    }
    get blockSize() {
      return 8;
    }
    init(q) {
      r(Buffer.isBuffer(q)), r(q.length === 16);
      const U = q.slice(0, 8), z = q.slice(8, 16);
      return this.x.init(U), this.y.init(z), this;
    }
    encrypt(q, U, z, E) {
      return this.x.encrypt(q, U, z, E), this.y.decrypt(q, U, q, U), this.x.encrypt(q, U, q, U), this;
    }
    decrypt(q, U, z, E) {
      return this.x.decrypt(q, U, z, E), this.y.encrypt(q, U, q, U), this.x.decrypt(q, U, q, U), this;
    }
    destroy() {
      return this.x.destroy(), this.y.destroy(), this;
    }
  }
  class d {
    constructor() {
      this.x = new c(), this.y = new c(), this.z = new c();
    }
    get blockSize() {
      return 8;
    }
    init(q) {
      r(Buffer.isBuffer(q)), r(q.length === 24);
      const U = q.slice(0, 8), z = q.slice(8, 16), E = q.slice(16, 24);
      return this.x.init(U), this.y.init(z), this.z.init(E), this;
    }
    encrypt(q, U, z, E) {
      return this.x.encrypt(q, U, z, E), this.y.decrypt(q, U, q, U), this.z.encrypt(q, U, q, U), this;
    }
    decrypt(q, U, z, E) {
      return this.z.decrypt(q, U, z, E), this.y.encrypt(q, U, q, U), this.x.decrypt(q, U, q, U), this;
    }
    destroy() {
      return this.x.destroy(), this.y.destroy(), this.z.destroy(), this;
    }
  }
  function l(_, q, U, z) {
    let E = 0, H = 0;
    for (let k = 6; k >= 0; k -= 2) {
      for (let V = 0; V <= 24; V += 8)
        E <<= 1, E |= q >>> V + k & 1;
      for (let V = 0; V <= 24; V += 8)
        E <<= 1, E |= _ >>> V + k & 1;
    }
    for (let k = 6; k >= 0; k -= 2) {
      for (let V = 1; V <= 25; V += 8)
        H <<= 1, H |= q >>> V + k & 1;
      for (let V = 1; V <= 25; V += 8)
        H <<= 1, H |= _ >>> V + k & 1;
    }
    U[z + 0] = E >>> 0, U[z + 1] = H >>> 0;
  }
  function h(_, q, U, z) {
    let E = 0, H = 0;
    for (let k = 0; k < 4; k++)
      for (let V = 24; V >= 0; V -= 8)
        E <<= 1, E |= q >>> V + k & 1, E <<= 1, E |= _ >>> V + k & 1;
    for (let k = 4; k < 8; k++)
      for (let V = 24; V >= 0; V -= 8)
        H <<= 1, H |= q >>> V + k & 1, H <<= 1, H |= _ >>> V + k & 1;
    U[z + 0] = E >>> 0, U[z + 1] = H >>> 0;
  }
  function x(_, q, U, z) {
    let E = 0, H = 0;
    for (let k = 7; k >= 5; k--) {
      for (let V = 0; V <= 24; V += 8)
        E <<= 1, E |= q >> V + k & 1;
      for (let V = 0; V <= 24; V += 8)
        E <<= 1, E |= _ >> V + k & 1;
    }
    for (let k = 0; k <= 24; k += 8)
      E <<= 1, E |= q >> k + 4 & 1;
    for (let k = 1; k <= 3; k++) {
      for (let V = 0; V <= 24; V += 8)
        H <<= 1, H |= q >> V + k & 1;
      for (let V = 0; V <= 24; V += 8)
        H <<= 1, H |= _ >> V + k & 1;
    }
    for (let k = 0; k <= 24; k += 8)
      H <<= 1, H |= _ >> k + 4 & 1;
    U[z + 0] = E >>> 0, U[z + 1] = H >>> 0;
  }
  function b(_, q) {
    return _ << q & 268435455 | _ >>> 28 - q;
  }
  function g(_, q, U, z) {
    let E = 0, H = 0, k = 0;
    for (; k < 24; k++)
      E <<= 1, E |= _ >>> e[k] & 1;
    for (; k < 48; k++)
      H <<= 1, H |= q >>> e[k] & 1;
    U[z + 0] = E >>> 0, U[z + 1] = H >>> 0;
  }
  function w(_, q, U) {
    let z = 0, E = 0;
    z = (_ & 1) << 5 | _ >>> 27;
    for (let H = 23; H >= 15; H -= 4)
      z <<= 6, z |= _ >>> H & 63;
    for (let H = 11; H >= 3; H -= 4)
      E |= _ >>> H & 63, E <<= 6;
    E |= (_ & 31) << 1 | _ >>> 31, q[U + 0] = z >>> 0, q[U + 1] = E >>> 0;
  }
  function I(_, q) {
    let U = 0;
    for (let z = 0; z < 4; z++) {
      const E = _ >>> 18 - z * 6 & 63;
      U = U << 4 | t[z * 64 + E];
    }
    for (let z = 0; z < 4; z++) {
      const E = q >>> 18 - z * 6 & 63;
      U = U << 4 | t[4 * 64 + z * 64 + E];
    }
    return U >>> 0;
  }
  function B(_) {
    let q = 0;
    for (let U = 0; U < 32; U++)
      q <<= 1, q |= _ >>> i[U] & 1;
    return q >>> 0;
  }
  function y(_, q) {
    return _[q++] * 16777216 + _[q++] * 65536 + _[q++] * 256 + _[q];
  }
  function A(_, q, U) {
    return _[U++] = q >>> 24, _[U++] = q >>> 16, _[U++] = q >>> 8, _[U++] = q, U;
  }
  return nf.DES = c, nf.EDE = o, nf.EDE3 = d, nf;
}
/*!
 * idea.js - IDEA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dgryski/go-idea:
 *   Copyright (c) 2013-2017, Damian Gryski. All rights reserved.
 *   https://github.com/dgryski/go-idea
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm
 *   https://github.com/dgryski/go-idea/blob/master/idea.go
 */
var Qa, ex;
function qm() {
  if (ex)
    return Qa;
  ex = 1;
  const r = _e, e = Buffer.alloc(16, 0);
  class t {
    constructor() {
      this.key = e, this.encryptKey = null, this.decryptKey = null;
    }
    get blockSize() {
      return 8;
    }
    init(l) {
      return r(Buffer.isBuffer(l)), r(l.length === 16), this.destroy(), this.key = Buffer.from(l), this;
    }
    getEncryptKey() {
      return this.encryptKey || (this.encryptKey = this.expandKey(this.key)), this.encryptKey;
    }
    getDecryptKey() {
      return this.decryptKey || (this.decryptKey = this.invertKey(this.getEncryptKey())), this.decryptKey;
    }
    encrypt(l, h, x, b) {
      const g = this.getEncryptKey();
      return this.crypt(l, h, x, b, g);
    }
    decrypt(l, h, x, b) {
      const g = this.getDecryptKey();
      return this.crypt(l, h, x, b, g);
    }
    destroy() {
      for (let l = 0; l < 16; l++)
        this.key[l] = 0;
      if (this.encryptKey)
        for (let l = 0; l < 52; l++)
          this.encryptKey[l] = 0;
      if (this.decryptKey)
        for (let l = 0; l < 52; l++)
          this.decryptKey[l] = 0;
      return this.key = e, this.encryptKey = null, this.decryptKey = null, this;
    }
    expandKey(l) {
      const h = new Uint16Array(52);
      let x = 0, b = 0, g = 0;
      for (; b < 8; b++)
        h[b] = c(l, b * 2);
      for (; b < 52; b++)
        g += 1, h[x + (g + 7)] = h[x + (g + 0 & 7)] << 9 | h[x + (g + 1 & 7)] >>> 7, x += g & 8, g &= 7;
      return h;
    }
    invertKey(l) {
      const h = new Uint16Array(52);
      let x, b, g, w = 52 - 1, I = 0;
      x = i(l[I++]), b = -l[I++], g = -l[I++], h[w--] = i(l[I++]), h[w--] = g, h[w--] = b, h[w--] = x;
      for (let B = 0; B < 8 - 1; B++)
        x = l[I++], h[w--] = l[I++], h[w--] = x, x = i(l[I++]), b = -l[I++], g = -l[I++], h[w--] = i(l[I++]), h[w--] = b, h[w--] = g, h[w--] = x;
      return x = l[I++], h[w--] = l[I++], h[w--] = x, x = i(l[I++]), b = -l[I++], g = -l[I++], h[w--] = i(l[I++]), h[w--] = g, h[w--] = b, h[w--] = x, h;
    }
    crypt(l, h, x, b, g) {
      let w = c(x, b + 0), I = c(x, b + 2), B = c(x, b + 4), y = c(x, b + 6), A = 0, _ = 0, q = 0;
      for (let U = 8 - 1; U >= 0; U--)
        w = n(w, g[q++]), I += g[q++], B += g[q++], y = n(y, g[q++]), _ = B, B ^= w, B = n(B, g[q++]), A = I, I ^= y, I += B, I = n(I, g[q++]), B += I, w ^= I, y ^= B, I ^= _, B ^= A;
      w = n(w, g[q++]), B += g[q++], I += g[q++], y = n(y, g[q++]), o(l, w, h + 0), o(l, B, h + 2), o(l, I, h + 4), o(l, y, h + 6);
    }
  }
  function i(d) {
    if (d &= 65535, d <= 1)
      return d;
    let l = 65537 / d & 65535, h = 65537 % d;
    if (h === 1)
      return 1 - l & 65535;
    let x = 1, b = 0;
    for (; h !== 1; ) {
      if (b = d / h & 65535, d %= h, x += b * l, x &= 65535, d === 1)
        return x;
      b = h / d & 65535, h %= d, l += b * x, l &= 65535;
    }
    return 1 - l & 65535;
  }
  function n(d, l) {
    if (d &= 65535, l &= 65535, l === 0)
      return 1 - d & 65535;
    if (d === 0)
      return 1 - l & 65535;
    const h = d * l >>> 0;
    return d = h & 65535, l = h >>> 16, d < l ? d - l + 1 & 65535 : d - l & 65535;
  }
  function c(d, l) {
    return d[l++] * 256 + d[l];
  }
  function o(d, l, h) {
    return d[h++] = l >>> 8, d[h++] = l, h;
  }
  return Qa = t, Qa;
}
/*!
 * serpent.js - serpent128/192/256 for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on aead/serpent:
 *   Copyright (c) 2016, Andreas Auernhammer (MIT License).
 *   https://github.com/aead/serpent
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Serpent_(cipher)
 *   https://www.cl.cam.ac.uk/~rja14/serpent.html
 *   https://github.com/aead/serpent
 */
var eh, tx;
function zm() {
  if (tx)
    return eh;
  tx = 1;
  const r = _e, e = 2654435769;
  class t {
    constructor(V) {
      r(V >>> 0 === V), r(V === 128 || V === 192 || V === 256), this.bits = V, this.subkeys = new Uint32Array(132), this.block = new Uint32Array(4);
    }
    get blockSize() {
      return 16;
    }
    init(V) {
      return r(Buffer.isBuffer(V)), r(V.length * 8 === this.bits), this.keySchedule(V), this;
    }
    keySchedule(V) {
      const T = this.subkeys, ie = new Uint32Array(16);
      let N = 0;
      for (let G = 0; G < V.length; G += 4)
        ie[N++] = E(V, G);
      for (N < 8 && (ie[N++] = 1); N < 16; )
        ie[N++] = 0;
      for (let G = 8; G < 16; G++) {
        const F = ie[G - 8] ^ ie[G - 5] ^ ie[G - 3] ^ ie[G - 1] ^ e ^ G - 8;
        ie[G] = F << 11 | F >>> 21, T[G - 8] = ie[G];
      }
      for (let G = 8; G < 132; G++) {
        const F = T[G - 8] ^ T[G - 5] ^ T[G - 3] ^ T[G - 1] ^ e ^ G;
        T[G] = F << 11 | F >>> 21;
      }
      return g(T, 0, 1, 2, 3), x(T, 4, 5, 6, 7), l(T, 8, 9, 10, 11), o(T, 12, 13, 14, 15), U(T, 16, 17, 18, 19), _(T, 20, 21, 22, 23), y(T, 24, 25, 26, 27), I(T, 28, 29, 30, 31), g(T, 32, 33, 34, 35), x(T, 36, 37, 38, 39), l(T, 40, 41, 42, 43), o(T, 44, 45, 46, 47), U(T, 48, 49, 50, 51), _(T, 52, 53, 54, 55), y(T, 56, 57, 58, 59), I(T, 60, 61, 62, 63), g(T, 64, 65, 66, 67), x(T, 68, 69, 70, 71), l(T, 72, 73, 74, 75), o(T, 76, 77, 78, 79), U(T, 80, 81, 82, 83), _(T, 84, 85, 86, 87), y(T, 88, 89, 90, 91), I(T, 92, 93, 94, 95), g(T, 96, 97, 98, 99), x(T, 100, 101, 102, 103), l(T, 104, 105, 106, 107), o(T, 108, 109, 110, 111), U(T, 112, 113, 114, 115), _(T, 116, 117, 118, 119), y(T, 120, 121, 122, 123), I(T, 124, 125, 126, 127), g(T, 128, 129, 130, 131), this;
    }
    encrypt(V, T, ie, N) {
      const G = this.subkeys, F = this.block;
      return F[0] = E(ie, N + 0), F[1] = E(ie, N + 4), F[2] = E(ie, N + 8), F[3] = E(ie, N + 12), i(F, G, 0, 1, 2, 3), o(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 4, 5, 6, 7), l(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 8, 9, 10, 11), x(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 12, 13, 14, 15), g(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 16, 17, 18, 19), I(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 20, 21, 22, 23), y(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 24, 25, 26, 27), _(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 28, 29, 30, 31), U(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 32, 33, 34, 35), o(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 36, 37, 38, 39), l(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 40, 41, 42, 43), x(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 44, 45, 46, 47), g(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 48, 49, 50, 51), I(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 52, 53, 54, 55), y(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 56, 57, 58, 59), _(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 60, 61, 62, 63), U(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 64, 65, 66, 67), o(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 68, 69, 70, 71), l(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 72, 73, 74, 75), x(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 76, 77, 78, 79), g(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 80, 81, 82, 83), I(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 84, 85, 86, 87), y(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 88, 89, 90, 91), _(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 92, 93, 94, 95), U(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 96, 97, 98, 99), o(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 100, 101, 102, 103), l(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 104, 105, 106, 107), x(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 108, 109, 110, 111), g(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 112, 113, 114, 115), I(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 116, 117, 118, 119), y(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 120, 121, 122, 123), _(F, 0, 1, 2, 3), n(F, 0, 1, 2, 3), i(F, G, 124, 125, 126, 127), U(F, 0, 1, 2, 3), F[0] ^= G[128], F[1] ^= G[129], F[2] ^= G[130], F[3] ^= G[131], H(V, F[0], T + 0), H(V, F[1], T + 4), H(V, F[2], T + 8), H(V, F[3], T + 12), this;
    }
    decrypt(V, T, ie, N) {
      const G = this.subkeys, F = this.block;
      return F[0] = E(ie, N + 0), F[1] = E(ie, N + 4), F[2] = E(ie, N + 8), F[3] = E(ie, N + 12), F[0] ^= G[128], F[1] ^= G[129], F[2] ^= G[130], F[3] ^= G[131], z(F, 0, 1, 2, 3), i(F, G, 124, 125, 126, 127), c(F, 0, 1, 2, 3), q(F, 0, 1, 2, 3), i(F, G, 120, 121, 122, 123), c(F, 0, 1, 2, 3), A(F, 0, 1, 2, 3), i(F, G, 116, 117, 118, 119), c(F, 0, 1, 2, 3), B(F, 0, 1, 2, 3), i(F, G, 112, 113, 114, 115), c(F, 0, 1, 2, 3), w(F, 0, 1, 2, 3), i(F, G, 108, 109, 110, 111), c(F, 0, 1, 2, 3), b(F, 0, 1, 2, 3), i(F, G, 104, 105, 106, 107), c(F, 0, 1, 2, 3), h(F, 0, 1, 2, 3), i(F, G, 100, 101, 102, 103), c(F, 0, 1, 2, 3), d(F, 0, 1, 2, 3), i(F, G, 96, 97, 98, 99), c(F, 0, 1, 2, 3), z(F, 0, 1, 2, 3), i(F, G, 92, 93, 94, 95), c(F, 0, 1, 2, 3), q(F, 0, 1, 2, 3), i(F, G, 88, 89, 90, 91), c(F, 0, 1, 2, 3), A(F, 0, 1, 2, 3), i(F, G, 84, 85, 86, 87), c(F, 0, 1, 2, 3), B(F, 0, 1, 2, 3), i(F, G, 80, 81, 82, 83), c(F, 0, 1, 2, 3), w(F, 0, 1, 2, 3), i(F, G, 76, 77, 78, 79), c(F, 0, 1, 2, 3), b(F, 0, 1, 2, 3), i(F, G, 72, 73, 74, 75), c(F, 0, 1, 2, 3), h(F, 0, 1, 2, 3), i(F, G, 68, 69, 70, 71), c(F, 0, 1, 2, 3), d(F, 0, 1, 2, 3), i(F, G, 64, 65, 66, 67), c(F, 0, 1, 2, 3), z(F, 0, 1, 2, 3), i(F, G, 60, 61, 62, 63), c(F, 0, 1, 2, 3), q(F, 0, 1, 2, 3), i(F, G, 56, 57, 58, 59), c(F, 0, 1, 2, 3), A(F, 0, 1, 2, 3), i(F, G, 52, 53, 54, 55), c(F, 0, 1, 2, 3), B(F, 0, 1, 2, 3), i(F, G, 48, 49, 50, 51), c(F, 0, 1, 2, 3), w(F, 0, 1, 2, 3), i(F, G, 44, 45, 46, 47), c(F, 0, 1, 2, 3), b(F, 0, 1, 2, 3), i(F, G, 40, 41, 42, 43), c(F, 0, 1, 2, 3), h(F, 0, 1, 2, 3), i(F, G, 36, 37, 38, 39), c(F, 0, 1, 2, 3), d(F, 0, 1, 2, 3), i(F, G, 32, 33, 34, 35), c(F, 0, 1, 2, 3), z(F, 0, 1, 2, 3), i(F, G, 28, 29, 30, 31), c(F, 0, 1, 2, 3), q(F, 0, 1, 2, 3), i(F, G, 24, 25, 26, 27), c(F, 0, 1, 2, 3), A(F, 0, 1, 2, 3), i(F, G, 20, 21, 22, 23), c(F, 0, 1, 2, 3), B(F, 0, 1, 2, 3), i(F, G, 16, 17, 18, 19), c(F, 0, 1, 2, 3), w(F, 0, 1, 2, 3), i(F, G, 12, 13, 14, 15), c(F, 0, 1, 2, 3), b(F, 0, 1, 2, 3), i(F, G, 8, 9, 10, 11), c(F, 0, 1, 2, 3), h(F, 0, 1, 2, 3), i(F, G, 4, 5, 6, 7), c(F, 0, 1, 2, 3), d(F, 0, 1, 2, 3), F[0] ^= G[0], F[1] ^= G[1], F[2] ^= G[2], F[3] ^= G[3], H(V, F[0], T + 0), H(V, F[1], T + 4), H(V, F[2], T + 8), H(V, F[3], T + 12), this;
    }
    destroy() {
      for (let V = 0; V < 132; V++)
        this.subkeys[V] = 0;
      for (let V = 0; V < 4; V++)
        this.block[V] = 0;
      return this;
    }
  }
  function i(k, V, T, ie, N, G) {
    k[0] ^= V[T], k[1] ^= V[ie], k[2] ^= V[N], k[3] ^= V[G];
  }
  function n(k, V, T, ie, N) {
    let G = k[V] << 13 | k[V] >>> 19, F = k[ie] << 3 | k[ie] >>> 32 - 3;
    const W = k[T] ^ G ^ F, ce = k[N] ^ F ^ G << 3;
    k[T] = W << 1 | W >>> 32 - 1, k[N] = ce << 7 | ce >>> 32 - 7, G ^= k[T] ^ k[N], F ^= k[N] ^ k[T] << 7, k[V] = G << 5 | G >>> 32 - 5, k[ie] = F << 22 | F >>> 32 - 22;
  }
  function c(k, V, T, ie, N) {
    let G = k[ie] >>> 22 | k[ie] << 10, F = k[V] >>> 5 | k[V] << 32 - 5;
    G ^= k[N] ^ k[T] << 7, F ^= k[T] ^ k[N];
    const W = k[N] >>> 7 | k[N] << 32 - 7, ce = k[T] >>> 1 | k[T] << 32 - 1;
    k[N] = W ^ G ^ F << 3, k[T] = ce ^ F ^ G, k[ie] = G >>> 3 | G << 32 - 3, k[V] = F >>> 13 | F << 32 - 13;
  }
  function o(k, V, T, ie, N) {
    const G = k[V] ^ k[N], F = k[ie] ^ G, W = k[T] ^ F;
    k[N] = k[V] & k[N] ^ W;
    const ce = k[V] ^ k[T] & G;
    k[ie] = W ^ (k[ie] | ce);
    const ne = k[N] & (F ^ ce);
    k[T] = ~F ^ ne, k[V] = ne ^ ~ce;
  }
  function d(k, V, T, ie, N) {
    const G = ~k[V], F = k[V] ^ k[T], W = k[N] ^ (G | F), ce = k[ie] ^ W;
    k[ie] = F ^ ce;
    const ne = G ^ k[N] & F;
    k[T] = W ^ k[ie] & ne, k[N] = k[V] & W ^ (ce | k[T]), k[V] = k[N] ^ (ce ^ ne);
  }
  function l(k, V, T, ie, N) {
    const G = k[T] ^ ~k[V], F = k[ie] ^ (k[V] | G);
    k[ie] = k[N] ^ F;
    const W = k[T] ^ (k[N] | G), ce = G ^ k[ie];
    k[N] = ce ^ F & W;
    const ne = F ^ W;
    k[T] = k[N] ^ ne, k[V] = F ^ ce & ne;
  }
  function h(k, V, T, ie, N) {
    const G = k[T] ^ k[N], F = k[V] ^ k[T] & G, W = G ^ F;
    k[N] = k[ie] ^ W;
    const ce = k[T] ^ G & F, ne = k[N] | ce;
    k[T] = F ^ ne;
    const xe = ~k[T], he = k[N] ^ ce;
    k[V] = xe ^ he, k[ie] = W ^ (xe | he);
  }
  function x(k, V, T, ie, N) {
    const G = k[V], F = k[N], W = ~G, ce = k[T] ^ F, ne = k[ie] & W;
    k[V] = ce ^ ne;
    const xe = k[ie] ^ W, he = k[ie] ^ k[V], me = k[T] & he;
    k[N] = xe ^ me, k[ie] = G ^ (F | me) & (k[V] | xe), k[T] = ce ^ k[N] ^ (k[ie] ^ (F | W));
  }
  function b(k, V, T, ie, N) {
    const G = k[V], F = k[N], W = k[T] ^ F, ce = ~W, ne = G ^ k[ie], xe = k[ie] ^ W, he = k[T] & xe;
    k[V] = ne ^ he;
    const me = G | ce, Ne = F ^ me, Je = ne | Ne;
    k[N] = W ^ Je;
    const Ze = ~xe, ht = k[V] | k[N];
    k[T] = Ze ^ ht, k[ie] = F & Ze ^ (ne ^ ht);
  }
  function g(k, V, T, ie, N) {
    const G = k[T], F = k[N], W = k[V] ^ k[T], ce = k[V] & k[ie], ne = k[V] | k[N], xe = k[ie] ^ k[N], he = W & ne, me = ce | he;
    k[ie] = xe ^ me;
    const Ne = k[T] ^ ne, Je = me ^ Ne, Ze = xe & Je;
    k[V] = W ^ Ze;
    const ht = k[ie] & k[V];
    k[T] = Je ^ ht, k[N] = (G | F) ^ (xe ^ ht);
  }
  function w(k, V, T, ie, N) {
    const G = k[V] | k[T], F = k[T] ^ k[ie], W = k[T] & F, ce = k[V] ^ W, ne = k[ie] ^ ce, xe = k[N] | ce;
    k[V] = F ^ xe;
    const he = F | xe, me = k[N] ^ he;
    k[ie] = ne ^ me;
    const Ne = G ^ me, Je = k[V] & Ne;
    k[N] = ce ^ Je, k[T] = k[N] ^ (k[V] ^ Ne);
  }
  function I(k, V, T, ie, N) {
    const G = k[V], F = G ^ k[N], W = k[N] & F, ce = k[ie] ^ W, ne = k[T] | ce;
    k[N] = F ^ ne;
    const xe = ~k[T], he = F | xe;
    k[V] = ce ^ he;
    const me = G & k[V], Ne = F ^ xe, Je = ne & Ne;
    k[ie] = me ^ Je, k[T] = G ^ ce ^ Ne & k[ie];
  }
  function B(k, V, T, ie, N) {
    const G = k[N], F = k[ie] | G, W = k[V] & F, ce = k[T] ^ W, ne = k[V] & ce, xe = k[ie] ^ ne;
    k[T] = G ^ xe;
    const he = ~k[V], me = xe & k[T];
    k[N] = ce ^ me;
    const Ne = k[T] | he, Je = G ^ Ne;
    k[V] = k[N] ^ Je, k[ie] = ce & Je ^ (k[T] ^ he);
  }
  function y(k, V, T, ie, N) {
    const G = k[T], F = ~k[V], W = k[V] ^ G, ce = k[V] ^ k[N], ne = k[ie] ^ F, xe = W | ce;
    k[V] = ne ^ xe;
    const he = k[N] & k[V], me = W ^ k[V];
    k[T] = he ^ me;
    const Ne = F | k[V], Je = W | he, Ze = ce ^ Ne;
    k[ie] = Je ^ Ze, k[N] = G ^ he ^ k[T] & Ze;
  }
  function A(k, V, T, ie, N) {
    const G = k[V], F = k[T], W = k[N], ce = ~k[ie], ne = F & ce, xe = W ^ ne, he = G & xe, me = F ^ ce;
    k[N] = he ^ me;
    const Ne = F | k[N], Je = G & Ne;
    k[T] = xe ^ Je;
    const Ze = G | W, ht = ce ^ Ne;
    k[V] = Ze ^ ht, k[ie] = F & Ze ^ (he | G ^ k[ie]);
  }
  function _(k, V, T, ie, N) {
    const G = ~k[V], F = k[V] ^ k[N], W = k[T] ^ F, ce = G | F, ne = k[ie] ^ ce;
    k[T] = k[T] ^ ne;
    const xe = F | k[T], he = k[N] ^ xe, me = ne & he;
    k[ie] = W ^ me;
    const Ne = ne ^ he;
    k[V] = k[ie] ^ Ne, k[N] = ~ne ^ W & Ne;
  }
  function q(k, V, T, ie, N) {
    const G = k[T], F = k[N], W = ~k[V], ce = k[V] ^ G, ne = k[ie] ^ ce, xe = k[ie] | W, he = F ^ xe;
    k[T] = ne ^ he;
    const me = ne & he, Ne = ce ^ me, Je = G | Ne;
    k[N] = he ^ Je;
    const Ze = G | k[N];
    k[V] = Ne ^ Ze, k[ie] = F & W ^ (ne ^ Ze);
  }
  function U(k, V, T, ie, N) {
    const G = k[T] ^ k[ie], F = k[ie] & G, W = k[N] ^ F, ce = k[V] ^ W, ne = k[N] | G, xe = ce & ne;
    k[T] = k[T] ^ xe;
    const he = W | k[T], me = k[V] & ce;
    k[N] = G ^ me;
    const Ne = ce ^ he, Je = k[N] & Ne;
    k[ie] = W ^ Je, k[V] = ~Ne ^ k[N] & k[ie];
  }
  function z(k, V, T, ie, N) {
    const G = k[V], F = k[N], W = k[ie] | G & k[T], ce = F & (G | k[T]);
    k[N] = W ^ ce;
    const ne = ~F, xe = k[T] ^ ce, he = xe | k[N] ^ ne;
    k[T] = G ^ he, k[V] = k[ie] ^ xe ^ (F | k[T]), k[ie] = W ^ k[T] ^ (k[V] ^ G & k[N]);
  }
  function E(k, V) {
    return k[V++] + k[V++] * 256 + k[V++] * 65536 + k[V++] * 16777216;
  }
  function H(k, V, T) {
    return k[T++] = V, V >>>= 8, k[T++] = V, V >>>= 8, k[T++] = V, V >>>= 8, k[T++] = V, T;
  }
  return eh = t, eh;
}
/*!
 * twofish.js - twofish for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Twofish
 *   https://www.schneier.com/academic/twofish/
 *   https://github.com/golang/crypto/blob/master/twofish/twofish.go
 */
var th, rx;
function Um() {
  if (rx)
    return th;
  rx = 1;
  const r = _e, e = 16, t = 361, i = 333, n = [
    new Uint8Array([1, 164, 85, 135, 90, 88, 219, 158]),
    new Uint8Array([164, 86, 130, 243, 30, 198, 104, 229]),
    new Uint8Array([2, 161, 252, 193, 71, 174, 61, 25]),
    new Uint8Array([164, 85, 135, 90, 88, 219, 158, 3])
  ], c = new Uint8Array([
    169,
    103,
    179,
    232,
    4,
    253,
    163,
    118,
    154,
    146,
    128,
    120,
    228,
    221,
    209,
    56,
    13,
    198,
    53,
    152,
    24,
    247,
    236,
    108,
    67,
    117,
    55,
    38,
    250,
    19,
    148,
    72,
    242,
    208,
    139,
    48,
    132,
    84,
    223,
    35,
    25,
    91,
    61,
    89,
    243,
    174,
    162,
    130,
    99,
    1,
    131,
    46,
    217,
    81,
    155,
    124,
    166,
    235,
    165,
    190,
    22,
    12,
    227,
    97,
    192,
    140,
    58,
    245,
    115,
    44,
    37,
    11,
    187,
    78,
    137,
    107,
    83,
    106,
    180,
    241,
    225,
    230,
    189,
    69,
    226,
    244,
    182,
    102,
    204,
    149,
    3,
    86,
    212,
    28,
    30,
    215,
    251,
    195,
    142,
    181,
    233,
    207,
    191,
    186,
    234,
    119,
    57,
    175,
    51,
    201,
    98,
    113,
    129,
    121,
    9,
    173,
    36,
    205,
    249,
    216,
    229,
    197,
    185,
    77,
    68,
    8,
    134,
    231,
    161,
    29,
    170,
    237,
    6,
    112,
    178,
    210,
    65,
    123,
    160,
    17,
    49,
    194,
    39,
    144,
    32,
    246,
    96,
    255,
    150,
    92,
    177,
    171,
    158,
    156,
    82,
    27,
    95,
    147,
    10,
    239,
    145,
    133,
    73,
    238,
    45,
    79,
    143,
    59,
    71,
    135,
    109,
    70,
    214,
    62,
    105,
    100,
    42,
    206,
    203,
    47,
    252,
    151,
    5,
    122,
    172,
    127,
    213,
    26,
    75,
    14,
    167,
    90,
    40,
    20,
    63,
    41,
    136,
    60,
    76,
    2,
    184,
    218,
    176,
    23,
    85,
    31,
    138,
    125,
    87,
    199,
    141,
    116,
    183,
    196,
    159,
    114,
    126,
    21,
    34,
    18,
    88,
    7,
    153,
    52,
    110,
    80,
    222,
    104,
    101,
    188,
    219,
    248,
    200,
    168,
    43,
    64,
    220,
    254,
    50,
    164,
    202,
    16,
    33,
    240,
    211,
    93,
    15,
    0,
    111,
    157,
    54,
    66,
    74,
    94,
    193,
    224
  ]), o = new Uint8Array([
    117,
    243,
    198,
    244,
    219,
    123,
    251,
    200,
    74,
    211,
    230,
    107,
    69,
    125,
    232,
    75,
    214,
    50,
    216,
    253,
    55,
    113,
    241,
    225,
    48,
    15,
    248,
    27,
    135,
    250,
    6,
    63,
    94,
    186,
    174,
    91,
    138,
    0,
    188,
    157,
    109,
    193,
    177,
    14,
    128,
    93,
    210,
    213,
    160,
    132,
    7,
    20,
    181,
    144,
    44,
    163,
    178,
    115,
    76,
    84,
    146,
    116,
    54,
    81,
    56,
    176,
    189,
    90,
    252,
    96,
    98,
    150,
    108,
    66,
    247,
    16,
    124,
    40,
    39,
    140,
    19,
    149,
    156,
    199,
    36,
    70,
    59,
    112,
    202,
    227,
    133,
    203,
    17,
    208,
    147,
    184,
    166,
    131,
    32,
    255,
    159,
    119,
    195,
    204,
    3,
    111,
    8,
    191,
    64,
    231,
    43,
    226,
    121,
    12,
    170,
    130,
    65,
    58,
    234,
    185,
    228,
    154,
    164,
    151,
    126,
    218,
    122,
    23,
    102,
    148,
    161,
    29,
    61,
    240,
    222,
    179,
    11,
    114,
    167,
    28,
    239,
    209,
    83,
    62,
    143,
    51,
    38,
    95,
    236,
    118,
    42,
    73,
    129,
    136,
    238,
    33,
    196,
    26,
    235,
    217,
    197,
    57,
    153,
    205,
    173,
    49,
    139,
    1,
    24,
    35,
    221,
    31,
    78,
    45,
    249,
    72,
    79,
    242,
    101,
    142,
    120,
    92,
    88,
    25,
    141,
    229,
    152,
    87,
    103,
    127,
    5,
    100,
    175,
    99,
    182,
    254,
    245,
    183,
    60,
    165,
    206,
    233,
    104,
    68,
    224,
    77,
    67,
    105,
    41,
    46,
    172,
    21,
    89,
    168,
    10,
    158,
    110,
    71,
    223,
    52,
    53,
    106,
    207,
    220,
    34,
    201,
    192,
    155,
    137,
    212,
    237,
    171,
    18,
    162,
    13,
    82,
    187,
    2,
    47,
    169,
    215,
    97,
    30,
    180,
    80,
    4,
    246,
    194,
    22,
    37,
    134,
    86,
    85,
    9,
    190,
    145
  ]);
  class d {
    constructor(A = 256) {
      r(A >>> 0 === A), r(A === 128 || A === 192 || A === 256), this.bits = A, this.S = [
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256)
      ], this.k = new Uint32Array(40);
    }
    get blockSize() {
      return e;
    }
    init(A) {
      r(Buffer.isBuffer(A));
      const _ = A.length;
      if (_ !== 16 && _ !== 24 && _ !== 32)
        throw new Error("Invalid key size.");
      if (_ !== this.bits >>> 3)
        throw new Error("Invalid key size.");
      const q = _ >>> 3, U = new Uint8Array(4 * 4);
      for (let E = 0; E < q; E++)
        for (let H = 0; H < 4; H++)
          for (let k = 0; k < 8; k++)
            U[4 * E + H] ^= l(A[8 * E + k], n[H][k], i);
      const z = new Uint8Array(4);
      for (let E = 0; E < 20; E++) {
        for (let V = 0; V < 4; V++)
          z[V] = 2 * E;
        const H = x(z, A, 0);
        for (let V = 0; V < 4; V++)
          z[V] = 2 * E + 1;
        const k = b(x(z, A, 1), 8);
        this.k[2 * E + 0] = H + k, this.k[2 * E + 1] = b(2 * k + H, 9);
      }
      switch (q) {
        case 2:
          for (let E = 0; E < 256; E++)
            this.S[0][E] = h(o[c[c[E] ^ U[0]] ^ U[4]], 0), this.S[1][E] = h(c[c[o[E] ^ U[1]] ^ U[5]], 1), this.S[2][E] = h(o[o[c[E] ^ U[2]] ^ U[6]], 2), this.S[3][E] = h(c[o[o[E] ^ U[3]] ^ U[7]], 3);
          break;
        case 3:
          for (let E = 0; E < 256; E++)
            this.S[0][E] = h(o[c[c[o[E] ^ U[0]] ^ U[4]] ^ U[8]], 0), this.S[1][E] = h(c[c[o[o[E] ^ U[1]] ^ U[5]] ^ U[9]], 1), this.S[2][E] = h(o[o[c[c[E] ^ U[2]] ^ U[6]] ^ U[10]], 2), this.S[3][E] = h(c[o[o[c[E] ^ U[3]] ^ U[7]] ^ U[11]], 3);
          break;
        case 4:
          for (let E = 0; E < 256; E++)
            this.S[0][E] = h(o[c[c[o[o[E] ^ U[0]] ^ U[4]] ^ U[8]] ^ U[12]], 0), this.S[1][E] = h(c[c[o[o[c[E] ^ U[1]] ^ U[5]] ^ U[9]] ^ U[13]], 1), this.S[2][E] = h(o[o[c[c[c[E] ^ U[2]] ^ U[6]] ^ U[10]] ^ U[14]], 2), this.S[3][E] = h(c[o[o[c[o[E] ^ U[3]] ^ U[7]] ^ U[11]] ^ U[15]], 3);
          break;
        default:
          throw new Error("unreachable");
      }
      return this;
    }
    encrypt(A, _, q, U) {
      const z = this.k, E = this.S[0], H = this.S[1], k = this.S[2], V = this.S[3];
      let T = I(q, U + 0), ie = I(q, U + 4), N = I(q, U + 8), G = I(q, U + 12), F, W;
      T ^= this.k[0], ie ^= this.k[1], N ^= this.k[2], G ^= this.k[3];
      for (let me = 0; me < 8; me++) {
        const Ne = 8 + me * 4;
        W = H[ie >>> 0 & 255] ^ k[ie >>> 8 & 255] ^ V[ie >>> 16 & 255] ^ E[ie >>> 24 & 255], F = E[T >>> 0 & 255] ^ H[T >>> 8 & 255] ^ k[T >>> 16 & 255] ^ V[T >>> 24 & 255], F += W, N = g(N ^ F + z[Ne + 0], 1), G = b(G, 1) ^ W + F + z[Ne + 1], W = H[G >>> 0 & 255] ^ k[G >>> 8 & 255] ^ V[G >>> 16 & 255] ^ E[G >>> 24 & 255], F = E[N >>> 0 & 255] ^ H[N >>> 8 & 255] ^ k[N >>> 16 & 255] ^ V[N >>> 24 & 255], F += W, T = g(T ^ F + z[Ne + 2], 1), ie = b(ie, 1) ^ W + F + z[Ne + 3];
      }
      const ce = N ^ this.k[4], ne = G ^ this.k[5], xe = T ^ this.k[6], he = ie ^ this.k[7];
      return B(A, ce, _ + 0), B(A, ne, _ + 4), B(A, xe, _ + 8), B(A, he, _ + 12), this;
    }
    decrypt(A, _, q, U) {
      const z = this.k, E = this.S[0], H = this.S[1], k = this.S[2], V = this.S[3], T = I(q, U + 0), ie = I(q, U + 4), N = I(q, U + 8), G = I(q, U + 12);
      let F = N ^ this.k[6], W = G ^ this.k[7], ce = T ^ this.k[4], ne = ie ^ this.k[5], xe, he;
      for (let me = 8; me > 0; me--) {
        const Ne = 4 + me * 4;
        he = H[ne >>> 0 & 255] ^ k[ne >>> 8 & 255] ^ V[ne >>> 16 & 255] ^ E[ne >>> 24 & 255], xe = E[ce >>> 0 & 255] ^ H[ce >>> 8 & 255] ^ k[ce >>> 16 & 255] ^ V[ce >>> 24 & 255], xe += he, F = b(F, 1) ^ xe + z[Ne + 2], W = g(W ^ he + xe + z[Ne + 3], 1), he = H[W >>> 0 & 255] ^ k[W >>> 8 & 255] ^ V[W >>> 16 & 255] ^ E[W >>> 24 & 255], xe = E[F >>> 0 & 255] ^ H[F >>> 8 & 255] ^ k[F >>> 16 & 255] ^ V[F >>> 24 & 255], xe += he, ce = b(ce, 1) ^ xe + z[Ne + 0], ne = g(ne ^ he + xe + z[Ne + 1], 1);
      }
      return F ^= this.k[0], W ^= this.k[1], ce ^= this.k[2], ne ^= this.k[3], B(A, F, _ + 0), B(A, W, _ + 4), B(A, ce, _ + 8), B(A, ne, _ + 12), this;
    }
    destroy() {
      return w(this.S[0]), w(this.S[1]), w(this.S[2]), w(this.S[3]), w(this.k), this;
    }
  }
  function l(y, A, _) {
    const q = new Uint32Array([0, A & 255]), U = new Uint32Array([0, _ >>> 0]);
    let z = 0;
    for (let E = 0; E < 7; E++)
      z ^= q[y & 1], y >>>= 1, q[1] = U[q[1] >>> 7] ^ q[1] << 1;
    return z ^= q[y & 1], z & 255;
  }
  function h(y, A) {
    const _ = y & 255, q = l(y, 91, t), U = l(y, 239, t);
    switch (A) {
      case 0:
        return _ | q << 8 | U << 16 | U << 24;
      case 1:
        return U | U << 8 | q << 16 | _ << 24;
      case 2:
        return q | U << 8 | _ << 16 | U << 24;
      case 3:
        return q | _ << 8 | U << 16 | q << 24;
    }
    throw new Error("unreachable");
  }
  function x(y, A, _) {
    const q = new Uint8Array(4);
    for (let E = 0; E < 4; E++)
      q[E] = y[E];
    switch (A.length >>> 3) {
      case 4:
        q[0] = o[q[0]] ^ A[4 * (6 + _) + 0], q[1] = c[q[1]] ^ A[4 * (6 + _) + 1], q[2] = c[q[2]] ^ A[4 * (6 + _) + 2], q[3] = o[q[3]] ^ A[4 * (6 + _) + 3];
      case 3:
        q[0] = o[q[0]] ^ A[4 * (4 + _) + 0], q[1] = o[q[1]] ^ A[4 * (4 + _) + 1], q[2] = c[q[2]] ^ A[4 * (4 + _) + 2], q[3] = c[q[3]] ^ A[4 * (4 + _) + 3];
      case 2:
        q[0] = o[c[c[q[0]] ^ A[4 * (2 + _) + 0]] ^ A[4 * (0 + _) + 0]], q[1] = c[c[o[q[1]] ^ A[4 * (2 + _) + 1]] ^ A[4 * (0 + _) + 1]], q[2] = o[o[c[q[2]] ^ A[4 * (2 + _) + 2]] ^ A[4 * (0 + _) + 2]], q[3] = c[o[o[q[3]] ^ A[4 * (2 + _) + 3]] ^ A[4 * (0 + _) + 3]];
        break;
      default:
        throw new Error("Invalid key size.");
    }
    let z = 0;
    for (let E = 0; E < 4; E++)
      z ^= h(q[E], E);
    return z >>> 0;
  }
  function b(y, A) {
    return y << (A & 31) | y >>> 32 - (A & 31);
  }
  function g(y, A) {
    return y >>> (A & 31) | y << 32 - (A & 31);
  }
  function w(y) {
    for (let A = 0; A < y.length; A++)
      y[A] = 0;
  }
  function I(y, A) {
    return y[A++] + y[A++] * 256 + y[A++] * 65536 + y[A++] * 16777216;
  }
  function B(y, A, _) {
    return y[_++] = A, A >>>= 8, y[_++] = A, A >>>= 8, y[_++] = A, A >>>= 8, y[_++] = A, _;
  }
  return th = d, th;
}
/*!
 * cipher.js - ciphers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ix;
function Cm() {
  if (ix)
    return qs;
  ix = 1;
  const r = _e, e = h8(), t = G1(), i = Om(), n = u8(), c = Pm(), o = Rm(), { DES: d, EDE: l, EDE3: h } = km(), x = qm(), b = zm(), g = Um();
  class w {
    constructor(z, E) {
      r(typeof z == "string"), r(typeof E == "boolean"), this.encrypt = E, this.ctx = null, this._init(z);
    }
    _init(z) {
      const [E, H] = q(z), k = e.get(H, this.encrypt);
      switch (E) {
        case "AES-128":
        case "AES-192":
        case "AES-256": {
          const V = E.slice(-3) | 0;
          this.ctx = new k(new t(V));
          break;
        }
        case "ARC2": {
          this.ctx = new k(new i());
          break;
        }
        case "ARC2-GUTMANN": {
          this.ctx = new k(new i(-1, 0));
          break;
        }
        case "ARC2-40": {
          this.ctx = new k(new i(40));
          break;
        }
        case "ARC2-64": {
          this.ctx = new k(new i(64));
          break;
        }
        case "ARC2-128": {
          this.ctx = new k(new i(128));
          break;
        }
        case "ARC2-128-GUTMANN": {
          this.ctx = new k(new i(128, 1024));
          break;
        }
        case "BF":
        case "BLOWFISH": {
          this.ctx = new k(new n());
          break;
        }
        case "CAMELLIA-128":
        case "CAMELLIA-192":
        case "CAMELLIA-256": {
          const V = E.slice(-3) | 0;
          this.ctx = new k(new c(V));
          break;
        }
        case "CAST5": {
          this.ctx = new k(new o());
          break;
        }
        case "DES": {
          this.ctx = new k(new d());
          break;
        }
        case "DES-EDE": {
          this.ctx = new k(new l());
          break;
        }
        case "DES-EDE3": {
          this.ctx = new k(new h());
          break;
        }
        case "IDEA": {
          this.ctx = new k(new x());
          break;
        }
        case "SERPENT-128":
        case "SERPENT-192":
        case "SERPENT-256": {
          const V = E.slice(-3) | 0;
          this.ctx = new k(new b(V));
          break;
        }
        case "TWOFISH-128":
        case "TWOFISH-192":
        case "TWOFISH-256": {
          const V = E.slice(-3) | 0;
          this.ctx = new k(new g(V));
          break;
        }
        default:
          throw new Error(`Unsupported cipher: ${z}.`);
      }
    }
    init(z, E) {
      return this.ctx.init(z, E), this;
    }
    update(z) {
      return this.ctx.update(z);
    }
    crypt(z, E) {
      return this.ctx.crypt(z, E);
    }
    final() {
      return this.ctx.final();
    }
    destroy() {
      return this.ctx.destroy(), this;
    }
    setAutoPadding(z) {
      return this.ctx.setAutoPadding(z), this;
    }
    setAAD(z) {
      return this.ctx.setAAD(z), this;
    }
    setCCM(z, E, H) {
      return this.ctx.setCCM(z, E, H), this;
    }
    getAuthTag() {
      return this.ctx.getAuthTag();
    }
    setAuthTag(z) {
      return this.ctx.setAuthTag(z), this;
    }
  }
  class I extends w {
    constructor(z) {
      super(z, !0);
    }
  }
  class B extends w {
    constructor(z) {
      super(z, !1);
    }
  }
  function y(U, z, E, H) {
    const k = new I(U);
    return k.init(z, E), Buffer.concat([
      k.update(H),
      k.final()
    ]);
  }
  function A(U, z, E, H) {
    const k = new B(U);
    return k.init(z, E), Buffer.concat([
      k.update(H),
      k.final()
    ]);
  }
  const _ = {
    __proto__: null,
    ECB: !0,
    CBC: !0,
    CTS: !0,
    XTS: !0,
    CTR: !0,
    CFB: !0,
    OFB: !0,
    GCM: !0,
    CCM: !0,
    EAX: !0
  };
  function q(U) {
    if (r(typeof U == "string"), U.substring(0, 3) === "RC2" && (U = "A" + U), U.length < 5)
      return [U, "RAW"];
    const z = U.substring(U.length - 3);
    return U[U.length - 4] !== "-" || !_[z] ? [U, "RAW"] : [U.substring(0, U.length - 4), z];
  }
  return qs.native = 0, qs.Cipher = I, qs.Decipher = B, qs.encrypt = y, qs.decrypt = A, qs;
}
var zs = {};
/*!
 * cipher.js - ciphers for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var sx;
function Tm() {
  if (sx)
    return zs;
  sx = 1;
  const r = _e, e = Dt();
  class t {
    constructor(h, x) {
      const [b, g] = d(h);
      this._handle = e.cipher_create(b, g, x);
    }
    init(h, x) {
      return x == null && (x = e.NULL), r(this instanceof t), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), e.cipher_init(this._handle, h, x), this;
    }
    update(h) {
      r(this instanceof t), r(Buffer.isBuffer(h));
      const { buffer: x, length: b } = e.cipher_update(this._handle, h);
      return Buffer.from(x, 0, b);
    }
    crypt(h, x) {
      return r(this instanceof t), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), e.cipher_crypt(this._handle, h, x);
    }
    final() {
      return r(this instanceof t), e.cipher_final(this._handle);
    }
    destroy() {
      return r(this instanceof t), e.cipher_destroy(this._handle), this;
    }
    setAutoPadding(h) {
      return r(this instanceof t), r(typeof h == "boolean"), e.cipher_set_padding(this._handle, h), this;
    }
    setAAD(h) {
      return r(this instanceof t), r(Buffer.isBuffer(h)), e.cipher_set_aad(this._handle, h), this;
    }
    setCCM(h, x, b) {
      return b == null && (b = e.NULL), r(this instanceof t), r(h >>> 0 === h), r(x >>> 0 === x), r(Buffer.isBuffer(b)), e.cipher_set_ccm(this._handle, h, x, b), this;
    }
    getAuthTag() {
      return r(this instanceof t), e.cipher_get_tag(this._handle);
    }
    setAuthTag(h) {
      return r(this instanceof t), r(Buffer.isBuffer(h)), e.cipher_set_tag(this._handle, h), this;
    }
  }
  class i extends t {
    constructor(h) {
      super(h, !0);
    }
  }
  class n extends t {
    constructor(h) {
      super(h, !1);
    }
  }
  function c(l, h, x, b) {
    x == null && (x = e.NULL), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(Buffer.isBuffer(b));
    const [g, w] = d(l), { buffer: I, length: B } = e.cipher_encrypt(g, w, h, x, b);
    return Buffer.from(I, 0, B);
  }
  function o(l, h, x, b) {
    x == null && (x = e.NULL), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(Buffer.isBuffer(b));
    const [g, w] = d(l), { buffer: I, length: B } = e.cipher_decrypt(g, w, h, x, b);
    return Buffer.from(I, 0, B);
  }
  function d(l) {
    if (r(typeof l == "string"), l.substring(0, 3) === "RC2" && (l = "A" + l), e.algorithms[l] != null) {
      const w = e.algorithms[l], I = e.modes.RAW;
      return [w >>> 0, I >>> 0];
    }
    if (l.length < 5 || l[l.length - 4] !== "-")
      throw new Error(`Unsupported cipher: ${l}.`);
    const h = l.substring(0, l.length - 4), x = l.substring(l.length - 3), b = e.algorithms[h], g = e.modes[x];
    if (b == null || g == null || g === e.modes.RAW)
      throw new Error(`Unsupported cipher: ${l}.`);
    return [b >>> 0, g >>> 0];
  }
  return zs.native = 2, zs.Cipher = i, zs.Decipher = n, zs.encrypt = c, zs.decrypt = o, zs;
}
/*!
 * cipher.js - cipher for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Su.exports = Cm() : Su.exports = Tm();
var Bo = Su.exports, Bu = { exports: {} };
/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var rh, nx;
function Dm() {
  if (nx)
    return rh;
  nx = 1;
  const r = _e, e = B0;
  function t(i) {
    r(Buffer.isBuffer(i)), e.randomFill(i, 0, i.length);
  }
  return t.native = 0, rh = t, rh;
}
/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ih, fx;
function Lm() {
  if (fx)
    return ih;
  fx = 1;
  const r = _e, e = Dt();
  function t(i) {
    r(Buffer.isBuffer(i)), e.cleanse(i);
  }
  return t.native = 2, ih = t, ih;
}
/*!
 * cleanse.js - cleanse for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Bu.exports = Dm() : Bu.exports = Lm();
var Km = Bu.exports, vu = { exports: {} };
/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */
var sh, cx;
function O8() {
  if (cx)
    return sh;
  cx = 1;
  const r = _e, e = Rr, t = 2147483648, i = new Uint32Array([
    1,
    0,
    32898,
    0,
    32906,
    2147483648,
    2147516416,
    2147483648,
    32907,
    0,
    2147483649,
    0,
    2147516545,
    2147483648,
    32777,
    2147483648,
    138,
    0,
    136,
    0,
    2147516425,
    0,
    2147483658,
    0,
    2147516555,
    0,
    139,
    2147483648,
    32905,
    2147483648,
    32771,
    2147483648,
    32770,
    2147483648,
    128,
    2147483648,
    32778,
    0,
    2147483658,
    2147483648,
    2147516545,
    2147483648,
    32896,
    2147483648,
    2147483649,
    0,
    2147516424,
    2147483648
  ]);
  class n {
    constructor() {
      this.state = new Uint32Array(50), this.block = Buffer.alloc(200), this.bs = 136, this.pos = t;
    }
    init(d) {
      d == null && (d = 256), r(d >>> 0 === d), r(d >= 128), r(d <= 512);
      const l = 1600 - d * 2;
      return r(l >= 0 && (l & 63) === 0), this.bs = l >>> 3, this.pos = 0, this;
    }
    update(d) {
      r(Buffer.isBuffer(d)), r(!(this.pos & t), "Context is not initialized.");
      let l = d.length, h = this.pos, x = 0;
      if (this.pos = (this.pos + l) % this.bs, h > 0) {
        let b = this.bs - h;
        if (b > l && (b = l), d.copy(this.block, h, x, x + b), h += b, l -= b, x += b, h < this.bs)
          return this;
        this._transform(this.block, 0);
      }
      for (; l >= this.bs; )
        this._transform(d, x), x += this.bs, l -= this.bs;
      return l > 0 && d.copy(this.block, 0, x, x + l), this;
    }
    final(d, l) {
      d == null && (d = 1), (l == null || l === 0) && (l = 100 - (this.bs >>> 1)), r((d & 255) === d), r(l >>> 0 === l), r(!(this.pos & t), "Context is not initialized."), this.block.fill(0, this.pos, this.bs), this.block[this.pos] |= d, this.block[this.bs - 1] |= 128, this._transform(this.block, 0), this.pos = t, r(l <= this.bs);
      const h = Buffer.alloc(l);
      for (let x = 0; x < l; x++)
        h[x] = this.state[x >>> 2] >>> 8 * (x & 3);
      for (let x = 0; x < 50; x++)
        this.state[x] = 0;
      for (let x = 0; x < this.bs; x++)
        this.block[x] = 0;
      return h;
    }
    _transform(d, l) {
      const h = this.bs >>> 2, x = this.state;
      for (let b = 0; b < h; b++)
        x[b] ^= c(d, l + b * 4);
      for (let b = 0; b < 48; b += 2) {
        const g = x[0] ^ x[10] ^ x[20] ^ x[30] ^ x[40], w = x[1] ^ x[11] ^ x[21] ^ x[31] ^ x[41], I = x[2] ^ x[12] ^ x[22] ^ x[32] ^ x[42], B = x[3] ^ x[13] ^ x[23] ^ x[33] ^ x[43], y = x[4] ^ x[14] ^ x[24] ^ x[34] ^ x[44], A = x[5] ^ x[15] ^ x[25] ^ x[35] ^ x[45], _ = x[6] ^ x[16] ^ x[26] ^ x[36] ^ x[46], q = x[7] ^ x[17] ^ x[27] ^ x[37] ^ x[47], U = x[8] ^ x[18] ^ x[28] ^ x[38] ^ x[48], z = x[9] ^ x[19] ^ x[29] ^ x[39] ^ x[49], E = U ^ (I << 1 | B >>> 31), H = z ^ (B << 1 | I >>> 31), k = g ^ (y << 1 | A >>> 31), V = w ^ (A << 1 | y >>> 31), T = I ^ (_ << 1 | q >>> 31), ie = B ^ (q << 1 | _ >>> 31), N = y ^ (U << 1 | z >>> 31), G = A ^ (z << 1 | U >>> 31), F = _ ^ (g << 1 | w >>> 31), W = q ^ (w << 1 | g >>> 31);
        x[0] ^= E, x[1] ^= H, x[10] ^= E, x[11] ^= H, x[20] ^= E, x[21] ^= H, x[30] ^= E, x[31] ^= H, x[40] ^= E, x[41] ^= H, x[2] ^= k, x[3] ^= V, x[12] ^= k, x[13] ^= V, x[22] ^= k, x[23] ^= V, x[32] ^= k, x[33] ^= V, x[42] ^= k, x[43] ^= V, x[4] ^= T, x[5] ^= ie, x[14] ^= T, x[15] ^= ie, x[24] ^= T, x[25] ^= ie, x[34] ^= T, x[35] ^= ie, x[44] ^= T, x[45] ^= ie, x[6] ^= N, x[7] ^= G, x[16] ^= N, x[17] ^= G, x[26] ^= N, x[27] ^= G, x[36] ^= N, x[37] ^= G, x[46] ^= N, x[47] ^= G, x[8] ^= F, x[9] ^= W, x[18] ^= F, x[19] ^= W, x[28] ^= F, x[29] ^= W, x[38] ^= F, x[39] ^= W, x[48] ^= F, x[49] ^= W;
        const ce = x[0], ne = x[1], xe = x[11] << 4 | x[10] >>> 28, he = x[10] << 4 | x[11] >>> 28, me = x[20] << 3 | x[21] >>> 29, Ne = x[21] << 3 | x[20] >>> 29, Je = x[31] << 9 | x[30] >>> 23, Ze = x[30] << 9 | x[31] >>> 23, ht = x[40] << 18 | x[41] >>> 14, dt = x[41] << 18 | x[40] >>> 14, Se = x[2] << 1 | x[3] >>> 31, we = x[3] << 1 | x[2] >>> 31, Z = x[13] << 12 | x[12] >>> 20, L = x[12] << 12 | x[13] >>> 20, oe = x[22] << 10 | x[23] >>> 22, s = x[23] << 10 | x[22] >>> 22, a = x[33] << 13 | x[32] >>> 19, p = x[32] << 13 | x[33] >>> 19, v = x[42] << 2 | x[43] >>> 30, C = x[43] << 2 | x[42] >>> 30, K = x[5] << 30 | x[4] >>> 2, O = x[4] << 30 | x[5] >>> 2, $ = x[14] << 6 | x[15] >>> 26, u = x[15] << 6 | x[14] >>> 26, S = x[25] << 11 | x[24] >>> 21, M = x[24] << 11 | x[25] >>> 21, Y = x[34] << 15 | x[35] >>> 17, J = x[35] << 15 | x[34] >>> 17, X = x[45] << 29 | x[44] >>> 3, re = x[44] << 29 | x[45] >>> 3, ae = x[6] << 28 | x[7] >>> 4, de = x[7] << 28 | x[6] >>> 4, ge = x[17] << 23 | x[16] >>> 9, Be = x[16] << 23 | x[17] >>> 9, ve = x[26] << 25 | x[27] >>> 7, Oe = x[27] << 25 | x[26] >>> 7, Ie = x[36] << 21 | x[37] >>> 11, Re = x[37] << 21 | x[36] >>> 11, ft = x[47] << 24 | x[46] >>> 8, Ye = x[46] << 24 | x[47] >>> 8, Fe = x[8] << 27 | x[9] >>> 5, Le = x[9] << 27 | x[8] >>> 5, He = x[18] << 20 | x[19] >>> 12, et = x[19] << 20 | x[18] >>> 12, xr = x[29] << 7 | x[28] >>> 25, tt = x[28] << 7 | x[29] >>> 25, it = x[38] << 8 | x[39] >>> 24, Ht = x[39] << 8 | x[38] >>> 24, Qe = x[48] << 14 | x[49] >>> 18, st = x[49] << 14 | x[48] >>> 18;
        x[0] = ce ^ ~Z & S, x[1] = ne ^ ~L & M, x[10] = ae ^ ~He & me, x[11] = de ^ ~et & Ne, x[20] = Se ^ ~$ & ve, x[21] = we ^ ~u & Oe, x[30] = Fe ^ ~xe & oe, x[31] = Le ^ ~he & s, x[40] = K ^ ~ge & xr, x[41] = O ^ ~Be & tt, x[2] = Z ^ ~S & Ie, x[3] = L ^ ~M & Re, x[12] = He ^ ~me & a, x[13] = et ^ ~Ne & p, x[22] = $ ^ ~ve & it, x[23] = u ^ ~Oe & Ht, x[32] = xe ^ ~oe & Y, x[33] = he ^ ~s & J, x[42] = ge ^ ~xr & Je, x[43] = Be ^ ~tt & Ze, x[4] = S ^ ~Ie & Qe, x[5] = M ^ ~Re & st, x[14] = me ^ ~a & X, x[15] = Ne ^ ~p & re, x[24] = ve ^ ~it & ht, x[25] = Oe ^ ~Ht & dt, x[34] = oe ^ ~Y & ft, x[35] = s ^ ~J & Ye, x[44] = xr ^ ~Je & v, x[45] = tt ^ ~Ze & C, x[6] = Ie ^ ~Qe & ce, x[7] = Re ^ ~st & ne, x[16] = a ^ ~X & ae, x[17] = p ^ ~re & de, x[26] = it ^ ~ht & Se, x[27] = Ht ^ ~dt & we, x[36] = Y ^ ~ft & Fe, x[37] = J ^ ~Ye & Le, x[46] = Je ^ ~v & K, x[47] = Ze ^ ~C & O, x[8] = Qe ^ ~ce & Z, x[9] = st ^ ~ne & L, x[18] = X ^ ~ae & He, x[19] = re ^ ~de & et, x[28] = ht ^ ~Se & $, x[29] = dt ^ ~we & u, x[38] = ft ^ ~Fe & xe, x[39] = Ye ^ ~Le & he, x[48] = v ^ ~K & ge, x[49] = C ^ ~O & Be, x[0] ^= i[b + 0], x[1] ^= i[b + 1];
      }
    }
    static hash() {
      return new n();
    }
    static hmac(d, l, h) {
      d == null && (d = 256), r(d >>> 0 === d);
      const x = 1600 - d * 2;
      return r(x >= 0 && (x & 63) === 0), new e(n, x >>> 3, [d], [l, h]);
    }
    static digest(d, l, h, x) {
      return n.ctx.init(l).update(d).final(h, x);
    }
    static root(d, l, h, x, b) {
      return h == null && (h = 256), b == null && (b = 0), b === 0 && (b = h >>> 3), r(h >>> 0 === h), r((h & 7) === 0), r(b >>> 0 === b), r(Buffer.isBuffer(d) && d.length === b), r(Buffer.isBuffer(l) && l.length === b), n.ctx.init(h).update(d).update(l).final(x, b);
    }
    static multi(d, l, h, x, b, g) {
      const { ctx: w } = n;
      return w.init(x), w.update(d), w.update(l), h && w.update(h), w.final(b, g);
    }
    static mac(d, l, h, x, b) {
      return n.hmac(h, x, b).init(l).update(d).final();
    }
  }
  n.native = 0, n.id = "KECCAK256", n.size = 32, n.bits = 256, n.blockSize = 136, n.zero = Buffer.alloc(32, 0), n.ctx = new n();
  function c(o, d) {
    return o[d++] + o[d++] * 256 + o[d++] * 65536 + o[d] * 16777216;
  }
  return sh = n, sh;
}
/*!
 * keccak.js - Keccak implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var nh, ox;
function P8() {
  if (ox)
    return nh;
  ox = 1;
  const r = _e, e = Dt(), t = Rr;
  class i {
    constructor() {
      this._handle = e.keccak_create();
    }
    init(c) {
      return c == null && (c = 256), r(this instanceof i), r(c >>> 0 === c), e.keccak_init(this._handle, c), this;
    }
    update(c) {
      return r(this instanceof i), r(Buffer.isBuffer(c)), e.keccak_update(this._handle, c), this;
    }
    final(c, o) {
      return c == null && (c = 1), o == null && (o = 0), r(this instanceof i), r(c >>> 0 === c), r(o >>> 0 === o), e.keccak_final(this._handle, c, o);
    }
    static hash() {
      return new i();
    }
    static hmac(c, o, d) {
      c == null && (c = 256), o == null && (o = 1), d == null && (d = 0), r(c >>> 0 === c), r(o >>> 0 === o), r(d >>> 0 === d);
      const h = 1600 - c * 2 >> 3;
      return new t(i, h, [c], [o, d]);
    }
    static digest(c, o, d, l) {
      return o == null && (o = 256), d == null && (d = 1), l == null && (l = 0), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(d >>> 0 === d), r(l >>> 0 === l), e.keccak_digest(c, o, d, l);
    }
    static root(c, o, d, l, h) {
      return d == null && (d = 256), l == null && (l = 1), h == null && (h = 0), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(d >>> 0 === d), r(l >>> 0 === l), r(h >>> 0 === h), e.keccak_root(c, o, d, l, h);
    }
    static multi(c, o, d, l, h, x) {
      return d == null && (d = e.NULL), l == null && (l = 256), h == null && (h = 1), x == null && (x = 0), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), r(h >>> 0 === h), r(x >>> 0 === x), e.keccak_multi(c, o, d, l, h, x);
    }
    static mac(c, o, d, l, h) {
      return i.hmac(d, l, h).init(o).update(c).final();
    }
  }
  return i.native = 2, i.id = "KECCAK256", i.size = 32, i.bits = 256, i.blockSize = 136, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), nh = i, nh;
}
/*!
 * keccak.js - keccak for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? vu.exports = O8() : vu.exports = P8();
var fn = vu.exports;
/*!
 * cshake.js - cSHAKE implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://keccak.team/specifications.html
 *   https://www.nist.gov/node/1131611
 *   https://doi.org/10.6028/NIST.SP.800-185
 *   https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.inc
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.c
 *   https://github.com/XKCP/XKCP/blob/8f447eb/tests/UnitTests/testSP800-185.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */
const zr = _e, R8 = fn, $m = Rr, ax = Buffer.alloc(0), Hm = Buffer.alloc(200, 0);
let os = class Ks extends R8 {
  constructor() {
    super(), this.pad = 4, this.rate = 1088;
  }
  init(e, t, i) {
    if (e == null && (e = 256), t == null && (t = ax), i == null && (i = ax), zr(e >>> 0 === e), zr(e === 128 || e === 256), zr(Buffer.isBuffer(t)), zr(Buffer.isBuffer(i)), super.init(e), t.length === 0 && i.length === 0)
      this.pad = 31;
    else {
      const n = 1600 - e * 2, c = n / 8;
      this.bytePad([t, i], c), this.rate = n, this.pad = 4;
    }
    return this;
  }
  final(e) {
    return super.final(this.pad, e);
  }
  bytePad(e, t) {
    zr(Array.isArray(e)), zr(t >>> 0 === t), zr(t > 0);
    let i = this.leftEncode(t);
    for (const c of e)
      i += this.encodeString(c);
    const n = t - i % t;
    return n === t || (i += this.zeroPad(n)), i;
  }
  encodeString(e) {
    zr(Buffer.isBuffer(e));
    const t = this.leftEncode(e.length * 8);
    return this.update(e), t + e.length;
  }
  zeroPad(e) {
    zr(e >>> 0 === e), zr(e <= 200);
    const t = Hm.slice(0, e);
    return this.update(t), t.length;
  }
  leftEncode(e) {
    zr(e >>> 0 === e), zr(e >= 0 && e < 22040);
    let t = e, i = 0;
    for (; t && i < 4; )
      i += 1, t >>>= 8;
    i === 0 && (i = 1);
    const n = Buffer.alloc(i + 1);
    for (let c = 1; c <= i; c++)
      n[c] = e >>> 8 * (i - c);
    return n[0] = i, this.update(n), n.length;
  }
  rightEncode(e) {
    zr(e >>> 0 === e), zr(e >= 0 && e < 22040);
    let t = e, i = 0;
    for (; t && i < 4; )
      i += 1, t >>>= 8;
    i === 0 && (i = 1);
    const n = Buffer.alloc(i + 1);
    for (let c = 1; c <= i; c++)
      n[c - 1] = e >>> 8 * (i - c);
    return n[i] = i, this.update(n), n.length;
  }
  static hash() {
    return new Ks();
  }
  static hmac(e, t, i, n) {
    e == null && (e = 256), zr(e >>> 0 === e), zr(e === 128 || e === 256);
    const c = 1600 - e * 2;
    return new $m(Ks, c / 8, [e, t, i], [n]);
  }
  static digest(e, t, i, n, c) {
    return Ks.ctx.init(t, i, n).update(e).final(c);
  }
  static root(e, t, i, n, c, o) {
    i == null && (i = 256), o == null && (o = 0), o === 0 && (zr(i >>> 0 === i), o = i >>> 3), zr(o >>> 0 === o), zr(Buffer.isBuffer(e) && e.length === o), zr(Buffer.isBuffer(t) && t.length === o);
    const { ctx: d } = Ks;
    return d.init(i, n, c), d.update(e), d.update(t), d.final(o);
  }
  static multi(e, t, i, n, c, o, d) {
    const { ctx: l } = Ks;
    return l.init(n, c, o), l.update(e), l.update(t), i && l.update(i), l.final(d);
  }
  static mac(e, t, i, n, c, o) {
    return Ks.hmac(i, n, c, o).init(t).update(e).final();
  }
};
os.native = R8.native;
os.id = "CSHAKE256";
os.size = 32;
os.bits = 256;
os.blockSize = 136;
os.zero = Buffer.alloc(32, 0);
os.ctx = new os();
var vo = os;
/*!
 * cshake128.js - CSHAKE128 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const k8 = vo;
class xi extends k8 {
  constructor() {
    super();
  }
  init(e, t) {
    return super.init(128, e, t);
  }
  static hash() {
    return new xi();
  }
  static hmac(e, t, i) {
    return super.hmac(128, e, t, i);
  }
  static digest(e, t, i, n) {
    return super.digest(e, 128, t, i, n);
  }
  static root(e, t, i, n, c) {
    return super.root(e, t, 128, i, n, c);
  }
  static multi(e, t, i, n, c, o) {
    return super.multi(e, t, i, 128, n, c, o);
  }
  static mac(e, t, i, n, c) {
    return super.mac(e, t, 128, i, n, c);
  }
}
xi.native = k8.native;
xi.id = "CSHAKE128";
xi.size = 16;
xi.bits = 128;
xi.blockSize = 168;
xi.zero = Buffer.alloc(16, 0);
xi.ctx = new xi();
var Fm = xi;
/*!
 * cshake256.js - CSHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const q8 = vo;
class bi extends q8 {
  constructor() {
    super();
  }
  init(e, t) {
    return super.init(256, e, t);
  }
  static hash() {
    return new bi();
  }
  static hmac(e, t, i) {
    return super.hmac(256, e, t, i);
  }
  static digest(e, t, i, n) {
    return super.digest(e, 256, t, i, n);
  }
  static root(e, t, i, n, c) {
    return super.root(e, t, 256, i, n, c);
  }
  static multi(e, t, i, n, c, o) {
    return super.multi(e, t, i, 256, n, c, o);
  }
  static mac(e, t, i, n, c) {
    return super.mac(e, t, 256, i, n, c);
  }
}
bi.native = q8.native;
bi.id = "CSHAKE256";
bi.size = 32;
bi.bits = 256;
bi.blockSize = 136;
bi.zero = Buffer.alloc(32, 0);
bi.ctx = new bi();
var Vm = bi, Eu = { exports: {} };
/*!
 * ctr-drbg.js - ctr-drbg implementation for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on google/boringssl:
 *   https://github.com/google/boringssl
 *
 * Resources:
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/google/boringssl/blob/master/crypto/fipsmodule/rand/ctrdrbg.c
 *   https://github.com/google/boringssl/blob/master/crypto/fipsmodule/rand/internal.h
 *   https://github.com/openssl/openssl/blob/master/crypto/rand/drbg_lib.c
 *   https://github.com/cryptocoinjs/drbg.js/blob/master/ctr.js
 *   https://github.com/netroby/jdk9-dev/blob/master/jdk/src/java.base/share/classes/sun/security/provider/CtrDrbg.java
 */
var fh, hx;
function Gm() {
  if (hx)
    return fh;
  hx = 1;
  const r = _e, e = G1(), t = 65536, i = 281474976710656;
  class n {
    constructor(l, h, x, b, g) {
      r(l >>> 0 === l), r(typeof h == "boolean"), this.bits = l, this.ctr = new c(l), this.keySize = l >>> 3, this.blkSize = 16, this.entSize = this.keySize + this.blkSize, this.slab = Buffer.alloc(this.entSize), this.K = this.slab.slice(0, this.keySize), this.V = this.slab.slice(this.keySize), this.derivation = h, this.rounds = 0, x && this.init(x, b, g);
    }
    init(l, h, x) {
      h == null && (h = Buffer.alloc(0)), x == null && (x = Buffer.alloc(0)), r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x));
      let b;
      if (this.derivation)
        b = this.derive(l, h, x);
      else {
        if (l.length + h.length > this.entSize)
          throw new Error("Entropy is too long.");
        if (x.length > this.entSize)
          throw new Error("Personalization string is too long.");
        b = Buffer.alloc(this.entSize, 0), l.copy(b, 0), h.copy(b, l.length);
        for (let g = 0; g < x.length; g++)
          b[g] ^= x[g];
      }
      return this.slab.fill(0), this.ctr.init(this.K, this.V), this.update(b), this.rounds = 1, this;
    }
    reseed(l, h) {
      if (h == null && (h = Buffer.alloc(0)), r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      let x;
      if (this.derivation)
        x = this.derive(l, h);
      else {
        if (h.length > this.entSize)
          throw new Error("Additional data is too long.");
        x = Buffer.alloc(this.entSize, 0), l.copy(x, 0);
        for (let b = 0; b < h.length; b++)
          x[b] ^= h[b];
      }
      return this.update(x), this.rounds = 1, this;
    }
    generate(l, h) {
      if (r(l >>> 0 === l), r(h == null || Buffer.isBuffer(h)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > i)
        throw new Error("Reseed is required.");
      if (l > t)
        throw new Error("Requested length is too long.");
      h && h.length > 0 && (this.derivation && (h = this.derive(h)), this.update(h));
      const x = Math.ceil(l / this.blkSize), b = Buffer.alloc(x * this.blkSize);
      for (let g = 0; g < x; g++)
        this.ctr.encrypt(b, g * this.blkSize);
      return this.update(h), this.rounds += 1, b.slice(0, l);
    }
    randomBytes(l) {
      return this.generate(l);
    }
    /*
     * Helpers
     */
    update(l) {
      if (l == null && (l = Buffer.alloc(0)), r(Buffer.isBuffer(l)), l.length > this.entSize)
        throw new Error("Seed is too long.");
      this.slab.fill(0);
      for (let h = 0; h < this.entSize; h += this.blkSize)
        this.ctr.encrypt(this.slab, h);
      for (let h = 0; h < l.length; h++)
        this.slab[h] ^= l[h];
      return this.ctr.init(this.K, this.V), this;
    }
    serialize(...l) {
      const h = this.entSize;
      let x = 0;
      for (const I of l)
        x += I.length;
      let b = this.blkSize + 4 + 4 + x + 1;
      b % this.blkSize && (b += this.blkSize - b % this.blkSize), r(b % this.blkSize === 0);
      const g = Buffer.alloc(b, 0);
      let w = this.blkSize;
      w = o(g, x, w), w = o(g, h, w);
      for (const I of l)
        w += I.copy(g, w);
      return g[w++] = 128, r(w === this.blkSize + 4 + 4 + x + 1), g;
    }
    derive(...l) {
      const h = this.serialize(...l), x = h.length / this.blkSize, b = Buffer.alloc(this.keySize), g = Math.ceil(this.entSize / this.blkSize), w = Buffer.alloc(g * this.blkSize), I = Buffer.alloc(g * this.blkSize), B = Buffer.alloc(this.blkSize);
      for (let q = 0; q < b.length; q++)
        b[q] = q;
      const y = new e(this.bits).init(b);
      for (let q = 0; q < g; q++) {
        B.fill(0), o(h, q, 0);
        for (let U = 0; U < x; U++) {
          for (let z = 0; z < B.length; z++)
            B[z] ^= h[U * this.blkSize + z];
          y.encrypt(B, 0, B, 0);
        }
        B.copy(w, q * this.blkSize);
      }
      const A = w.slice(0, this.keySize), _ = w.slice(this.keySize, this.entSize);
      y.init(A);
      for (let q = 0; q < g; q++)
        y.encrypt(_, 0, _, 0), _.copy(I, q * this.blkSize);
      return I.slice(0, this.entSize);
    }
  }
  n.native = 0;
  class c {
    constructor(l) {
      this.ctx = new e(l), this.ctr = Buffer.alloc(16);
    }
    init(l, h) {
      return this.ctx.init(l), h.copy(this.ctr, 0), this;
    }
    increment() {
      for (let l = this.ctr.length - 1; l >= 0 && (this.ctr[l] += 1, this.ctr[l] === 0); l--)
        ;
    }
    encrypt(l, h) {
      return this.increment(), this.ctx.encrypt(l, h, this.ctr, 0), this;
    }
  }
  function o(d, l, h) {
    return d[h++] = l >>> 24, d[h++] = l >>> 16, d[h++] = l >>> 8, d[h++] = l, h;
  }
  return fh = n, fh;
}
/*!
 * ctr-drbg.js - ctr-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ch, dx;
function Ym() {
  if (dx)
    return ch;
  dx = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n, c, o, d, l) {
      r(n >>> 0 === n), r(typeof c == "boolean"), this._handle = e.ctr_drbg_create(n, c), o && this.init(o, d, l);
    }
    init(n, c, o) {
      return o == null && (o = e.NULL), r(this instanceof t), r(Buffer.isBuffer(n)), r(c == null || Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), c && (n = Buffer.concat([n, c])), e.ctr_drbg_init(this._handle, n, o), this;
    }
    reseed(n, c) {
      return c == null && (c = e.NULL), r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ctr_drbg_reseed(this._handle, n, c), this;
    }
    generate(n, c) {
      return c == null && (c = e.NULL), r(this instanceof t), r(n >>> 0 === n), r(Buffer.isBuffer(c)), e.ctr_drbg_generate(this._handle, n, c);
    }
    randomBytes(n) {
      return this.generate(n);
    }
  }
  return t.native = 2, ch = t, ch;
}
/*!
 * ctr-drbg.js - ctr-drbg for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Eu.exports = Gm() : Eu.exports = Ym();
var Jm = Eu.exports, Iu = { exports: {} }, sr = {}, Au = { exports: {} };
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */
var oh, ux;
function Xm() {
  if (ux)
    return oh;
  ux = 1;
  const r = _e, e = 281474976710656, t = Buffer.from([0]), i = Buffer.from([1]);
  class n {
    constructor(o, d, l, h) {
      r(o && typeof o.id == "string"), this.hash = o, this.minEntropy = o.id === "SHA1" ? 10 : 24, this.K = Buffer.alloc(o.size), this.V = Buffer.alloc(o.size), this.rounds = 0, d && this.init(d, l, h);
    }
    init(o, d, l) {
      d == null && (d = Buffer.alloc(0)), l == null && (l = Buffer.alloc(0)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l));
      for (let x = 0; x < this.V.length; x++)
        this.K[x] = 0, this.V[x] = 1;
      const h = Buffer.concat([o, d, l]);
      if (h.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(h), this.rounds = 1, this;
    }
    reseed(o, d) {
      if (d == null && (d = Buffer.alloc(0)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      const l = Buffer.concat([o, d]);
      if (l.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.update(l), this.rounds = 1, this;
    }
    generate(o, d) {
      if (r(o >>> 0 === o), r(d == null || Buffer.isBuffer(d)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > e)
        throw new Error("Reseed is required.");
      d && d.length > 0 && this.update(d);
      const l = Math.ceil(o / this.hash.size), h = Buffer.alloc(l * this.hash.size);
      for (let x = 0; x < l; x++)
        this.V = this.mac(this.V), this.V.copy(h, x * this.hash.size);
      return this.update(d), this.rounds += 1, h.slice(0, o);
    }
    randomBytes(o) {
      return this.generate(o);
    }
    /*
     * Helpers
     */
    mac(o) {
      return this.hash.mac(o, this.K);
    }
    hmac() {
      return this.hash.hmac().init(this.K);
    }
    update(o) {
      r(o == null || Buffer.isBuffer(o));
      const d = this.hmac();
      if (d.update(this.V), d.update(t), o && d.update(o), this.K = d.final(), this.V = this.mac(this.V), o && o.length > 0) {
        const l = this.hmac();
        l.update(this.V), l.update(i), l.update(o), this.K = l.final(), this.V = this.mac(this.V);
      }
      return this;
    }
  }
  return n.native = 0, oh = n, oh;
}
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ah, lx;
function Zm() {
  if (lx)
    return ah;
  lx = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n, c, o, d) {
      this._handle = e.hmac_drbg_create(e.hash(n)), c && this.init(c, o, d);
    }
    init(n, c, o) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c == null || Buffer.isBuffer(c)), r(o == null || Buffer.isBuffer(o)), c && o ? n = Buffer.concat([n, c, o]) : c ? n = Buffer.concat([n, c]) : o && (n = Buffer.concat([n, o])), e.hmac_drbg_init(this._handle, n), this;
    }
    reseed(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c == null || Buffer.isBuffer(c)), c && (n = Buffer.concat([n, c])), e.hmac_drbg_reseed(this._handle, n), this;
    }
    generate(n, c) {
      return c == null && (c = e.NULL), r(this instanceof t), r(n >>> 0 === n), r(Buffer.isBuffer(c)), e.hmac_drbg_generate(this._handle, n, c);
    }
    randomBytes(n) {
      return this.generate(n);
    }
  }
  return t.native = 2, ah = t, ah;
}
/*!
 * hmac-drbg.js - hmac-drbg for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Au.exports = Xm() : Au.exports = Zm();
var J1 = Au.exports, _u = { exports: {} };
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */
var hh, xx;
function Eo() {
  if (xx)
    return hh;
  xx = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(8, 0), n = Buffer.alloc(64, 0);
  n[0] = 128;
  const c = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  class o {
    constructor() {
      this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = Buffer.alloc(64), this.size = t;
    }
    init() {
      return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this;
    }
    update(y) {
      return r(Buffer.isBuffer(y)), this._update(y, y.length), this;
    }
    final() {
      return this._final(Buffer.alloc(32));
    }
    _update(y, A) {
      r(this.size !== t, "Context is not initialized.");
      let _ = this.size & 63, q = 0;
      if (this.size += A, _ > 0) {
        let U = 64 - _;
        if (U > A && (U = A), y.copy(this.block, _, q, q + U), _ += U, A -= U, q += U, _ < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; A >= 64; )
        this._transform(y, q), q += 64, A -= 64;
      A > 0 && y.copy(this.block, 0, q, q + A);
    }
    _final(y) {
      r(this.size !== t, "Context is not initialized.");
      const A = this.size & 63, _ = this.size * 8;
      I(i, _ * (1 / 4294967296) >>> 0, 0), I(i, _ >>> 0, 4), this._update(n, 1 + (119 - A & 63)), this._update(i, 8);
      for (let q = 0; q < 8; q++)
        I(y, this.state[q], q * 4), this.state[q] = 0;
      for (let q = 0; q < 64; q++)
        this.msg[q] = 0;
      for (let q = 0; q < 64; q++)
        this.block[q] = 0;
      return this.size = t, y;
    }
    _transform(y, A) {
      const _ = this.msg;
      let q = this.state[0], U = this.state[1], z = this.state[2], E = this.state[3], H = this.state[4], k = this.state[5], V = this.state[6], T = this.state[7], ie = 0;
      for (; ie < 16; ie++)
        _[ie] = w(y, A + ie * 4);
      for (; ie < 64; ie++)
        _[ie] = x(_[ie - 2]) + _[ie - 7] + h(_[ie - 15]) + _[ie - 16];
      for (ie = 0; ie < 64; ie++) {
        const N = T + l(H) + b(H, k, V) + c[ie] + _[ie], G = d(q) + g(q, U, z);
        T = V, V = k, k = H, H = E + N >>> 0, E = z, z = U, U = q, q = N + G >>> 0;
      }
      this.state[0] += q, this.state[1] += U, this.state[2] += z, this.state[3] += E, this.state[4] += H, this.state[5] += k, this.state[6] += V, this.state[7] += T;
    }
    static hash() {
      return new o();
    }
    static hmac() {
      return new e(o, 64);
    }
    static digest(y) {
      return o.ctx.init().update(y).final();
    }
    static root(y, A) {
      return r(Buffer.isBuffer(y) && y.length === 32), r(Buffer.isBuffer(A) && A.length === 32), o.ctx.init().update(y).update(A).final();
    }
    static multi(y, A, _) {
      const { ctx: q } = o;
      return q.init(), q.update(y), q.update(A), _ && q.update(_), q.final();
    }
    static mac(y, A) {
      return o.hmac().init(A).update(y).final();
    }
  }
  o.native = 0, o.id = "SHA256", o.size = 32, o.bits = 256, o.blockSize = 64, o.zero = Buffer.alloc(32, 0), o.ctx = new o();
  function d(B) {
    return (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10);
  }
  function l(B) {
    return (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7);
  }
  function h(B) {
    return (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3;
  }
  function x(B) {
    return (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
  }
  function b(B, y, A) {
    return A ^ B & (y ^ A);
  }
  function g(B, y, A) {
    return B & y | A & (B | y);
  }
  function w(B, y) {
    return B[y++] * 16777216 + B[y++] * 65536 + B[y++] * 256 + B[y];
  }
  function I(B, y, A) {
    return B[A++] = y >>> 24, B[A++] = y >>> 16, B[A++] = y >>> 8, B[A++] = y, A;
  }
  return hh = o, hh;
}
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var dh, bx;
function Wm() {
  if (bx)
    return dh;
  bx = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.SHA256);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.SHA256);
    }
    static digest(c) {
      return r.digest(t.SHA256, c);
    }
    static root(c, o) {
      return r.root(t.SHA256, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.SHA256, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.SHA256, c, o);
    }
  }
  return i.native = 2, i.id = "SHA256", i.size = 32, i.bits = 256, i.blockSize = 64, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), dh = i, dh;
}
/*!
 * sha256.js - sha256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? _u.exports = Eo() : _u.exports = Wm();
var Ti = _u.exports, ff = {};
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */
var px;
function z8() {
  if (px)
    return ff;
  px = 1;
  const r = _e, e = J0, t = B0, i = new Uint8Array([
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53
  ]), n = new e("16294579238595022365", 10), c = 10412 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31, o = 0 | 1 << 37 - 32 | 1 << 41 - 32 | 1 << 43 - 32 | 1 << 47 - 32 | 1 << 53 - 32 | 1 << 59 - 32 | 1 << 61 - 32, d = new e(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37), l = new e(29 * 31 * 41 * 43 * 47 * 53);
  function h(g, w = 20, I = t) {
    if (r(g >>> 0 === g), r(w >>> 0 === w), r(I != null), g < 2)
      throw new Error("Prime must be at least 2 bits.");
    for (; ; ) {
      const B = e.randomBits(I, g);
      B.setn(g - 1, 1), B.setn(g - 2, 1), B.setn(0, 1);
      const y = B.mod(n);
      e:
        for (let A = 0; A < 1 << 20; A += 2) {
          const _ = y.addn(A);
          for (let q = 0; q < i.length; q++) {
            const U = i[q];
            if (_.modrn(U) === 0 && (g > 6 || _.cmpn(U) !== 0))
              continue e;
          }
          B.iaddn(A);
          break;
        }
      if (B.bitLength() === g && x(B, w, I))
        return B;
    }
  }
  function x(g, w, I = t) {
    if (r(g instanceof e), g.sign() <= 0)
      return !1;
    if (g.cmpn(64) < 0) {
      const A = g.word(0);
      return A > 31 ? (o & 1 << A - 32) !== 0 : (c & 1 << A) !== 0;
    }
    if (g.isEven())
      return !1;
    const B = g.mod(d).toNumber(), y = g.mod(l).toNumber();
    return B % 3 === 0 || B % 5 === 0 || B % 7 === 0 || B % 11 === 0 || B % 13 === 0 || B % 17 === 0 || B % 19 === 0 || B % 23 === 0 || B % 37 === 0 || y % 29 === 0 || y % 31 === 0 || y % 41 === 0 || y % 43 === 0 || y % 47 === 0 || y % 53 === 0 ? !1 : g.isPrime(I, w);
  }
  function b(g, w, I) {
    if (!x(g, w, I))
      return !1;
    const B = g.subn(1).iushrn(1);
    return !!x(B, w, I);
  }
  return ff.randomPrime = h, ff.isProbablePrime = x, ff.isSafePrime = b, ff;
}
var A0 = {};
/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var mx;
function X1() {
  if (mx)
    return A0;
  mx = 1;
  const r = M0, e = J0;
  function t(I, B, y) {
    if (r(Buffer.isBuffer(I)), r(B >>> 0 === B), r(typeof y == "boolean"), B >= I.length)
      throw new Error("Invalid size.");
    const A = I[B], _ = A & 127;
    if (B += 1, !(A & 128))
      return [_, B];
    if (y && _ === 0)
      throw new Error("Indefinite length.");
    let q = 0;
    for (let U = 0; U < _; U++) {
      r(B < I.length);
      const z = I[B];
      if (B += 1, q >= 1 << 24)
        throw new Error("Length too large.");
      if (q *= 256, q += z, y && q === 0)
        throw new Error("Unexpected leading zeroes.");
    }
    if (y && q < 128)
      throw new Error("Non-minimal length.");
    return [q, B];
  }
  function i(I, B, y = !0) {
    if (r(Buffer.isBuffer(I)), r(B >>> 0 === B), r(typeof y == "boolean"), B >= I.length || I[B] !== 48)
      throw new Error("Invalid sequence tag.");
    B += 1;
    let A;
    if ([A, B] = t(I, B, y), y && B + A !== I.length)
      throw new Error("Trailing bytes.");
    return B;
  }
  function n(I, B, y = !0) {
    if (r(Buffer.isBuffer(I)), r(B >>> 0 === B), r(typeof y == "boolean"), B >= I.length || I[B] !== 2)
      throw new Error("Invalid integer tag.");
    B += 1;
    let A;
    if ([A, B] = t(I, B, y), B + A > I.length)
      throw new Error("Integer body out of bounds.");
    if (y) {
      if (A === 0)
        throw new Error("Zero length integer.");
      if (I[B] & 128)
        throw new Error("Integers must be positive.");
      if (A > 1 && I[B] === 0 && !(I[B + 1] & 128))
        throw new Error("Unexpected leading zeroes.");
    }
    for (; A > 0 && I[B] === 0; )
      B += 1, A -= 1;
    if (A > 2048)
      throw new Error("Invalid integer size.");
    const _ = e.decode(I.slice(B, B + A));
    return B += A, [_, B];
  }
  function c(I, B, y, A = !0) {
    r(Buffer.isBuffer(I)), r(B >>> 0 === B), r((y & 255) === y), r(typeof A == "boolean");
    let _;
    if ([_, B] = n(I, B, A), _.cmpn(y) !== 0)
      throw new Error("Invalid version.");
    return B;
  }
  function o(I) {
    return r(I >>> 0 === I), I <= 127 ? 1 : I <= 255 ? 2 : (r(I <= 65535), 3);
  }
  function d(I) {
    return 1 + o(I) + I;
  }
  function l(I) {
    r(I instanceof e);
    const B = I.bitLength();
    let y = B + 7 >>> 3;
    return B > 0 && !(B & 7) && (y += I.testn(B - 1)), B === 0 && (y = 1), 1 + o(y) + y;
  }
  function h(I) {
    return r((I & 255) === I), 3;
  }
  function x(I, B, y) {
    return r(Buffer.isBuffer(I)), r(B >>> 0 === B), r(y >>> 0 === y), y <= 127 ? I[B++] = y : y <= 255 ? (I[B++] = 129, I[B++] = y) : (r(y <= 65535), I[B++] = 130, I[B++] = y >> 8, I[B++] = y & 255), r(B <= I.length), B;
  }
  function b(I, B, y) {
    return r(Buffer.isBuffer(I)), r(B >>> 0 === B), I[B++] = 48, x(I, B, y);
  }
  function g(I, B, y) {
    r(Buffer.isBuffer(I)), r(B >>> 0 === B), r(y instanceof e);
    const A = y.bitLength();
    let _ = A + 7 >>> 3, q = 0;
    return A > 0 && !(A & 7) && (q = y.testn(A - 1)), A === 0 && (_ = 1), I[B++] = 2, B = x(I, B, q + _), q && (I[B++] = 0), A !== 0 ? y.encode().copy(I, B) : I[B] = 0, B += _, r(B <= I.length), B;
  }
  function w(I, B, y) {
    return r(Buffer.isBuffer(I)), r(B >>> 0 === B), r((y & 255) === y), r(B + 3 <= I.length), I[B++] = 2, I[B++] = 1, I[B++] = y, B;
  }
  return A0.readSize = t, A0.readSeq = i, A0.readInt = n, A0.readVersion = c, A0.sizeSize = o, A0.sizeSeq = d, A0.sizeInt = l, A0.sizeVersion = h, A0.writeSize = x, A0.writeSeq = b, A0.writeInt = g, A0.writeVersion = w, A0;
}
/*!
 * dsa.js - DSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * References:
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 *
 *   [DSA] Digital Signature Algorithm (wikipedia)
 *     https://en.wikipedia.org/wiki/Digital_Signature_Algorithm
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */
var gx;
function jm() {
  if (gx)
    return sr;
  gx = 1;
  const r = _e, e = J0, t = B0, i = J1, n = Ti, { isProbablePrime: c } = z8(), o = X1(), d = 2048, l = 512, h = 1e4;
  class x {
    constructor() {
      this.p = new e(0), this.q = new e(0), this.g = new e(0);
    }
    bits() {
      return this.p.bitLength();
    }
    size() {
      return this.q.byteLength();
    }
    isSane() {
      if (this.p.sign() < 0 || this.q.sign() < 0)
        return !1;
      const p = this.p.bitLength(), v = this.q.bitLength();
      return !(p < l || p > h || v !== 160 && v !== 224 && v !== 256 || this.g.cmpn(2) < 0 || this.g.cmp(this.p.subn(1)) >= 0 || !this.p.isOdd() || !this.q.isOdd());
    }
    verify() {
      return this.g.powm(this.q, this.p).cmpn(1) === 0;
    }
    generate(p, v) {
      if (r(p >>> 0 === p), r(v >>> 0 === v), !(p === 1024 && v === 160) && !(p === 2048 && v === 224) && !(p === 2048 && v === 256) && !(p === 3072 && v === 256))
        throw new Error("Invalid parameter sizes.");
      if (p < l || p > h || v & 7)
        throw new Error("Invalid parameter sizes.");
      let C = null, K = null;
      e:
        for (; ; )
          if (C = e.randomBits(t, v), C.setn(v - 1, 1), C.setn(0, 1), !!c(C, 64))
            for (let S = 0; S < 4 * p; S++) {
              K = e.randomBits(t, p), K.setn(p - 1, 1), K.setn(0, 1), K.isub(K.mod(C).isubn(1));
              const M = K.bitLength();
              if (!(M < p || M > h) && c(K, 64))
                break e;
            }
      const O = new e(2), u = K.subn(1).div(C);
      for (; ; ) {
        const S = O.powm(u, K);
        if (S.cmpn(1) === 0) {
          O.iaddn(1);
          continue;
        }
        return this.p = K, this.q = C, this.g = S, this;
      }
    }
    toParams() {
      const p = new x();
      return p.p = this.p, p.q = this.q, p.g = this.g, p;
    }
    encode() {
      let p = 0;
      p += o.sizeInt(this.p), p += o.sizeInt(this.q), p += o.sizeInt(this.g);
      const v = Buffer.alloc(o.sizeSeq(p));
      let C = 0;
      return C = o.writeSeq(v, C, p), C = o.writeInt(v, C, this.p), C = o.writeInt(v, C, this.q), C = o.writeInt(v, C, this.g), r(C === v.length), v;
    }
    decode(p) {
      r(Buffer.isBuffer(p));
      let v = 0;
      if (v = o.readSeq(p, v), [this.p, v] = o.readInt(p, v), [this.q, v] = o.readInt(p, v), [this.g, v] = o.readInt(p, v), v !== p.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static generate(p, v) {
      return new x().generate(p, v);
    }
    static decode(p) {
      return new x().decode(p);
    }
  }
  class b extends x {
    constructor() {
      super(), this.y = new e(0);
    }
    isSane() {
      return !(!super.isSane() || this.y.cmpn(2) < 0 || this.y.cmp(this.p.subn(1)) >= 0);
    }
    verify() {
      return super.verify() ? this.y.powm(this.q, this.p).cmpn(1) === 0 : !1;
    }
    encode() {
      let p = 0;
      p += o.sizeInt(this.y), p += o.sizeInt(this.p), p += o.sizeInt(this.q), p += o.sizeInt(this.g);
      const v = Buffer.alloc(o.sizeSeq(p));
      let C = 0;
      return C = o.writeSeq(v, C, p), C = o.writeInt(v, C, this.y), C = o.writeInt(v, C, this.p), C = o.writeInt(v, C, this.q), C = o.writeInt(v, C, this.g), r(C === v.length), v;
    }
    decode(p) {
      r(Buffer.isBuffer(p));
      let v = 0;
      if (v = o.readSeq(p, v), [this.y, v] = o.readInt(p, v), [this.p, v] = o.readInt(p, v), [this.q, v] = o.readInt(p, v), [this.g, v] = o.readInt(p, v), v !== p.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(p) {
      return new b().decode(p);
    }
  }
  class g extends b {
    constructor() {
      super(), this.x = new e(0);
    }
    isSane() {
      return !(!super.isSane() || this.x.sign() <= 0 || this.x.cmp(this.q) >= 0);
    }
    isSaneCompute() {
      const p = new x();
      return p.p = this.p, p.q = this.q, p.g = this.g, !(!p.isSane() || this.x.sign() <= 0 || this.x.cmp(this.q) >= 0);
    }
    verify() {
      if (!super.verify())
        return !1;
      const p = this.g.powm(this.x, this.p);
      return this.y.eq(p);
    }
    toPublic() {
      const p = new b();
      return p.p = this.p, p.q = this.q, p.g = this.g, p.y = this.y, p;
    }
    encode() {
      let p = 0;
      p += o.sizeVersion(0), p += o.sizeInt(this.p), p += o.sizeInt(this.q), p += o.sizeInt(this.g), p += o.sizeInt(this.y), p += o.sizeInt(this.x);
      const v = Buffer.alloc(o.sizeSeq(p));
      let C = 0;
      return C = o.writeSeq(v, C, p), C = o.writeVersion(v, C, 0), C = o.writeInt(v, C, this.p), C = o.writeInt(v, C, this.q), C = o.writeInt(v, C, this.g), C = o.writeInt(v, C, this.y), C = o.writeInt(v, C, this.x), r(C === v.length), v;
    }
    decode(p) {
      r(Buffer.isBuffer(p));
      let v = 0;
      if (v = o.readSeq(p, v), v = o.readVersion(p, v, 0), [this.p, v] = o.readInt(p, v), [this.q, v] = o.readInt(p, v), [this.g, v] = o.readInt(p, v), [this.y, v] = o.readInt(p, v), [this.x, v] = o.readInt(p, v), v !== p.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(p) {
      return new g().decode(p);
    }
  }
  class w {
    constructor() {
      this.r = new e(0), this.s = new e(0);
    }
    encode() {
      const p = o.sizeInt(this.r) + o.sizeInt(this.s), v = Buffer.alloc(o.sizeSeq(p));
      let C = 0;
      return C = o.writeSeq(v, C, p), C = o.writeInt(v, C, this.r), C = o.writeInt(v, C, this.s), r(C === v.length), v;
    }
    decode(p) {
      r(Buffer.isBuffer(p));
      let v = 0;
      if (v = o.readSeq(p, v), [this.r, v] = o.readInt(p, v), [this.s, v] = o.readInt(p, v), v !== p.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    encodeRS(p) {
      return r(p >> 0 === p), Buffer.concat([
        this.r.encode("be", p),
        this.s.encode("be", p)
      ]);
    }
    decodeRS(p, v) {
      return r(Buffer.isBuffer(p)), v == null && (v = p.length >>> 1), r(v >> 0 === v), r(p.length === v * 2), this.r = e.decode(p.slice(0, v)), this.s = e.decode(p.slice(v, v * 2)), this;
    }
    static decode(p) {
      return new w().decode(p);
    }
    static decodeRS(p, v) {
      return new w().decodeRS(p, v);
    }
  }
  function I(a) {
    r(Buffer.isBuffer(a));
    let p;
    try {
      p = g.decode(a);
    } catch {
      p = b.decode(a);
    }
    const v = p.toParams();
    if (!v.isSane())
      throw new Error("Invalid DSA key.");
    return v.encode();
  }
  function B(a) {
    if (a == null && (a = d), r(a >>> 0 === a), a < l || a > h)
      throw new RangeError(`"bits" ranges from ${l} to ${h}.`);
    const p = a, v = a < 2048 ? 160 : 256;
    return x.generate(p, v).encode();
  }
  async function y(a) {
    return B(a);
  }
  function A(a) {
    const p = x.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA params.");
    return p.bits();
  }
  function _(a) {
    const p = x.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA params.");
    return p.q.bitLength();
  }
  function q(a) {
    r(Buffer.isBuffer(a));
    let p;
    try {
      p = x.decode(a);
    } catch {
      return !1;
    }
    return p.isSane() ? p.verify() : !1;
  }
  function U(a) {
    r(a && typeof a == "object");
    const p = new x();
    if (a.p != null && (p.p = e.decode(a.p)), a.q != null && (p.q = e.decode(a.q)), a.g != null && (p.g = e.decode(a.g)), !p.isSane())
      throw new Error("Invalid DSA parameters.");
    return p.encode();
  }
  function z(a) {
    const p = x.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA parameters.");
    return {
      p: p.p.encode(),
      q: p.q.encode(),
      g: p.g.encode()
    };
  }
  function E(a) {
    const p = x.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA parameters.");
    const { p: v, q: C, g: K } = p, O = e.random(t, 1, C), $ = K.powm(O, v), u = new g();
    return u.p = v, u.q = C, u.g = K, u.x = O, u.y = $, u.encode();
  }
  function H(a) {
    const p = B(a);
    return E(p);
  }
  async function k(a) {
    const p = await y(a);
    return E(p);
  }
  function V(a) {
    const p = g.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA private key.");
    return p.bits();
  }
  function T(a) {
    const p = g.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA private key.");
    return p.q.bitLength();
  }
  function ie(a) {
    r(Buffer.isBuffer(a));
    let p;
    try {
      p = g.decode(a);
    } catch {
      return !1;
    }
    return p.isSane() ? p.verify() : !1;
  }
  function N(a) {
    r(a && typeof a == "object");
    const p = new g();
    if (a.p != null && (p.p = e.decode(a.p)), a.q != null && (p.q = e.decode(a.q)), a.g != null && (p.g = e.decode(a.g)), a.y != null && (p.y = e.decode(a.y)), a.x != null && (p.x = e.decode(a.x)), p.y.isZero()) {
      if (!p.isSaneCompute())
        throw new Error("Invalid DSA private key.");
      p.y = p.g.powm(p.x, p.p);
    } else if (!p.isSane())
      throw new Error("Invalid DSA private key.");
    return p.encode();
  }
  function G(a) {
    const p = g.decode(a);
    if (!p.isSane())
      throw new Error("Invalid RSA private key.");
    return {
      p: p.p.encode(),
      q: p.q.encode(),
      g: p.g.encode(),
      y: p.y.encode(),
      x: p.x.encode()
    };
  }
  function F(a) {
    const p = g.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA private key.");
    return p.toPublic().encode();
  }
  function W(a) {
    const p = b.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA public key.");
    return p.bits();
  }
  function ce(a) {
    const p = b.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA public key.");
    return p.q.bitLength();
  }
  function ne(a) {
    let p;
    try {
      p = b.decode(a);
    } catch {
      return !1;
    }
    return p.isSane() ? p.verify() : !1;
  }
  function xe(a) {
    r(a && typeof a == "object");
    const p = new b();
    if (a.p != null && (p.p = e.decode(a.p)), a.q != null && (p.q = e.decode(a.q)), a.g != null && (p.g = e.decode(a.g)), a.y != null && (p.y = e.decode(a.y)), !p.isSane())
      throw new Error("Invalid DSA public key.");
    return p.encode();
  }
  function he(a) {
    const p = b.decode(a);
    if (!p.isSane())
      throw new Error("Invalid DSA public key.");
    return {
      p: p.p.encode(),
      q: p.q.encode(),
      g: p.g.encode(),
      y: p.y.encode()
    };
  }
  function me(a, p) {
    return w.decode(a).encodeRS(p);
  }
  function Ne(a, p) {
    return w.decodeRS(a, p).encode();
  }
  function Je(a, p) {
    const v = g.decode(p);
    return ht(a, v).encodeRS(v.size());
  }
  function Ze(a, p) {
    const v = g.decode(p);
    return ht(a, v).encode();
  }
  function ht(a, p) {
    if (r(Buffer.isBuffer(a)), r(p instanceof g), !p.isSane())
      throw new Error("Invalid DSA private key.");
    const { p: v, q: C, g: K, x: O } = p, $ = C.byteLength(), u = oe(a, C), S = O.encode("be", $), M = u.encode("be", $), Y = new i(n, S, M);
    for (; ; ) {
      const J = L(Y.generate($), C);
      if (J.isZero() || J.cmp(C) >= 0)
        continue;
      const re = s(K, J, v, C).mod(C);
      if (re.isZero())
        continue;
      const ae = e.random(t, 1, C), de = J.mul(ae).fermat(C), ge = O.mul(ae).imod(C), Be = u.mul(ae).imod(C), Oe = re.mul(ge).iadd(Be).imod(C).mul(de).imod(C);
      if (Oe.isZero())
        continue;
      const Ie = new w();
      return Ie.r = re, Ie.s = Oe, Ie;
    }
  }
  function dt(a, p, v) {
    r(Buffer.isBuffer(a)), r(Buffer.isBuffer(p)), r(Buffer.isBuffer(v));
    let C;
    try {
      C = b.decode(v);
    } catch {
      return !1;
    }
    let K;
    try {
      K = w.decodeRS(p, C.size());
    } catch {
      return !1;
    }
    try {
      return we(a, K, C);
    } catch {
      return !1;
    }
  }
  function Se(a, p, v) {
    r(Buffer.isBuffer(a)), r(Buffer.isBuffer(p)), r(Buffer.isBuffer(v));
    let C;
    try {
      C = b.decode(v);
    } catch {
      return !1;
    }
    let K;
    try {
      K = w.decode(p);
    } catch {
      return !1;
    }
    try {
      return we(a, K, C);
    } catch {
      return !1;
    }
  }
  function we(a, p, v) {
    const { r: C, s: K } = p, { p: O, q: $, g: u, y: S } = v;
    if (!v.isSane() || C.isZero() || C.cmp($) >= 0 || K.isZero() || K.cmp($) >= 0)
      return !1;
    const M = oe(a, $), Y = K.invert($), J = M.mul(Y).imod($), X = C.mul(Y).imod($), re = u.powm(J, O), ae = S.powm(X, O);
    return re.mul(ae).imod(O).imod($).eq(C);
  }
  function Z(a, p) {
    const v = b.decode(a), C = g.decode(p);
    if (!v.isSane())
      throw new Error("Invalid DSA public key.");
    if (!C.isSane())
      throw new Error("Invalid DSA private key.");
    const { p: K, q: O, g: $, x: u } = C, { y: S } = v;
    if (!v.p.eq(K) || !v.q.eq(O) || !v.g.eq($))
      throw new Error("Incompatible DSA parameters.");
    if (!v.verify())
      throw new Error("Invalid DSA public key.");
    return s(S, u, K, O).encode("be", K.byteLength());
  }
  function L(a, p) {
    r(Buffer.isBuffer(a)), r(p instanceof e);
    const v = p.bitLength(), C = v + 7 >>> 3;
    a.length > C && (a = a.slice(0, C));
    const K = e.decode(a), O = a.length * 8 - v;
    return O > 0 && K.iushrn(O), K;
  }
  function oe(a, p) {
    return L(a, p).imod(p);
  }
  function s(a, p, v, C) {
    r(a instanceof e), r(p instanceof e), r(v instanceof e), r(C instanceof e);
    const K = a.toRed(e.mont(v)), O = e.random(t, 1, C), $ = p.sub(O).imod(C), u = K.redPow($), S = K.redPow(O);
    return u.redMul(S).fromRed();
  }
  return sr.native = 0, sr.paramsCreate = I, sr.paramsGenerate = B, sr.paramsGenerateAsync = y, sr.paramsBits = A, sr.paramsScalarBits = _, sr.paramsVerify = q, sr.paramsImport = U, sr.paramsExport = z, sr.privateKeyCreate = E, sr.privateKeyGenerate = H, sr.privateKeyGenerateAsync = k, sr.privateKeyBits = V, sr.privateKeyScalarBits = T, sr.privateKeyVerify = ie, sr.privateKeyImport = N, sr.privateKeyExport = G, sr.publicKeyCreate = F, sr.publicKeyBits = W, sr.publicKeyScalarBits = ce, sr.publicKeyVerify = ne, sr.publicKeyImport = xe, sr.publicKeyExport = he, sr.signatureImport = me, sr.signatureExport = Ne, sr.sign = Je, sr.signDER = Ze, sr.verify = dt, sr.verifyDER = Se, sr.derive = Z, sr;
}
var nr = {};
/*!
 * dsa.js - DSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var wx;
function Qm() {
  if (wx)
    return nr;
  wx = 1;
  const r = _e, e = Dt();
  function t(W) {
    return r(Buffer.isBuffer(W)), e.dsa_params_create(W);
  }
  function i(W) {
    if (W == null && (W = 2048), r(W >>> 0 === W), W < 1024 || W > 3072)
      throw new RangeError("`bits` must range between 1024 and 3072.");
    return e.dsa_params_generate(W, e.entropy());
  }
  async function n(W) {
    if (W == null && (W = 2048), r(W >>> 0 === W), W < 1024 || W > 3072)
      throw new RangeError("`bits` must range between 1024 and 3072.");
    return e.dsa_params_generate_async(W, e.entropy());
  }
  function c(W) {
    return r(Buffer.isBuffer(W)), e.dsa_params_bits(W);
  }
  function o(W) {
    return r(Buffer.isBuffer(W)), e.dsa_params_qbits(W);
  }
  function d(W) {
    return r(Buffer.isBuffer(W)), e.dsa_params_verify(W);
  }
  function l(W) {
    r(W && typeof W == "object");
    const ce = e.encode([
      W.p,
      W.q,
      W.g
    ]);
    return e.dsa_params_import(ce);
  }
  function h(W) {
    r(Buffer.isBuffer(W));
    const ce = e.dsa_params_export(W), ne = e.decode(ce, 3);
    return {
      p: ne[0],
      q: ne[1],
      g: ne[2]
    };
  }
  function x(W) {
    return r(Buffer.isBuffer(W)), e.dsa_privkey_create(W, e.entropy());
  }
  function b(W) {
    const ce = i(W);
    return x(ce);
  }
  async function g(W) {
    const ce = await n(W);
    return x(ce);
  }
  function w(W) {
    return r(Buffer.isBuffer(W)), e.dsa_privkey_bits(W);
  }
  function I(W) {
    return r(Buffer.isBuffer(W)), e.dsa_privkey_qbits(W);
  }
  function B(W) {
    return r(Buffer.isBuffer(W)), e.dsa_privkey_verify(W);
  }
  function y(W) {
    r(W && typeof W == "object");
    const ce = e.encode([
      W.p,
      W.q,
      W.g,
      W.y,
      W.x
    ]);
    return e.dsa_privkey_import(ce);
  }
  function A(W) {
    r(Buffer.isBuffer(W));
    const ce = e.dsa_privkey_export(W), ne = e.decode(ce, 5);
    return {
      p: ne[0],
      q: ne[1],
      g: ne[2],
      y: ne[3],
      x: ne[4]
    };
  }
  function _(W) {
    return r(Buffer.isBuffer(W)), e.dsa_pubkey_create(W);
  }
  function q(W) {
    return r(Buffer.isBuffer(W)), e.dsa_pubkey_bits(W);
  }
  function U(W) {
    return r(Buffer.isBuffer(W)), e.dsa_pubkey_qbits(W);
  }
  function z(W) {
    return r(Buffer.isBuffer(W)), e.dsa_pubkey_verify(W);
  }
  function E(W) {
    r(W && typeof W == "object");
    const ce = e.encode([
      W.p,
      W.q,
      W.g,
      W.y
    ]);
    return e.dsa_pubkey_import(ce);
  }
  function H(W) {
    r(Buffer.isBuffer(W));
    const ce = e.dsa_pubkey_export(W), ne = e.decode(ce, 4);
    return {
      p: ne[0],
      q: ne[1],
      g: ne[2],
      y: ne[3]
    };
  }
  function k(W, ce) {
    return ce == null && (ce = 0), r(Buffer.isBuffer(W)), r(ce >>> 0 === ce), e.dsa_signature_import(W, ce);
  }
  function V(W, ce) {
    return ce == null && (ce = 0), r(Buffer.isBuffer(W)), r(ce >>> 0 === ce), e.dsa_signature_export(W, ce);
  }
  function T(W, ce) {
    return r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), e.dsa_sign(W, ce, e.entropy());
  }
  function ie(W, ce) {
    return r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), e.dsa_sign_der(W, ce, e.entropy());
  }
  function N(W, ce, ne) {
    return r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), r(Buffer.isBuffer(ne)), e.dsa_verify(W, ce, ne);
  }
  function G(W, ce, ne) {
    return r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), r(Buffer.isBuffer(ne)), e.dsa_verify_der(W, ce, ne);
  }
  function F(W, ce) {
    return r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), e.dsa_derive(W, ce);
  }
  return nr.native = 2, nr.paramsCreate = t, nr.paramsGenerate = i, nr.paramsGenerateAsync = n, nr.paramsBits = c, nr.paramsScalarBits = o, nr.paramsVerify = d, nr.paramsImport = l, nr.paramsExport = h, nr.privateKeyCreate = x, nr.privateKeyGenerate = b, nr.privateKeyGenerateAsync = g, nr.privateKeyBits = w, nr.privateKeyScalarBits = I, nr.privateKeyVerify = B, nr.privateKeyImport = y, nr.privateKeyExport = A, nr.publicKeyCreate = _, nr.publicKeyBits = q, nr.publicKeyScalarBits = U, nr.publicKeyVerify = z, nr.publicKeyImport = E, nr.publicKeyExport = H, nr.signatureImport = k, nr.signatureExport = V, nr.sign = T, nr.signDER = ie, nr.verify = N, nr.verifyDER = G, nr.derive = F, nr;
}
/*!
 * dsa.js - DSA for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Iu.exports = jm() : Iu.exports = Qm();
var U8 = Iu.exports, Z1 = {}, ti = {};
/*!
 * util.js - encoding utils for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const ei = _e;
function eg(r) {
  ei(Buffer.isBuffer(r));
  let e = 0;
  for (; e < r.length && r[e] === 0; )
    e += 1;
  let t = (r.length - e) * 8;
  if (t === 0)
    return 0;
  t -= 8;
  let i = r[e];
  for (; i; )
    t += 1, i >>>= 1;
  return t;
}
function tg(r) {
  ei(Buffer.isBuffer(r));
  let e = r.length;
  for (; e > 0 && r[e - 1] === 0; )
    e -= 1;
  let t = e * 8;
  if (t === 0)
    return 0;
  t -= 8;
  let i = r[e - 1];
  for (; i; )
    t += 1, i >>>= 1;
  return t;
}
function rg(r, e) {
  ei(Buffer.isBuffer(r)), ei(Buffer.isBuffer(e));
  let t = 0, i = r.length, n = 0, c = e.length;
  for (; i > 0 && r[t] === 0; )
    t += 1, i -= 1;
  for (; c > 0 && e[n] === 0; )
    n += 1, c -= 1;
  if (i < c)
    return -1;
  if (i > c)
    return 1;
  for (let o = 0; o < i; o++) {
    if (r[t + o] < e[n + o])
      return -1;
    if (r[t + o] > e[n + o])
      return 1;
  }
  return 0;
}
function ig(r, e) {
  ei(Buffer.isBuffer(r)), ei(Buffer.isBuffer(e));
  let t = r.length, i = e.length;
  for (; t > 0 && r[t - 1] === 0; )
    t -= 1;
  for (; i > 0 && e[i - 1] === 0; )
    i -= 1;
  if (t < i)
    return -1;
  if (t > i)
    return 1;
  for (let n = t - 1; n >= 0; n--) {
    if (r[n] < e[n])
      return -1;
    if (r[n] > e[n])
      return 1;
  }
  return 0;
}
function C8(r) {
  ei(Buffer.isBuffer(r));
  let e = 0;
  for (; e < r.length && r[e] === 0; )
    e += 1;
  return r.slice(e);
}
function T8(r) {
  ei(Buffer.isBuffer(r));
  let e = r.length;
  for (; e > 0 && r[e - 1] === 0; )
    e -= 1;
  return r.slice(0, e);
}
function sg(r, e) {
  if (ei(Buffer.isBuffer(r)), ei(e >>> 0 === e), r.length > e && (r = C8(r)), r.length > e)
    throw new RangeError(`Buffer expected to be ${e} bytes in size.`);
  const t = Buffer.alloc(e, 0);
  return r.copy(t, e - r.length), t;
}
function ng(r, e) {
  if (ei(Buffer.isBuffer(r)), ei(e >>> 0 === e), r.length > e && (r = T8(r)), r.length > e)
    throw new RangeError(`Buffer expected to be ${e} bytes in size.`);
  const t = Buffer.alloc(e, 0);
  return r.copy(t, 0), t;
}
ti.countLeft = eg;
ti.countRight = tg;
ti.compareLeft = rg;
ti.compareRight = ig;
ti.trimLeft = C8;
ti.trimRight = T8;
ti.padLeft = sg;
ti.padRight = ng;
/*!
 * dsaies.js - dsaies for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme
 *   https://nacl.cr.yp.to/secretbox.html
 */
const Ys = _e, ss = U8, fg = B0, Wc = Lf, { padLeft: cg } = ti;
function og(r, e, t, i = null) {
  if (Ys(r != null), Ys(Buffer.isBuffer(e)), Ys(Buffer.isBuffer(t)), Ys(i == null || Buffer.isBuffer(i)), i == null) {
    const b = ss.paramsCreate(t);
    i = ss.privateKeyCreate(b);
  }
  const n = ss.publicKeyBits(t) + 7 >>> 3, { y: c } = ss.privateKeyExport(i), o = ss.derive(t, i), d = Wc.derive(o, r), l = fg.randomBytes(24), h = cg(c, n), x = Wc.seal(e, d, l);
  return Buffer.concat([h, l, x]);
}
function ag(r, e, t) {
  Ys(r != null), Ys(Buffer.isBuffer(e)), Ys(Buffer.isBuffer(t));
  const i = ss.privateKeyBits(t) + 7 >>> 3;
  if (e.length < i + 24)
    throw new Error("Invalid ciphertext.");
  const { p: n, q: c, g: o } = ss.privateKeyExport(t), d = e.slice(0, i), l = ss.publicKeyImport({ p: n, q: c, g: o, y: d }), h = e.slice(i, i + 24), x = e.slice(i + 24), b = ss.derive(l, t), g = Wc.derive(b, r);
  return Wc.open(x, g, h);
}
Z1.encrypt = og;
Z1.decrypt = ag;
var Mu = { exports: {} }, lc = {};
/*!
 * eb2k.js - EVP_BytesToKey for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on crypto-browserify/EVP_BytesToKey:
 *   Copyright (c) 2017, crypto-browserify contributors
 *   https://github.com/crypto-browserify/EVP_BytesToKey
 *
 * Resources:
 *   https://github.com/openssl/openssl/blob/2e9d61e/crypto/evp/evp_key.c
 *   https://github.com/crypto-browserify/EVP_BytesToKey/blob/master/index.js
 *   https://github.com/openssl/openssl/blob/master/crypto/evp/evp_key.c
 */
var yx;
function hg() {
  if (yx)
    return lc;
  yx = 1;
  const r = _e;
  function e(t, i, n, c, o) {
    if (typeof i == "string" && (i = Buffer.from(i, "utf8")), typeof n == "string" && (n = Buffer.from(n, "utf8")), n == null && (n = Buffer.alloc(0)), o == null && (o = 0), r(t && typeof t.id == "string"), r(Buffer.isBuffer(i)), r(Buffer.isBuffer(n)), r(c >>> 0 === c), r(o >>> 0 === o), n.length > 8 && (n = n.slice(0, 8)), n.length !== 0 && n.length !== 8)
      throw new RangeError("Salt must be at least 8 bytes.");
    const d = Buffer.alloc(c), l = Buffer.alloc(o);
    let h = Buffer.alloc(0), x = 0, b = 0;
    for (; x < c || b < o; ) {
      let g = 0;
      if (h = t.multi(h, i, n), x < c) {
        const w = Math.min(c - x, h.length - g);
        h.copy(d, x, g, g + w), x += w, g += w;
      }
      if (b < o) {
        const w = Math.min(o - b, h.length - g);
        h.copy(l, b, g, g + w), b += w, g += w;
      }
    }
    return [d, l];
  }
  return lc.native = 0, lc.derive = e, lc;
}
var xc = {};
/*!
 * eb2k.js - EVP_BytesToKey for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Sx;
function dg() {
  if (Sx)
    return xc;
  Sx = 1;
  const r = _e, e = Dt();
  function t(i, n, c, o, d) {
    return typeof n == "string" && (n = Buffer.from(n, "utf8")), typeof c == "string" && (c = Buffer.from(c, "utf8")), c == null && (c = e.NULL), d == null && (d = 0), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(d >>> 0 === d), e.eb2k_derive(e.hash(i), n, c, o, d);
  }
  return xc.native = 2, xc.derive = t, xc;
}
/*!
 * eb2k.js - eb2k for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Mu.exports = hg() : Mu.exports = dg();
var D8 = Mu.exports, W1 = {};
/*!
 * ecies.js - ecies for javascript (crypto_secretbox_xsalsa20poly1305)
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme
 *   https://nacl.cr.yp.to/secretbox.html
 */
const Nu = _e, jc = Lf, ug = B0;
function lg(r, e, t, i, n = null) {
  Nu(r && typeof r.id == "string"), n == null && (n = r.privateKeyGenerate());
  const c = r.publicKeyCreate(n), o = r.derive(i, n), d = jc.derive(o, e), l = ug.randomBytes(24), h = jc.seal(t, d, l);
  return Buffer.concat([c, l, h]);
}
function xg(r, e, t, i) {
  Nu(r && typeof r.id == "string"), Nu(Buffer.isBuffer(t));
  const n = r.type === "ecdsa" ? 1 + r.size : r.size;
  if (t.length < n + 24)
    throw new Error("Invalid ciphertext.");
  const c = t.slice(0, n), o = t.slice(n, n + 24), d = t.slice(n + 24), l = r.derive(c, i), h = jc.derive(l, e);
  return jc.open(d, h, o);
}
W1.encrypt = lg;
W1.decrypt = xg;
var Ou = { exports: {} };
/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */
var uh, Bx;
function j1() {
  if (Bx)
    return uh;
  Bx = 1;
  const r = _e, e = J0, t = N8, i = Ti;
  class n {
    constructor(o, d = (l) => l) {
      this.curve = o, this.encode = d, this.hash = new i(), this.chacha = new t(), this.key = Buffer.alloc(32, 0), this.iv = Buffer.alloc(8, 0), this.cache = [new e(1), new e(1)];
    }
    init(o) {
      r(Array.isArray(o)), this.hash.init();
      for (const [d, l, h] of o)
        this.hash.update(i.digest(d)), this.hash.update(l), this.hash.update(this.encode(h));
      return this.key = this.hash.final(), this.cache[0] = new e(1), this.cache[1] = new e(1), this;
    }
    encrypt(o) {
      const d = this.curve.scalarSize * 2, l = Buffer.alloc(d, 0), h = l.slice(0, this.curve.scalarSize), x = l.slice(this.curve.scalarSize);
      return this.chacha.init(this.key, this.iv, o), this.chacha.encrypt(l), [
        this.curve.decodeScalar(h),
        this.curve.decodeScalar(x)
      ];
    }
    refresh(o) {
      let d = 0;
      for (; ; ) {
        this.iv[4] = d, this.iv[5] = d >>> 8, this.iv[6] = d >>> 16, this.iv[7] = d >>> 24, d += 1;
        const [l, h] = this.encrypt(o);
        if (!(l.isZero() || l.cmp(this.curve.n) >= 0) && !(h.isZero() || h.cmp(this.curve.n) >= 0)) {
          this.cache[0] = l, this.cache[1] = h;
          break;
        }
      }
    }
    generate(o) {
      return r(o >>> 0 === o), o & 1 && this.refresh(o >>> 1), this.cache[o & 1];
    }
  }
  return uh = n, uh;
}
/*!
 * eddsa.js - EdDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [EDDSA] High-speed high-security signatures
 *     D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, B. Yang
 *     https://ed25519.cr.yp.to/ed25519-20110926.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 * Implementation Notes:
 *
 *   - In contrast to the ECDSA backend, we allow points at
 *     infinity (in all functions).
 *
 *   - Mike Hamburg's Ed448-Goldilocks rejects both infinity as
 *     well as the torsion point (0, -1). We do not replicate
 *     this behavior.
 *
 *   - For Ed25519, we do "cofactor-less" verification by default.
 *     This means torsion components will affect the result of the
 *     verification.
 *
 *   - For Ed448, we do cofactor verification by default to mimic
 *     OpenSSL and Mike Hamburg's Ed448-Goldilocks implementation.
 *
 *   - `verifySingle`/`verifyBatch` do cofactor verification. Do
 *     not use `verifyBatch` expecting the same results as the
 *     regular `verify` call[1]. This will not be the case for
 *     Ed25519.
 *
 *   - All functions are completely unaware of points of small
 *     order and torsion components (in other words, points will
 *     not be explicitly checked for this, anywhere).
 *
 *   - `deriveWithScalar` and `exchangeWithScalar` automatically
 *     clamp scalars before multiplying (meaning torsion components
 *     are removed from the result and points of small order will
 *     be normalized to infinity).
 *
 *   - The HD function, `publicKeyTweakMul`, _does not_ clamp
 *     automatically. It is possible to end up with a torsion
 *     component in the resulting point (assuming the input
 *     point had one).
 *
 *   - Ed448-Goldilocks is 4-isogenous to Curve448. This means
 *     that when converting to Curve448, small order points will
 *     be normalized to (0, 0). When converting back to Ed448,
 *     any small order points will be normalized to infinity,
 *     and any torsion components will be removed completely.
 *     Also note that when converting back, the implementation
 *     needs to divide the point by 4. This is a major perf hit,
 *     so treat `x448.publicKeyConvert` as if it were a point
 *     multiplication.
 *
 *   - Elligators should not be used with Edwards curves. As
 *     Tibouchi notes[2], regular public keys will map to
 *     _distinguishable_ field elements as they are always in
 *     the primary subgroup. Either the Ristretto Elligator[3],
 *     or a prime order curve with an Elligator Squared[2]
 *     construction are suitable alternatives here.
 *
 *   - These notes also spell out why you should avoid using
 *     Edwards curves on a blockchain[4].
 *
 *   [1] https://moderncrypto.org/mail-archive/curves/2016/000836.html
 *   [2] https://eprint.iacr.org/2014/043.pdf
 *   [3] https://ristretto.group/formulas/elligator.html
 *   [4] https://src.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html
 */
var lh, vx;
function L8() {
  if (vx)
    return lh;
  vx = 1;
  const r = _e, e = j1(), t = J0, i = So(), n = B0;
  class c {
    constructor(h, x, b, g, w) {
      r(typeof h == "string"), r(!x || typeof x == "string"), r(!b || typeof b == "string"), r(g), this.id = h, this.type = "eddsa", this.mid = x || null, this.eid = b || null, this.hash = g, this.native = 0, this._pre = w || null, this._curve = null, this._mont = null, this._iso = null, this._rng = null;
    }
    get curve() {
      return this._curve || (this._curve = i.curve(this.id, this._pre), this._curve.precompute(n), this._pre = null), this._curve;
    }
    get mont() {
      return this.mid && !this._mont && (this._mont = i.curve(this.mid)), this._mont;
    }
    get iso() {
      return this.eid ? (this._iso || (this._iso = i.curve(this.eid)), this._iso) : this.mont;
    }
    get rng() {
      return this._rng || (this._rng = new e(this.curve)), this._rng;
    }
    get size() {
      return this.curve.adjustedSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    hashNonce(h, x, b, g) {
      const w = new o(this);
      return w.init(b, g), w.update(h), w.update(x), w.final();
    }
    hashChallenge(h, x, b, g, w) {
      const I = new o(this);
      return I.init(g, w), I.update(h), I.update(x), I.update(b), I.final();
    }
    privateKeyGenerate() {
      return n.randomBytes(this.curve.adjustedSize);
    }
    scalarGenerate() {
      const h = n.randomBytes(this.curve.scalarSize);
      return this.curve.clamp(h);
    }
    privateKeyExpand(h) {
      r(Buffer.isBuffer(h)), r(h.length === this.curve.adjustedSize);
      const x = this.hash.digest(h, this.curve.adjustedSize * 2);
      return this.curve.splitHash(x);
    }
    privateKeyConvert(h) {
      const [x] = this.privateKeyExpand(h);
      return x;
    }
    privateKeyVerify(h) {
      return r(Buffer.isBuffer(h)), h.length === this.curve.adjustedSize;
    }
    scalarVerify(h) {
      return r(Buffer.isBuffer(h)), h.length === this.curve.scalarSize;
    }
    scalarIsZero(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        x = this.curve.decodeScalar(h).imod(this.curve.n);
      } catch {
        return !1;
      }
      return x.isZero();
    }
    scalarClamp(h) {
      return r(Buffer.isBuffer(h)), r(h.length === this.curve.scalarSize), this.curve.clamp(Buffer.from(h));
    }
    privateKeyExport(h) {
      const x = this.publicKeyCreate(h), { x: b, y: g } = this.publicKeyExport(x);
      return {
        d: Buffer.from(h),
        x: b,
        y: g
      };
    }
    privateKeyImport(h) {
      if (r(h && typeof h == "object"), r(Buffer.isBuffer(h.d)), h.d.length !== this.curve.adjustedSize)
        throw new Error("Invalid private key.");
      return Buffer.from(h.d);
    }
    scalarTweakAdd(h, x) {
      const b = this.curve.decodeScalar(h), g = this.curve.decodeScalar(x), w = b.add(g).imod(this.curve.n);
      return this.curve.encodeScalar(w);
    }
    scalarTweakMul(h, x) {
      const b = this.curve.decodeScalar(h), g = this.curve.decodeScalar(x), w = b.mul(g).imod(this.curve.n);
      return this.curve.encodeScalar(w);
    }
    scalarReduce(h) {
      const b = this.curve.decodeScalar(h).imod(this.curve.n);
      return this.curve.encodeScalar(b);
    }
    scalarNegate(h) {
      const b = this.curve.decodeScalar(h).imod(this.curve.n).neg().imod(this.curve.n);
      return this.curve.encodeScalar(b);
    }
    scalarInvert(h) {
      const x = this.curve.decodeScalar(h).imod(this.curve.n);
      if (x.isZero())
        return this.curve.encodeScalar(x);
      const b = x.invert(this.curve.n);
      return this.curve.encodeScalar(b);
    }
    publicKeyCreate(h) {
      const x = this.privateKeyConvert(h);
      return this.publicKeyFromScalar(x);
    }
    publicKeyFromScalar(h) {
      const x = this.curve.decodeScalar(h).imod(this.curve.n);
      return this.curve.g.mulBlind(x).encode();
    }
    publicKeyConvert(h) {
      if (!this.mont)
        throw new Error("No equivalent montgomery curve.");
      const x = this.curve.decodePoint(h);
      return this.mont.pointFromEdwards(x).encode();
    }
    publicKeyFromUniform(h) {
      const x = this.curve.decodeUniform(h);
      return this.curve.pointFromUniform(x, this.iso).encode();
    }
    publicKeyToUniform(h, x = n.randomInt()) {
      const b = this.curve.decodePoint(h), g = this.curve.pointToUniform(b, x, this.iso);
      return this.curve.encodeUniform(g, x >>> 8);
    }
    publicKeyFromHash(h, x = !1) {
      return this.curve.pointFromHash(h, x, this.iso).encode();
    }
    publicKeyToHash(h, x = n.randomInt()) {
      const b = this.curve.decodePoint(h);
      return this.curve.pointToHash(b, x, n, this.iso);
    }
    publicKeyVerify(h) {
      r(Buffer.isBuffer(h));
      try {
        this.curve.decodePoint(h);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyIsInfinity(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        x = this.curve.decodePoint(h);
      } catch {
        return !1;
      }
      return x.isInfinity();
    }
    publicKeyIsSmall(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        x = this.curve.decodePoint(h);
      } catch {
        return !1;
      }
      return x.isSmall();
    }
    publicKeyHasTorsion(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        x = this.curve.decodePoint(h);
      } catch {
        return !1;
      }
      return x.hasTorsion();
    }
    publicKeyExport(h) {
      const { x, y: b } = this.curve.decodePoint(h);
      return {
        x: this.curve.encodeField(x.fromRed()),
        y: this.curve.encodeField(b.fromRed())
      };
    }
    publicKeyImport(h) {
      r(h && typeof h == "object");
      let x = null, b = null, g;
      if (h.x != null && (x = t.decode(h.x, this.curve.endian), x.cmp(this.curve.p) >= 0))
        throw new Error("Invalid point.");
      if (h.y != null && (b = t.decode(h.y, this.curve.endian), b.cmp(this.curve.p) >= 0))
        throw new Error("Invalid point.");
      if (x && b) {
        if (g = this.curve.point(x, b), !g.validate())
          throw new Error("Invalid point.");
      } else if (x)
        g = this.curve.pointFromX(x, h.sign);
      else if (b)
        g = this.curve.pointFromY(b, h.sign);
      else
        throw new Error("Invalid point.");
      return g.encode();
    }
    publicKeyTweakAdd(h, x) {
      const b = this.curve.decodeScalar(x).imod(this.curve.n), g = this.curve.decodePoint(h);
      return this.curve.g.mul(b).add(g).encode();
    }
    publicKeyTweakMul(h, x) {
      const b = this.curve.decodeScalar(x);
      return this.curve.decodePoint(h).mul(b).encode();
    }
    publicKeyCombine(h) {
      r(Array.isArray(h));
      let x = this.curve.point();
      for (const b of h) {
        const g = this.curve.decodePoint(b);
        x = x.add(g);
      }
      return x.encode();
    }
    publicKeyNegate(h) {
      return this.curve.decodePoint(h).neg().encode();
    }
    sign(h, x, b, g) {
      const [w, I] = this.privateKeyExpand(x);
      return this.signWithScalar(h, w, I, b, g);
    }
    signWithScalar(h, x, b, g, w) {
      w == null && (w = Buffer.alloc(0)), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(b)), r(b.length === this.curve.adjustedSize);
      const { n: I } = this.curve, B = this.curve.g, y = this.hashNonce(b, h, g, w), A = B.mulBlind(y).encode(), _ = this.curve.decodeScalar(x), q = B.mulBlind(_).encode(), U = this.hashChallenge(A, q, h, g, w), z = y.add(U.mul(_)).imod(I);
      return Buffer.concat([A, this.curve.encodeAdjusted(z)]);
    }
    signTweakAdd(h, x, b, g, w) {
      const [I, B] = this.privateKeyExpand(x), y = this.scalarTweakAdd(I, b), _ = this.hash.multi(B, b, null, this.curve.adjustedSize * 2).slice(0, this.curve.adjustedSize);
      return this.signWithScalar(h, y, _, g, w);
    }
    signTweakMul(h, x, b, g, w) {
      const [I, B] = this.privateKeyExpand(x), y = this.scalarTweakMul(I, b), _ = this.hash.multi(B, b, null, this.curve.adjustedSize * 2).slice(0, this.curve.adjustedSize);
      return this.signWithScalar(h, y, _, g, w);
    }
    verify(h, x, b, g, w) {
      if (w == null && (w = Buffer.alloc(0)), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(Buffer.isBuffer(b)), r(g == null || typeof g == "boolean"), r(Buffer.isBuffer(w)), x.length !== this.curve.adjustedSize * 2 || b.length !== this.curve.adjustedSize)
        return !1;
      try {
        return this._verify(h, x, b, g, w);
      } catch {
        return !1;
      }
    }
    _verify(h, x, b, g, w) {
      const { n: I } = this.curve, B = this.curve.g, y = x.slice(0, this.curve.adjustedSize), A = x.slice(this.curve.adjustedSize), _ = this.curve.decodePoint(y), q = this.curve.decodeAdjusted(A), U = this.curve.decodePoint(b);
      if (q.cmp(I) >= 0)
        return !1;
      const z = this.hashChallenge(y, b, h, g, w);
      return B.mulAdd(q, U.neg(), z).eq(_);
    }
    verifySingle(h, x, b, g, w) {
      if (w == null && (w = Buffer.alloc(0)), r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(Buffer.isBuffer(b)), r(g == null || typeof g == "boolean"), r(Buffer.isBuffer(w)), x.length !== this.curve.adjustedSize * 2 || b.length !== this.curve.adjustedSize)
        return !1;
      try {
        return this._verifySingle(h, x, b, g, w);
      } catch {
        return !1;
      }
    }
    _verifySingle(h, x, b, g, w) {
      const { n: I } = this.curve, B = this.curve.g, y = x.slice(0, this.curve.adjustedSize), A = x.slice(this.curve.adjustedSize), _ = this.curve.decodePoint(y), q = this.curve.decodeAdjusted(A), U = this.curve.decodePoint(b);
      if (q.cmp(I) >= 0)
        return !1;
      const z = this.hashChallenge(y, b, h, g, w), E = this.curve.imulH(q), H = U.mulH(), k = _.mulH();
      return B.mulAdd(E, H.neg(), z).eq(k);
    }
    verifyBatch(h, x, b) {
      b == null && (b = Buffer.alloc(0)), r(Array.isArray(h)), r(x == null || typeof x == "boolean"), r(Buffer.isBuffer(b));
      for (const g of h) {
        r(Array.isArray(g) && g.length === 3);
        const [w, I, B] = g;
        if (r(Buffer.isBuffer(w)), r(Buffer.isBuffer(I)), r(Buffer.isBuffer(B)), I.length !== this.curve.adjustedSize * 2 || B.length !== this.curve.adjustedSize)
          return !1;
      }
      try {
        return this._verifyBatch(h, x, b);
      } catch {
        return !1;
      }
    }
    _verifyBatch(h, x, b) {
      const { n: g } = this.curve, w = this.curve.g, I = new Array(1 + h.length * 2), B = new Array(1 + h.length * 2), y = new t(0);
      this.rng.init(h), I[0] = w, B[0] = y;
      for (let A = 0; A < h.length; A++) {
        const [_, q, U] = h[A], z = q.slice(0, this.curve.adjustedSize), E = q.slice(this.curve.adjustedSize), H = this.curve.decodePoint(z), k = this.curve.decodeAdjusted(E), V = this.curve.decodePoint(U);
        if (k.cmp(g) >= 0)
          return !1;
        const T = this.hashChallenge(z, U, _, x, b), ie = this.rng.generate(A), N = T.mul(ie).imod(g);
        y.iadd(k.mul(ie)).imod(g), I[1 + A * 2 + 0] = H.mulH(), B[1 + A * 2 + 0] = ie, I[1 + A * 2 + 1] = V.mulH(), B[1 + A * 2 + 1] = N;
      }
      return this.curve.imulH(y.ineg()), this.curve.mulAll(I, B).isInfinity();
    }
    derive(h, x) {
      const b = this.privateKeyConvert(x);
      return this.deriveWithScalar(h, b);
    }
    deriveWithScalar(h, x) {
      const b = this.curve.decodePoint(h), g = this.curve.decodeClamped(x), w = b.mulBlind(g, n);
      if (w.isInfinity())
        throw new Error("Invalid point.");
      return w.encode();
    }
  }
  class o {
    constructor(h) {
      this.curve = h.curve, this.hash = new h.hash();
    }
    init(h, x) {
      return r(h == null || typeof h == "boolean"), r(Buffer.isBuffer(x)), x.length > 255 && (x = x.slice(0, 255)), this.hash.init(), (this.curve.context || h != null || x.length > 0) && (this.curve.prefix && this.hash.update(this.curve.prefix), this.hash.update(d(h)), this.hash.update(d(x.length)), this.hash.update(x)), this;
    }
    update(h) {
      return this.hash.update(h), this;
    }
    final() {
      const h = this.hash.final(this.curve.adjustedSize * 2);
      return t.decode(h, this.curve.endian).imod(this.curve.n);
    }
  }
  function d(l) {
    const h = Buffer.alloc(1);
    return h[0] = l & 255, h;
  }
  return lh = c, lh;
}
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/EdDSA#Ed25519
 *   https://ed25519.cr.yp.to/ed25519-20110926.pdf
 *   https://tools.ietf.org/html/rfc8032#section-5.1
 */
var xh, Ex;
function bg() {
  if (Ex)
    return xh;
  Ex = 1;
  const r = L8(), e = Cf, t = A8;
  return xh = new r("ED25519", "X25519", null, e, t), xh;
}
/*!
 * eddsa.js - EdDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var bh, Ix;
function K8() {
  if (Ix)
    return bh;
  Ix = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n) {
      r(e.curves.edwards[n] != null), this.id = n, this.type = "eddsa", this.native = 2, this._ctx = null;
    }
    get _handle() {
      return this._ctx || (this._ctx = e.curve("edwards", this.id)), this._ctx;
    }
    get size() {
      return r(this instanceof t), e.eddsa_pubkey_size(this._handle);
    }
    get bits() {
      return r(this instanceof t), e.edwards_curve_field_bits(this._handle);
    }
    privateKeyGenerate() {
      return r(this instanceof t), e.eddsa_privkey_generate(this._handle, e.entropy());
    }
    scalarGenerate() {
      return r(this instanceof t), e.eddsa_scalar_generate(this._handle, e.entropy());
    }
    privateKeyExpand(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_privkey_expand(this._handle, n);
    }
    privateKeyConvert(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_privkey_convert(this._handle, n);
    }
    privateKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_privkey_verify(this._handle, n);
    }
    scalarVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_scalar_verify(this._handle, n);
    }
    scalarIsZero(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_scalar_is_zero(this._handle, n);
    }
    scalarClamp(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_scalar_clamp(this._handle, n);
    }
    privateKeyExport(n) {
      r(this instanceof t), r(Buffer.isBuffer(n));
      const c = e.eddsa_pubkey_create(this._handle, n), [o, d] = e.eddsa_pubkey_export(this._handle, c);
      return {
        d: e.copy(n),
        x: o,
        y: d
      };
    }
    privateKeyImport(n) {
      return r(this instanceof t), r(n && typeof n == "object"), r(Buffer.isBuffer(n.d)), e.eddsa_privkey_import(this._handle, n.d);
    }
    scalarTweakAdd(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.eddsa_scalar_tweak_add(this._handle, n, c);
    }
    scalarTweakMul(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.eddsa_scalar_tweak_mul(this._handle, n, c);
    }
    scalarReduce(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_scalar_reduce(this._handle, n);
    }
    scalarNegate(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_scalar_negate(this._handle, n);
    }
    scalarInvert(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_scalar_invert(this._handle, n);
    }
    publicKeyCreate(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_create(this._handle, n);
    }
    publicKeyFromScalar(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_from_scalar(this._handle, n);
    }
    publicKeyConvert(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_convert(this._handle, n);
    }
    publicKeyFromUniform(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_from_uniform(this._handle, n);
    }
    publicKeyToUniform(n, c = e.hint()) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c >>> 0 === c), e.eddsa_pubkey_to_uniform(this._handle, n, c);
    }
    publicKeyFromHash(n, c = !1) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.eddsa_pubkey_from_hash(this._handle, n, c);
    }
    publicKeyToHash(n, c = e.hint()) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c >>> 0 === c), e.eddsa_pubkey_to_hash(this._handle, n, c, e.entropy());
    }
    publicKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_verify(this._handle, n);
    }
    publicKeyIsInfinity(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_is_infinity(this._handle, n);
    }
    publicKeyIsSmall(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_is_small(this._handle, n);
    }
    publicKeyHasTorsion(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_has_torsion(this._handle, n);
    }
    publicKeyExport(n) {
      r(this instanceof t), r(Buffer.isBuffer(n));
      const [c, o] = e.eddsa_pubkey_export(this._handle, n);
      return { x: c, y: o };
    }
    publicKeyImport(n) {
      r(this instanceof t), r(n && typeof n == "object");
      let { x: c, y: o, sign: d } = n;
      return c == null && (c = e.NULL), o == null && (o = e.NULL), d = e.ternary(d), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.eddsa_pubkey_import(this._handle, c, o, d);
    }
    publicKeyTweakAdd(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.eddsa_pubkey_tweak_add(this._handle, n, c);
    }
    publicKeyTweakMul(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.eddsa_pubkey_tweak_mul(this._handle, n, c);
    }
    publicKeyCombine(n) {
      r(this instanceof t), r(Array.isArray(n));
      for (const c of n)
        r(Buffer.isBuffer(c));
      return e.eddsa_pubkey_combine(this._handle, n);
    }
    publicKeyNegate(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.eddsa_pubkey_negate(this._handle, n);
    }
    sign(n, c, o, d) {
      return r(this instanceof t), o = e.ternary(o), d == null && (d = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(d)), e.eddsa_sign(this._handle, n, c, o, d);
    }
    signWithScalar(n, c, o, d, l) {
      return r(this instanceof t), d = e.ternary(d), l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(l)), e.eddsa_sign_with_scalar(this._handle, n, c, o, d, l);
    }
    signTweakAdd(n, c, o, d, l) {
      return r(this instanceof t), d = e.ternary(d), l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(l)), e.eddsa_sign_tweak_add(this._handle, n, c, o, d, l);
    }
    signTweakMul(n, c, o, d, l) {
      return r(this instanceof t), d = e.ternary(d), l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(l)), e.eddsa_sign_tweak_mul(this._handle, n, c, o, d, l);
    }
    verify(n, c, o, d, l) {
      return r(this instanceof t), d = e.ternary(d), l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(l)), e.eddsa_verify(this._handle, n, c, o, d, l);
    }
    verifySingle(n, c, o, d, l) {
      return r(this instanceof t), d = e.ternary(d), l == null && (l = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(l)), e.eddsa_verify_single(this._handle, n, c, o, d, l);
    }
    verifyBatch(n, c, o) {
      r(this instanceof t), c = e.ternary(c), o == null && (o = e.NULL), r(Array.isArray(n)), r(Buffer.isBuffer(o));
      for (const d of n)
        r(Array.isArray(d)), r(d.length === 3), r(Buffer.isBuffer(d[0])), r(Buffer.isBuffer(d[1])), r(Buffer.isBuffer(d[2]));
      return e.eddsa_verify_batch(this._handle, n, c, o);
    }
    derive(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.eddsa_derive(this._handle, n, c);
    }
    deriveWithScalar(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.eddsa_derive_with_scalar(this._handle, n, c);
    }
  }
  return bh = t, bh;
}
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ph, Ax;
function pg() {
  if (Ax)
    return ph;
  Ax = 1;
  const r = K8();
  return ph = new r("ED25519"), ph;
}
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Ou.exports = bg() : Ou.exports = pg();
var $8 = Ou.exports, Pu = { exports: {} };
/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */
const H8 = fn;
let as = class F8 extends H8 {
  /**
   * Create a SHAKE Context.
   * @constructor
   */
  constructor() {
    super();
  }
  final(e) {
    return super.final(31, e);
  }
  static hash() {
    return new F8();
  }
  static hmac(e, t) {
    return super.hmac(e, 31, t);
  }
  static digest(e, t, i) {
    return super.digest(e, t, 31, i);
  }
  static root(e, t, i, n) {
    return super.root(e, t, i, 31, n);
  }
  static multi(e, t, i, n, c) {
    return super.multi(e, t, i, n, 31, c);
  }
  static mac(e, t, i, n) {
    return super.mac(e, t, i, 31, n);
  }
};
as.native = H8.native;
as.id = "SHAKE256";
as.size = 32;
as.bits = 256;
as.blockSize = 136;
as.zero = Buffer.alloc(32, 0);
as.ctx = new as();
var Q1 = as;
/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const V8 = Q1;
class pi extends V8 {
  constructor() {
    super();
  }
  init() {
    return super.init(256);
  }
  static hash() {
    return new pi();
  }
  static hmac(e) {
    return super.hmac(256, e);
  }
  static digest(e, t) {
    return super.digest(e, 256, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 256, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 256, n);
  }
  static mac(e, t, i) {
    return super.mac(e, t, 256, i);
  }
}
pi.native = V8.native;
pi.id = "SHAKE256";
pi.size = 32;
pi.bits = 256;
pi.blockSize = 136;
pi.zero = Buffer.alloc(32, 0);
pi.ctx = new pi();
var Io = pi;
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://eprint.iacr.org/2015/625.pdf
 *   https://tools.ietf.org/html/rfc8032#section-5.2
 */
var mh, _x;
function mg() {
  if (_x)
    return mh;
  _x = 1;
  const r = L8(), e = Io;
  return mh = new r("ED448", "X448", "MONT448", e), mh;
}
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var gh, Mx;
function gg() {
  if (Mx)
    return gh;
  Mx = 1;
  const r = K8();
  return gh = new r("ED448"), gh;
}
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Pu.exports = mg() : Pu.exports = gg();
var wg = Pu.exports, Dr = {}, ut = {}, Pe = {}, el = {};
el.custom = "inspect";
var Ue = {};
/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
function G8(r, e, t) {
  if (!r) {
    const i = new TypeError(`'${e}' must be a(n) ${t}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(i, G8), i;
  }
}
var Tn = G8;
/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
let yg = class Y8 extends Error {
  /**
   * Create an encoding error.
   * @constructor
   * @param {Number} offset
   * @param {String} reason
   */
  constructor(e, t, i) {
    super(), this.type = "EncodingError", this.name = "EncodingError", this.code = "ERR_ENCODING", this.message = `${t} (offset=${e}).`, Error.captureStackTrace && Error.captureStackTrace(this, i || Y8);
  }
};
var Kf = yg;
/*!
 * encoding.js - encoding utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const gt = Tn, v0 = Kf, Dn = 1 / 4294967296, { MAX_SAFE_INTEGER: Sg } = Number, Ln = new Float32Array(1), Qr = new Uint8Array(Ln.buffer), $f = new Float64Array(1), cr = new Uint8Array($f.buffer);
Ln[0] = -1;
const As = Qr[3] === 0;
function Bg(r, e, t) {
  switch (t) {
    case 8:
      return tl(r, e);
    case 7:
      return J8(r, e);
    case 6:
      return X8(r, e);
    case 5:
      return Z8(r, e);
    case 4:
      return vs(r, e);
    case 3:
      return rl(r, e);
    case 2:
      return il(r, e);
    case 1:
      return sl(r, e);
    default:
      throw new v0(e, "Invalid read length");
  }
}
function tl(r, e) {
  const t = vs(r, e + 4), i = vs(r, e);
  return N0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function J8(r, e) {
  const t = rl(r, e + 4), i = vs(r, e);
  return N0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function X8(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e++] * 16777216 + r[e++] * 4294967296 + r[e] * 1099511627776;
}
function Z8(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e++] * 16777216 + r[e] * 4294967296;
}
function vs(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216;
}
function rl(r, e) {
  return r[e++] + r[e++] * 256 + r[e] * 65536;
}
function il(r, e) {
  return r[e++] + r[e] * 256;
}
function sl(r, e) {
  return r[e];
}
function vg(r, e, t) {
  switch (t) {
    case 8:
      return W8(r, e);
    case 7:
      return j8(r, e);
    case 6:
      return Q8(r, e);
    case 5:
      return e5(r, e);
    case 4:
      return rn(r, e);
    case 3:
      return nl(r, e);
    case 2:
      return t5(r, e);
    case 1:
      return sl(r, e);
    default:
      throw new v0(e, "Invalid read length");
  }
}
function W8(r, e) {
  const t = rn(r, e), i = rn(r, e + 4);
  return N0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function j8(r, e) {
  const t = nl(r, e), i = rn(r, e + 3);
  return N0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function Q8(r, e) {
  return r[e++] * 1099511627776 + r[e++] * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function e5(r, e) {
  return r[e++] * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function rn(r, e) {
  return r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function nl(r, e) {
  return r[e++] * 65536 + r[e++] * 256 + r[e];
}
function t5(r, e) {
  return r[e++] * 256 + r[e];
}
function Eg(r, e, t) {
  switch (t) {
    case 8:
      return r5(r, e);
    case 7:
      return i5(r, e);
    case 6:
      return s5(r, e);
    case 5:
      return n5(r, e);
    case 4:
      return fl(r, e);
    case 3:
      return cl(r, e);
    case 2:
      return f5(r, e);
    case 1:
      return ol(r, e);
    default:
      throw new v0(e, "Invalid read length");
  }
}
function r5(r, e) {
  const t = fl(r, e + 4), i = vs(r, e);
  return N0(To(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function i5(r, e) {
  const t = cl(r, e + 4), i = vs(r, e);
  return N0(To(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function s5(r, e) {
  const t = r[e + 4] + r[e + 5] * 256;
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216 + (t | (t & 32768) * 131070) * 4294967296;
}
function n5(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e++] * 16777216 + (r[e] | (r[e] & 128) * 33554430) * 4294967296;
}
function fl(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + (r[e] << 24);
}
function cl(r, e) {
  const t = r[e++] + r[e++] * 256 + r[e] * 65536;
  return t | (t & 8388608) * 510;
}
function f5(r, e) {
  const t = r[e++] + r[e] * 256;
  return t | (t & 32768) * 131070;
}
function ol(r, e) {
  const t = r[e];
  return t | (t & 128) * 33554430;
}
function Ig(r, e, t) {
  switch (t) {
    case 8:
      return c5(r, e);
    case 7:
      return o5(r, e);
    case 6:
      return a5(r, e);
    case 5:
      return h5(r, e);
    case 4:
      return al(r, e);
    case 3:
      return hl(r, e);
    case 2:
      return d5(r, e);
    case 1:
      return ol(r, e);
    default:
      throw new v0(e, "Invalid read length");
  }
}
function c5(r, e) {
  const t = al(r, e), i = rn(r, e + 4);
  return N0(To(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function o5(r, e) {
  const t = hl(r, e), i = rn(r, e + 3);
  return N0(To(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function a5(r, e) {
  const t = r[e++] * 256 + r[e++];
  return (t | (t & 32768) * 131070) * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function h5(r, e) {
  const t = r[e++];
  return (t | (t & 128) * 33554430) * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function al(r, e) {
  return (r[e++] << 24) + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function hl(r, e) {
  const t = r[e++] * 65536 + r[e++] * 256 + r[e];
  return t | (t & 8388608) * 510;
}
function d5(r, e) {
  const t = r[e++] * 256 + r[e];
  return t | (t & 32768) * 131070;
}
function u5(r, e) {
  return Qr[3] = r[e++], Qr[2] = r[e++], Qr[1] = r[e++], Qr[0] = r[e], Ln[0];
}
function l5(r, e) {
  return Qr[0] = r[e++], Qr[1] = r[e++], Qr[2] = r[e++], Qr[3] = r[e], Ln[0];
}
function x5(r, e) {
  return cr[7] = r[e++], cr[6] = r[e++], cr[5] = r[e++], cr[4] = r[e++], cr[3] = r[e++], cr[2] = r[e++], cr[1] = r[e++], cr[0] = r[e], $f[0];
}
function b5(r, e) {
  return cr[0] = r[e++], cr[1] = r[e++], cr[2] = r[e++], cr[3] = r[e++], cr[4] = r[e++], cr[5] = r[e++], cr[6] = r[e++], cr[7] = r[e], $f[0];
}
const Ag = As ? u5 : l5, _g = As ? l5 : u5, Mg = As ? x5 : b5, Ng = As ? b5 : x5;
function Og(r, e, t, i) {
  switch (i) {
    case 8:
      return Hf(r, e, t);
    case 7:
      return Ao(r, e, t);
    case 6:
      return _o(r, e, t);
    case 5:
      return Mo(r, e, t);
    case 4:
      return Ff(r, e, t);
    case 3:
      return No(r, e, t);
    case 2:
      return Vf(r, e, t);
    case 1:
      return Kn(r, e, t);
    default:
      throw new v0(t, "Invalid write length");
  }
}
function Hf(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), v5(r, e, t, !1);
}
function Ao(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), E5(r, e, t, !1);
}
function _o(r, e, t) {
  gt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Dn | 0;
  return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, r[t++] = i, r[t++] = i >>> 8, t;
}
function Mo(r, e, t) {
  gt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Dn | 0;
  return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, r[t++] = i, t;
}
function Ff(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t;
}
function No(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t;
}
function Vf(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e, r[t++] = e >>> 8, t;
}
function Kn(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t] = e, t + 1;
}
function Pg(r, e, t, i) {
  switch (i) {
    case 8:
      return Oo(r, e, t);
    case 7:
      return Po(r, e, t);
    case 6:
      return Ro(r, e, t);
    case 5:
      return ko(r, e, t);
    case 4:
      return qo(r, e, t);
    case 3:
      return zo(r, e, t);
    case 2:
      return Uo(r, e, t);
    case 1:
      return Kn(r, e, t);
    default:
      throw new v0(t, "Invalid write length");
  }
}
function Oo(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), v5(r, e, t, !0);
}
function Po(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), E5(r, e, t, !0);
}
function Ro(r, e, t) {
  gt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Dn | 0;
  return r[t++] = i >>> 8, r[t++] = i, r[t + 3] = e, e >>>= 8, r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 4;
}
function ko(r, e, t) {
  gt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Dn | 0;
  return r[t++] = i, r[t + 3] = e, e >>>= 8, r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 4;
}
function qo(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t + 3] = e, e >>>= 8, r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 4;
}
function zo(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 3;
}
function Uo(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e >>> 8, r[t++] = e, t;
}
function Rg(r, e, t, i) {
  switch (i) {
    case 8:
      return Hf(r, e, t);
    case 7:
      return Ao(r, e, t);
    case 6:
      return _o(r, e, t);
    case 5:
      return Mo(r, e, t);
    case 4:
      return No(r, e, t);
    case 3:
      return Ff(r, e, t);
    case 2:
      return Vf(r, e, t);
    case 1:
      return Kn(r, e, t);
    default:
      throw new v0(t, "Invalid write length");
  }
}
function kg(r, e, t) {
  return Hf(r, e, t);
}
function qg(r, e, t) {
  return Ao(r, e, t);
}
function zg(r, e, t) {
  return _o(r, e, t);
}
function Ug(r, e, t) {
  return Mo(r, e, t);
}
function Qc(r, e, t) {
  return Ff(r, e, t);
}
function p5(r, e, t) {
  return No(r, e, t);
}
function Cg(r, e, t) {
  return Vf(r, e, t);
}
function Tg(r, e, t) {
  return Kn(r, e, t);
}
function Dg(r, e, t, i) {
  switch (i) {
    case 8:
      return Oo(r, e, t);
    case 7:
      return Po(r, e, t);
    case 6:
      return Ro(r, e, t);
    case 5:
      return ko(r, e, t);
    case 4:
      return qo(r, e, t);
    case 3:
      return zo(r, e, t);
    case 2:
      return Uo(r, e, t);
    case 1:
      return Kn(r, e, t);
    default:
      throw new v0(t, "Invalid write length");
  }
}
function Lg(r, e, t) {
  return Oo(r, e, t);
}
function Kg(r, e, t) {
  return Po(r, e, t);
}
function $g(r, e, t) {
  return Ro(r, e, t);
}
function Hg(r, e, t) {
  return ko(r, e, t);
}
function eo(r, e, t) {
  return qo(r, e, t);
}
function m5(r, e, t) {
  return zo(r, e, t);
}
function Fg(r, e, t) {
  return Uo(r, e, t);
}
function g5(r, e, t) {
  return gt(Do(e), "num", "number"), $f[0] = e, r[t++] = cr[0], r[t++] = cr[1], r[t++] = cr[2], r[t++] = cr[3], r[t++] = cr[4], r[t++] = cr[5], r[t++] = cr[6], r[t++] = cr[7], t;
}
function w5(r, e, t) {
  return gt(Do(e), "num", "number"), $f[0] = e, r[t++] = cr[7], r[t++] = cr[6], r[t++] = cr[5], r[t++] = cr[4], r[t++] = cr[3], r[t++] = cr[2], r[t++] = cr[1], r[t++] = cr[0], t;
}
function y5(r, e, t) {
  return gt(Do(e), "num", "number"), Ln[0] = e, r[t++] = Qr[0], r[t++] = Qr[1], r[t++] = Qr[2], r[t++] = Qr[3], t;
}
function S5(r, e, t) {
  return gt(Do(e), "num", "number"), Ln[0] = e, r[t++] = Qr[3], r[t++] = Qr[2], r[t++] = Qr[1], r[t++] = Qr[0], t;
}
const Vg = As ? S5 : y5, Gg = As ? y5 : S5, Yg = As ? w5 : g5, Jg = As ? g5 : w5;
function Xg(r, e) {
  let t, i;
  switch (Js(e < r.length, e), r[e]) {
    case 255:
      i = 9, Js(e + i <= r.length, e), t = tl(r, e + 1), N0(t > 4294967295, e, "Non-canonical varint");
      break;
    case 254:
      i = 5, Js(e + i <= r.length, e), t = vs(r, e + 1), N0(t > 65535, e, "Non-canonical varint");
      break;
    case 253:
      i = 3, Js(e + i <= r.length, e), t = il(r, e + 1), N0(t >= 253, e, "Non-canonical varint");
      break;
    default:
      i = 1, t = r[e];
      break;
  }
  return new I5(i, t);
}
function Zg(r, e, t) {
  return gt(Number.isSafeInteger(e), "num", "integer"), e < 253 ? (r[t++] = e, t) : e <= 65535 ? (r[t++] = 253, Vf(r, e, t)) : e <= 4294967295 ? (r[t++] = 254, Ff(r, e, t)) : (r[t++] = 255, Hf(r, e, t));
}
function Co(r) {
  return gt(Number.isSafeInteger(r), "num", "integer"), r < 253 ? 1 : r <= 65535 ? 3 : r <= 4294967295 ? 5 : 9;
}
function Wg(r, e) {
  let t = 0, i = 0;
  for (; ; ) {
    Js(e < r.length, e);
    const n = r[e++];
    if (i += 1, N0(t <= 70368744177663 - (n & 127), e, "Number exceeds 2^53-1"), t = t * 128 + (n & 127), !(n & 128))
      break;
    N0(t !== Sg, e, "Number exceeds 2^53-1"), t += 1;
  }
  return new I5(i, t);
}
function jg(r, e, t) {
  gt(Number.isSafeInteger(e), "num", "integer");
  const i = [];
  let n = 0;
  for (; i[n] = e & 127 | (n ? 128 : 0), !(e <= 127); )
    e = (e - e % 128) / 128 - 1, n += 1;
  Js(t + n + 1 <= r.length, t);
  do
    r[t++] = i[n];
  while (n--);
  return t;
}
function Qg(r) {
  gt(Number.isSafeInteger(r), "num", "integer");
  let e = 0;
  for (; e += 1, !(r <= 127); )
    r = (r - r % 128) / 128 - 1;
  return e;
}
function ew(r, e, t) {
  if (gt(Buffer.isBuffer(r), "data", "buffer"), gt(e >>> 0 === e, "off", "integer"), gt(t >>> 0 === t, "size", "integer"), e + t > r.length)
    throw new v0(e, "Out of bounds read");
  return r.slice(e, e + t);
}
function tw(r, e, t) {
  if (gt(Buffer.isBuffer(r), "data", "buffer"), gt(e >>> 0 === e, "off", "integer"), gt(t >>> 0 === t, "size", "integer"), e + t > r.length)
    throw new v0(e, "Out of bounds read");
  const i = Buffer.allocUnsafeSlow(t);
  return r.copy(i, 0, e, e + t), i;
}
function rw(r, e, t) {
  if (gt(Buffer.isBuffer(r), "data", "buffer"), gt(Buffer.isBuffer(e), "value", "buffer"), gt(t >>> 0 === t, "off", "integer"), t + e.length > r.length)
    throw new v0(t, "Out of bounds write");
  return e.copy(r, t, 0, e.length);
}
function iw(r, e, t, i) {
  if (i == null && (i = "binary"), gt(Buffer.isBuffer(r), "data", "buffer"), gt(e >>> 0 === e, "off", "integer"), gt(t >>> 0 === t, "size", "integer"), gt(typeof i == "string", "enc", "string"), e + t > r.length)
    throw new v0(e, "Out of bounds read");
  return r.toString(i, e, e + t);
}
function sw(r, e, t, i) {
  if (i == null && (i = "binary"), gt(Buffer.isBuffer(r), "data", "buffer"), gt(typeof e == "string", "str", "string"), gt(t >>> 0 === t, "off", "integer"), gt(typeof i == "string", "enc", "string"), e.length === 0)
    return 0;
  const n = Buffer.byteLength(e, i);
  if (t + n > r.length)
    throw new v0(t, "Out of bounds write");
  return r.write(e, t, i);
}
function B5(r, e) {
  gt(Buffer.isBuffer(r), "data", "buffer");
  const t = Buffer.allocUnsafeSlow(e);
  return r.copy(t, 0), t;
}
function nw(r) {
  return gt(Buffer.isBuffer(r), "data", "buffer"), B5(r, r.length);
}
function fw(r, e) {
  gt(Buffer.isBuffer(r), "a", "buffer"), gt(Buffer.isBuffer(e), "b", "buffer");
  const t = r.length + e.length, i = Buffer.allocUnsafeSlow(t);
  return r.copy(i, 0), e.copy(i, r.length), i;
}
function cw(r) {
  return gt(Buffer.isBuffer(r), "data", "buffer"), Co(r.length) + r.length;
}
function ow(r) {
  return Co(r) + r;
}
function aw(r, e) {
  if (e == null && (e = "binary"), gt(typeof r == "string", "str", "string"), gt(typeof e == "string", "enc", "string"), r.length === 0)
    return 1;
  const t = Buffer.byteLength(r, e);
  return Co(t) + t;
}
function To(r, e) {
  return r < 0 && (r = ~r, e === 0 && (r += 1)), (r & 4292870144) === 0;
}
function v5(r, e, t, i) {
  let n = !1;
  e < 0 && (e = -e, n = !0);
  let c = e * Dn | 0, o = e | 0;
  return n && (o === 0 ? c = ~c + 1 | 0 : (c = ~c, o = ~o + 1)), i ? (t = eo(r, c, t), t = eo(r, o, t)) : (t = Qc(r, o, t), t = Qc(r, c, t)), t;
}
function E5(r, e, t, i) {
  let n = !1;
  e < 0 && (e = -e, n = !0);
  let c = e * Dn | 0, o = e | 0;
  return n && (o === 0 ? c = ~c + 1 | 0 : (c = ~c, o = ~o + 1)), i ? (t = m5(r, c, t), t = eo(r, o, t)) : (t = Qc(r, o, t), t = p5(r, c, t)), t;
}
let I5 = class {
  constructor(e, t) {
    this.size = e, this.value = t;
  }
};
function Do(r) {
  return typeof r == "number" && isFinite(r);
}
function Js(r, e) {
  if (!r)
    throw new v0(e, "Out of bounds read", Js);
}
function N0(r, e, t) {
  if (!r)
    throw new v0(e, t, N0);
}
Ue.readU = Bg;
Ue.readU64 = tl;
Ue.readU56 = J8;
Ue.readU48 = X8;
Ue.readU40 = Z8;
Ue.readU32 = vs;
Ue.readU24 = rl;
Ue.readU16 = il;
Ue.readU8 = sl;
Ue.readUBE = vg;
Ue.readU64BE = W8;
Ue.readU56BE = j8;
Ue.readU48BE = Q8;
Ue.readU40BE = e5;
Ue.readU32BE = rn;
Ue.readU24BE = nl;
Ue.readU16BE = t5;
Ue.readI = Eg;
Ue.readI64 = r5;
Ue.readI56 = i5;
Ue.readI48 = s5;
Ue.readI40 = n5;
Ue.readI32 = fl;
Ue.readI24 = cl;
Ue.readI16 = f5;
Ue.readI8 = ol;
Ue.readIBE = Ig;
Ue.readI64BE = c5;
Ue.readI56BE = o5;
Ue.readI48BE = a5;
Ue.readI40BE = h5;
Ue.readI32BE = al;
Ue.readI24BE = hl;
Ue.readI16BE = d5;
Ue.readFloat = Ag;
Ue.readFloatBE = _g;
Ue.readDouble = Mg;
Ue.readDoubleBE = Ng;
Ue.writeU = Og;
Ue.writeU64 = Hf;
Ue.writeU56 = Ao;
Ue.writeU48 = _o;
Ue.writeU40 = Mo;
Ue.writeU32 = Ff;
Ue.writeU24 = No;
Ue.writeU16 = Vf;
Ue.writeU8 = Kn;
Ue.writeUBE = Pg;
Ue.writeU64BE = Oo;
Ue.writeU56BE = Po;
Ue.writeU48BE = Ro;
Ue.writeU40BE = ko;
Ue.writeU32BE = qo;
Ue.writeU24BE = zo;
Ue.writeU16BE = Uo;
Ue.writeI = Rg;
Ue.writeI64 = kg;
Ue.writeI56 = qg;
Ue.writeI48 = zg;
Ue.writeI40 = Ug;
Ue.writeI32 = Qc;
Ue.writeI24 = p5;
Ue.writeI16 = Cg;
Ue.writeI8 = Tg;
Ue.writeIBE = Dg;
Ue.writeI64BE = Lg;
Ue.writeI56BE = Kg;
Ue.writeI48BE = $g;
Ue.writeI40BE = Hg;
Ue.writeI32BE = eo;
Ue.writeI24BE = m5;
Ue.writeI16BE = Fg;
Ue.writeFloat = Vg;
Ue.writeFloatBE = Gg;
Ue.writeDouble = Yg;
Ue.writeDoubleBE = Jg;
Ue.readVarint = Xg;
Ue.writeVarint = Zg;
Ue.sizeVarint = Co;
Ue.readVarint2 = Wg;
Ue.writeVarint2 = jg;
Ue.sizeVarint2 = Qg;
Ue.sliceBytes = ew;
Ue.readBytes = tw;
Ue.writeBytes = rw;
Ue.readString = iw;
Ue.writeString = sw;
Ue.realloc = B5;
Ue.copy = nw;
Ue.concat = fw;
Ue.sizeVarBytes = cw;
Ue.sizeVarlen = ow;
Ue.sizeVarString = aw;
/*!
 * reader.js - buffer reader for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const L0 = Tn, Ft = Ue, cf = Kf, hw = Buffer.alloc(0);
let dw = class {
  /**
   * Create a buffer reader.
   * @constructor
   * @param {Buffer} data
   * @param {Boolean?} zeroCopy - Do not reallocate buffers when
   * slicing. Note that this can lead to memory leaks if not used
   * carefully.
   */
  constructor(e, t = !1) {
    L0(Buffer.isBuffer(e), "data", "buffer"), L0(typeof t == "boolean", "zeroCopy", "boolean"), this.data = e, this.offset = 0, this.zeroCopy = t, this.stack = [];
  }
  /**
   * Assertion.
   * @param {Number} size
   */
  check(e) {
    if (this.offset + e > this.data.length)
      throw new cf(this.offset, "Out of bounds read", this.check);
  }
  /**
   * Get total size of passed-in Buffer.
   * @returns {Buffer}
   */
  getSize() {
    return this.data.length;
  }
  /**
   * Calculate number of bytes left to read.
   * @returns {Number}
   */
  left() {
    return this.check(0), this.data.length - this.offset;
  }
  /**
   * Seek to a position to read from by offset.
   * @param {Number} off - Offset (positive or negative).
   */
  seek(e) {
    if (L0(Number.isSafeInteger(e), "off", "integer"), this.offset + e < 0)
      throw new cf(this.offset, "Out of bounds read");
    return this.check(e), this.offset += e, this;
  }
  /**
   * Mark the current starting position.
   */
  start() {
    return this.stack.push(this.offset), this.offset;
  }
  /**
   * Stop reading. Pop the start position off the stack
   * and calculate the size of the data read.
   * @returns {Number} Size.
   * @throws on empty stack.
   */
  end() {
    if (this.stack.length === 0)
      throw new Error("Cannot end without a stack item.");
    const e = this.stack.pop();
    return this.offset - e;
  }
  /**
   * Stop reading. Pop the start position off the stack
   * and return the data read.
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer} Data read.
   * @throws on empty stack.
   */
  endData(e = !1) {
    if (L0(typeof e == "boolean", "zeroCopy", "boolean"), this.stack.length === 0)
      throw new Error("Cannot end without a stack item.");
    const t = this.stack.pop(), i = this.offset, n = i - t, c = this.data;
    if (n === c.length)
      return c;
    if (this.zeroCopy || e)
      return c.slice(t, i);
    const o = Buffer.allocUnsafeSlow(n);
    return c.copy(o, 0, t, i), o;
  }
  /**
   * Destroy the reader. Remove references to the data.
   */
  destroy() {
    return this.data = hw, this.offset = 0, this.stack.length = 0, this;
  }
  /**
   * Read uint8.
   * @returns {Number}
   */
  readU8() {
    this.check(1);
    const e = this.data[this.offset];
    return this.offset += 1, e;
  }
  /**
   * Read uint16le.
   * @returns {Number}
   */
  readU16() {
    this.check(2);
    const e = Ft.readU16(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read uint16be.
   * @returns {Number}
   */
  readU16BE() {
    this.check(2);
    const e = Ft.readU16BE(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read uint24le.
   * @returns {Number}
   */
  readU24() {
    this.check(3);
    const e = Ft.readU24(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read uint24be.
   * @returns {Number}
   */
  readU24BE() {
    this.check(3);
    const e = Ft.readU24BE(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read uint32le.
   * @returns {Number}
   */
  readU32() {
    this.check(4);
    const e = Ft.readU32(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read uint32be.
   * @returns {Number}
   */
  readU32BE() {
    this.check(4);
    const e = Ft.readU32BE(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read uint40le.
   * @returns {Number}
   */
  readU40() {
    this.check(5);
    const e = Ft.readU40(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read uint40be.
   * @returns {Number}
   */
  readU40BE() {
    this.check(5);
    const e = Ft.readU40BE(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read uint48le.
   * @returns {Number}
   */
  readU48() {
    this.check(6);
    const e = Ft.readU48(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read uint48be.
   * @returns {Number}
   */
  readU48BE() {
    this.check(6);
    const e = Ft.readU48BE(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read uint56le.
   * @returns {Number}
   */
  readU56() {
    this.check(7);
    const e = Ft.readU56(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read uint56be.
   * @returns {Number}
   */
  readU56BE() {
    this.check(7);
    const e = Ft.readU56BE(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read uint64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readU64() {
    this.check(8);
    const e = Ft.readU64(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read uint64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readU64BE() {
    this.check(8);
    const e = Ft.readU64BE(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read int8.
   * @returns {Number}
   */
  readI8() {
    this.check(1);
    const e = Ft.readI8(this.data, this.offset);
    return this.offset += 1, e;
  }
  /**
   * Read int16le.
   * @returns {Number}
   */
  readI16() {
    this.check(2);
    const e = Ft.readI16(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read int16be.
   * @returns {Number}
   */
  readI16BE() {
    this.check(2);
    const e = Ft.readI16BE(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read int24le.
   * @returns {Number}
   */
  readI24() {
    this.check(3);
    const e = Ft.readI24(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read int24be.
   * @returns {Number}
   */
  readI24BE() {
    this.check(3);
    const e = Ft.readI24BE(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read int32le.
   * @returns {Number}
   */
  readI32() {
    this.check(4);
    const e = Ft.readI32(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read int32be.
   * @returns {Number}
   */
  readI32BE() {
    this.check(4);
    const e = Ft.readI32BE(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read int40le.
   * @returns {Number}
   */
  readI40() {
    this.check(5);
    const e = Ft.readI40(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read int40be.
   * @returns {Number}
   */
  readI40BE() {
    this.check(5);
    const e = Ft.readI40BE(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read int48le.
   * @returns {Number}
   */
  readI48() {
    this.check(6);
    const e = Ft.readI48(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read int48be.
   * @returns {Number}
   */
  readI48BE() {
    this.check(6);
    const e = Ft.readI48BE(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read int56le.
   * @returns {Number}
   */
  readI56() {
    this.check(7);
    const e = Ft.readI56(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read int56be.
   * @returns {Number}
   */
  readI56BE() {
    this.check(7);
    const e = Ft.readI56BE(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read int64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readI64() {
    this.check(8);
    const e = Ft.readI64(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read int64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readI64BE() {
    this.check(8);
    const e = Ft.readI64BE(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read float le.
   * @returns {Number}
   */
  readFloat() {
    this.check(4);
    const e = Ft.readFloat(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read float be.
   * @returns {Number}
   */
  readFloatBE() {
    this.check(4);
    const e = Ft.readFloatBE(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read double float le.
   * @returns {Number}
   */
  readDouble() {
    this.check(8);
    const e = Ft.readDouble(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read double float be.
   * @returns {Number}
   */
  readDoubleBE() {
    this.check(8);
    const e = Ft.readDoubleBE(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read a varint.
   * @returns {Number}
   */
  readVarint() {
    const { size: e, value: t } = Ft.readVarint(this.data, this.offset);
    return this.offset += e, t;
  }
  /**
   * Read a varint (type 2).
   * @returns {Number}
   */
  readVarint2() {
    const { size: e, value: t } = Ft.readVarint2(this.data, this.offset);
    return this.offset += e, t;
  }
  /**
   * Read N bytes (will do a fast slice if zero copy).
   * @param {Number} size
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */
  readBytes(e, t = !1) {
    L0(e >>> 0 === e, "size", "integer"), L0(typeof t == "boolean", "zeroCopy", "boolean"), this.check(e);
    let i;
    return this.zeroCopy || t ? i = this.data.slice(this.offset, this.offset + e) : (i = Buffer.allocUnsafeSlow(e), this.data.copy(i, 0, this.offset, this.offset + e)), this.offset += e, i;
  }
  /**
   * Read a varint number of bytes (will do a fast slice if zero copy).
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */
  readVarBytes(e = !1) {
    return this.readBytes(this.readVarint(), e);
  }
  /**
   * Slice N bytes and create a child reader.
   * @param {Number} size
   * @returns {BufferReader}
   */
  readChild(e) {
    L0(e >>> 0 === e, "size", "integer"), this.check(e);
    const t = this.data.slice(0, this.offset + e), i = new this.constructor(t);
    return i.offset = this.offset, this.offset += e, i;
  }
  /**
   * Read a string.
   * @param {Number} size
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */
  readString(e, t) {
    t == null && (t = "binary"), L0(e >>> 0 === e, "size", "integer"), L0(typeof t == "string", "enc", "string"), this.check(e);
    const i = this.data.toString(t, this.offset, this.offset + e);
    return this.offset += e, i;
  }
  /**
   * Read a 32-byte hash.
   * @param {String} enc - `"hex"` or `null`.
   * @returns {Hash|Buffer}
   */
  readHash(e) {
    return e ? this.readString(32, e) : this.readBytes(32);
  }
  /**
   * Read string of a varint length.
   * @param {String} enc - Any buffer-supported encoding.
   * @param {Number?} limit - Size limit.
   * @returns {String}
   */
  readVarString(e, t = 0) {
    e == null && (e = "binary"), L0(typeof e == "string", "enc", "string"), L0(t >>> 0 === t, "limit", "integer");
    const i = this.readVarint();
    if (t !== 0 && i > t)
      throw new cf(this.offset, "String exceeds limit");
    return this.readString(i, e);
  }
  /**
   * Read a null-terminated string.
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */
  readNullString(e) {
    e == null && (e = "binary"), L0(typeof e == "string", "enc", "string");
    let t = this.offset;
    for (; t < this.data.length && this.data[t] !== 0; t++)
      ;
    if (t === this.data.length)
      throw new cf(this.offset, "No NUL terminator");
    const i = this.readString(t - this.offset, e);
    return this.offset = t + 1, i;
  }
  /**
   * Create a checksum from the last start position.
   * @param {Function} hash
   * @returns {Number} Checksum.
   */
  createChecksum(e) {
    (!e || typeof e.digest != "function") && L0(typeof e == "function", "hash", "function");
    let t = 0;
    this.stack.length > 0 && (t = this.stack[this.stack.length - 1]);
    const i = this.data.slice(t, this.offset), n = e.digest ? e.digest(i) : e(i);
    return Ft.readU32(n, 0);
  }
  /**
   * Verify a 4-byte checksum against a calculated checksum.
   * @param {Function} hash
   * @returns {Number} checksum
   * @throws on bad checksum
   */
  verifyChecksum(e) {
    const t = this.createChecksum(e), i = this.readU32();
    if (t !== i)
      throw new cf(this.offset, "Checksum mismatch");
    return t;
  }
};
var A5 = dw;
/*!
 * writer.js - buffer writer for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Zr = Tn, zt = Ue, Nx = Kf, Ox = 0, Px = 1, Rx = 2, kx = 3, qx = 4, zx = 5, Ux = 6, Cx = 7, Tx = 8, Dx = 9, Lx = 10, Kx = 11, $x = 12, Hx = 13, Fx = 14, Vx = 15, Gx = 16, Yx = 17, Jx = 18, Xx = 19, Zx = 20, Wx = 21, jx = 22, Qx = 23, e3 = 24, t3 = 25, r3 = 26, i3 = 27, s3 = 28, n3 = 29, f3 = 30, c3 = 31, o3 = 32, a3 = 33, h3 = 34, of = 35, d3 = 36, wh = 37, yh = 38, u3 = 39, l3 = 40;
let uw = class {
  /**
   * Create a buffer writer.
   * @constructor
   */
  constructor() {
    this.ops = [], this.offset = 0;
  }
  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */
  render() {
    const e = Buffer.allocUnsafeSlow(this.offset);
    let t = 0;
    for (const i of this.ops)
      switch (i.type) {
        case Ox:
          t += i.value;
          break;
        case Px:
          t = zt.writeU8(e, i.value, t);
          break;
        case Rx:
          t = zt.writeU16(e, i.value, t);
          break;
        case kx:
          t = zt.writeU16BE(e, i.value, t);
          break;
        case qx:
          t = zt.writeU24(e, i.value, t);
          break;
        case zx:
          t = zt.writeU24BE(e, i.value, t);
          break;
        case Ux:
          t = zt.writeU32(e, i.value, t);
          break;
        case Cx:
          t = zt.writeU32BE(e, i.value, t);
          break;
        case Tx:
          t = zt.writeU40(e, i.value, t);
          break;
        case Dx:
          t = zt.writeU40BE(e, i.value, t);
          break;
        case Lx:
          t = zt.writeU48(e, i.value, t);
          break;
        case Kx:
          t = zt.writeU48BE(e, i.value, t);
          break;
        case $x:
          t = zt.writeU56(e, i.value, t);
          break;
        case Hx:
          t = zt.writeU56BE(e, i.value, t);
          break;
        case Fx:
          t = zt.writeU64(e, i.value, t);
          break;
        case Vx:
          t = zt.writeU64BE(e, i.value, t);
          break;
        case Gx:
          t = zt.writeI8(e, i.value, t);
          break;
        case Yx:
          t = zt.writeI16(e, i.value, t);
          break;
        case Jx:
          t = zt.writeI16BE(e, i.value, t);
          break;
        case Xx:
          t = zt.writeI24(e, i.value, t);
          break;
        case Zx:
          t = zt.writeI24BE(e, i.value, t);
          break;
        case Wx:
          t = zt.writeI32(e, i.value, t);
          break;
        case jx:
          t = zt.writeI32BE(e, i.value, t);
          break;
        case Qx:
          t = zt.writeI40(e, i.value, t);
          break;
        case e3:
          t = zt.writeI40BE(e, i.value, t);
          break;
        case t3:
          t = zt.writeI48(e, i.value, t);
          break;
        case r3:
          t = zt.writeI48BE(e, i.value, t);
          break;
        case i3:
          t = zt.writeI56(e, i.value, t);
          break;
        case s3:
          t = zt.writeI56BE(e, i.value, t);
          break;
        case n3:
          t = zt.writeI64(e, i.value, t);
          break;
        case f3:
          t = zt.writeI64BE(e, i.value, t);
          break;
        case c3:
          t = zt.writeFloat(e, i.value, t);
          break;
        case o3:
          t = zt.writeFloatBE(e, i.value, t);
          break;
        case a3:
          t = zt.writeDouble(e, i.value, t);
          break;
        case h3:
          t = zt.writeDoubleBE(e, i.value, t);
          break;
        case of:
          t = zt.writeVarint(e, i.value, t);
          break;
        case d3:
          t = zt.writeVarint2(e, i.value, t);
          break;
        case wh:
          t += i.data.copy(e, t);
          break;
        case yh:
          t += e.write(i.value, t, i.enc);
          break;
        case u3:
          t += i.func(e.slice(0, t)).copy(e, t, 0, 4);
          break;
        case l3:
          e.fill(i.value, t, t + i.size), t += i.size;
          break;
        default:
          throw new Error("Invalid type.");
      }
    if (t !== e.length)
      throw new Nx(t, "Out of bounds write");
    return this.destroy(), e;
  }
  /**
   * Get size of data written so far.
   * @returns {Number}
   */
  getSize() {
    return this.offset;
  }
  /**
   * Seek to relative offset.
   * @param {Number} offset
   */
  seek(e) {
    if (Zr(Number.isSafeInteger(e), "off", "integer"), this.offset + e < 0)
      throw new Nx(this.offset, "Out of bounds write");
    return this.offset += e, this.ops.push(new Ut(Ox, e)), this;
  }
  /**
   * Destroy the buffer writer. Remove references to `ops`.
   */
  destroy() {
    return this.ops.length = 0, this.offset = 0, this;
  }
  /**
   * Write uint8.
   * @param {Number} value
   */
  writeU8(e) {
    return this.offset += 1, this.ops.push(new Ut(Px, e)), this;
  }
  /**
   * Write uint16le.
   * @param {Number} value
   */
  writeU16(e) {
    return this.offset += 2, this.ops.push(new Ut(Rx, e)), this;
  }
  /**
   * Write uint16be.
   * @param {Number} value
   */
  writeU16BE(e) {
    return this.offset += 2, this.ops.push(new Ut(kx, e)), this;
  }
  /**
   * Write uint24le.
   * @param {Number} value
   */
  writeU24(e) {
    return this.offset += 3, this.ops.push(new Ut(qx, e)), this;
  }
  /**
   * Write uint24be.
   * @param {Number} value
   */
  writeU24BE(e) {
    return this.offset += 3, this.ops.push(new Ut(zx, e)), this;
  }
  /**
   * Write uint32le.
   * @param {Number} value
   */
  writeU32(e) {
    return this.offset += 4, this.ops.push(new Ut(Ux, e)), this;
  }
  /**
   * Write uint32be.
   * @param {Number} value
   */
  writeU32BE(e) {
    return this.offset += 4, this.ops.push(new Ut(Cx, e)), this;
  }
  /**
   * Write uint40le.
   * @param {Number} value
   */
  writeU40(e) {
    return this.offset += 5, this.ops.push(new Ut(Tx, e)), this;
  }
  /**
   * Write uint40be.
   * @param {Number} value
   */
  writeU40BE(e) {
    return this.offset += 5, this.ops.push(new Ut(Dx, e)), this;
  }
  /**
   * Write uint48le.
   * @param {Number} value
   */
  writeU48(e) {
    return this.offset += 6, this.ops.push(new Ut(Lx, e)), this;
  }
  /**
   * Write uint48be.
   * @param {Number} value
   */
  writeU48BE(e) {
    return this.offset += 6, this.ops.push(new Ut(Kx, e)), this;
  }
  /**
   * Write uint56le.
   * @param {Number} value
   */
  writeU56(e) {
    return this.offset += 7, this.ops.push(new Ut($x, e)), this;
  }
  /**
   * Write uint56be.
   * @param {Number} value
   */
  writeU56BE(e) {
    return this.offset += 7, this.ops.push(new Ut(Hx, e)), this;
  }
  /**
   * Write uint64le.
   * @param {Number} value
   */
  writeU64(e) {
    return this.offset += 8, this.ops.push(new Ut(Fx, e)), this;
  }
  /**
   * Write uint64be.
   * @param {Number} value
   */
  writeU64BE(e) {
    return this.offset += 8, this.ops.push(new Ut(Vx, e)), this;
  }
  /**
   * Write int8.
   * @param {Number} value
   */
  writeI8(e) {
    return this.offset += 1, this.ops.push(new Ut(Gx, e)), this;
  }
  /**
   * Write int16le.
   * @param {Number} value
   */
  writeI16(e) {
    return this.offset += 2, this.ops.push(new Ut(Yx, e)), this;
  }
  /**
   * Write int16be.
   * @param {Number} value
   */
  writeI16BE(e) {
    return this.offset += 2, this.ops.push(new Ut(Jx, e)), this;
  }
  /**
   * Write int24le.
   * @param {Number} value
   */
  writeI24(e) {
    return this.offset += 3, this.ops.push(new Ut(Xx, e)), this;
  }
  /**
   * Write int24be.
   * @param {Number} value
   */
  writeI24BE(e) {
    return this.offset += 3, this.ops.push(new Ut(Zx, e)), this;
  }
  /**
   * Write int32le.
   * @param {Number} value
   */
  writeI32(e) {
    return this.offset += 4, this.ops.push(new Ut(Wx, e)), this;
  }
  /**
   * Write int32be.
   * @param {Number} value
   */
  writeI32BE(e) {
    return this.offset += 4, this.ops.push(new Ut(jx, e)), this;
  }
  /**
   * Write int40le.
   * @param {Number} value
   */
  writeI40(e) {
    return this.offset += 5, this.ops.push(new Ut(Qx, e)), this;
  }
  /**
   * Write int40be.
   * @param {Number} value
   */
  writeI40BE(e) {
    return this.offset += 5, this.ops.push(new Ut(e3, e)), this;
  }
  /**
   * Write int48le.
   * @param {Number} value
   */
  writeI48(e) {
    return this.offset += 6, this.ops.push(new Ut(t3, e)), this;
  }
  /**
   * Write int48be.
   * @param {Number} value
   */
  writeI48BE(e) {
    return this.offset += 6, this.ops.push(new Ut(r3, e)), this;
  }
  /**
   * Write int56le.
   * @param {Number} value
   */
  writeI56(e) {
    return this.offset += 7, this.ops.push(new Ut(i3, e)), this;
  }
  /**
   * Write int56be.
   * @param {Number} value
   */
  writeI56BE(e) {
    return this.offset += 7, this.ops.push(new Ut(s3, e)), this;
  }
  /**
   * Write int64le.
   * @param {Number} value
   */
  writeI64(e) {
    return this.offset += 8, this.ops.push(new Ut(n3, e)), this;
  }
  /**
   * Write int64be.
   * @param {Number} value
   */
  writeI64BE(e) {
    return this.offset += 8, this.ops.push(new Ut(f3, e)), this;
  }
  /**
   * Write float le.
   * @param {Number} value
   */
  writeFloat(e) {
    return this.offset += 4, this.ops.push(new Ut(c3, e)), this;
  }
  /**
   * Write float be.
   * @param {Number} value
   */
  writeFloatBE(e) {
    return this.offset += 4, this.ops.push(new Ut(o3, e)), this;
  }
  /**
   * Write double le.
   * @param {Number} value
   */
  writeDouble(e) {
    return this.offset += 8, this.ops.push(new Ut(a3, e)), this;
  }
  /**
   * Write double be.
   * @param {Number} value
   */
  writeDoubleBE(e) {
    return this.offset += 8, this.ops.push(new Ut(h3, e)), this;
  }
  /**
   * Write a varint.
   * @param {Number} value
   */
  writeVarint(e) {
    return this.offset += zt.sizeVarint(e), this.ops.push(new Ut(of, e)), this;
  }
  /**
   * Write a varint (type 2).
   * @param {Number} value
   */
  writeVarint2(e) {
    return this.offset += zt.sizeVarint2(e), this.ops.push(new Ut(d3, e)), this;
  }
  /**
   * Write bytes.
   * @param {Buffer} value
   */
  writeBytes(e) {
    return Zr(Buffer.isBuffer(e), "value", "buffer"), e.length === 0 ? this : (this.offset += e.length, this.ops.push(new x3(wh, e)), this);
  }
  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */
  writeVarBytes(e) {
    return Zr(Buffer.isBuffer(e), "value", "buffer"), this.offset += zt.sizeVarint(e.length), this.ops.push(new Ut(of, e.length)), e.length === 0 ? this : (this.offset += e.length, this.ops.push(new x3(wh, e)), this);
  }
  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */
  copy(e, t, i) {
    Zr(Buffer.isBuffer(e), "value", "buffer"), Zr(t >>> 0 === t, "start", "integer"), Zr(i >>> 0 === i, "end", "integer"), Zr(i >= t, "start", "integer");
    const n = e.slice(t, i);
    return this.writeBytes(n), this;
  }
  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeString(e, t) {
    return t == null && (t = "binary"), Zr(typeof e == "string", "value", "string"), Zr(typeof t == "string", "enc", "string"), e.length === 0 ? this : (this.offset += Buffer.byteLength(e, t), this.ops.push(new b3(yh, e, t)), this);
  }
  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */
  writeHash(e) {
    return typeof e != "string" ? (Zr(Buffer.isBuffer(e), "value", "buffer"), Zr(e.length === 32, "value", "32-byte hash"), this.writeBytes(e), this) : (Zr(e.length === 64, "value", "32-byte hash"), this.writeString(e, "hex"), this);
  }
  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeVarString(e, t) {
    if (t == null && (t = "binary"), Zr(typeof e == "string", "value", "string"), Zr(typeof t == "string", "enc", "string"), e.length === 0)
      return this.ops.push(new Ut(of, 0)), this;
    const i = Buffer.byteLength(e, t);
    return this.offset += zt.sizeVarint(i), this.offset += i, this.ops.push(new Ut(of, i)), this.ops.push(new b3(yh, e, t)), this;
  }
  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeNullString(e, t) {
    return this.writeString(e, t), this.writeU8(0), this;
  }
  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */
  writeChecksum(e) {
    return e && typeof e.digest == "function" && (e = e.digest.bind(e)), Zr(typeof e == "function", "hash", "function"), this.offset += 4, this.ops.push(new lw(u3, e)), this;
  }
  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */
  fill(e, t) {
    return Zr((e & 255) === e, "value", "byte"), Zr(t >>> 0 === t, "size", "integer"), t === 0 ? this : (this.offset += t, this.ops.push(new xw(l3, e, t)), this);
  }
}, Gf = class {
  constructor(e) {
    this.type = e;
  }
}, Ut = class extends Gf {
  constructor(e, t) {
    super(e), this.value = t;
  }
}, x3 = class extends Gf {
  constructor(e, t) {
    super(e), this.data = t;
  }
}, b3 = class extends Gf {
  constructor(e, t, i) {
    super(e), this.value = t, this.enc = i;
  }
}, lw = class extends Gf {
  constructor(e, t) {
    super(e), this.func = t;
  }
}, xw = class extends Gf {
  constructor(e, t, i) {
    super(e), this.value = t, this.size = i;
  }
};
var _5 = uw;
/*!
 * staticwriter.js - buffer writer for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Lr = Tn, Vt = Ue, bc = Kf, p3 = Buffer.alloc(0), m3 = 102400;
let Sh = null, bw = class Ru {
  /**
   * Statically allocated buffer writer.
   * @constructor
   * @param {Number|Buffer} options
   */
  constructor(e) {
    this.data = p3, this.offset = 0, e != null && this.init(e);
  }
  /**
   * Assertion.
   * @param {Number} size
   */
  check(e) {
    if (this.offset + e > this.data.length)
      throw new bc(this.offset, "Out of bounds write", this.check);
  }
  /**
   * Initialize options.
   * @param {Object} options
   */
  init(e) {
    return Buffer.isBuffer(e) ? (this.data = e, this.offset = 0, this) : (Lr(e >>> 0 === e, "size", "integer"), this.data = Buffer.allocUnsafeSlow(e), this.offset = 0, this);
  }
  /**
   * Allocate writer from preallocated 100kb pool.
   * @param {Number} size
   * @returns {StaticWriter}
   */
  static pool(e) {
    if (Lr(e >>> 0 === e, "size", "integer"), e <= m3) {
      Sh || (Sh = Buffer.allocUnsafeSlow(m3));
      const t = new Ru();
      return t.data = Sh.slice(0, e), t;
    }
    return new Ru(e);
  }
  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */
  render() {
    const { data: e, offset: t } = this;
    if (t !== e.length)
      throw new bc(t, "Out of bounds write");
    return this.destroy(), e;
  }
  /**
   * Slice the final buffer at written offset.
   * @returns {Buffer} Rendered buffer.
   */
  slice() {
    const { data: e, offset: t } = this;
    if (t > e.length)
      throw new bc(t, "Out of bounds write");
    return this.destroy(), e.slice(0, t);
  }
  /**
   * Get size of data written so far.
   * @returns {Number}
   */
  getSize() {
    return this.offset;
  }
  /**
   * Seek to relative offset.
   * @param {Number} off
   */
  seek(e) {
    if (Lr(Number.isSafeInteger(e), "off", "integer"), this.offset + e < 0)
      throw new bc(this.offset, "Out of bounds write");
    return this.check(e), this.offset += e, this;
  }
  /**
   * Destroy the buffer writer.
   */
  destroy() {
    return this.data = p3, this.offset = 0, this;
  }
  /**
   * Write uint8.
   * @param {Number} value
   */
  writeU8(e) {
    return this.check(1), this.offset = Vt.writeU8(this.data, e, this.offset), this;
  }
  /**
   * Write uint16le.
   * @param {Number} value
   */
  writeU16(e) {
    return this.check(2), this.offset = Vt.writeU16(this.data, e, this.offset), this;
  }
  /**
   * Write uint16be.
   * @param {Number} value
   */
  writeU16BE(e) {
    return this.check(2), this.offset = Vt.writeU16BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint24le.
   * @param {Number} value
   */
  writeU24(e) {
    return this.check(3), this.offset = Vt.writeU24(this.data, e, this.offset), this;
  }
  /**
   * Write uint24be.
   * @param {Number} value
   */
  writeU24BE(e) {
    return this.check(3), this.offset = Vt.writeU24BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint32le.
   * @param {Number} value
   */
  writeU32(e) {
    return this.check(4), this.offset = Vt.writeU32(this.data, e, this.offset), this;
  }
  /**
   * Write uint32be.
   * @param {Number} value
   */
  writeU32BE(e) {
    return this.check(4), this.offset = Vt.writeU32BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint40le.
   * @param {Number} value
   */
  writeU40(e) {
    return this.check(5), this.offset = Vt.writeU40(this.data, e, this.offset), this;
  }
  /**
   * Write uint40be.
   * @param {Number} value
   */
  writeU40BE(e) {
    return this.check(5), this.offset = Vt.writeU40BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint48le.
   * @param {Number} value
   */
  writeU48(e) {
    return this.check(6), this.offset = Vt.writeU48(this.data, e, this.offset), this;
  }
  /**
   * Write uint48be.
   * @param {Number} value
   */
  writeU48BE(e) {
    return this.check(6), this.offset = Vt.writeU48BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint56le.
   * @param {Number} value
   */
  writeU56(e) {
    return this.check(7), this.offset = Vt.writeU56(this.data, e, this.offset), this;
  }
  /**
   * Write uint56be.
   * @param {Number} value
   */
  writeU56BE(e) {
    return this.check(7), this.offset = Vt.writeU56BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint64le.
   * @param {Number} value
   */
  writeU64(e) {
    return this.check(8), this.offset = Vt.writeU64(this.data, e, this.offset), this;
  }
  /**
   * Write uint64be.
   * @param {Number} value
   */
  writeU64BE(e) {
    return this.check(8), this.offset = Vt.writeU64BE(this.data, e, this.offset), this;
  }
  /**
   * Write int8.
   * @param {Number} value
   */
  writeI8(e) {
    return this.check(1), this.offset = Vt.writeI8(this.data, e, this.offset), this;
  }
  /**
   * Write int16le.
   * @param {Number} value
   */
  writeI16(e) {
    return this.check(2), this.offset = Vt.writeI16(this.data, e, this.offset), this;
  }
  /**
   * Write int16be.
   * @param {Number} value
   */
  writeI16BE(e) {
    return this.check(2), this.offset = Vt.writeI16BE(this.data, e, this.offset), this;
  }
  /**
   * Write int24le.
   * @param {Number} value
   */
  writeI24(e) {
    return this.check(3), this.offset = Vt.writeI24(this.data, e, this.offset), this;
  }
  /**
   * Write int24be.
   * @param {Number} value
   */
  writeI24BE(e) {
    return this.check(3), this.offset = Vt.writeI24BE(this.data, e, this.offset), this;
  }
  /**
   * Write int32le.
   * @param {Number} value
   */
  writeI32(e) {
    return this.check(4), this.offset = Vt.writeI32(this.data, e, this.offset), this;
  }
  /**
   * Write int32be.
   * @param {Number} value
   */
  writeI32BE(e) {
    return this.check(4), this.offset = Vt.writeI32BE(this.data, e, this.offset), this;
  }
  /**
   * Write int40le.
   * @param {Number} value
   */
  writeI40(e) {
    return this.check(5), this.offset = Vt.writeI40(this.data, e, this.offset), this;
  }
  /**
   * Write int40be.
   * @param {Number} value
   */
  writeI40BE(e) {
    return this.check(5), this.offset = Vt.writeI40BE(this.data, e, this.offset), this;
  }
  /**
   * Write int48le.
   * @param {Number} value
   */
  writeI48(e) {
    return this.check(6), this.offset = Vt.writeI48(this.data, e, this.offset), this;
  }
  /**
   * Write int48be.
   * @param {Number} value
   */
  writeI48BE(e) {
    return this.check(6), this.offset = Vt.writeI48BE(this.data, e, this.offset), this;
  }
  /**
   * Write int56le.
   * @param {Number} value
   */
  writeI56(e) {
    return this.check(7), this.offset = Vt.writeI56(this.data, e, this.offset), this;
  }
  /**
   * Write int56be.
   * @param {Number} value
   */
  writeI56BE(e) {
    return this.check(7), this.offset = Vt.writeI56BE(this.data, e, this.offset), this;
  }
  /**
   * Write int64le.
   * @param {Number} value
   */
  writeI64(e) {
    return this.check(8), this.offset = Vt.writeI64(this.data, e, this.offset), this;
  }
  /**
   * Write int64be.
   * @param {Number} value
   */
  writeI64BE(e) {
    return this.check(8), this.offset = Vt.writeI64BE(this.data, e, this.offset), this;
  }
  /**
   * Write float le.
   * @param {Number} value
   */
  writeFloat(e) {
    return this.check(4), this.offset = Vt.writeFloat(this.data, e, this.offset), this;
  }
  /**
   * Write float be.
   * @param {Number} value
   */
  writeFloatBE(e) {
    return this.check(4), this.offset = Vt.writeFloatBE(this.data, e, this.offset), this;
  }
  /**
   * Write double le.
   * @param {Number} value
   */
  writeDouble(e) {
    return this.check(8), this.offset = Vt.writeDouble(this.data, e, this.offset), this;
  }
  /**
   * Write double be.
   * @param {Number} value
   */
  writeDoubleBE(e) {
    return this.check(8), this.offset = Vt.writeDoubleBE(this.data, e, this.offset), this;
  }
  /**
   * Write a varint.
   * @param {Number} value
   */
  writeVarint(e) {
    return this.offset = Vt.writeVarint(this.data, e, this.offset), this;
  }
  /**
   * Write a varint (type 2).
   * @param {Number} value
   */
  writeVarint2(e) {
    return this.offset = Vt.writeVarint2(this.data, e, this.offset), this;
  }
  /**
   * Write bytes.
   * @param {Buffer} value
   */
  writeBytes(e) {
    return Lr(Buffer.isBuffer(e), "value", "buffer"), this.check(e.length), this.offset += e.copy(this.data, this.offset), this;
  }
  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */
  writeVarBytes(e) {
    return Lr(Buffer.isBuffer(e), "value", "buffer"), this.writeVarint(e.length), this.writeBytes(e), this;
  }
  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */
  copy(e, t, i) {
    return Lr(Buffer.isBuffer(e), "value", "buffer"), Lr(t >>> 0 === t, "start", "integer"), Lr(i >>> 0 === i, "end", "integer"), Lr(i >= t, "start", "integer"), this.check(i - t), this.offset += e.copy(this.data, this.offset, t, i), this;
  }
  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeString(e, t) {
    if (t == null && (t = "binary"), Lr(typeof e == "string", "value", "string"), Lr(typeof t == "string", "enc", "string"), e.length === 0)
      return this;
    const i = Buffer.byteLength(e, t);
    return this.check(i), this.offset += this.data.write(e, this.offset, t), this;
  }
  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */
  writeHash(e) {
    return typeof e != "string" ? (Lr(Buffer.isBuffer(e), "value", "buffer"), Lr(e.length === 32, "value", "32-byte hash"), this.writeBytes(e), this) : (Lr(e.length === 64, "value", "32-byte hash"), this.check(32), this.offset += this.data.write(e, this.offset, "hex"), this);
  }
  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeVarString(e, t) {
    if (t == null && (t = "binary"), Lr(typeof e == "string", "value", "string"), Lr(typeof t == "string", "enc", "string"), e.length === 0)
      return this.writeVarint(0), this;
    const i = Buffer.byteLength(e, t);
    return this.writeVarint(i), this.check(i), this.offset += this.data.write(e, this.offset, t), this;
  }
  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeNullString(e, t) {
    return this.writeString(e, t), this.writeU8(0), this;
  }
  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */
  writeChecksum(e) {
    (!e || typeof e.digest != "function") && Lr(typeof e == "function", "hash", "function"), this.check(4);
    const t = this.data.slice(0, this.offset);
    return (e.digest ? e.digest(t) : e(t)).copy(this.data, this.offset, 0, 4), this.offset += 4, this;
  }
  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */
  fill(e, t) {
    return Lr((e & 255) === e, "value", "byte"), Lr(t >>> 0 === t, "size", "integer"), this.check(t), this.data.fill(e, this.offset, this.offset + t), this.offset += t, this;
  }
};
var M5 = bw;
/*!
 * struct.js - struct object for bcoin
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Bh = Tn, pw = A5, mw = _5, gw = M5, { custom: ww } = el;
let yw = class {
  constructor() {
  }
  inject(e) {
    return Bh(e instanceof this.constructor, "obj", "struct"), this.decode(e.encode());
  }
  clone() {
    return new this.constructor().inject(this);
  }
  /*
   * Bindable
   */
  getSize(e) {
    return -1;
  }
  write(e, t) {
    return e;
  }
  read(e, t) {
    return this;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  fromString(e, t) {
    return this;
  }
  getJSON() {
    return this;
  }
  fromJSON(e, t) {
    return this;
  }
  fromOptions(e, t) {
    return this;
  }
  from(e, t) {
    return this.fromOptions(e, t);
  }
  format() {
    return this.getJSON();
  }
  /*
   * API
   */
  encode(e) {
    const t = this.getSize(e), i = t === -1 ? new mw() : new gw(t);
    return this.write(i, e), i.render();
  }
  decode(e, t) {
    const i = new pw(e);
    return this.read(i, t), this;
  }
  toHex(e) {
    return this.encode(e).toString("hex");
  }
  fromHex(e, t) {
    Bh(typeof e == "string", "str", "string");
    const i = e.length >>> 1, n = Buffer.from(e, "hex");
    if (n.length !== i)
      throw new Error("Invalid hex string.");
    return this.decode(n, t);
  }
  toBase64(e) {
    return this.encode(e).toString("base64");
  }
  fromBase64(e, t) {
    Bh(typeof e == "string", "str", "string");
    const i = Buffer.from(e, "base64");
    if (e.length > Sw(i.length))
      throw new Error("Invalid base64 string.");
    return this.decode(i, t);
  }
  toJSON() {
    return this.getJSON();
  }
  [ww]() {
    return this.format();
  }
  /*
   * Static API
   */
  static read(e, t) {
    return new this().read(e, t);
  }
  static decode(e, t) {
    return new this().decode(e, t);
  }
  static fromHex(e, t) {
    return new this().fromHex(e, t);
  }
  static fromBase64(e, t) {
    return new this().fromBase64(e, t);
  }
  static fromString(e, t) {
    return new this().fromString(e, t);
  }
  static fromJSON(e, t) {
    return new this().fromJSON(e, t);
  }
  static fromOptions(e, t) {
    return new this().fromOptions(e, t);
  }
  static from(e, t) {
    return new this().from(e, t);
  }
  /*
   * Aliases
   */
  toWriter(e, t) {
    return this.write(e, t);
  }
  fromReader(e, t) {
    return this.read(e, t);
  }
  toRaw(e) {
    return this.encode(e);
  }
  fromRaw(e, t) {
    return this.decode(e, t);
  }
  /*
   * Static Aliases
   */
  static fromReader(e, t) {
    return this.read(e, t);
  }
  static fromRaw(e, t) {
    return this.decode(e, t);
  }
};
function Sw(r) {
  return (4 * r / 3 + 3 & -4) >>> 0;
}
var Bw = yw;
/*!
 * bufio.js - buffer utilities for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const vw = el, Te = Ue, O0 = Tn, $n = Kf, N5 = A5, O5 = _5, dl = M5, Ew = Bw;
Pe.custom = vw;
Pe.encoding = Te;
Pe.EncodingError = $n;
Pe.BufferReader = N5;
Pe.BufferWriter = O5;
Pe.StaticWriter = dl;
Pe.Struct = Ew;
Pe.read = function(e, t) {
  return new N5(e, t);
};
Pe.write = function(e) {
  return e != null ? new dl(e) : new O5();
};
Pe.pool = function(e) {
  return dl.pool(e);
};
function Qt(r, e) {
  return function(t, i) {
    if (O0(Buffer.isBuffer(t), "data", "buffer"), O0(i >>> 0 === i, "off", "integer"), i + e > t.length)
      throw new $n(i, "Out of bounds read");
    return r(t, i);
  };
}
function Lo(r) {
  return function(e, t, i) {
    if (O0(Buffer.isBuffer(e), "data", "buffer"), O0(t >>> 0 === t, "off", "integer"), O0(i >>> 0 === i, "len", "integer"), t + i > e.length)
      throw new $n(t, "Out of bounds read");
    return r(e, t, i);
  };
}
function P5(r) {
  return function(e, t) {
    return O0(Buffer.isBuffer(e), "data", "buffer"), O0(t >>> 0 === t, "off", "integer"), r(e, t);
  };
}
function er(r, e) {
  return function(t, i, n) {
    if (O0(Buffer.isBuffer(t), "data", "buffer"), O0(n >>> 0 === n, "off", "integer"), n + e > t.length)
      throw new $n(n, "Out of bounds write");
    return r(t, i, n);
  };
}
function Ko(r) {
  return function(e, t, i, n) {
    if (O0(Buffer.isBuffer(e), "data", "buffer"), O0(i >>> 0 === i, "off", "integer"), O0(n >>> 0 === n, "len", "integer"), i + n > e.length)
      throw new $n(i, "Out of bounds write");
    return r(e, t, i, n);
  };
}
function R5(r, e) {
  return function(t, i, n) {
    if (O0(Buffer.isBuffer(t), "data", "buffer"), O0(n >>> 0 === n, "off", "integer"), n + e(i) > t.length)
      throw new $n(n, "Out of bounds write");
    return r(t, i, n);
  };
}
Pe.readU = Lo(Te.readU);
Pe.readU64 = Qt(Te.readU64, 8);
Pe.readU56 = Qt(Te.readU56, 7);
Pe.readU48 = Qt(Te.readU48, 6);
Pe.readU40 = Qt(Te.readU40, 5);
Pe.readU32 = Qt(Te.readU32, 4);
Pe.readU24 = Qt(Te.readU24, 3);
Pe.readU16 = Qt(Te.readU16, 2);
Pe.readU8 = Qt(Te.readU8, 1);
Pe.readUBE = Lo(Te.readUBE);
Pe.readU64BE = Qt(Te.readU64BE, 8);
Pe.readU56BE = Qt(Te.readU56BE, 7);
Pe.readU48BE = Qt(Te.readU48BE, 6);
Pe.readU40BE = Qt(Te.readU40BE, 5);
Pe.readU32BE = Qt(Te.readU32BE, 4);
Pe.readU24BE = Qt(Te.readU24BE, 3);
Pe.readU16BE = Qt(Te.readU16BE, 2);
Pe.readI = Lo(Te.readI);
Pe.readI64 = Qt(Te.readI64, 8);
Pe.readI56 = Qt(Te.readI56, 7);
Pe.readI48 = Qt(Te.readI48, 6);
Pe.readI40 = Qt(Te.readI40, 5);
Pe.readI32 = Qt(Te.readI32, 4);
Pe.readI24 = Qt(Te.readI24, 3);
Pe.readI16 = Qt(Te.readI16, 2);
Pe.readI8 = Qt(Te.readI8, 1);
Pe.readIBE = Lo(Te.readIBE);
Pe.readI64BE = Qt(Te.readI64BE, 8);
Pe.readI56BE = Qt(Te.readI56BE, 7);
Pe.readI48BE = Qt(Te.readI48BE, 6);
Pe.readI40BE = Qt(Te.readI40BE, 5);
Pe.readI32BE = Qt(Te.readI32BE, 4);
Pe.readI24BE = Qt(Te.readI24BE, 3);
Pe.readI16BE = Qt(Te.readI16BE, 2);
Pe.readFloat = Qt(Te.readFloat, 4);
Pe.readFloatBE = Qt(Te.readFloatBE, 4);
Pe.readDouble = Qt(Te.readDouble, 8);
Pe.readDoubleBE = Qt(Te.readDoubleBE, 8);
Pe.writeU = Ko(Te.writeU);
Pe.writeU64 = er(Te.writeU64, 8);
Pe.writeU56 = er(Te.writeU56, 7);
Pe.writeU48 = er(Te.writeU48, 6);
Pe.writeU40 = er(Te.writeU40, 5);
Pe.writeU32 = er(Te.writeU32, 4);
Pe.writeU24 = er(Te.writeU24, 3);
Pe.writeU16 = er(Te.writeU16, 2);
Pe.writeU8 = er(Te.writeU8, 1);
Pe.writeUBE = Ko(Te.writeUBE);
Pe.writeU64BE = er(Te.writeU64BE, 8);
Pe.writeU56BE = er(Te.writeU56BE, 7);
Pe.writeU48BE = er(Te.writeU48BE, 6);
Pe.writeU40BE = er(Te.writeU40BE, 5);
Pe.writeU32BE = er(Te.writeU32BE, 4);
Pe.writeU24BE = er(Te.writeU24BE, 3);
Pe.writeU16BE = er(Te.writeU16BE, 2);
Pe.writeI = Ko(Te.writeI);
Pe.writeI64 = er(Te.writeI64, 8);
Pe.writeI56 = er(Te.writeI56, 7);
Pe.writeI48 = er(Te.writeI48, 6);
Pe.writeI40 = er(Te.writeI40, 5);
Pe.writeI32 = er(Te.writeI32, 4);
Pe.writeI24 = er(Te.writeI24, 3);
Pe.writeI16 = er(Te.writeI16, 2);
Pe.writeI8 = er(Te.writeI8, 1);
Pe.writeIBE = Ko(Te.writeIBE);
Pe.writeI64BE = er(Te.writeI64BE, 8);
Pe.writeI56BE = er(Te.writeI56BE, 7);
Pe.writeI48BE = er(Te.writeI48BE, 6);
Pe.writeI40BE = er(Te.writeI40BE, 5);
Pe.writeI32BE = er(Te.writeI32BE, 4);
Pe.writeI24BE = er(Te.writeI24BE, 3);
Pe.writeI16BE = er(Te.writeI16BE, 2);
Pe.writeFloat = er(Te.writeFloat, 4);
Pe.writeFloatBE = er(Te.writeFloatBE, 4);
Pe.writeDouble = er(Te.writeDouble, 8);
Pe.writeDoubleBE = er(Te.writeDoubleBE, 8);
Pe.readVarint = P5(Te.readVarint);
Pe.writeVarint = R5(Te.writeVarint, Te.sizeVarint);
Pe.sizeVarint = Te.sizeVarint;
Pe.readVarint2 = P5(Te.readVarint2);
Pe.writeVarint2 = R5(Te.writeVarint2, Te.sizeVarint2);
Pe.sizeVarint2 = Te.sizeVarint2;
Pe.sliceBytes = Te.sliceBytes;
Pe.readBytes = Te.readBytes;
Pe.writeBytes = Te.writeBytes;
Pe.readString = Te.readString;
Pe.writeString = Te.writeString;
Pe.realloc = Te.realloc;
Pe.copy = Te.copy;
Pe.concat = Te.concat;
Pe.sizeVarBytes = Te.sizeVarBytes;
Pe.sizeVarlen = Te.sizeVarlen;
Pe.sizeVarString = Te.sizeVarString;
var X0 = {};
/*!
 * objects.js - OIDs encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://www.ietf.org/rfc/rfc2459.txt
 *   https://tools.ietf.org/html/rfc3279
 *   http://oid-info.com/get/1.2.840.10040.4
 *   http://oid-info.com/get/1.2.840.113549.1.1
 *   http://oid-info.com/get/1.2.840.10045.4.3
 *   https://tools.ietf.org/html/draft-jivsov-openpgp-sha3-01
 *   https://github.com/golang/go/blob/master/src/crypto/x509/x509.go
 *   https://github.com/golang/go/blob/master/src/crypto/x509/pkix/pkix.go
 *   https://tools.ietf.org/html/draft-josefsson-pkix-eddsa-01
 *   https://tools.ietf.org/html/rfc5480
 *   https://tools.ietf.org/html/draft-josefsson-pkix-newcurves-00
 *   https://tools.ietf.org/id/draft-ietf-curdle-pkix-06.html
 *   https://tools.ietf.org/html/rfc7693
 */
const Iw = "0.0", Ri = {
  COUNTRY: "2.5.4.6",
  ORGANIZATION: "2.5.4.10",
  ORGANIZATIONALUNIT: "2.5.4.11",
  COMMONNAME: "2.5.4.3",
  SERIALNUMBER: "2.5.4.5",
  LOCALITY: "2.5.4.7",
  PROVINCE: "2.5.4.8",
  STREETADDRESS: "2.5.4.9",
  POSTALCODE: "2.5.4.17"
}, Aw = {
  [Ri.COUNTRY]: "COUNTRY",
  [Ri.ORGANIZATION]: "ORGANIZATION",
  [Ri.ORGANIZATIONALUNIT]: "ORGANIZATIONALUNIT",
  [Ri.COMMONNAME]: "COMMONNAME",
  [Ri.SERIALNUMBER]: "SERIALNUMBER",
  [Ri.LOCALITY]: "LOCALITY",
  [Ri.PROVINCE]: "PROVINCE",
  [Ri.STREETADDRESS]: "STREETADDRESS",
  [Ri.POSTALCODE]: "POSTALCODE"
}, $s = {
  DH: "1.2.840.113549.1.3.1",
  DSA: "1.2.840.10040.4.1",
  DSA_ALT: "1.2.840.10040.4.2",
  RSA: "1.2.840.113549.1.1.1",
  ECDSA: "1.2.840.10045.2.1",
  EDDSA: "1.3.6.1.4.1.11591.4.12.1"
}, _w = {
  [$s.DH]: "DH",
  [$s.DSA]: "DSA",
  [$s.DSA_ALT]: "DSA",
  [$s.RSA]: "RSA",
  [$s.ECDSA]: "ECDSA",
  [$s.EDDSA]: "EDDSA"
}, Pt = {
  BLAKE2B160: "1.3.6.1.4.1.1722.12.2.1.5",
  BLAKE2B256: "1.3.6.1.4.1.1722.12.2.1.8",
  BLAKE2B384: "1.3.6.1.4.1.1722.12.2.1.12",
  BLAKE2B512: "1.3.6.1.4.1.1722.12.2.1.16",
  BLAKE2S128: "1.3.6.1.4.1.1722.12.2.2.4",
  BLAKE2S160: "1.3.6.1.4.1.1722.12.2.2.5",
  BLAKE2S224: "1.3.6.1.4.1.1722.12.2.2.7",
  BLAKE2S256: "1.3.6.1.4.1.1722.12.2.2.8",
  GOST94: "1.2.643.2.2.20",
  MD2: "1.2.840.113549.2.2",
  MD4: "1.2.840.113549.2.4",
  MD5: "1.2.840.113549.2.5",
  MDC2: "1.3.14.3.2.19",
  RIPEMD160: "1.0.10118.3.0.49",
  RIPEMD160_ALT: "1.3.36.3.2.1",
  SHA1: "1.3.14.3.2.26",
  SHA224: "2.16.840.1.101.3.4.2.4",
  SHA256: "2.16.840.1.101.3.4.2.1",
  SHA384: "2.16.840.1.101.3.4.2.2",
  SHA512: "2.16.840.1.101.3.4.2.3",
  SHA3_224: "2.16.840.1.101.3.4.2.7",
  SHA3_256: "2.16.840.1.101.3.4.2.8",
  SHA3_384: "2.16.840.1.101.3.4.2.9",
  SHA3_512: "2.16.840.1.101.3.4.2.10",
  SHAKE128: "2.16.840.1.101.3.4.2.11",
  SHAKE256: "2.16.840.1.101.3.4.2.12",
  SM3: "1.0.10118.3.0.65",
  WHIRLPOOL: "1.0.10118.3.0.55"
}, Mw = {
  [Pt.BLAKE2B160]: "BLAKE2B160",
  [Pt.BLAKE2B256]: "BLAKE2B256",
  [Pt.BLAKE2B384]: "BLAKE2B384",
  [Pt.BLAKE2B512]: "BLAKE2B512",
  [Pt.BLAKE2S128]: "BLAKE2S128",
  [Pt.BLAKE2S160]: "BLAKE2S160",
  [Pt.BLAKE2S224]: "BLAKE2S224",
  [Pt.BLAKE2S256]: "BLAKE2S256",
  [Pt.GOST94]: "GOST94",
  [Pt.MD2]: "MD2",
  [Pt.MD4]: "MD4",
  [Pt.MD5]: "MD5",
  [Pt.MDC2]: "MDC2",
  [Pt.RIPEMD160]: "RIPEMD160",
  [Pt.RIPEMD160_ALT]: "RIPEMD160",
  [Pt.SHA1]: "SHA1",
  [Pt.SHA224]: "SHA224",
  [Pt.SHA256]: "SHA256",
  [Pt.SHA384]: "SHA384",
  [Pt.SHA512]: "SHA512",
  [Pt.SHA3_224]: "SHA3_224",
  [Pt.SHA3_256]: "SHA3_256",
  [Pt.SHA3_384]: "SHA3_384",
  [Pt.SHA3_512]: "SHA3_512",
  [Pt.SHAKE128]: "SHAKE128",
  [Pt.SHAKE256]: "SHAKE256",
  [Pt.SM3]: "SM3",
  [Pt.WHIRLPOOL]: "WHIRLPOOL"
}, br = {
  P192: "1.2.840.10045.3.1.1",
  P224: "1.3.132.0.33",
  P256: "1.2.840.10045.3.1.7",
  P384: "1.3.132.0.34",
  P521: "1.3.132.0.35",
  BRAINPOOLP256: "1.3.36.3.3.2.8.1.1.7",
  BRAINPOOLP384: "1.3.36.3.3.2.8.1.1.11",
  BRAINPOOLP512: "1.3.36.3.3.2.8.1.1.13",
  SECP192K1: "1.3.132.0.31",
  SECP224K1: "1.3.132.0.32",
  SECP256K1: "1.3.132.0.10",
  FRP256V1: "1.2.250.1.223.101.256.1",
  X25519: "1.3.101.110",
  X25519_ALT: "1.3.6.1.4.1.11591.7",
  ED25519: "1.3.101.112",
  X448: "1.3.101.111",
  X448_ALT: "1.3.6.1.4.1.11591.8",
  ED448: "1.3.101.113",
  // Non-standard, but officially registered:
  // See: https://github.com/weidai11/cryptopp/issues/67#issuecomment-162191213
  ED1174: "1.3.6.1.4.1.9509.5.2.6",
  ED41417: "1.3.6.1.4.1.9509.5.2.5",
  CURVE383187: "1.3.6.1.4.1.9509.5.1.4",
  M221: "1.3.6.1.4.1.9509.5.1.1",
  E222: "1.3.6.1.4.1.9509.5.2.1",
  M383: "1.3.6.1.4.1.9509.5.1.2",
  E382: "1.3.6.1.4.1.9509.5.2.2",
  M511: "1.3.6.1.4.1.9509.5.1.3",
  E521: "1.3.6.1.4.1.9509.5.2.4"
}, Nw = {
  [br.P192]: "P192",
  [br.P224]: "P224",
  [br.P256]: "P256",
  [br.P384]: "P384",
  [br.P521]: "P521",
  [br.BRAINPOOLP256]: "BRAINPOOLP256",
  [br.BRAINPOOLP384]: "BRAINPOOLP384",
  [br.BRAINPOOLP512]: "BRAINPOOLP512",
  [br.SECP192K1]: "SECP192K1",
  [br.SECP224K1]: "SECP224K1",
  [br.SECP256K1]: "SECP256K1",
  [br.FRP256V1]: "FRP256V1",
  [br.X25519]: "X25519",
  [br.X25519_ALT]: "X25519",
  [br.ED25519]: "ED25519",
  [br.X448]: "X448",
  [br.X448_ALT]: "X448",
  [br.ED448]: "ED448",
  [br.ED1174]: "ED1174",
  [br.ED41417]: "ED41417",
  [br.CURVE383187]: "CURVE383187",
  [br.M221]: "M221",
  [br.E222]: "E222",
  [br.M383]: "M383",
  [br.E382]: "E382",
  [br.M511]: "M511",
  [br.E521]: "E521"
}, Kt = {
  DSASHA1: "1.2.840.10040.4.3",
  RSAMD2: "1.2.840.113549.1.1.2",
  RSAMD4: "1.2.840.113549.1.1.3",
  RSAMD5: "1.2.840.113549.1.1.4",
  RSASHA1: "1.2.840.113549.1.1.5",
  RSASHA1_MS: "1.3.14.3.2.29",
  RSAPSS: "1.2.840.113549.1.1.10",
  RSASHA256: "1.2.840.113549.1.1.11",
  RSASHA384: "1.2.840.113549.1.1.12",
  RSASHA512: "1.2.840.113549.1.1.13",
  RSASHA224: "1.2.840.113549.1.1.14",
  MGF1: "1.2.840.113549.1.1.8",
  RSASHA3_256: "2.16.840.1.101.3.4.2.8",
  RSASHA3_384: "2.16.840.1.101.3.4.2.9",
  RSASHA3_512: "2.16.840.1.101.3.4.2.10",
  ECDSASHA1: "1.2.840.10045.4.1",
  ECDSASHA224: "1.2.840.10045.4.3.1",
  ECDSASHA256: "1.2.840.10045.4.3.2",
  ECDSASHA384: "1.2.840.10045.4.3.3",
  ECDSASHA512: "1.2.840.10045.4.3.4",
  EDDSA: "1.3.6.1.4.1.11591.4.12.2"
}, Ow = {
  [Kt.DSASHA1]: "DSASHA1",
  [Kt.RSAMD2]: "RSAMD2",
  [Kt.RSAMD4]: "RSAMD4",
  [Kt.RSAMD5]: "RSAMD5",
  [Kt.RSASHA1]: "RSASHA1",
  [Kt.RSASHA1_MS]: "RSASHA1",
  [Kt.RSAPSS]: "RSAPSS",
  [Kt.RSASHA256]: "RSASHA256",
  [Kt.RSASHA384]: "RSASHA384",
  [Kt.RSASHA512]: "RSASHA512",
  [Kt.MGF1]: "MGF1",
  [Kt.RSASHA3_256]: "RSASHA3_256",
  [Kt.RSASHA3_384]: "RSASHA3_384",
  [Kt.RSASHA3_512]: "RSASHA3_512",
  [Kt.ECDSASHA1]: "ECDSASHA1",
  [Kt.ECDSASHA224]: "ECDSASHA224",
  [Kt.ECDSASHA384]: "ECDSASHA384",
  [Kt.ECDSASHA512]: "ECDSASHA512",
  [Kt.EDDSA]: "EDDSA"
}, Pw = {
  [Kt.DSASHA1]: Pt.SHA1,
  [Kt.RSAMD2]: Pt.MD2,
  [Kt.RSAMD4]: Pt.MD4,
  [Kt.RSAMD5]: Pt.MD5,
  [Kt.RSASHA1]: Pt.SHA1,
  [Kt.RSASHA1_MS]: Pt.SHA1,
  [Kt.RSAPSS]: null,
  [Kt.RSASHA256]: Pt.SHA256,
  [Kt.RSASHA384]: Pt.SHA384,
  [Kt.RSASHA512]: Pt.SHA512,
  [Kt.MGF1]: null,
  [Kt.RSASHA3_256]: Pt.SHA3_256,
  [Kt.RSASHA3_384]: Pt.SHA3_384,
  [Kt.RSASHA3_512]: Pt.SHA3_512,
  [Kt.ECDSASHA1]: Pt.SHA1,
  [Kt.ECDSASHA224]: Pt.SHA224,
  [Kt.ECDSASHA384]: Pt.SHA384,
  [Kt.ECDSASHA512]: Pt.SHA512,
  [Kt.EDDSA]: null
};
X0.NONE = Iw;
X0.attrs = Ri;
X0.attrsByVal = Aw;
X0.keyAlgs = $s;
X0.keyAlgsByVal = _w;
X0.hashes = Pt;
X0.hashesByVal = Mw;
X0.curves = br;
X0.curvesByVal = Nw;
X0.sigAlgs = Kt;
X0.sigAlgsByVal = Ow;
X0.sigToHash = Pw;
/*!
 * asn1.js - ASN1 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/asn1.js:
 *   Copyright Fedor Indutny, 2013.
 *   https://github.com/indutny/asn1.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One
 *   https://en.wikipedia.org/wiki/X.690#BER_encoding
 *   https://en.wikipedia.org/wiki/X.690#DER_encoding
 *   http://luca.ntop.org/Teaching/Appunti/asn1.html
 *   ftp://ftp.rsasecurity.com/pub/pkcs/ascii/layman.asc
 *   https://tools.ietf.org/html/rfc2560
 *   https://tools.ietf.org/html/rfc5280
 *   https://github.com/indutny/asn1.js/blob/master/rfc/2560/index.js
 *   https://github.com/indutny/asn1.js/blob/master/rfc/5280/index.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/base/node.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/encoders/der.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/decoders/der.js
 *   https://github.com/openssl/openssl/blob/master/include/openssl/asn1.h
 *   https://github.com/golang/go/blob/master/src/encoding/asn1/asn1.go
 *   https://github.com/golang/go/blob/master/src/encoding/asn1/marshal.go
 */
const Ve = _e, Ss = Pe, kr = X0, sn = Buffer.alloc(0), Lc = Buffer.alloc(1, 0), Kc = new Uint32Array(2), Rw = -62167219200, kw = 253402300799, qw = -43200, zw = 50400, xt = {
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTSTRING: 4,
  NULL: 5,
  OID: 6,
  ENUM: 10,
  UTF8STRING: 12,
  SEQUENCE: 16,
  SET: 17,
  NUMSTRING: 18,
  PRINTSTRING: 19,
  T61STRING: 20,
  IA5STRING: 22,
  UTCTIME: 23,
  GENTIME: 24,
  GENSTRING: 27
}, Uw = {
  1: "BOOLEAN",
  2: "INTEGER",
  3: "BITSTRING",
  4: "OCTSTRING",
  5: "NULL",
  6: "OID",
  10: "ENUM",
  12: "UTF8STRING",
  16: "SEQUENCE",
  17: "SET",
  18: "NUMSTRING",
  19: "PRINTSTRING",
  20: "T61STRING",
  22: "IA5STRING",
  23: "UTCTIME",
  24: "GENTIME",
  27: "GENSTRING"
}, is = {
  UNIVERSAL: 0,
  APPLICATION: 1,
  CONTEXT: 2,
  PRIVATE: 3
}, Cw = {
  0: "UNIVERSAL",
  1: "APPLICATION",
  2: "CONTEXT",
  3: "PRIVATE"
}, ku = 255, $c = 256, qu = 130560, kf = 0, Bf = 512, Hc = 1024;
class r0 extends Ss.Struct {
  constructor() {
    super(), this.flags = 0;
  }
  get mode() {
    return this.flags & qu;
  }
  set mode(e) {
    this.flags &= ~qu, this.flags |= e;
  }
  get opt() {
    return (this.flags & $c) !== 0;
  }
  set opt(e) {
    e ? this.flags |= $c : this.flags &= ~$c;
  }
  get target() {
    return this.flags & ku;
  }
  set target(e) {
    this.flags &= ~ku, this.flags |= e;
  }
  get isRaw() {
    return !1;
  }
  explicit(e) {
    return Ve(e >>> 0 === e), this.mode = Bf, this.target = e, this;
  }
  implicit(e) {
    return Ve(e >>> 0 === e), this.mode = Hc, this.target = e, this;
  }
  optional(e = !0) {
    return Ve(typeof e == "boolean"), this.opt = e, this;
  }
  clean() {
    return !1;
  }
  getBodySize(e) {
    return 0;
  }
  writeBody(e, t) {
    return e;
  }
  readBody(e, t) {
    return this;
  }
  encodeBody(e) {
    const t = this.getBodySize(), i = Ss.write(t);
    return this.writeBody(i, e), i.render();
  }
  decodeBody(e, t) {
    const i = Ss.read(e);
    return this.readBody(i, t);
  }
  set() {
    return this;
  }
  from(e, ...t) {
    return e == null ? this : this.set(e, ...t);
  }
  error(e) {
    if (this.opt)
      return this;
    const t = new Error(e);
    throw Error.captureStackTrace && Error.captureStackTrace(t, this.error), t;
  }
  getSize(e) {
    if (this.opt && this.clean())
      return 0;
    const t = this.getBodySize(e);
    let i = 0;
    return i += vh(t), i += t, this.mode === Bf && (i += vh(i)), i;
  }
  write(e, t) {
    if (this.opt && this.clean())
      return e;
    const i = this.getBodySize();
    switch (this.mode) {
      case Bf: {
        const n = vh(i) + i;
        Eh(e, this.target, is.CONTEXT, !1, n);
      }
      case kf: {
        const n = this.type !== xt.SEQUENCE && this.type !== xt.SET;
        Eh(e, this.type, is.UNIVERSAL, n, i);
        break;
      }
      case Hc: {
        const n = this.type !== xt.SEQUENCE && this.type !== xt.SET;
        Eh(e, this.target, is.CONTEXT, n, i);
        break;
      }
      default:
        throw new Error("Invalid mode.");
    }
    return this.writeBody(e, t);
  }
  read(e, t) {
    switch (this.mode) {
      case Bf: {
        const i = Af(e, this.opt);
        if (!i)
          return this;
        if (i.cls !== is.CONTEXT)
          return this.error(`Unexpected class: ${i.cls}.`);
        if (i.primitive)
          return this.error("Unexpected primitive flag.");
        if (i.type !== this.target)
          return this.error(`Unexpected type: ${i.type}.`);
        e.seek(i.len), e = e.readChild(i.size);
      }
      case kf: {
        const i = Af(e, this.opt);
        if (!i)
          return this;
        if (i.cls !== is.UNIVERSAL)
          return this.error(`Unexpected class: ${i.cls}.`);
        const n = this.type !== xt.SEQUENCE && this.type !== xt.SET;
        if (i.primitive !== n)
          return this.error("Unexpected primitive flag.");
        if (i.type !== this.type)
          return this.error(`Unexpected type: ${i.type}.`);
        if (this.isRaw) {
          const o = i.len + i.size;
          this.raw = e.readBytes(o), e.seek(-o);
        }
        e.seek(i.len);
        const c = e.readChild(i.size);
        return this.readBody(c, t);
      }
      case Hc: {
        const i = Af(e, this.opt);
        if (!i)
          return this;
        if (i.cls !== is.CONTEXT)
          return this.error(`Unexpected class: ${i.cls}.`);
        const n = this.type !== xt.SEQUENCE && this.type !== xt.SET;
        if (i.primitive !== n)
          return this.error("Unexpected primitive flag.");
        if (i.type !== this.target)
          return this.error(`Unexpected type: ${i.type}.`);
        e.seek(i.len);
        const c = e.readChild(i.size);
        return this.readBody(c, t);
      }
      default:
        throw new Error("Invalid mode.");
    }
  }
  fromArray(e) {
    return this;
  }
  fromNumber(e) {
    return this;
  }
  fromPEM(e) {
    return this;
  }
  static decodeBody(e) {
    return new this().decodeBody(e);
  }
  static fromArray(e) {
    return new this().fromArray(e);
  }
  static fromNumber(e) {
    return new this().fromNumber(e);
  }
  static fromPEM(e) {
    return new this().fromPEM(e);
  }
}
class Tw extends r0 {
  constructor(...e) {
    super(), this.raw = null, this.from(...e);
  }
  get type() {
    return xt.SEQUENCE;
  }
}
let Dw = class extends r0 {
  constructor(...e) {
    super(), this.raw = null, this.from(...e);
  }
  get type() {
    return xt.SET;
  }
};
class k5 extends r0 {
  constructor(...e) {
    super(), this.node = new to(), this.raw = null, this.from(...e);
  }
  get isRaw() {
    return !0;
  }
  explicit(e) {
    throw new Error("Cannot set explicit on any.");
  }
  implicit(e) {
    throw new Error("Cannot set implicit on any.");
  }
  get type() {
    return this.node.type;
  }
  getSize(e) {
    return this.node.flags = this.flags, this.node.getSize(e);
  }
  write(e, t) {
    return Ve(e), Ve(this.mode === kf), this.node.flags = this.flags, this.node.write(e, t), e;
  }
  read(e, t) {
    Ve(e), Ve(this.mode === kf);
    const i = Af(e, this.opt);
    if (!i)
      return this.node.flags = this.flags, this;
    const n = bl(i.type);
    return this.node = new n(), this.node.flags = this.flags, this.node.read(e, t), this;
  }
  getBodySize(e) {
    return this.node.flags = this.flags, this.node.getBodySize(e);
  }
  writeBody(e, t) {
    return this.node.flags = this.flags, this.node.writeBody(e, t), e;
  }
  readBody(e, t) {
    return this.node.flags = this.flags, this.node.readBody(e, t), this;
  }
  set(e) {
    return e == null && (e = new to()), Ve(e instanceof r0), this.node = e, this.node.flags = this.flags, this;
  }
  clean() {
    return this.node.type === xt.NULL;
  }
  format() {
    return {
      type: this.constructor.name,
      node: this.node
    };
  }
}
class Lw extends r0 {
  constructor(e, ...t) {
    super(), Ve(e instanceof r0), this.node = e, this.from(...t);
  }
  get type() {
    return this.node.type;
  }
  choices() {
    throw new Error("Unimplemented.");
  }
  getSize(e) {
    return this.node.getSize(e);
  }
  write(e, t) {
    return Ve(e), this.node.flags = this.flags, this.node.write(e, t), e;
  }
  read(e, t) {
    Ve(e);
    const i = this.choices();
    Ve(Array.isArray(i)), Ve(i.length >= 1);
    const n = Af(e, this.opt);
    if (!n)
      return this;
    if (i.indexOf(n.type) === -1)
      throw new Error(`Could not satisfy choice for: ${n.type}.`);
    const c = bl(n.type), o = new c();
    return o.flags = this.flags, this.node = o.read(e, t), this;
  }
  getBodySize(e) {
    return this.node.getBodySize(e);
  }
  writeBody(e, t) {
    return this.node.writeBody(e, t), e;
  }
  readBody(e, t) {
    return this.node.readBody(e, t), this;
  }
  set(...e) {
    return this.node.set(...e);
  }
  clean() {
    return this.node.clean();
  }
  format() {
    return {
      type: this.constructor.name,
      node: this.node
    };
  }
}
const _s = class extends r0 {
  constructor(...e) {
    super(), this.value = "", this.from(...e);
  }
  get encoding() {
    return "binary";
  }
  getBodySize() {
    return Buffer.byteLength(this.value, this.encoding);
  }
  writeBody(e) {
    return e.writeString(this.value, this.encoding), e;
  }
  readBody(e) {
    const t = e.readString(e.left(), this.encoding);
    switch (this.type) {
      case xt.NUMSTRING: {
        if (!Fw(t))
          throw new Error("Invalid num string.");
        break;
      }
      case xt.PRINTSTRING: {
        if (!Vw(t))
          throw new Error("Invalid print string.");
        break;
      }
      case xt.IA5STRING: {
        if (!Gw(t))
          throw new Error("Invalid print string.");
        break;
      }
    }
    return this.value = t, this;
  }
  set(e) {
    return e == null && (e = ""), Ve(typeof e == "string"), this.value = e, this;
  }
  clean() {
    return this.value.length === 0;
  }
  format() {
    return `<${this.constructor.name}: ${this.value}>`;
  }
}, ul = class extends r0 {
  constructor(...e) {
    super(), this.value = !1, this.from(...e);
  }
  get type() {
    return xt.BOOLEAN;
  }
  getBodySize() {
    return 1;
  }
  writeBody(e) {
    return e.writeU8(this.value ? 255 : 0), e;
  }
  readBody(e) {
    if (e.left() !== 1)
      throw new Error("Non-minimal boolean.");
    const t = e.readU8();
    if (t !== 0 && t !== 255)
      throw new Error("Invalid boolean.");
    return this.value = t === 255, this;
  }
  set(e) {
    return e == null && (e = !1), Ve(typeof e == "boolean"), this.value = e, this;
  }
  clean() {
    return this.value === !1;
  }
  format() {
    return `<${this.constructor.name}: ${this.value}>`;
  }
};
class $o extends r0 {
  constructor(...e) {
    super(), this.value = Lc, this.negative = !1, this.from(...e);
  }
  get type() {
    return xt.INTEGER;
  }
  getBodySize() {
    const e = this.value;
    if (e.length === 0)
      return 1;
    let t = 0, i = 0;
    if (!this.negative && e[0] > 127)
      t = 1;
    else if (this.negative) {
      if (e[0] > 128)
        t = 1;
      else if (e[0] === 128) {
        t = 0;
        for (let n = 1; n < e.length; n++)
          t |= e[n];
        t = t ? 1 : 0;
      }
    }
    return i += t, i += e.length, i;
  }
  writeBody(e) {
    const t = this.value;
    if (t.length === 0)
      return e.writeU8(0), e;
    let i = 0, n = 0;
    if (!this.negative && t[0] > 127)
      i = 1, n = 0;
    else if (this.negative) {
      if (n = 255, t[0] > 128)
        i = 1;
      else if (t[0] === 128) {
        i = 0;
        for (let o = 1; o < t.length; o++)
          i |= t[o];
        n = i !== 0 ? 255 : 0, i = n & 1;
      }
    }
    i && e.writeU8(n);
    const c = e.offset;
    return e.writeBytes(t), n && y3(e.data, c, e.offset), this;
  }
  readBody(e) {
    let t = e.readBytes(e.left());
    if (t.length === 0)
      throw new Error("Zero length integer.");
    const i = t[0] & 128;
    if (t.length === 1)
      return i && (t[0] = (t[0] ^ 255) + 1), this.negative = i !== 0, this.value = t, this;
    if (t[0] === 0 && !(t[1] & 128))
      throw new Error("Non-minimal integer.");
    if (t[0] === 255 && (t[1] & 128) === 128)
      throw new Error("Non-minimal integer.");
    let n = 0;
    if (t[0] === 0)
      n = 1;
    else if (t[0] === 255) {
      for (let c = 1; c < t.length; c++)
        n |= t[c];
      n = n !== 0 ? 1 : 0;
    }
    if (n && i === (t[1] & 128))
      throw new Error("Invalid integer padding.");
    return n && (t = t.slice(1)), i && y3(t, 0, t.length), this.negative = i !== 0, this.value = Ih(t), this;
  }
  set(e, t) {
    return typeof e == "number" ? this.fromNumber(e) : (e == null && (e = Lc), Ve(Buffer.isBuffer(e)), this.value = Ih(e), this.negative = !1, t != null && (Ve(typeof t == "boolean"), this.negative = t), this);
  }
  clean() {
    return !this.negative && this.value.equals(Lc);
  }
  formatValue() {
    return this.value.toString("hex");
  }
  toNumber() {
    let e = Ss.readUBE(this.value, 0, this.value.length);
    return this.negative && (e = -e), e;
  }
  fromNumber(e) {
    Ve(Number.isSafeInteger(e));
    const t = Buffer.alloc(8);
    let i = !1;
    return e < 0 && (i = !0, e = -e), Ss.writeU64BE(t, e, 0), this.value = Ih(t), this.negative = i, this;
  }
  format() {
    const e = this.constructor.name;
    if (this.value.length <= 6)
      return `<${e}: ${this.toNumber()}>`;
    const t = this.negative ? "-" : "", i = this.value.toString("hex");
    return `<${e}: ${t}0x${i}>`;
  }
}
class Kw extends $o {
  constructor(...e) {
    super(...e);
  }
  getBodySize() {
    return Ve(!this.negative), super.getBodySize();
  }
  writeBody(e) {
    return Ve(!this.negative), super.writeBody(e);
  }
  readBody(e) {
    return super.readBody(e), Ve(!this.negative), this;
  }
  set(e) {
    return super.set(e);
  }
  toNumber() {
    return Ve(!this.negative), super.toNumber();
  }
  fromNumber(e) {
    return super.fromNumber(e), Ve(!this.negative), this;
  }
}
class q5 extends r0 {
  constructor(...e) {
    super(), this.bits = 0, this.value = sn, this.from(...e);
  }
  get type() {
    return xt.BITSTRING;
  }
  getBodySize() {
    return 1 + this.value.length;
  }
  writeBody(e) {
    const t = 8 - (this.bits & 7) & 7;
    return e.writeU8(t), e.writeBytes(this.value), e;
  }
  readBody(e) {
    const t = e.readBytes(e.left());
    if (t.length === 0)
      throw new Error("Zero length bit string.");
    const i = t[0];
    if (i > 7 || t.length === 1 && i > 0 || t[t.length - 1] & (1 << i) - 1)
      throw new Error("Invalid padding bits.");
    return this.bits = (t.length - 1) * 8 - i, this.value = t.slice(1), this;
  }
  rightAlign() {
    const e = this.value, t = 8 - (this.bits & 7);
    if (t === 8 || e.length === 0)
      return e;
    const i = Buffer.alloc(e.length);
    i[0] = e[0] >>> t;
    for (let n = 1; n < e.length; n++)
      i[n] = e[n - 1] << 8 - t, i[n] |= e[n] >>> t;
    return i;
  }
  getBit(e) {
    if (Ve(e >>> 0 === e), e < 0 || e > this.bits)
      return 0;
    const t = e >>> 3, i = 7 - (e & 7);
    return this.value[t] >>> i & 1;
  }
  setBit(e, t) {
    if (Ve(e >>> 0 === e), e < 0 || e > this.bits)
      return this;
    const i = e >>> 3, n = 7 - (e & 7);
    return t ? this.value[i] |= 1 << n : this.value[i] &= ~(1 << n), this;
  }
  set(e) {
    return e == null && (e = sn), typeof e == "number" ? (Ve(e >>> 0 === e), this.bits = e, this.value = Buffer.alloc(e + 7 >>> 3)) : (Ve(Buffer.isBuffer(e)), this.bits = e.length * 8, this.value = e), this;
  }
  clean() {
    return this.bits === 0 && this.value.length === 0;
  }
  format() {
    let e = this.rightAlign();
    return e.length > 32 && (e = e.slice(0, 32)), `<${this.constructor.name}: ${this.bits}:${e.toString("hex")}>`;
  }
}
class z5 extends r0 {
  constructor(...e) {
    super(), this.value = sn, this.from(...e);
  }
  get type() {
    return xt.OCTSTRING;
  }
  getBodySize() {
    return this.value.length;
  }
  writeBody(e) {
    return e.writeBytes(this.value), e;
  }
  readBody(e) {
    return this.value = e.readBytes(e.left()), this;
  }
  set(e) {
    return e == null && (e = sn), Ve(Buffer.isBuffer(e)), this.value = e, this;
  }
  clean() {
    return this.value.length === 0;
  }
  format() {
    let e = this.value;
    return e.length > 32 && (e = e.slice(0, 32)), `<${this.constructor.name}: ${e.toString("hex")}>`;
  }
}
class to extends r0 {
  constructor(...e) {
    super(), this.from(...e);
  }
  get type() {
    return xt.NULL;
  }
  getBodySize() {
    return 0;
  }
  writeBody(e) {
    return e;
  }
  readBody(e) {
    if (e.left() !== 0)
      throw new Error("Non-minimal NULL.");
    return this;
  }
  clean() {
    return !0;
  }
  format() {
    return `<${this.constructor.name}>`;
  }
}
class Ho extends r0 {
  constructor(...e) {
    super(), this.value = Kc, this.from(...e);
  }
  get type() {
    return xt.OID;
  }
  getBodySize() {
    const e = this.value;
    if (e.length < 2 || e[0] > 2 || e[0] < 2 && e[1] >= 40)
      throw new Error("Invalid OID.");
    let t = zu(e[0] * 40 + e[1]);
    for (let i = 2; i < e.length; i++)
      t += zu(e[i]);
    return t;
  }
  writeBody(e) {
    const t = this.value, i = e.data;
    if (t.length < 2 || t[0] > 2 || t[0] < 2 && t[1] >= 40)
      throw new Error("Invalid OID.");
    let n = e.offset;
    n = g3(i, t[0] * 40 + t[1], n);
    for (let c = 2; c < t.length; c++)
      n = g3(i, t[c], n);
    return e.offset = n, e;
  }
  readBody(e) {
    const t = e.readBytes(e.left(), !0);
    if (t.length === 0)
      throw new Error("Zero length OID.");
    const i = new Uint32Array(t.length + 1);
    let [n, c] = Uu(t, 0);
    n < 80 ? (i[0] = n / 40 >>> 0, i[1] = n % 40) : (i[0] = 2, i[1] = n - 80);
    let o = 2;
    for (; c < t.length; o++)
      [n, c] = Uu(t, c), i[o] = n;
    return this.value = i.subarray(0, o), this;
  }
  equals(e) {
    return Ve(e instanceof Ho), w3(this.value, e.value);
  }
  set(e) {
    return e == null && (e = Kc), typeof e == "string" ? this.fromString(e) : Array.isArray(e) ? this.fromArray(e) : (Ve(e instanceof Uint32Array), this.value = e, this);
  }
  clean() {
    return w3(this.value, Kc);
  }
  toArray() {
    const e = [];
    for (let t = 0; t < this.value.length; t++)
      e.push(this.value[t]);
    return e;
  }
  fromArray(e) {
    Ve(Array.isArray(e));
    const t = new Uint32Array(e.length);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Ve(n >>> 0 === n), t[i] = n;
    }
    return this.value = t, this;
  }
  toString() {
    let e = "";
    for (let t = 0; t < this.value.length; t++)
      t > 0 && (e += "."), e += this.value[t].toString(10);
    return e;
  }
  fromString(e) {
    Ve(typeof e == "string"), kr.attrs.hasOwnProperty(e) ? e = kr.attrs[e] : kr.keyAlgs.hasOwnProperty(e) ? e = kr.keyAlgs[e] : kr.hashes.hasOwnProperty(e) ? e = kr.hashes[e] : kr.curves.hasOwnProperty(e) && (e = kr.curves[e]);
    const t = e.split("."), i = new Uint32Array(t.length);
    for (let n = 0; n < t.length; n++) {
      const c = t[n];
      i[n] = y0(c);
    }
    return this.value = i, this;
  }
  getAttributeName() {
    return kr.attrsByVal[this.toString()] || null;
  }
  getSignatureAlgorithmName() {
    return kr.sigAlgsByVal[this.toString()] || null;
  }
  getSignatureHash() {
    return kr.sigToHash[this.toString()] || null;
  }
  getSignatureHashName() {
    const e = this.getSignatureHash();
    return e && kr.hashesByVal[e] || null;
  }
  getKeyAlgorithmName() {
    return kr.keyAlgsByVal[this.toString()] || null;
  }
  getHashName() {
    return kr.hashesByVal[this.toString()] || null;
  }
  getCurveName() {
    return kr.curvesByVal[this.toString()] || null;
  }
  format() {
    const e = this.toString(), t = kr.attrsByVal[e] || kr.sigAlgsByVal[e] || kr.keyAlgsByVal[e] || kr.hashesByVal[e] || kr.curvesByVal[e] || "UNKNOWN", i = `${e} (${t})`;
    return `<${this.constructor.name}: ${i}>`;
  }
}
class U5 extends $o {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.ENUM;
  }
}
class C5 extends _s {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.UTF8STRING;
  }
  get encoding() {
    return "utf8";
  }
}
class ll extends r0 {
  constructor(...e) {
    super(), this.value = sn, this.from(...e);
  }
  get type() {
    return xt.SEQUENCE;
  }
  getBodySize() {
    return this.value.length;
  }
  writeBody(e) {
    return e.writeBytes(this.value), e;
  }
  readBody(e) {
    return this.value = e.readBytes(e.left()), this;
  }
  set(e) {
    return e == null && (e = sn), Array.isArray(e) ? this.fromArray(e) : (Ve(Buffer.isBuffer(e)), this.value = e, this);
  }
  clean() {
    return this.value.length === 0;
  }
  *children() {
    const e = Ss.read(this.value);
    for (; e.left(); )
      yield k5.read(e).node;
  }
  toArray() {
    const e = [];
    for (const t of this.children())
      e.push(t);
    return e;
  }
  fromArray(e) {
    Ve(Array.isArray(e));
    let t = 0;
    for (const n of e)
      Ve(n instanceof r0), t += n.getSize();
    const i = Ss.write(t);
    for (const n of e)
      n.write(i);
    return this.value = i.render(), this;
  }
  format() {
    return this.toArray();
  }
}
class T5 extends ll {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.SET;
  }
}
class D5 extends _s {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.NUMSTRING;
  }
}
class L5 extends _s {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.PRINTSTRING;
  }
}
class K5 extends _s {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.T61STRING;
  }
}
class $5 extends _s {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.IA5STRING;
  }
}
let xl = class extends r0 {
  constructor(...e) {
    super(), this.value = 0, this.offset = 0, this.from(...e);
  }
  set(e, t) {
    return e == null && (e = 0), t == null && (t = 0), typeof e == "string" ? this.fromString(e) : (Ve(qf(e)), Ve(pl(t)), this.value = e, this.offset = t, this);
  }
  clean() {
    return this.value === 0 && this.offset === 0;
  }
  unix() {
    return this.value - this.offset;
  }
  toString() {
    return new Date(this.value * 1e3).toISOString().slice(0, -5) + ml(this.offset);
  }
  fromString(e) {
    Ve(typeof e == "string");
    const t = Date.parse(e);
    if (t !== t)
      throw new Error("Invalid date string.");
    const i = Math.floor(t / 1e3);
    if (!qf(i))
      throw new Error("Invalid time.");
    return this.value = i, this.offset = 0, this;
  }
  format() {
    const e = this.constructor.name, t = this.value;
    let i = this.offset.toString(10);
    return this.offset >= 0 && (i = "+" + i), `<${e}: ${t}${i} (${this.toString()})>`;
  }
};
class H5 extends xl {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.UTCTIME;
  }
  getBodySize() {
    return this.offset === 0 ? 13 : 17;
  }
  writeBody(e) {
    Ve(qf(this.value));
    const t = new Date(this.value * 1e3);
    let i = "";
    return i += G0(t.getUTCFullYear() % 100), i += G0(t.getUTCMonth() + 1), i += G0(t.getUTCDate()), i += G0(t.getUTCHours()), i += G0(t.getUTCMinutes()), i += G0(t.getUTCSeconds()), i += ml(this.offset), e.writeString(i, "binary"), e;
  }
  readBody(e) {
    const t = e.left();
    if (t !== 13 && t !== 17)
      throw new Error("Invalid UTCTIME.");
    const i = e.readString(t, "binary"), n = y0(i.substring(0, 2)), c = y0(i.substring(2, 4)), o = y0(i.substring(4, 6)), d = y0(i.substring(6, 8)), l = y0(i.substring(8, 10)), h = y0(i.substring(10, 12));
    return this.value = G5(n, c, o, d, l, h, !0), this.offset = Y5(i.substring(12)), this;
  }
}
class F5 extends xl {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.GENTIME;
  }
  getBodySize() {
    return this.offset === 0 ? 15 : 19;
  }
  writeBody(e) {
    Ve(qf(this.value));
    const t = new Date(this.value * 1e3);
    let i = "";
    return i += t.getUTCFullYear().toString(10), i += G0(t.getUTCMonth() + 1), i += G0(t.getUTCDate()), i += G0(t.getUTCHours()), i += G0(t.getUTCMinutes()), i += G0(t.getUTCSeconds()), i += ml(this.offset), e.writeString(i, "binary"), e;
  }
  readBody(e) {
    const t = e.left();
    if (t !== 15 && t !== 19)
      throw new Error("Invalid GENTIME.");
    const i = e.readString(t, "binary"), n = y0(i.substring(0, 4)), c = y0(i.substring(4, 6)), o = y0(i.substring(6, 8)), d = y0(i.substring(8, 10)), l = y0(i.substring(10, 12)), h = y0(i.substring(12, 14));
    return this.value = G5(n, c, o, d, l, h, !1), this.offset = Y5(i.substring(14)), this;
  }
}
class V5 extends _s {
  constructor(...e) {
    super(...e);
  }
  get type() {
    return xt.GENSTRING;
  }
}
function bl(r) {
  switch (Ve(r >>> 0 === r), r) {
    case xt.BOOLEAN:
      return ul;
    case xt.INTEGER:
      return $o;
    case xt.BITSTRING:
      return q5;
    case xt.OCTSTRING:
      return z5;
    case xt.NULL:
      return to;
    case xt.OID:
      return Ho;
    case xt.ENUM:
      return U5;
    case xt.UTF8STRING:
      return C5;
    case xt.SEQUENCE:
      return ll;
    case xt.SET:
      return T5;
    case xt.NUMSTRING:
      return D5;
    case xt.PRINTSTRING:
      return L5;
    case xt.T61STRING:
      return K5;
    case xt.IA5STRING:
      return $5;
    case xt.UTCTIME:
      return H5;
    case xt.GENTIME:
      return F5;
    case xt.GENSTRING:
      return V5;
    default:
      throw new Error(`Unknown type: ${r}.`);
  }
}
function vh(r) {
  return Ve(r >>> 0 === r), r <= 127 ? 1 + 1 : r <= 255 ? 1 + 1 + 1 : r <= 65535 ? 1 + 1 + 2 : (Ve(r <= 16777215), 1 + 1 + 3);
}
function Eh(r, e, t, i, n) {
  return Ve(r), Ve(e >>> 0 === e), Ve(t >>> 0 === t), Ve(typeof i == "boolean"), Ve(n >>> 0 === n), i || (e |= 32), e |= t << 6, n <= 127 ? (r.writeU8(e), r.writeU8(n), r) : n <= 255 ? (r.writeU8(e), r.writeU8(129), r.writeU8(n), r) : n <= 65535 ? (r.writeU8(e), r.writeU8(130), r.writeU16BE(n), r) : (Ve(n <= 16777215), r.writeU8(e), r.writeU8(131), r.writeU24BE(n), r);
}
function $w(r) {
  const e = r.offset, t = r.readU8(), i = t >>> 6, n = (t & 32) === 0;
  let c = t & 31;
  if (c === 31 && ([c, r.offset] = Uu(r.data, r.offset), c < 31))
    throw new Error("Non-minimal type.");
  switch (i) {
    case is.UNIVERSAL:
    case is.CONTEXT:
      break;
    default:
      throw new Error("Unknown class.");
  }
  const o = Hw(r), d = r.offset - e;
  return {
    type: c,
    cls: i,
    primitive: n,
    size: o,
    len: d
  };
}
function Af(r, e) {
  const t = r.offset;
  let i = null, n = null;
  try {
    i = $w(r);
  } catch (c) {
    n = c;
  }
  if (r.offset = t, !e && !i)
    throw n;
  return i;
}
function Hw(r) {
  const e = r.readU8(), t = e & 127;
  if (!(e & 128))
    return t;
  if (t === 0)
    throw new Error("Indefinite length.");
  let i = 0;
  for (let n = 0; n < t; n++) {
    const c = r.readU8();
    if (i >= 1 << 24)
      throw new Error("Length too large.");
    if (i *= 256, i += c, i === 0)
      throw new Error("Unexpected leading zeroes.");
  }
  if (i < 128)
    throw new Error("Non-minimal length.");
  return i;
}
function zu(r) {
  if (Ve(r >>> 0 === r), r === 0)
    return 1;
  let e = 0;
  for (; r > 0; )
    e += 1, r >>>= 7;
  return e;
}
function g3(r, e, t) {
  Ve(Buffer.isBuffer(r)), Ve(e >>> 0 === e), Ve(t >>> 0 === t);
  const i = zu(e);
  for (let n = i - 1; n >= 0; n--) {
    let c = e >>> n * 7;
    if (c &= 127, n !== 0 && (c |= 128), t >= r.length)
      throw new Ss.EncodingError(t, "Out of bounds write");
    r[t] = c, t += 1;
  }
  return t;
}
function Uu(r, e) {
  Ve(Buffer.isBuffer(r)), Ve(e >>> 0 === e);
  let t = 0, i = 0;
  for (; e < r.length; t++) {
    if (t === 5)
      throw new Error("Base128 integer too large.");
    const n = r[e];
    if (i *= 128, i += n & 127, e += 1, !(n & 128)) {
      if (i > 4294967295)
        throw new Error("Base128 integer too large.");
      return [i, e];
    }
  }
  throw new Error("Base128 integer too short.");
}
function G0(r) {
  return r < 10 ? "0" + r.toString(10) : r.toString(10);
}
function Fw(r) {
  Ve(typeof r == "string");
  for (let e = 0; e < r.length; e++) {
    const t = r.charCodeAt(e);
    if (!(t >= 48 && t <= 57) && t !== 32)
      return !1;
  }
  return !0;
}
function Vw(r) {
  Ve(typeof r == "string");
  for (let e = 0; e < r.length; e++) {
    const t = r.charCodeAt(e);
    if (!(t >= 48 && t <= 57) && !(t >= 65 && t <= 90) && !(t >= 97 && t <= 122)) {
      switch (t) {
        case 32:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 61:
        case 63:
          continue;
      }
      return !1;
    }
  }
  return !0;
}
function Gw(r) {
  Ve(typeof r == "string");
  for (let e = 0; e < r.length; e++)
    if (r.charCodeAt(e) >= 128)
      return !1;
  return !0;
}
function y0(r) {
  Ve(typeof r == "string");
  let e = 0;
  if (r.length === 0 || r.length > 10)
    throw new Error("Invalid integer.");
  for (let t = 0; t < r.length; t++) {
    const i = r.charCodeAt(t) - 48;
    if (i < 0 || i > 9)
      throw new Error("Invalid integer.");
    if (e *= 10, e += i, e > 4294967295)
      throw new Error("Invalid integer.");
  }
  return e;
}
function w3(r, e) {
  if (Ve(r instanceof Uint32Array), Ve(e instanceof Uint32Array), r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
function Ih(r) {
  if (Ve(Buffer.isBuffer(r)), r.length === 0)
    return Buffer.from([0]);
  if (r[0] !== 0)
    return r;
  for (let e = 1; e < r.length; e++)
    if (r[e] !== 0)
      return r.slice(e);
  return r.slice(-1);
}
function y3(r, e, t) {
  Ve(Buffer.isBuffer(r)), Ve(e >>> 0 === e), Ve(t >>> 0 === t), Ve(e <= t);
  let i = 1;
  for (let n = t - 1; n >= e; n--)
    i += r[n] ^ 255, r[n] = i & 255, i >>>= 8;
  return r;
}
function qf(r) {
  return !(!Number.isSafeInteger(r) || r < Rw || r > kw);
}
function G5(r, e, t, i, n, c, o) {
  if (Ve(r >>> 0 === r), Ve(e >>> 0 === e), Ve(t >>> 0 === t), Ve(i >>> 0 === i), Ve(n >>> 0 === n), Ve(c >>> 0 === c), Ve(typeof o == "boolean"), o && (r < 70 ? r = 2e3 + r : r = 1900 + r), r > 275760)
    throw new Error("Invalid year.");
  if (e < 1 || e > 12 || t < 1 || t > 32)
    throw new Error("Invalid month or day.");
  if (i > 23 || n > 59 || c > 59)
    throw new Error("Invalid hours, minutes, or seconds.");
  const d = Date.UTC(r, e - 1, t, i, n, c, 0);
  Ve(d === d);
  const l = d / 1e3;
  return Ve(qf(l)), l;
}
function pl(r) {
  return !(!Number.isSafeInteger(r) || r < qw || r > zw);
}
function ml(r) {
  if (Ve(pl(r)), r === 0)
    return "Z";
  let e = "";
  r < 0 ? (e += "-", r = -r) : e += "+";
  const t = r / 60 >>> 0, i = t / 60 >>> 0, n = t % 60;
  return e += G0(i), e += G0(n), e;
}
function Y5(r) {
  if (Ve(typeof r == "string"), r.length === 0)
    throw new Error("Invalid time offset.");
  const e = r[0];
  switch (e) {
    case "Z": {
      if (r.length !== 1)
        throw new Error("Non-minimal time offset.");
      return 0;
    }
    case "+":
    case "-": {
      if (r.length !== 5)
        throw new Error("Non-minimal time offset.");
      const t = y0(r.substring(1, 3)), i = y0(r.substring(3, 5));
      let c = (t * 60 + i) * 60;
      if (e === "-" && (c = -c), !pl(c))
        throw new Error("Not a time zone.");
      return c;
    }
  }
  throw new Error("Invalid time offset.");
}
ut.EMPTY = sn;
ut.ZERO = Lc;
ut.EMPTY_OID = Kc;
ut.types = xt;
ut.typesByVal = Uw;
ut.classes = is;
ut.classesByVal = Cw;
ut.objects = kr;
ut.TARGET = ku;
ut.OPTIONAL = $c;
ut.MODE = qu;
ut.NORMAL = kf;
ut.EXPLICIT = Bf;
ut.IMPLICIT = Hc;
ut.Node = r0;
ut.Sequence = Tw;
ut.Set = Dw;
ut.Any = k5;
ut.Choice = Lw;
ut.Str = _s;
ut.String = _s;
ut.Bool = ul;
ut.Boolean = ul;
ut.Integer = $o;
ut.Unsigned = Kw;
ut.BitString = q5;
ut.OctString = z5;
ut.Null = to;
ut.OID = Ho;
ut.Enum = U5;
ut.Utf8String = C5;
ut.RawSequence = ll;
ut.RawSet = T5;
ut.NumString = D5;
ut.PrintString = L5;
ut.T61String = K5;
ut.IA5String = $5;
ut.Time = xl;
ut.UTCTime = H5;
ut.GenTime = F5;
ut.GenString = V5;
ut.typeToClass = bl;
var Cu = { exports: {} }, Fi = {};
/*!
 * base16.js - base16 for javascript
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */
var S3;
function Yw() {
  if (S3)
    return Fi;
  S3 = 1;
  const r = _e, e = "0123456789abcdef", t = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function i(g, w) {
    r(Buffer.isBuffer(g));
    let I = g.length, B = w < 0 ? I - 1 : 0, y = "";
    for (; I--; )
      y += e[g[B] >> 4], y += e[g[B] & 15], B += w;
    return y;
  }
  function n(g, w) {
    r(typeof g == "string");
    let I = g.length, B = w < 0 ? I - 2 : 0, y = 0, A = 0;
    if (I & 1)
      throw new Error("Invalid hex string.");
    I >>>= 1, w *= 2;
    const _ = Buffer.alloc(I);
    for (; I--; ) {
      const q = g.charCodeAt(B + 0), U = g.charCodeAt(B + 1), z = t[q & 127], E = t[U & 127];
      A |= q | U | z | E, _[y++] = z << 4 | E, B += w;
    }
    if (A & 4294967168)
      throw new Error("Invalid hex string.");
    return _;
  }
  function c(g) {
    if (r(typeof g == "string"), g.length & 1)
      return !1;
    for (let w = 0; w < g.length; w++) {
      const I = g.charCodeAt(w);
      if (I & 65408 || t[I] === -1)
        return !1;
    }
    return !0;
  }
  function o(g) {
    return i(g, 1);
  }
  function d(g) {
    return n(g, 1);
  }
  function l(g) {
    return c(g);
  }
  function h(g) {
    return i(g, -1);
  }
  function x(g) {
    return n(g, -1);
  }
  function b(g) {
    return c(g);
  }
  return Fi.native = 0, Fi.encode = o, Fi.decode = d, Fi.test = l, Fi.encodeLE = h, Fi.decodeLE = x, Fi.testLE = b, Fi;
}
var Vi = {};
/*!
 * base16.js - base16 for javascript
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var B3;
function Jw() {
  if (B3)
    return Vi;
  B3 = 1;
  const r = _e, e = Dt();
  function t(l) {
    return r(Buffer.isBuffer(l)), e.base16_encode(l);
  }
  function i(l) {
    return r(typeof l == "string"), e.base16_decode(l);
  }
  function n(l) {
    return r(typeof l == "string"), e.base16_test(l);
  }
  function c(l) {
    return r(Buffer.isBuffer(l)), e.base16le_encode(l);
  }
  function o(l) {
    return r(typeof l == "string"), e.base16le_decode(l);
  }
  function d(l) {
    return r(typeof l == "string"), e.base16le_test(l);
  }
  return Vi.native = 2, Vi.encode = t, Vi.decode = i, Vi.test = n, Vi.encodeLE = c, Vi.decodeLE = o, Vi.testLE = d, Vi;
}
/*!
 * base16.js - base16 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Cu.exports = Yw() : Cu.exports = Jw();
var Xw = Cu.exports, Tu = { exports: {} }, Gi = {};
/*!
 * base32.js - base32 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 *   https://github.com/bitcoin/bitcoin/blob/11d486d/src/utilstrencodings.cpp#L230
 */
var v3;
function Zw() {
  if (v3)
    return Gi;
  v3 = 1;
  const r = _e, e = "abcdefghijklmnopqrstuvwxyz234567", t = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1
  ], i = "0123456789abcdefghijklmnopqrstuv", n = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ], c = [0, 6, 4, 3, 1];
  function o(y, A, _) {
    r(Buffer.isBuffer(y)), r(typeof _ == "boolean");
    let q = "", U = 0, z = 0;
    for (let E = 0; E < y.length; E++) {
      const H = y[E];
      switch (U) {
        case 0:
          q += A[H >>> 3], z = (H & 7) << 2, U = 1;
          break;
        case 1:
          q += A[z | H >>> 6], q += A[H >>> 1 & 31], z = (H & 1) << 4, U = 2;
          break;
        case 2:
          q += A[z | H >>> 4], z = (H & 15) << 1, U = 3;
          break;
        case 3:
          q += A[z | H >>> 7], q += A[H >>> 2 & 31], z = (H & 3) << 3, U = 4;
          break;
        case 4:
          q += A[z | H >>> 5], q += A[H & 31], U = 0;
          break;
      }
    }
    if (U > 0 && (q += A[z], _))
      for (let E = 0; E < c[U]; E++)
        q += "=";
    return q;
  }
  function d(y, A, _) {
    r(typeof y == "string"), r(typeof _ == "boolean");
    const q = l(y), U = Buffer.alloc(q);
    let z = 0, E = 0, H = 0, k = 0;
    for (; k < y.length; k++) {
      const V = y.charCodeAt(k);
      if (V & 65408)
        throw new Error("Invalid base32 string.");
      const T = A[V];
      if (T === -1)
        break;
      switch (z) {
        case 0:
          E = T, z = 1;
          break;
        case 1:
          U[H++] = E << 3 | T >>> 2, E = T & 3, z = 2;
          break;
        case 2:
          E = E << 5 | T, z = 3;
          break;
        case 3:
          U[H++] = E << 1 | T >>> 4, E = T & 15, z = 4;
          break;
        case 4:
          U[H++] = E << 4 | T >>> 1, E = T & 1, z = 5;
          break;
        case 5:
          E = E << 5 | T, z = 6;
          break;
        case 6:
          U[H++] = E << 2 | T >>> 3, E = T & 7, z = 7;
          break;
        case 7:
          U[H++] = E << 5 | T, E = 0, z = 0;
          break;
      }
    }
    if (z === 1 || z === 3 || z === 6)
      throw new Error("Invalid base32 string.");
    if (E > 0)
      throw new Error("Invalid base32 string.");
    if (y.length !== k + (-z & 7) * _)
      throw new Error("Invalid base32 string.");
    for (; k < y.length; k++)
      if (y.charCodeAt(k) !== 61)
        throw new Error("Invalid base32 string.");
    return r(H === q), U;
  }
  function l(y) {
    let A = y.length;
    for (let q = 0; q < 6 && A > 0; q++)
      y[A - 1] === "=" && (A -= 1);
    let _ = (A >>> 3) * 5;
    switch (A & 7) {
      case 7:
        _ += 1;
      case 6:
      case 5:
        _ += 1;
      case 4:
        _ += 1;
      case 3:
      case 2:
        _ += 1;
    }
    return _;
  }
  function h(y, A, _) {
    r(typeof y == "string"), r(typeof _ == "boolean");
    let q = 0;
    for (; q < y.length; q++) {
      const z = y.charCodeAt(q);
      if (z & 65408)
        return !1;
      if (A[z] === -1)
        break;
    }
    const U = q & 7;
    switch (U) {
      case 1:
        return !1;
      case 2:
        if (A[y.charCodeAt(q - 1)] & 3)
          return !1;
        break;
      case 3:
        return !1;
      case 4:
        if (A[y.charCodeAt(q - 1)] & 15)
          return !1;
        break;
      case 5:
        if (A[y.charCodeAt(q - 1)] & 1)
          return !1;
        break;
      case 6:
        return !1;
      case 7:
        if (A[y.charCodeAt(q - 1)] & 7)
          return !1;
        break;
    }
    if (y.length !== q + (-U & 7) * _)
      return !1;
    for (; q < y.length; q++)
      if (y.charCodeAt(q) !== 61)
        return !1;
    return !0;
  }
  function x(y, A = !1) {
    return o(y, e, A);
  }
  function b(y, A = !1) {
    return d(y, t, A);
  }
  function g(y, A = !1) {
    return h(y, t, A);
  }
  function w(y, A = !1) {
    return o(y, i, A);
  }
  function I(y, A = !1) {
    return d(y, n, A);
  }
  function B(y, A = !1) {
    return h(y, n, A);
  }
  return Gi.native = 0, Gi.encode = x, Gi.decode = b, Gi.test = g, Gi.encodeHex = w, Gi.decodeHex = I, Gi.testHex = B, Gi;
}
var Yi = {};
/*!
 * base32.js - base32 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var E3;
function Ww() {
  if (E3)
    return Yi;
  E3 = 1;
  const r = _e, e = Dt();
  function t(l, h = !1) {
    return r(Buffer.isBuffer(l)), r(typeof h == "boolean"), e.base32_encode(l, h);
  }
  function i(l, h = !1) {
    return r(typeof l == "string"), r(typeof h == "boolean"), e.base32_decode(l, h);
  }
  function n(l, h = !1) {
    return r(typeof l == "string"), r(typeof h == "boolean"), e.base32_test(l, h);
  }
  function c(l, h = !1) {
    return r(Buffer.isBuffer(l)), r(typeof h == "boolean"), e.base32hex_encode(l, h);
  }
  function o(l, h = !1) {
    return r(typeof l == "string"), r(typeof h == "boolean"), e.base32hex_decode(l, h);
  }
  function d(l, h = !1) {
    return r(typeof l == "string"), r(typeof h == "boolean"), e.base32hex_test(l, h);
  }
  return Yi.native = 2, Yi.encode = t, Yi.decode = i, Yi.test = n, Yi.encodeHex = c, Yi.decodeHex = o, Yi.testHex = d, Yi;
}
/*!
 * base32.js - base32 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Tu.exports = Zw() : Tu.exports = Ww();
var jw = Tu.exports, Du = { exports: {} }, dn = {};
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
 */
var I3;
function Qw() {
  if (I3)
    return dn;
  I3 = 1;
  const r = _e, e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", t = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    -1,
    17,
    18,
    19,
    20,
    21,
    -1,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    -1,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    -1,
    -1,
    -1,
    -1,
    -1
  ], i = Buffer.alloc(128);
  function n(d) {
    r(Buffer.isBuffer(d));
    let l = 0, h = 0;
    for (; h < d.length && d[h] === 0; h++)
      l += 1;
    const x = ((d.length - l) * 138 / 100 | 0) + 1, b = x <= 128 ? i.fill(0) : Buffer.alloc(x);
    let g = 0;
    for (; h < d.length; h++) {
      let I = d[h], B = 0;
      for (let y = x - 1; y >= 0 && !(I === 0 && B >= g); y--, B++)
        I += b[y] * 256, b[y] = I % 58, I = I / 58 | 0;
      r(I === 0), g = B;
    }
    for (h = x - g; h < x && b[h] === 0; )
      h += 1;
    let w = "";
    for (let I = 0; I < l; I++)
      w += "1";
    for (; h < x; )
      w += e[b[h++]];
    return w;
  }
  function c(d) {
    r(typeof d == "string");
    let l = 0, h = 0;
    for (; h < d.length && d[h] === "1"; h++)
      l += 1;
    const x = (d.length * 733 / 1e3 | 0) + 1, b = x <= 128 ? i.fill(0) : Buffer.alloc(x);
    let g = 0;
    for (; h < d.length; h++) {
      const B = d.charCodeAt(h);
      if (B & 65408)
        throw new Error("Invalid base58 string.");
      const y = t[B];
      if (y === -1)
        throw new Error("Invalid base58 string.");
      let A = y, _ = 0;
      for (let q = x - 1; q >= 0 && !(A === 0 && _ >= g); q--, _++)
        A += b[q] * 58, b[q] = A, A >>>= 8;
      r(A === 0), g = _;
    }
    h = x - g;
    const w = Buffer.alloc(l + (x - h));
    let I;
    for (I = 0; I < l; I++)
      w[I] = 0;
    for (; h < x; )
      w[I++] = b[h++];
    return w;
  }
  function o(d) {
    r(typeof d == "string");
    for (let l = 0; l < d.length; l++) {
      const h = d.charCodeAt(l);
      if (h & 65408 || t[h] === -1)
        return !1;
    }
    return !0;
  }
  return dn.native = 0, dn.encode = n, dn.decode = c, dn.test = o, dn;
}
var un = {};
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var A3;
function ey() {
  if (A3)
    return un;
  A3 = 1;
  const r = _e, e = Dt();
  function t(c) {
    return r(Buffer.isBuffer(c)), e.base58_encode(c);
  }
  function i(c) {
    r(typeof c == "string");
    const { buffer: o, length: d } = e.base58_decode(c);
    return Buffer.from(o, 0, d);
  }
  function n(c) {
    return r(typeof c == "string"), e.base58_test(c);
  }
  return un.native = 2, un.encode = t, un.decode = i, un.test = n, un;
}
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Du.exports = Qw() : Du.exports = ey();
var ty = Du.exports, Lu = { exports: {} }, Ji = {};
/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */
var _3;
function ry() {
  if (_3)
    return Ji;
  _3 = 1;
  const r = _e, e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", i = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ], n = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    63,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function c(y, A, _) {
    r(Buffer.isBuffer(y));
    let q = y.length, U = "", z = 0;
    for (; q >= 3; ) {
      const E = y[z++], H = y[z++], k = y[z++];
      U += A[E >> 2], U += A[(E & 3) << 4 | H >> 4], U += A[(H & 15) << 2 | k >> 6], U += A[k & 63], q -= 3;
    }
    switch (q) {
      case 1: {
        const E = y[z++];
        U += A[E >> 2], U += A[(E & 3) << 4], _ && (U += "==");
        break;
      }
      case 2: {
        const E = y[z++], H = y[z++];
        U += A[E >> 2], U += A[(E & 3) << 4 | H >> 4], U += A[(H & 15) << 2], _ && (U += "=");
        break;
      }
    }
    return U;
  }
  function o(y, A, _) {
    r(typeof y == "string");
    const q = Buffer.alloc(_);
    let U = y.length, z = 0, E = 0;
    if (U > 0 && y[U - 1] === "=" && (U -= 1), U > 0 && y[U - 1] === "=" && (U -= 1), (U & 3) === 1)
      throw new Error("Invalid base64 string.");
    for (; U >= 4; ) {
      const H = y.charCodeAt(z++), k = y.charCodeAt(z++), V = y.charCodeAt(z++), T = y.charCodeAt(z++);
      if ((H | k | V | T) & 65408)
        throw new Error("Invalid base64 string.");
      const ie = A[H], N = A[k], G = A[V], F = A[T];
      if ((ie | N | G | F) < 0)
        throw new Error("Invalid base64 string.");
      q[E++] = ie << 2 | N >> 4, q[E++] = N << 4 | G >> 2, q[E++] = G << 6 | F >> 0, U -= 4;
    }
    switch (U) {
      case 1:
        throw new Error("Invalid base64 string.");
      case 2: {
        const H = y.charCodeAt(z++), k = y.charCodeAt(z++);
        if ((H | k) & 65408)
          throw new Error("Invalid base64 string.");
        const V = A[H], T = A[k];
        if ((V | T) < 0)
          throw new Error("Invalid base64 string.");
        if (q[E++] = V << 2 | T >> 4, T & 15)
          throw new Error("Invalid base64 string.");
        break;
      }
      case 3: {
        const H = y.charCodeAt(z++), k = y.charCodeAt(z++), V = y.charCodeAt(z++);
        if ((H | k | V) & 65408)
          throw new Error("Invalid base64 string.");
        const T = A[H], ie = A[k], N = A[V];
        if ((T | ie | N) < 0)
          throw new Error("Invalid base64 string.");
        if (q[E++] = T << 2 | ie >> 4, q[E++] = ie << 4 | N >> 2, N & 3)
          throw new Error("Invalid base64 string.");
        break;
      }
    }
    return r(E === _), q;
  }
  function d(y, A) {
    r(typeof y == "string");
    let _ = y.length;
    if (_ > 0 && y[_ - 1] === "=" && (_ -= 1), _ > 0 && y[_ - 1] === "=" && (_ -= 1), (_ & 3) === 1)
      return !1;
    for (let q = 0; q < _; q++) {
      const U = y.charCodeAt(q);
      if (U & 65408 || A[U] === -1)
        return !1;
    }
    switch (_ & 3) {
      case 1:
        return !1;
      case 2:
        return (A[y.charCodeAt(_ - 1)] & 15) === 0;
      case 3:
        return (A[y.charCodeAt(_ - 1)] & 3) === 0;
    }
    return !0;
  }
  function l(y) {
    return c(y, e, !0);
  }
  function h(y) {
    const A = I(y);
    if (!B(y, A))
      throw new Error("Invalid base64 padding.");
    return o(y, i, A);
  }
  function x(y) {
    const A = I(y);
    return B(y, A) ? d(y, i) : !1;
  }
  function b(y) {
    return c(y, t, !1);
  }
  function g(y) {
    const A = I(y);
    if (!B(y, 0))
      throw new Error("Invalid base64 padding.");
    return o(y, n, A);
  }
  function w(y) {
    return B(y, 0) ? d(y, n) : !1;
  }
  function I(y) {
    r(typeof y == "string");
    let A = y.length;
    A > 0 && y[A - 1] === "=" && (A -= 1), A > 0 && y[A - 1] === "=" && (A -= 1);
    let _ = (A >>> 2) * 3;
    const q = A & 3;
    return q && (_ += q - 1), _;
  }
  function B(y, A) {
    switch (r(typeof y == "string"), A % 3) {
      case 0:
        return y.length === 0 ? !0 : y.length === 1 ? y[0] !== "=" : y[y.length - 2] !== "=" && y[y.length - 1] !== "=";
      case 1:
        return y.length >= 4 && y[y.length - 2] === "=" && y[y.length - 1] === "=";
      case 2:
        return y.length >= 4 && y[y.length - 2] !== "=" && y[y.length - 1] === "=";
      default:
        throw new Error("unreachable");
    }
  }
  return Ji.native = 0, Ji.encode = l, Ji.decode = h, Ji.test = x, Ji.encodeURL = b, Ji.decodeURL = g, Ji.testURL = w, Ji;
}
var Xi = {};
/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var M3;
function iy() {
  if (M3)
    return Xi;
  M3 = 1;
  const r = _e, e = Dt();
  function t(l) {
    return r(Buffer.isBuffer(l)), e.base64_encode(l);
  }
  function i(l) {
    return r(typeof l == "string"), e.base64_decode(l);
  }
  function n(l) {
    return r(typeof l == "string"), e.base64_test(l);
  }
  function c(l) {
    return r(Buffer.isBuffer(l)), e.base64url_encode(l);
  }
  function o(l) {
    return r(typeof l == "string"), e.base64url_decode(l);
  }
  function d(l) {
    return r(typeof l == "string"), e.base64url_test(l);
  }
  return Xi.native = 2, Xi.encode = t, Xi.decode = i, Xi.test = n, Xi.encodeURL = c, Xi.decodeURL = o, Xi.testURL = d, Xi;
}
/*!
 * base64.js - base64 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Lu.exports = ry() : Lu.exports = iy();
var Fo = Lu.exports;
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bech32:
 *   Copyright (c) 2017, Pieter Wuille (MIT License).
 *   https://github.com/sipa/bech32
 *
 * Resources:
 *   https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 *   https://github.com/sipa/bech32/blob/master/ref/c/segwit_addr.c
 *   https://github.com/bitcoin/bitcoin/blob/master/src/bech32.cpp
 */
var Ah, N3;
function sy() {
  if (N3)
    return Ah;
  N3 = 1;
  const r = _e, e = Buffer.alloc(65), t = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", i = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    15,
    -1,
    10,
    17,
    21,
    20,
    26,
    30,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  class n {
    constructor(o) {
      r(o >>> 0 === o), this.checksum = o, this.native = 0;
    }
    /**
     * Update checksum.
     * @ignore
     * @param {Number} c
     * @returns {Number}
     */
    polymod(o) {
      const d = o >>> 25;
      return (o & 33554431) << 5 ^ 996825010 & -(d >> 0 & 1) ^ 642813549 & -(d >> 1 & 1) ^ 513874426 & -(d >> 2 & 1) ^ 1027748829 & -(d >> 3 & 1) ^ 705979059 & -(d >> 4 & 1);
    }
    /**
     * Encode hrp and data as a bech32 string.
     * @param {String} hrp
     * @param {Buffer} data
     * @returns {String}
     */
    serialize(o, d) {
      if (r(typeof o == "string"), r(Buffer.isBuffer(d)), o.length === 0 || o.length > 83)
        throw new Error("Invalid bech32 human-readable part.");
      if (o.length + 1 + d.length + 6 > 90)
        throw new Error("Invalid bech32 data length.");
      let l = "", h = 1, x;
      for (x = 0; x < o.length; x++) {
        const b = o.charCodeAt(x);
        if (b < 33 || b > 126)
          throw new Error("Invalid bech32 character.");
        if (b >= 65 && b <= 90)
          throw new Error("Invalid bech32 character.");
        h = this.polymod(h) ^ b >> 5;
      }
      h = this.polymod(h);
      for (let b = 0; b < o.length; b++) {
        const g = o.charCodeAt(b);
        h = this.polymod(h) ^ g & 31, l += o[b];
      }
      l += "1";
      for (let b = 0; b < d.length; b++) {
        const g = d[b];
        if (g >> 5)
          throw new Error("Invalid bech32 value.");
        h = this.polymod(h) ^ g, l += t[g];
      }
      for (let b = 0; b < 6; b++)
        h = this.polymod(h);
      h ^= this.checksum;
      for (let b = 0; b < 6; b++)
        l += t[h >>> (5 - b) * 5 & 31];
      return l;
    }
    /**
     * Decode a bech32 string.
     * @param {String} str
     * @returns {Array} [hrp, data]
     */
    deserialize(o) {
      if (r(typeof o == "string"), o.length < 8 || o.length > 90)
        throw new Error("Invalid bech32 string length.");
      let d = !1, l = !1, h = 0;
      for (let B = 0; B < o.length; B++) {
        const y = o.charCodeAt(B);
        if (y < 33 || y > 126)
          throw new Error("Invalid bech32 character.");
        y >= 97 && y <= 122 ? d = !0 : y >= 65 && y <= 90 ? l = !0 : y === 49 && (h = B);
      }
      if (h === 0)
        throw new Error("Invalid bech32 human-readable part.");
      const x = o.length - (h + 1);
      if (x < 6)
        throw new Error("Invalid bech32 data length.");
      if (d && l)
        throw new Error("Invalid bech32 casing.");
      let b = 1, g = "";
      for (let B = 0; B < h; B++) {
        let y = o.charCodeAt(B);
        y >= 65 && y <= 90 && (y += 32), b = this.polymod(b) ^ y >> 5, g += String.fromCharCode(y);
      }
      b = this.polymod(b);
      for (let B = 0; B < h; B++)
        b = this.polymod(b) ^ o.charCodeAt(B) & 31;
      const w = Buffer.alloc(x - 6);
      let I = 0;
      for (let B = h + 1; B < o.length; B++) {
        const y = i[o.charCodeAt(B)];
        if (y === -1)
          throw new Error("Invalid bech32 character.");
        b = this.polymod(b) ^ y, B < o.length - 6 && (w[I++] = y);
      }
      if (b !== this.checksum)
        throw new Error("Invalid bech32 checksum.");
      return r(I === w.length), [g, w];
    }
    /**
     * Test whether a string is a bech32 string.
     * @param {String} str
     * @returns {Boolean}
     */
    is(o) {
      r(typeof o == "string");
      try {
        return this.deserialize(o), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Convert serialized data to another base.
     * @param {Buffer} dst
     * @param {Number} dstoff
     * @param {Number} dstbits
     * @param {Buffer} src
     * @param {Number} srcoff
     * @param {Number} srcbits
     * @param {Boolean} pad
     * @returns {Buffer}
     */
    convert(o, d, l, h, x, b, g) {
      r(Buffer.isBuffer(o)), r(d >>> 0 === d), r(l >>> 0 === l), r(Buffer.isBuffer(h)), r(x >>> 0 === x), r(b >>> 0 === b), r(typeof g == "boolean"), r(l >= 1 && l <= 8), r(b >= 1 && b <= 8);
      const w = (1 << l) - 1;
      let I = 0, B = 0, y = x, A = d;
      for (; y < h.length; y++)
        for (I = I << b | h[y], B += b; B >= l; )
          B -= l, o[A++] = I >>> B & w;
      const _ = l - B;
      if (g)
        B && (o[A++] = I << _ & w);
      else if (I << _ & w || B >= b)
        throw new Error("Invalid bits.");
      return r(A <= o.length), o.slice(0, A);
    }
    /**
     * Calculate size required for bit conversion.
     * @param {Number} len
     * @param {Number} srcbits
     * @param {Number} dstbits
     * @param {Boolean} pad
     * @returns {Number}
     */
    convertSize(o, d, l, h) {
      return r(o >>> 0 === o), r(d >>> 0 === d), r(l >>> 0 === l), r(typeof h == "boolean"), r(d >= 1 && d <= 8), r(l >= 1 && l <= 8), (o * d + (l - 1) * (h | 0)) / l >>> 0;
    }
    /**
     * Convert serialized data to another base.
     * @param {Buffer} data
     * @param {Number} srcbits
     * @param {Number} dstbits
     * @param {Boolean} pad
     * @returns {Buffer}
     */
    convertBits(o, d, l, h) {
      r(Buffer.isBuffer(o));
      const x = this.convertSize(o.length, d, l, h), b = Buffer.alloc(x);
      return this.convert(b, 0, l, o, 0, d, h);
    }
    /**
     * Serialize data to bech32 address.
     * @param {String} hrp
     * @param {Number} version
     * @param {Buffer} hash
     * @returns {String}
     */
    encode(o, d, l) {
      if (r(typeof o == "string"), r(d >>> 0 === d), r(Buffer.isBuffer(l)), d > 31)
        throw new Error("Invalid bech32 version.");
      if (l.length < 2 || l.length > 40)
        throw new Error("Invalid bech32 data length.");
      const h = e;
      h[0] = d;
      const x = this.convert(h, 1, 5, l, 0, 8, !0);
      return this.serialize(o, x);
    }
    /**
     * Deserialize data from bech32 address.
     * @param {String} addr
     * @returns {Array}
     */
    decode(o) {
      const [d, l] = this.deserialize(o);
      if (l.length === 0 || l.length > 65)
        throw new Error("Invalid bech32 data length.");
      const h = l[0];
      if (h > 31)
        throw new Error("Invalid bech32 version.");
      const x = l, b = this.convert(x, 0, 8, l, 1, 5, !1);
      if (b.length < 2 || b.length > 40)
        throw new Error("Invalid bech32 data length.");
      return [d, h, b];
    }
    /**
     * Test whether a string is a bech32 string.
     * @param {String} addr
     * @returns {Boolean}
     */
    test(o) {
      r(typeof o == "string");
      try {
        return this.decode(o), !0;
      } catch {
        return !1;
      }
    }
  }
  return Ah = n, Ah;
}
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var _h, O3;
function ny() {
  if (O3)
    return _h;
  O3 = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n) {
      r(n >>> 0 === n), this.checksum = n, this.native = 2;
    }
    serialize(n, c) {
      return r(typeof n == "string"), r(Buffer.isBuffer(c)), e.bech32_serialize(n, c, this.checksum);
    }
    deserialize(n) {
      return r(typeof n == "string"), e.bech32_deserialize(n, this.checksum);
    }
    is(n) {
      return r(typeof n == "string"), e.bech32_is(n, this.checksum);
    }
    convertBits(n, c, o, d) {
      return r(Buffer.isBuffer(n)), r(c >>> 0 === c), r(o >>> 0 === o), r(typeof d == "boolean"), e.bech32_convert_bits(n, c, o, d);
    }
    encode(n, c, o) {
      return r(typeof n == "string"), r(c >>> 0 === c), r(Buffer.isBuffer(o)), e.bech32_encode(n, c, o, this.checksum);
    }
    decode(n) {
      return r(typeof n == "string"), e.bech32_decode(n, this.checksum);
    }
    test(n) {
      return r(typeof n == "string"), e.bech32_test(n, this.checksum);
    }
  }
  return _h = t, _h;
}
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
let Ku;
process.env.NODE_BACKEND === "js" ? Ku = sy() : Ku = ny();
var fy = new Ku(1), $u = { exports: {} }, Ni = {};
/*!
 * cash32.js - cashaddr for bcrypto
 * Copyright (c) 2018-2020, The Bcoin Developers (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Bitcoin-ABC/bitcoin-abc:
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   Copyright (c) 2009-2017, The Bitcoin Core Developers (MIT License).
 *   https://github.com/Bitcoin-ABC/bitcoin-abc
 *
 * Parts of this software are based on sipa/bech32:
 *   Copyright (c) 2017, Pieter Wuille (MIT License).
 *   https://github.com/sipa/bech32
 *
 * Resources:
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md
 *   https://github.com/Bitcoin-ABC/bitcoin-abc/blob/master/src/cashaddr.cpp
 *   https://github.com/Bitcoin-ABC/bitcoin-abc/blob/master/src/cashaddrenc.cpp
 *   https://github.com/Bitcoin-ABC/bitcoin-abc/blob/master/src/util/strencodings.h
 */
var P3;
function cy() {
  if (P3)
    return Ni;
  P3 = 1;
  const r = _e, e = Buffer.alloc(104), t = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", i = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    15,
    -1,
    10,
    17,
    21,
    20,
    26,
    30,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    29,
    -1,
    24,
    13,
    25,
    9,
    8,
    23,
    -1,
    18,
    22,
    31,
    27,
    19,
    -1,
    1,
    0,
    3,
    16,
    11,
    28,
    12,
    14,
    6,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  function n(B, y) {
    const A = B[1] >>> 3;
    B[0] &= 4294967295, B[1] &= 7, B[1] <<= 5, B[1] |= B[0] >>> 27, B[0] <<= 5, A >>> 0 & 1 && (B[0] ^= 4072443489, B[1] ^= 152), A >>> 1 & 1 && (B[0] ^= 3077413346, B[1] ^= 121), A >>> 2 & 1 && (B[0] ^= 1046459332, B[1] ^= 243), A >>> 3 & 1 && (B[0] ^= 783016616, B[1] ^= 174), A >>> 4 & 1 && (B[0] ^= 1329849456, B[1] ^= 30), B[0] ^= y;
  }
  function c(B, y) {
    if (r(typeof B == "string"), r(Buffer.isBuffer(y)), B.length === 0 || B.length > 83)
      throw new Error("Invalid cash32 prefix.");
    if (y.length > 104)
      throw new Error("Invalid cash32 data.");
    const A = [1, 0];
    let _ = "";
    for (let q = 0; q < B.length; q++) {
      const U = B.charCodeAt(q);
      if (U < 97 || U > 122)
        throw new Error("Invalid cash32 prefix.");
      n(A, U & 31), _ += String.fromCharCode(U);
    }
    n(A, 0), _ += ":";
    for (let q = 0; q < y.length; q++) {
      const U = y[q];
      if (U >> 5)
        throw new Error("Invalid cash32 value.");
      n(A, U), _ += t[U];
    }
    for (let q = 0; q < 8; q++)
      n(A, 0);
    A[0] ^= 1, _ += t[A[1] >>> 3 & 31], _ += t[(A[0] >>> 30 | A[1] << 2) & 31];
    for (let q = 2; q < 8; q++)
      _ += t[A[0] >>> (7 - q) * 5 & 31];
    return _;
  }
  function o(B, y) {
    if (r(typeof B == "string"), r(typeof y == "string"), B.length < 8 || B.length > 196)
      throw new Error("Invalid cash32 string.");
    let A = !1, _ = !1, q = !1, U = 0;
    for (let T = 0; T < B.length; T++) {
      const ie = B.charCodeAt(T);
      if (ie >= 97 && ie <= 122) {
        A = !0;
        continue;
      }
      if (ie >= 65 && ie <= 90) {
        _ = !0;
        continue;
      }
      if (ie >= 48 && ie <= 57) {
        q = !0;
        continue;
      }
      if (ie === 58) {
        if (q || T === 0 || U !== 0)
          throw new Error("Invalid cash32 prefix.");
        U = T;
        continue;
      }
      throw new Error("Invalid cash32 string.");
    }
    if (A && _)
      throw new Error("Invalid cash32 casing.");
    const z = [1, 0];
    let E = "", H;
    if (U === 0) {
      if (y.length === 0 || y.length > 83)
        throw new Error("Invalid cash32 prefix.");
      for (let T = 0; T < y.length; T++) {
        const ie = y.charCodeAt(T);
        if (ie < 97 || ie > 122)
          throw new Error("Invalid cash32 prefix.");
        n(z, ie & 31);
      }
      E = y, H = B.length;
    } else {
      if (U > 83)
        throw new Error("Invalid cash32 prefix.");
      for (let T = 0; T < U; T++) {
        const ie = B.charCodeAt(T) | 32;
        n(z, ie & 31), E += String.fromCharCode(ie);
      }
      H = B.length - (U + 1);
    }
    if (H < 8 || H > 112)
      throw new Error("Invalid cash32 data.");
    n(z, 0);
    const k = Buffer.alloc(H - 8);
    let V = 0;
    for (let T = B.length - H; T < B.length; T++) {
      const ie = i[B.charCodeAt(T)];
      if (ie === -1)
        throw new Error("Invalid cash32 character.");
      n(z, ie), T < B.length - 8 && (k[V++] = ie);
    }
    if (z[0] !== 1 || z[1] !== 0)
      throw new Error("Invalid cash32 checksum.");
    return r(V === k.length), [E, k];
  }
  function d(B, y) {
    r(typeof B == "string"), r(typeof y == "string");
    try {
      return o(B, y), !0;
    } catch {
      return !1;
    }
  }
  function l(B, y, A, _, q, U, z) {
    r(Buffer.isBuffer(B)), r(y >>> 0 === y), r(A >>> 0 === A), r(Buffer.isBuffer(_)), r(q >>> 0 === q), r(U >>> 0 === U), r(typeof z == "boolean"), r(A >= 1 && A <= 8), r(U >= 1 && U <= 8);
    const E = (1 << A) - 1, H = (1 << U + A - 1) - 1;
    let k = 0, V = 0, T = q, ie = y;
    for (; T < _.length; T++)
      for (k = (k << U | _[T]) & H, V += U; V >= A; )
        V -= A, B[ie++] = k >>> V & E;
    const N = A - V;
    if (z)
      V && (B[ie++] = k << N & E);
    else if (V >= U || k << N & E)
      throw new Error("Invalid bits.");
    return r(ie <= B.length), B.slice(0, ie);
  }
  function h(B, y, A, _) {
    return r(B >>> 0 === B), r(y >>> 0 === y), r(A >>> 0 === A), r(typeof _ == "boolean"), r(y >= 1 && y <= 8), r(A >= 1 && A <= 8), (B * y + (A - 1) * (_ | 0)) / A >>> 0;
  }
  function x(B, y, A, _) {
    r(Buffer.isBuffer(B));
    const q = h(B.length, y, A, _), U = Buffer.alloc(q);
    return l(U, 0, A, B, 0, y, _);
  }
  function b(B) {
    switch (r(B >>> 0 === B), B) {
      case 20:
        return 0;
      case 24:
        return 1;
      case 28:
        return 2;
      case 32:
        return 3;
      case 40:
        return 4;
      case 48:
        return 5;
      case 56:
        return 6;
      case 64:
        return 7;
      default:
        throw new Error("Non-standard length.");
    }
  }
  function g(B, y, A) {
    if (r(typeof B == "string"), r(y >>> 0 === y), r(Buffer.isBuffer(A)), y > 15)
      throw new Error("Invalid cash32 type.");
    const _ = b(A.length), q = Buffer.alloc(A.length + 1);
    q[0] = y << 3 | _, A.copy(q, 1);
    const z = l(e, 0, 5, q, 0, 8, !0);
    return c(B, z);
  }
  function w(B, y = "bitcoincash") {
    const [A, _] = o(B, y);
    if (A !== y)
      throw new Error("Invalid cash32 prefix.");
    if (_.length === 0 || _.length > 104)
      throw new Error("Invalid cash32 data.");
    const U = l(_, 0, 8, _, 0, 5, !1);
    if (U.length === 0 || U.length > 1 + 64)
      throw new Error("Invalid cash32 data.");
    const z = U[0] >> 3 & 31, E = U.slice(1);
    let H = 20 + 4 * (U[0] & 3);
    if (U[0] & 4 && (H *= 2), z > 15)
      throw new Error("Invalid cash32 type.");
    if (H !== E.length)
      throw new Error("Invalid cash32 data length.");
    return [z, E];
  }
  function I(B, y = "bitcoincash") {
    r(typeof B == "string"), r(typeof y == "string");
    try {
      return w(B, y), !0;
    } catch {
      return !1;
    }
  }
  return Ni.native = 0, Ni.serialize = c, Ni.deserialize = o, Ni.is = d, Ni.convertBits = x, Ni.encode = g, Ni.decode = w, Ni.test = I, Ni;
}
var Oi = {};
/*!
 * cash32.js - cashaddr for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var R3;
function oy() {
  if (R3)
    return Oi;
  R3 = 1;
  const r = _e, e = Dt();
  function t(h, x) {
    return r(typeof h == "string"), r(Buffer.isBuffer(x)), e.cash32_serialize(h, x);
  }
  function i(h, x) {
    return r(typeof h == "string"), r(typeof x == "string"), e.cash32_deserialize(h, x);
  }
  function n(h, x) {
    return r(typeof h == "string"), r(typeof x == "string"), e.cash32_is(h, x);
  }
  function c(h, x, b, g) {
    return r(Buffer.isBuffer(h)), r(x >>> 0 === x), r(b >>> 0 === b), r(typeof g == "boolean"), e.cash32_convert_bits(h, x, b, g);
  }
  function o(h, x, b) {
    return r(typeof h == "string"), r(x >>> 0 === x), r(Buffer.isBuffer(b)), e.cash32_encode(h, x, b);
  }
  function d(h, x = "bitcoincash") {
    return r(typeof h == "string"), r(typeof x == "string"), e.cash32_decode(h, x);
  }
  function l(h, x = "bitcoincash") {
    return r(typeof h == "string"), r(typeof x == "string"), e.cash32_test(h, x);
  }
  return Oi.native = 2, Oi.serialize = t, Oi.deserialize = i, Oi.is = n, Oi.convertBits = c, Oi.encode = o, Oi.decode = d, Oi.test = l, Oi;
}
/*!
 * cash32.js - cashaddr for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? $u.exports = cy() : $u.exports = oy();
var ay = $u.exports;
/*!
 * lines.js - line reader for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const J5 = _e;
function* hy(r) {
  J5(typeof r == "string");
  let e = 0, t = 0, i = 0;
  for (r.length > 0 && r.charCodeAt(0) === 65279 && (e += 1, t += 1); e < r.length; e++) {
    const n = r.charCodeAt(e);
    switch (n) {
      case 13:
      case 10:
      case 133: {
        if (t !== e) {
          const c = k3(r.substring(t, e));
          c.length > 0 && (yield [i, c]);
        }
        n === 13 && e + 1 < r.length && r.charCodeAt(e + 1) === 10 && (e += 1), t = e + 1, i += 1;
        break;
      }
    }
  }
  if (t !== e) {
    const n = k3(r.substring(t, e));
    n.length > 0 && (yield [i, n]);
  }
}
function k3(r) {
  J5(typeof r == "string");
  for (let e = r.length - 1; e >= 0; e--) {
    switch (r.charCodeAt(e)) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
        continue;
    }
    return r.substring(0, e + 1);
  }
  return r;
}
var X5 = hy, Yf = {}, Yr = {};
/*!
 * pem.js - PEM for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail
 *   https://tools.ietf.org/html/rfc1421
 *   https://tools.ietf.org/html/rfc1422
 *   https://tools.ietf.org/html/rfc1423
 *   https://tools.ietf.org/html/rfc1424
 *   https://tools.ietf.org/html/rfc4880
 *   https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem
 *   https://github.com/crypto-browserify/EVP_BytesToKey/blob/master/index.js
 *   https://github.com/openssl/openssl/blob/master/include/openssl/pem.h
 *   https://github.com/openssl/openssl/blob/master/crypto/pem/pem_lib.c
 *   https://github.com/openssl/openssl/blob/master/crypto/evp/evp_key.c
 *   https://github.com/openssl/openssl/blob/master/crypto/pem/pem_pkey.c
 */
const Pr = _e, ro = Fo, dy = X5, Hu = Buffer.alloc(0);
let Vo = class {
  constructor(e, t) {
    e == null && (e = "PRIVACY-ENHANCED MESSAGE"), t == null && (t = Hu), Pr(typeof e == "string"), Pr(Buffer.isBuffer(t)), this.type = e, this.headers = /* @__PURE__ */ new Map(), this.data = t;
  }
  toString(e) {
    return Z5(this.type, this.headers, this.data, e);
  }
  fromString(e, t) {
    const n = W5(e, t).next();
    if (n.done)
      throw new Error("No PEM data found.");
    const c = n.value;
    return this.type = c.type, this.headers = c.headers, this.data = c.data, this;
  }
  getProcType() {
    const e = this.headers.get("Proc-Type");
    return e ? Fu.fromString(e) : null;
  }
  setProcType(e, t) {
    Pr(e != null && t);
    const i = new Fu(e, t);
    return this.headers.set("Proc-Type", i.toString()), this;
  }
  unsetProcType() {
    return this.headers.delete("Proc-Type"), this;
  }
  getDEKInfo() {
    const e = this.headers.get("DEK-Info");
    return e ? Vu.fromString(e) : null;
  }
  setDEKInfo(e, t) {
    Pr(e);
    const i = new Vu(e, t);
    return this.headers.set("DEK-Info", i.toString()), this;
  }
  unsetDEKInfo() {
    return this.headers.delete("DEK-Info"), this;
  }
  isEncrypted() {
    let e;
    try {
      e = this.getProcType();
    } catch {
      return !1;
    }
    return e ? e.version === 4 && e.state === "ENCRYPTED" : !1;
  }
  static fromString(e, t) {
    return new this().fromString(e, t);
  }
};
class Fu {
  constructor(e, t) {
    e == null && (e = 0), t == null && (t = "NONE"), Pr(e >>> 0 === e), Pr(typeof t == "string"), this.version = e, this.state = t.toUpperCase();
  }
  toString() {
    return `${this.version},${this.state}`;
  }
  fromString(e) {
    Pr(typeof e == "string");
    const t = e.split(",", 3);
    if (t.length !== 2)
      throw new Error("Invalid Proc-Type.");
    return this.version = xy(t[0]), this.state = t[1].toUpperCase(), this;
  }
  static fromString(e) {
    return new this().fromString(e);
  }
}
class Vu {
  constructor(e, t) {
    e == null && (e = "AES-128-ECB"), t == null && (t = Hu), Pr(typeof e == "string"), Pr(Buffer.isBuffer(t)), this.name = e.toUpperCase(), this.iv = t;
  }
  toString() {
    const e = this.name;
    if (this.iv.length === 0)
      return e;
    const t = this.iv.toString("hex");
    return `${e},${t.toUpperCase()}`;
  }
  fromString(e) {
    Pr(typeof e == "string");
    const t = e.split(",", 3);
    if (t.length < 1 || t.length > 2)
      throw new Error("Invalid DEK-Info.");
    const i = t[0];
    if (i.length === 0)
      throw new Error("Invalid DEK-Info name.");
    if (this.name = i.toUpperCase(), this.iv = Hu, t.length > 1) {
      const n = t[1], c = Buffer.from(n, "hex");
      if (c.length !== n.length >>> 1)
        throw new Error("Invalid DEK-Info IV.");
      this.iv = c;
    }
    return this;
  }
  static fromString(e) {
    return new this().fromString(e);
  }
}
function Z5(r, e, t, i = !1) {
  Pr(typeof r == "string"), Pr(e instanceof Map), Pr(Buffer.isBuffer(t)), Pr(typeof i == "boolean");
  let n = "";
  if (n += `-----BEGIN ${r}-----
`, e.size > 0) {
    for (const [o, d] of e)
      n += `${o}: ${d}
`;
    n += `
`;
  }
  const c = ro.encode(t);
  for (let o = 0; o < c.length; o += 64)
    n += c.substring(o, o + 64) + `
`;
  if (i) {
    const o = j5(t);
    n += `=${ro.encode(o)}
`;
  }
  return n += `-----END ${r}-----
`, n;
}
function* W5(r, e = !1) {
  Pr(typeof r == "string"), Pr(typeof e == "boolean");
  let t = "", i = null, n = null;
  for (const [, c] of dy(r)) {
    const o = c.indexOf(":");
    if (o !== -1) {
      if (!i)
        throw new Error("PEM parse error (misplaced header).");
      const d = c.substring(0, o).trim(), l = c.substring(o + 1).trim();
      i.headers.set(d, l);
      continue;
    }
    if (c.length >= 15 && c.substring(0, 5) === "-----") {
      if (c.slice(-5) !== "-----")
        throw new Error("PEM parse error (invalid preamble).");
      const d = c.slice(5, -5);
      if (d.substring(0, 6) === "BEGIN ") {
        if (i)
          throw new Error("PEM parse error (un-ended block).");
        const l = d.substring(6).trim();
        i = new Vo(), i.type = l;
        continue;
      }
      if (d.substring(0, 4) === "END ") {
        if (!i)
          throw new Error("PEM parse error (unexpected end).");
        const l = d.substring(4).trim();
        if (i.type !== l)
          throw new Error("PEM parse error (type mismatch).");
        if (i.data = ro.decode(t), n && !j5(i.data).equals(n))
          throw new Error("PEM parse error (invalid armor checksum).");
        yield i, t = "", i = null, n = null;
        continue;
      }
      throw new Error("PEM parse error (unknown preamble).");
    }
    if (!i)
      throw new Error("PEM parse error (unexpected data).");
    if (c.length === 5 && c.charCodeAt(0) === 61) {
      if (!e)
        continue;
      if (n)
        throw new Error("PEM parse error (unexpected armor checksum).");
      n = ro.decode(c.substring(1));
      continue;
    }
    if (c.length > 96)
      throw new Error("PEM parse error (line too long).");
    t += c.replace(/[\t\v ]/g, "");
  }
  if (i || n)
    throw new Error("PEM parse error (un-ended block).");
  if (t.length !== 0)
    throw new Error("PEM parse error (trailing data).");
}
function uy(r, e, t) {
  Pr(Buffer.isBuffer(r)), Pr(typeof e == "string");
  const i = new Vo();
  return i.type = e, i.data = r, i.toString(t);
}
function ly(r, e, t) {
  Pr(typeof r == "string"), Pr(typeof e == "string");
  const i = Vo.fromString(r, t);
  if (i.type !== e)
    throw new Error("PEM type mismatch.");
  return i.data;
}
function j5(r) {
  Pr(Buffer.isBuffer(r));
  let e = 11994318;
  for (let i = 0; i < r.length; i++) {
    const n = r[i];
    e ^= n << 16;
    for (let c = 0; c < 8; c++)
      e <<= 1, e & 16777216 && (e ^= 25578747);
  }
  e &= 16777215;
  const t = Buffer.alloc(3);
  return t[2] = e, e >>>= 8, t[1] = e, e >>>= 8, t[0] = e, t;
}
function xy(r) {
  if (Pr(typeof r == "string"), r.length < 1 || r.length > 10)
    throw new Error("Invalid integer.");
  let e = 0;
  for (let t = 0; t < r.length; t++) {
    const i = r.charCodeAt(t);
    if (i < 48 || i > 57)
      throw new Error("Invalid integer.");
    if (e *= 10, e += i - 48, t > 0 && e === 0)
      throw new Error("Invalid integer.");
    if (e > 4294967295)
      throw new Error("Invalid integer.");
  }
  return e;
}
Yr.PEMBlock = Vo;
Yr.ProcType = Fu;
Yr.DEKInfo = Vu;
Yr.encode = Z5;
Yr.decode = W5;
Yr.toPEM = uy;
Yr.fromPEM = ly;
/*!
 * openssl.js - openssl-specific encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://www.openssl.org/docs/man1.1.0/apps/dsa.html
 *   https://superuser.com/questions/478966/dsa-private-key-format
 *   https://github.com/dlitz/pycrypto/blob/master/lib/Crypto/PublicKey/DSA.py
 *   https://github.com/openssl/openssl/blob/master/crypto/dsa/dsa_asn1.c
 */
const o0 = ut, Rn = Yr;
let by = class extends o0.Sequence {
  constructor(e, t, i) {
    super(), this.p = new o0.Unsigned(e), this.q = new o0.Unsigned(t), this.g = new o0.Unsigned(i);
  }
  getBodySize() {
    let e = 0;
    return e += this.p.getSize(), e += this.q.getSize(), e += this.g.getSize(), e;
  }
  writeBody(e) {
    return this.p.write(e), this.q.write(e), this.g.write(e), e;
  }
  readBody(e) {
    return this.p.read(e), this.q.read(e), this.g.read(e), this;
  }
  clean() {
    return this.p.clean() && this.q.clean() && this.g.clean();
  }
  toPEM() {
    return Rn.toPEM(this.encode(), "DSA PARAMETERS");
  }
  fromPEM(e) {
    const t = Rn.fromPEM(e, "DSA PARAMETERS");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      p: this.p,
      q: this.q,
      g: this.g
    };
  }
}, py = class extends o0.Sequence {
  constructor(e, t, i, n) {
    super(), this.y = new o0.Unsigned(e), this.p = new o0.Unsigned(t), this.q = new o0.Unsigned(i), this.g = new o0.Unsigned(n);
  }
  getBodySize() {
    let e = 0;
    return e += this.y.getSize(), e += this.p.getSize(), e += this.q.getSize(), e += this.g.getSize(), e;
  }
  writeBody(e) {
    return this.y.write(e), this.p.write(e), this.q.write(e), this.g.write(e), e;
  }
  readBody(e) {
    return this.y.read(e), this.p.read(e), this.q.read(e), this.g.read(e), this;
  }
  clean() {
    return this.y.clean() && this.p.clean() && this.q.clean() && this.g.clean();
  }
  toPEM() {
    return Rn.toPEM(this.encode(), "DSA PUBLIC KEY");
  }
  fromPEM(e) {
    const t = Rn.fromPEM(e, "DSA PUBLIC KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      y: this.y,
      p: this.p,
      q: this.q,
      g: this.g
    };
  }
};
class my extends o0.Sequence {
  constructor(e, t, i, n, c, o) {
    super(), this.version = new o0.Unsigned(e), this.p = new o0.Unsigned(t), this.q = new o0.Unsigned(i), this.g = new o0.Unsigned(n), this.y = new o0.Unsigned(c), this.x = new o0.Unsigned(o);
  }
  getBodySize() {
    let e = 0;
    return e += this.version.getSize(), e += this.p.getSize(), e += this.q.getSize(), e += this.g.getSize(), e += this.y.getSize(), e += this.x.getSize(), e;
  }
  writeBody(e) {
    return this.version.write(e), this.p.write(e), this.q.write(e), this.g.write(e), this.y.write(e), this.x.write(e), e;
  }
  readBody(e) {
    return this.version.read(e), this.p.read(e), this.q.read(e), this.g.read(e), this.y.read(e), this.x.read(e), this;
  }
  clean() {
    return this.p.clean() && this.q.clean() && this.g.clean() && this.y.clean() && this.x.clean();
  }
  toPEM() {
    return Rn.toPEM(this.encode(), "DSA PRIVATE KEY");
  }
  fromPEM(e) {
    const t = Rn.fromPEM(e, "DSA PRIVATE KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      p: this.p,
      q: this.q,
      g: this.g,
      y: this.y,
      x: this.x
    };
  }
}
Yf.DSAParams = by;
Yf.DSAPublicKey = py;
Yf.DSAPrivateKey = my;
var Go = {}, Gu = { exports: {} };
/*!
 * md5.js - MD5 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD5
 *   https://tools.ietf.org/html/rfc1321
 */
var Mh, q3;
function Q5() {
  if (q3)
    return Mh;
  q3 = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(8, 0), n = Buffer.alloc(64, 0);
  n[0] = 128;
  const c = new Uint32Array([
    3614090360,
    3905402710,
    606105819,
    3250441966,
    4118548399,
    1200080426,
    2821735955,
    4249261313,
    1770035416,
    2336552879,
    4294925233,
    2304563134,
    1804603682,
    4254626195,
    2792965006,
    1236535329,
    4129170786,
    3225465664,
    643717713,
    3921069994,
    3593408605,
    38016083,
    3634488961,
    3889429448,
    568446438,
    3275163606,
    4107603335,
    1163531501,
    2850285829,
    4243563512,
    1735328473,
    2368359562,
    4294588738,
    2272392833,
    1839030562,
    4259657740,
    2763975236,
    1272893353,
    4139469664,
    3200236656,
    681279174,
    3936430074,
    3572445317,
    76029189,
    3654602809,
    3873151461,
    530742520,
    3299628645,
    4096336452,
    1126891415,
    2878612391,
    4237533241,
    1700485571,
    2399980690,
    4293915773,
    2240044497,
    1873313359,
    4264355552,
    2734768916,
    1309151649,
    4149444226,
    3174756917,
    718787259,
    3951481745
  ]), o = new Uint8Array([
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21
  ]);
  class d {
    constructor() {
      this.state = new Uint32Array(4), this.msg = new Uint32Array(16), this.block = Buffer.alloc(64), this.size = t;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.size = 0, this;
    }
    update(g) {
      return r(Buffer.isBuffer(g)), this._update(g, g.length), this;
    }
    final() {
      return this._final(Buffer.alloc(16));
    }
    _update(g, w) {
      r(this.size !== t, "Context is not initialized.");
      let I = this.size & 63, B = 0;
      if (this.size += w, I > 0) {
        let y = 64 - I;
        if (y > w && (y = w), g.copy(this.block, I, B, B + y), I += y, w -= y, B += y, I < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; w >= 64; )
        this._transform(g, B), B += 64, w -= 64;
      w > 0 && g.copy(this.block, 0, B, B + w);
    }
    _final(g) {
      r(this.size !== t, "Context is not initialized.");
      const w = this.size & 63, I = this.size * 8;
      x(i, I >>> 0, 0), x(i, I * (1 / 4294967296) >>> 0, 4), this._update(n, 1 + (119 - w & 63)), this._update(i, 8);
      for (let B = 0; B < 4; B++)
        x(g, this.state[B], B * 4), this.state[B] = 0;
      for (let B = 0; B < 16; B++)
        this.msg[B] = 0;
      for (let B = 0; B < 64; B++)
        this.block[B] = 0;
      return this.size = t, g;
    }
    _transform(g, w) {
      const I = this.msg;
      let B = this.state[0], y = this.state[1], A = this.state[2], _ = this.state[3], q = 0;
      for (; q < 16; q++)
        I[q] = h(g, w + q * 4);
      for (q = 0; q < 64; q++) {
        let U, z;
        q < 16 ? (U = y & A | ~y & _, z = q) : q < 32 ? (U = _ & y | ~_ & A, z = 5 * q + 1 & 15) : q < 48 ? (U = y ^ A ^ _, z = 3 * q + 5 & 15) : (U = A ^ (y | ~_), z = 7 * q & 15), U >>>= 0, U = U + B + c[q] + I[z], U >>>= 0, B = _, _ = A, A = y, y = y + l(U, o[q]), y >>>= 0;
      }
      this.state[0] += B, this.state[1] += y, this.state[2] += A, this.state[3] += _;
    }
    static hash() {
      return new d();
    }
    static hmac() {
      return new e(d, 64);
    }
    static digest(g) {
      return d.ctx.init().update(g).final();
    }
    static root(g, w) {
      return r(Buffer.isBuffer(g) && g.length === 16), r(Buffer.isBuffer(w) && w.length === 16), d.ctx.init().update(g).update(w).final();
    }
    static multi(g, w, I) {
      const { ctx: B } = d;
      return B.init(), B.update(g), B.update(w), I && B.update(I), B.final();
    }
    static mac(g, w) {
      return d.hmac().init(w).update(g).final();
    }
  }
  d.native = 0, d.id = "MD5", d.size = 16, d.bits = 128, d.blockSize = 64, d.zero = Buffer.alloc(16, 0), d.ctx = new d();
  function l(b, g) {
    return b << g | b >>> 32 - g;
  }
  function h(b, g) {
    return b[g++] + b[g++] * 256 + b[g++] * 65536 + b[g] * 16777216;
  }
  function x(b, g, w) {
    return b[w++] = g, g >>>= 8, b[w++] = g, g >>>= 8, b[w++] = g, g >>>= 8, b[w++] = g, w;
  }
  return Mh = d, Mh;
}
/*!
 * md5.js - MD5 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Nh, z3;
function gy() {
  if (z3)
    return Nh;
  z3 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.MD5);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.MD5);
    }
    static digest(c) {
      return r.digest(t.MD5, c);
    }
    static root(c, o) {
      return r.root(t.MD5, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.MD5, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.MD5, c, o);
    }
  }
  return i.native = 2, i.id = "MD5", i.size = 16, i.bits = 128, i.blockSize = 64, i.zero = Buffer.alloc(16, 0), i.ctx = new i(), Nh = i, Nh;
}
/*!
 * md5.js - MD5 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Gu.exports = Q5() : Gu.exports = gy();
var gl = Gu.exports;
/*!
 * pemcrypt.js - PEM encryption for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc1421
 */
const Nn = _e, { PEMBlock: e7 } = Yr, t7 = Bo, wy = B0, r7 = D8, i7 = gl, yy = {
  __proto__: null,
  "AES-128": [16, 16],
  "AES-192": [24, 16],
  "AES-256": [32, 16],
  "ARC2-40": [5, 8],
  "ARC2-64": [8, 8],
  "ARC2-128": [16, 8],
  BF: [16, 8],
  BLOWFISH: [16, 8],
  "CAMELLIA-128": [16, 16],
  "CAMELLIA-192": [24, 16],
  "CAMELLIA-256": [32, 16],
  CAST5: [16, 8],
  DES: [8, 8],
  "DES-EDE": [16, 8],
  "DES-EDE3": [24, 8],
  IDEA: [16, 8],
  "SERPENT-128": [16, 16],
  "SERPENT-192": [24, 16],
  "SERPENT-256": [32, 16],
  "TWOFISH-128": [16, 16],
  "TWOFISH-192": [24, 16],
  "TWOFISH-256": [32, 16]
};
function Sy(r, e, t) {
  if (Nn(r instanceof e7), Nn(typeof e == "string"), Nn(typeof t == "string"), r.isEncrypted())
    throw new Error("PEM block is already encrypted.");
  const [i, n] = s7(e), c = wy.randomBytes(n), [o] = r7.derive(i7, t, c, i, n);
  return r.data = t7.encrypt(e, o, c, r.data), r.setProcType(4, "ENCRYPTED"), r.setDEKInfo(e, c), r;
}
function By(r, e) {
  if (Nn(r instanceof e7), Nn(typeof e == "string"), !r.isEncrypted())
    throw new Error("PEM block is not encrypted.");
  const t = r.getDEKInfo();
  if (!t)
    throw new Error("DEK-Info not found.");
  const [i, n] = s7(t.name), [c] = r7.derive(i7, e, t.iv, i, n);
  return r.data = t7.decrypt(t.name, c, t.iv, r.data), r.unsetProcType(), r.unsetDEKInfo(), r;
}
function s7(r) {
  if (Nn(typeof r == "string"), r.substring(0, 3) === "RC2" && (r = "A" + r), r.length < 5 || r[r.length - 4] !== "-")
    throw new Error(`Unsupported cipher: ${r}.`);
  const e = r.substring(0, r.length - 4), t = yy[e];
  if (!t)
    throw new Error(`Unsupported cipher: ${r}.`);
  return t;
}
Go.encrypt = Sy;
Go.decrypt = By;
var Yo = {};
/*!
 * pkcs1.js - PKCS1 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PKCS_1
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017#appendix-A.1.1
 *   https://tools.ietf.org/html/rfc8017#appendix-A.1.2
 *   https://github.com/golang/go/blob/master/src/crypto/x509/pkcs1.go
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_asn1.c
 */
const F0 = ut, io = Yr;
class vy extends F0.Sequence {
  constructor(e, t) {
    super(), this.n = new F0.Unsigned(e), this.e = new F0.Unsigned(t);
  }
  getBodySize() {
    let e = 0;
    return e += this.n.getSize(), e += this.e.getSize(), e;
  }
  writeBody(e) {
    return this.n.write(e), this.e.write(e), e;
  }
  readBody(e) {
    return this.n.read(e), this.e.read(e), this;
  }
  clean() {
    return this.n.clean() && this.e.clean();
  }
  toPEM() {
    return io.toPEM(this.encode(), "RSA PUBLIC KEY");
  }
  fromPEM(e) {
    const t = io.fromPEM(e, "RSA PUBLIC KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      n: this.n,
      e: this.e
    };
  }
}
class Ey extends F0.Sequence {
  constructor(e, t, i, n, c, o, d, l, h) {
    super(), this.version = new F0.Unsigned(e), this.n = new F0.Unsigned(t), this.e = new F0.Unsigned(i), this.d = new F0.Unsigned(n), this.p = new F0.Unsigned(c), this.q = new F0.Unsigned(o), this.dp = new F0.Unsigned(d), this.dq = new F0.Unsigned(l), this.qi = new F0.Unsigned(h);
  }
  getBodySize() {
    let e = 0;
    return e += this.version.getSize(), e += this.n.getSize(), e += this.e.getSize(), e += this.d.getSize(), e += this.p.getSize(), e += this.q.getSize(), e += this.dp.getSize(), e += this.dq.getSize(), e += this.qi.getSize(), e;
  }
  writeBody(e) {
    return this.version.write(e), this.n.write(e), this.e.write(e), this.d.write(e), this.p.write(e), this.q.write(e), this.dp.write(e), this.dq.write(e), this.qi.write(e), e;
  }
  readBody(e) {
    return this.version.read(e), this.n.read(e), this.e.read(e), this.d.read(e), this.p.read(e), this.q.read(e), this.dp.read(e), this.dq.read(e), this.qi.read(e), this;
  }
  clean() {
    return this.n.clean() && this.e.clean() && this.d.clean() && this.p.clean() && this.q.clean() && this.dp.clean() && this.dq.clean() && this.qi.clean();
  }
  toPEM() {
    return io.toPEM(this.encode(), "RSA PRIVATE KEY");
  }
  fromPEM(e) {
    const t = io.fromPEM(e, "RSA PRIVATE KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      n: this.n,
      e: this.e,
      d: this.d,
      p: this.p,
      q: this.q,
      dp: this.dp,
      dq: this.dq,
      qi: this.qi
    };
  }
}
Yo.RSAPublicKey = vy;
Yo.RSAPrivateKey = Ey;
var n7 = {};
/*!
 * pkcs3.js - PKCS3 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://www.teletrust.de/fileadmin/files/oid/oid_pkcs-3v1-4.pdf
 */
const Oh = ut, U3 = Yr;
class Iy extends Oh.Sequence {
  constructor(e, t) {
    super(), this.p = new Oh.Unsigned(e), this.g = new Oh.Unsigned(t);
  }
  getBodySize() {
    let e = 0;
    return e += this.p.getSize(), e += this.g.getSize(), e;
  }
  writeBody(e) {
    return this.p.write(e), this.g.write(e), e;
  }
  readBody(e) {
    return this.p.read(e), this.g.read(e), this;
  }
  clean() {
    return this.p.clean() && this.g.clean();
  }
  toPEM() {
    return U3.toPEM(this.encode(), "DH PARAMETERS");
  }
  fromPEM(e) {
    const t = U3.fromPEM(e, "DH PARAMETERS");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      p: this.p,
      g: this.g
    };
  }
}
n7.DHParams = Iy;
/*!
 * pkcs5.js - PKCS5 padding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PKCS
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc8018
 */
const ln = _e, Ay = {
  pad(r, e) {
    ln(Buffer.isBuffer(r)), ln(e >>> 0 === e), ln(e > 0 && e < 256);
    const t = e - r.length % e, i = Buffer.alloc(r.length + t);
    r.copy(i, 0);
    for (let n = r.length; n < i.length; n++)
      i[n] = t;
    return i;
  },
  unpad(r, e) {
    if (ln(Buffer.isBuffer(r)), ln(e >>> 0 === e), ln(e > 0 && e < 256), r.length < e || r.length % e !== 0)
      throw new Error("Invalid block.");
    let t = r[r.length - 1], i = 1;
    i &= t - 1 >>> 31 ^ 1, i &= t - e - 1 >>> 31, t &= -i;
    const n = e - t;
    for (let c = 0; c < e; c++) {
      const o = r[c];
      i &= c - n >>> 31 | (o ^ t) - 1 >>> 31;
    }
    if (!i)
      throw new Error("Invalid padding.");
    return r.slice(0, n);
  }
};
var _y = Ay, Jo = {}, z0 = {};
/*!
 * x509.js - X509 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/asn1.js:
 *   Copyright Fedor Indutny, 2013.
 *   https://github.com/indutny/asn1.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/X.509
 *   https://tools.ietf.org/html/rfc4158
 *   https://www.ietf.org/rfc/rfc2560.txt
 *   https://www.ietf.org/rfc/rfc5280.txt
 *   https://github.com/indutny/asn1.js/blob/master/rfc/2560/index.js
 *   https://github.com/indutny/asn1.js/blob/master/rfc/5280/index.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/base/node.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/encoders/der.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/decoders/der.js
 */
const C3 = _e, pr = ut, kn = Yr, { types: T3 } = pr;
class My extends pr.Sequence {
  constructor() {
    super(), this.tbsCertificate = new f7(), this.signatureAlgorithm = new Jf(), this.signature = new pr.BitString();
  }
  get isRaw() {
    return !0;
  }
  getBodySize() {
    let e = 0;
    return e += this.tbsCertificate.getSize(), e += this.signatureAlgorithm.getSize(), e += this.signature.getSize(), e;
  }
  writeBody(e) {
    return this.tbsCertificate.write(e), this.signatureAlgorithm.write(e), this.signature.write(e), e;
  }
  readBody(e) {
    return this.tbsCertificate.read(e), this.signatureAlgorithm.read(e), this.signature.read(e), this;
  }
  clean() {
    return this.tbsCertificate.clean() && this.signatureAlgorithm.clean() && this.signature.clean();
  }
  toPEM() {
    return kn.toPEM(this.encode(), "CERTIFICATE");
  }
  fromPEM(e) {
    const t = kn.fromPEM(e, "CERTIFICATE");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      tbsCertificate: this.tbsCertificate,
      signatureAlgorithm: this.signatureAlgorithm,
      signature: this.signature
    };
  }
}
class f7 extends pr.Sequence {
  constructor() {
    super(), this.version = new pr.Unsigned().explicit(0).optional(), this.serialNumber = new pr.Integer(), this.signature = new Jf(), this.issuer = new Yu(), this.validity = new o7(), this.subject = new Yu(), this.subjectPublicKeyInfo = new a7(), this.issuerUniqueID = new pr.BitString().implicit(1).optional(), this.subjectUniqueID = new pr.BitString().implicit(2).optional(), this.extensions = new h7().explicit(3).optional();
  }
  get isRaw() {
    return !0;
  }
  getBodySize() {
    let e = 0;
    return e += this.version.getSize(), e += this.serialNumber.getSize(), e += this.signature.getSize(), e += this.issuer.getSize(), e += this.validity.getSize(), e += this.subject.getSize(), e += this.subjectPublicKeyInfo.getSize(), e += this.issuerUniqueID.getSize(), e += this.subjectUniqueID.getSize(), e += this.extensions.getSize(), e;
  }
  writeBody(e) {
    return this.version.write(e), this.serialNumber.write(e), this.signature.write(e), this.issuer.write(e), this.validity.write(e), this.subject.write(e), this.subjectPublicKeyInfo.write(e), this.issuerUniqueID.write(e), this.subjectUniqueID.write(e), this.extensions.write(e), e;
  }
  readBody(e) {
    return this.version.read(e), this.serialNumber.read(e), this.signature.read(e), this.issuer.read(e), this.validity.read(e), this.subject.read(e), this.subjectPublicKeyInfo.read(e), this.issuerUniqueID.read(e), this.subjectUniqueID.read(e), this.extensions.read(e), this;
  }
  clean() {
    return this.version.clean() && this.serialNumber.clean() && this.signature.clean() && this.issuer.clean() && this.validity.clean() && this.subject.clean() && this.subjectPublicKeyInfo.clean() && this.issuerUniqueID.clean() && this.subjectUniqueID.clean() && this.extensions.clean();
  }
  toPEM() {
    return kn.toPEM(this.encode(), "TBS CERTIFICATE");
  }
  fromPEM(e) {
    const t = kn.fromPEM(e, "TBS CERTIFICATE");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      serialNumber: this.serialNumber,
      signature: this.signature,
      issuer: this.issuer,
      validity: this.validity,
      subject: this.subject,
      subjectPublicKeyInfo: this.subjectPublicKeyInfo,
      issuerUniqueID: this.issuerUniqueID,
      subjectUniqueID: this.subjectUniqueID,
      extensions: this.extensions
    };
  }
}
class Jf extends pr.Sequence {
  constructor(e, t) {
    super(), this.algorithm = new pr.OID(e), this.parameters = new pr.Any(t).optional();
  }
  getBodySize() {
    let e = 0;
    return e += this.algorithm.getSize(), e += this.parameters.getSize(), e;
  }
  writeBody(e) {
    return this.algorithm.write(e), this.parameters.write(e), e;
  }
  readBody(e) {
    return this.algorithm.read(e), this.parameters.read(e), this;
  }
  clean() {
    return this.algorithm.clean() && this.parameters.clean();
  }
  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      parameters: this.parameters
    };
  }
}
class Yu extends pr.Sequence {
  constructor() {
    super(), this.names = [];
  }
  getBodySize() {
    let e = 0;
    for (const t of this.names)
      e += t.getSize();
    return e;
  }
  writeBody(e) {
    for (const t of this.names)
      t.write(e);
    return e;
  }
  readBody(e) {
    for (; e.left(); ) {
      const t = c7.read(e);
      this.names.push(t);
    }
    return this;
  }
  clean() {
    return this.names.length === 0;
  }
  format() {
    return {
      type: this.constructor.name,
      names: this.names
    };
  }
}
class c7 extends pr.Set {
  constructor(e, t) {
    super(), this.attributes = [new Ju(e, t)];
  }
  getBodySize() {
    let e = 0;
    C3(this.attributes.length >= 1);
    for (const t of this.attributes)
      e += t.getSize();
    return e;
  }
  writeBody(e) {
    C3(this.attributes.length >= 1);
    for (const t of this.attributes)
      t.write(e);
    return e;
  }
  readBody(e) {
    for (this.attributes[0].read(e); e.left(); ) {
      const t = Ju.read(e);
      this.attributes.push(t);
    }
    return this;
  }
  clean() {
    return this.attributes.length === 1 && this.attributes[0].clean();
  }
  format() {
    return {
      type: this.constructor.name,
      attributes: this.attributes
    };
  }
}
class Ju extends pr.Sequence {
  constructor(e, t) {
    super(), this.id = new pr.OID(e), this.value = new pr.Any(t);
  }
  getBodySize() {
    let e = 0;
    return e += this.id.getSize(), e += this.value.getSize(), e;
  }
  writeBody(e) {
    return this.id.write(e), this.value.write(e), e;
  }
  readBody(e) {
    return this.id.read(e), this.value.read(e), this;
  }
  clean() {
    return this.id.clean() && this.value.clean();
  }
  format() {
    return {
      type: this.constructor.name,
      id: this.id,
      value: this.value
    };
  }
}
class o7 extends pr.Sequence {
  constructor() {
    super(), this.notBefore = new Xu(), this.notAfter = new Xu();
  }
  getBodySize() {
    let e = 0;
    return e += this.notBefore.getSize(), e += this.notAfter.getSize(), e;
  }
  writeBody(e) {
    return this.notBefore.write(e), this.notAfter.write(e), e;
  }
  readBody(e) {
    return this.notBefore.read(e), this.notAfter.read(e), this;
  }
  clean() {
    return this.notBefore.clean() && this.notAfter.clean();
  }
  format() {
    return {
      type: this.constructor.name,
      notBefore: this.notBefore,
      notAfter: this.notAfter
    };
  }
}
class Xu extends pr.Choice {
  constructor(e) {
    super(new pr.UTCTime(), e);
  }
  choices() {
    return [
      T3.UTCTIME,
      T3.GENTIME
    ];
  }
}
class a7 extends pr.Sequence {
  constructor(e, t, i) {
    super(), this.algorithm = new Jf(e, t), this.publicKey = new pr.BitString(i);
  }
  get isRaw() {
    return !0;
  }
  getBodySize() {
    let e = 0;
    return e += this.algorithm.getSize(), e += this.publicKey.getSize(), e;
  }
  writeBody(e) {
    return this.algorithm.write(e), this.publicKey.write(e), e;
  }
  readBody(e) {
    return this.algorithm.read(e), this.publicKey.read(e), this;
  }
  clean() {
    return this.algorithm.clean() && this.publicKey.clean();
  }
  toPEM() {
    return kn.toPEM(this.encode(), "PUBLIC KEY");
  }
  fromPEM(e) {
    const t = kn.fromPEM(e, "PUBLIC KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      publicKey: this.publicKey
    };
  }
}
class h7 extends pr.Sequence {
  constructor() {
    super(), this.extensions = [];
  }
  getBodySize() {
    let e = 0;
    for (const t of this.extensions)
      e += t.getSize();
    return e;
  }
  writeBody(e) {
    for (const t of this.extensions)
      t.write(e);
    return e;
  }
  readBody(e) {
    for (const t of this.extensions)
      t.read(e);
    return this;
  }
  clean() {
    return this.extensions.length === 0;
  }
  format() {
    return {
      type: this.constructor.name,
      extensions: this.extensions
    };
  }
}
class Ny extends pr.Sequence {
  constructor() {
    super(), this.extnID = new pr.OID(), this.critical = new pr.Bool().optional(), this.extnValue = new pr.OctString();
  }
  getBodySize() {
    let e = 0;
    return e += this.extnID.getSize(), e += this.critical.getSize(), e += this.extnValue.getSize(), e;
  }
  writeBody(e) {
    return this.extnID.write(e), this.critical.write(e), this.extnValue.write(e), e;
  }
  readBody(e) {
    return this.extnID.read(e), this.critical.read(e), this.extnValue.read(e), this;
  }
  clean() {
    return this.extnID.clean() && this.critical.clean() && this.extnValue.clean();
  }
  format() {
    return {
      type: this.constructor.name,
      extnID: this.extnID,
      critical: this.critical,
      extnValue: this.extnValue
    };
  }
}
class Oy extends pr.Sequence {
  constructor(e, t) {
    super(), this.algorithm = new Jf(e), this.algorithm.parameters.optional(!1), this.digest = new pr.OctString(t);
  }
  getBodySize() {
    let e = 0;
    return e += this.algorithm.getSize(), e += this.digest.getSize(), e;
  }
  writeBody(e) {
    return this.algorithm.write(e), this.digest.write(e), e;
  }
  readBody(e) {
    return this.algorithm.read(e), this.digest.read(e), this;
  }
  clean() {
    return this.algorithm.clean() && this.digest.clean();
  }
  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      digest: this.digest
    };
  }
}
z0.Certificate = My;
z0.TBSCertificate = f7;
z0.AlgorithmIdentifier = Jf;
z0.RDNSequence = Yu;
z0.RDN = c7;
z0.Attribute = Ju;
z0.Validity = o7;
z0.Time = Xu;
z0.SubjectPublicKeyInfo = a7;
z0.Extensions = h7;
z0.Extension = Ny;
z0.DigestInfo = Oy;
/*!
 * pkcs8.js - PKCS8 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PKCS_8
 *   https://tools.ietf.org/html/rfc5208
 *   https://tools.ietf.org/html/rfc5958
 *   https://github.com/golang/go/blob/master/src/crypto/x509/pkcs8.go
 */
const Ws = ut, qn = Yr, wl = z0;
class Py extends Ws.Sequence {
  constructor(e, t, i) {
    super(), this.algorithm = new wl.AlgorithmIdentifier(e, t), this.publicKey = new Ws.BitString(i);
  }
  getBodySize() {
    let e = 0;
    return e += this.algorithm.getSize(), e += this.publicKey.getSize(), e;
  }
  writeBody(e) {
    return this.algorithm.write(e), this.publicKey.write(e), e;
  }
  readBody(e) {
    return this.algorithm.read(e), this.publicKey.read(e), this;
  }
  clean() {
    return this.algorithm.clean() && this.publicKey.clean();
  }
  toPEM() {
    return qn.toPEM(this.encode(), "PUBLIC KEY");
  }
  fromPEM(e) {
    const t = qn.fromPEM(e, "PUBLIC KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      publicKey: this.publicKey
    };
  }
}
class Ry extends Ws.Sequence {
  constructor(e, t, i, n) {
    super(), this.version = new Ws.Unsigned(e), this.algorithm = new wl.AlgorithmIdentifier(t, i), this.privateKey = new Ws.OctString(n);
  }
  get isRaw() {
    return !0;
  }
  getBodySize() {
    let e = 0;
    return e += this.version.getSize(), e += this.algorithm.getSize(), e += this.privateKey.getSize(), e;
  }
  writeBody(e) {
    return this.version.write(e), this.algorithm.write(e), this.privateKey.write(e), e;
  }
  readBody(e) {
    return this.version.read(e), this.algorithm.read(e), this.privateKey.read(e), this;
  }
  clean() {
    return this.version.clean() && this.algorithm.clean() && this.privateKey.clean();
  }
  toPEM() {
    return qn.toPEM(this.encode(), "PRIVATE KEY");
  }
  fromPEM(e) {
    const t = qn.fromPEM(e, "PRIVATE KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      algorithm: this.algorithm,
      privateKey: this.privateKey
    };
  }
}
class ky extends Ws.Sequence {
  constructor(e, t, i) {
    super(), this.algorithm = new wl.AlgorithmIdentifier(e, t), this.data = new Ws.OctString(i);
  }
  getBodySize() {
    let e = 0;
    return e += this.algorithm.getSize(), e += this.data.getSize(), e;
  }
  writeBody(e) {
    return this.algorithm.write(e), this.data.write(e), e;
  }
  readBody(e) {
    return this.algorithm.read(e), this.data.read(e), this;
  }
  clean() {
    return this.algorithm.clean() && this.data.clean();
  }
  toPEM() {
    return qn.toPEM(this.encode(), "ENCRYPTED PRIVATE KEY");
  }
  fromPEM(e) {
    const t = qn.fromPEM(e, "ENCRYPTED PRIVATE KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      data: this.data
    };
  }
}
Jo.PublicKeyInfo = Py;
Jo.PrivateKeyInfo = Ry;
Jo.EncryptedPrivateKeyInfo = ky;
var Xo = {};
/*!
 * rfc3279.js - rfc3279 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc3279
 *   https://tools.ietf.org/html/rfc5912
 */
const ys = ut, zn = Yr;
class qy extends ys.Sequence {
  constructor(e, t, i) {
    super(), this.p = new ys.Unsigned(e), this.q = new ys.Unsigned(t), this.g = new ys.Unsigned(i);
  }
  getBodySize() {
    let e = 0;
    return e += this.p.getSize(), e += this.q.getSize(), e += this.g.getSize(), e;
  }
  writeBody(e) {
    return this.p.write(e), this.q.write(e), this.g.write(e), e;
  }
  readBody(e) {
    return this.p.read(e), this.q.read(e), this.g.read(e), this;
  }
  clean() {
    return this.p.clean() && this.q.clean() && this.g.clean();
  }
  toPEM() {
    return zn.toPEM(this.encode(), "DSA PARAMETERS");
  }
  fromPEM(e) {
    const t = zn.fromPEM(e, "DSA PARAMETERS");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      p: this.p,
      q: this.q,
      g: this.g
    };
  }
}
class zy extends ys.Unsigned {
  constructor(e) {
    super(e);
  }
  get y() {
    return this.value;
  }
  set y(e) {
    this.value = e;
  }
  toPEM() {
    return zn.toPEM(this.encode(), "DSA PUBLIC KEY");
  }
  fromPEM(e) {
    const t = zn.fromPEM(e, "DSA PUBLIC KEY");
    return this.decode(t);
  }
}
class Uy extends ys.Sequence {
  constructor(e, t) {
    super(), this.r = new ys.Unsigned(e), this.s = new ys.Unsigned(t);
  }
  getBodySize() {
    let e = 0;
    return e += this.r.getSize(), e += this.s.getSize(), e;
  }
  writeBody(e) {
    return this.r.write(e), this.s.write(e), e;
  }
  readBody(e) {
    return this.r.read(e), this.s.read(e), this;
  }
  clean() {
    return this.r.clean() && this.s.clean();
  }
  toPEM() {
    return zn.toPEM(this.encode(), "DSA SIGNATURE");
  }
  fromPEM(e) {
    const t = zn.fromPEM(e, "DSA SIGNATURE");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      r: this.r,
      s: this.s
    };
  }
}
Xo.DSAParams = qy;
Xo.DSAPublicKey = zy;
Xo.DSASignature = Uy;
var Zo = {};
/*!
 * sec1.js - SEC1 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   http://www.secg.org/sec1-v2.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/ec/ec_asn1.c
 *   https://github.com/golang/go/blob/master/src/crypto/x509/sec1.go
 *   https://tools.ietf.org/html/rfc5915
 */
const ws = ut, so = Yr;
class Cy extends ws.Sequence {
  constructor(e, t, i, n) {
    super(), this.version = new ws.Unsigned(e), this.privateKey = new ws.OctString(t), this.namedCurveOID = new ws.OID(i).explicit(0).optional(), this.publicKey = new ws.BitString(n).explicit(1).optional();
  }
  getBodySize() {
    let e = 0;
    return e += this.version.getSize(), e += this.privateKey.getSize(), e += this.namedCurveOID.getSize(), e += this.publicKey.getSize(), e;
  }
  writeBody(e) {
    return this.version.write(e), this.privateKey.write(e), this.namedCurveOID.write(e), this.publicKey.write(e), e;
  }
  readBody(e) {
    return this.version.read(e), this.privateKey.read(e), this.namedCurveOID.read(e), this.publicKey.read(e), this;
  }
  clean() {
    return this.version.clean() && this.privateKey.clean() && this.namedCurveOID.clean() && this.publicKey.clean();
  }
  toPEM() {
    return so.toPEM(this.encode(), "EC PRIVATE KEY");
  }
  fromPEM(e) {
    const t = so.fromPEM(e, "EC PRIVATE KEY");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      privateKey: this.privateKey,
      namedCurveOID: this.namedCurveOID,
      publicKey: this.publicKey
    };
  }
}
class Ty extends ws.Sequence {
  constructor(e, t) {
    super(), this.r = new ws.Unsigned(e), this.s = new ws.Unsigned(t);
  }
  getBodySize() {
    let e = 0;
    return e += this.r.getSize(), e += this.s.getSize(), e;
  }
  writeBody(e) {
    return this.r.write(e), this.s.write(e), e;
  }
  readBody(e) {
    return this.r.read(e), this.s.read(e), this;
  }
  clean() {
    return this.r.clean() && this.s.clean();
  }
  toPEM() {
    return so.toPEM(this.encode(), "EC SIGNATURE");
  }
  fromPEM(e) {
    const t = so.fromPEM(e, "EC SIGNATURE");
    return this.decode(t);
  }
  format() {
    return {
      type: this.constructor.name,
      r: this.r,
      s: this.s
    };
  }
}
Zo.ECPrivateKey = Cy;
Zo.ECDSASignature = Ty;
/*!
 * index.js - encoding for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
Dr.asn1 = ut;
Dr.base16 = Xw;
Dr.base32 = jw;
Dr.base58 = ty;
Dr.base64 = Fo;
Dr.bech32 = fy;
Dr.cash32 = ay;
Dr.lines = X5;
Dr.openssl = Yf;
Dr.pem = Yr;
Dr.pemcrypt = Go;
Dr.pkcs1 = Yo;
Dr.pkcs3 = n7;
Dr.pkcs5 = _y;
Dr.pkcs8 = Jo;
Dr.rfc3279 = Xo;
Dr.sec1 = Zo;
Dr.util = ti;
Dr.x509 = z0;
var Zu = { exports: {} };
/*!
 * gost94.js - GOST94 implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/GOST_(hash_function)
 *   https://tools.ietf.org/html/rfc4357
 *   https://tools.ietf.org/html/rfc5831
 *   https://github.com/RustCrypto/hashes/blob/master/gost94/src/gost94.rs
 */
var Ph, D3;
function Dy() {
  if (D3)
    return Ph;
  D3 = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(32, 0), n = Buffer.alloc(32, 0), c = Buffer.from([
    0,
    255,
    0,
    255,
    0,
    255,
    0,
    255,
    255,
    0,
    255,
    0,
    255,
    0,
    255,
    0,
    0,
    255,
    255,
    0,
    255,
    0,
    0,
    255,
    255,
    0,
    0,
    0,
    255,
    255,
    0,
    255
  ]), o = [
    Buffer.from([10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15]),
    Buffer.from([5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8]),
    Buffer.from([7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13]),
    Buffer.from([4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3]),
    Buffer.from([7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5]),
    Buffer.from([7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3]),
    Buffer.from([13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11]),
    Buffer.from([1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12])
  ], d = [
    Buffer.from([4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3]),
    Buffer.from([14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9]),
    Buffer.from([5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11]),
    Buffer.from([7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3]),
    Buffer.from([6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2]),
    Buffer.from([4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14]),
    Buffer.from([13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12]),
    Buffer.from([1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12])
  ], l = [
    Buffer.from([12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1]),
    Buffer.from([6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 11, 13, 0, 15]),
    Buffer.from([11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0]),
    Buffer.from([12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11]),
    Buffer.from([7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12]),
    Buffer.from([5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0]),
    Buffer.from([8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7]),
    Buffer.from([1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2])
  ];
  class h {
    constructor() {
      this.S = o, this.state = Buffer.alloc(32), this.sigma = Buffer.alloc(32), this.block = Buffer.alloc(32), this.size = t;
    }
    init(E) {
      return E == null && (E = o), r(Array.isArray(E) && E.length === 8), this.S = E, this.state.fill(0), this.sigma.fill(0), this.size = 0, this;
    }
    update(E) {
      return r(Buffer.isBuffer(E)), this._update(E, E.length), this;
    }
    final() {
      return this._final(Buffer.alloc(32));
    }
    _update(E, H) {
      r(this.size !== t, "Context is not initialized.");
      let k = this.size & 31, V = 0;
      if (this.size += H, k > 0) {
        let T = 32 - k;
        if (T > H && (T = H), E.copy(this.block, k, V, V + T), k += T, H -= T, V += T, k < 32)
          return;
        this._transform(this.block, 0);
      }
      for (; H >= 32; )
        this._transform(E, V), V += 32, H -= 32;
      H > 0 && E.copy(this.block, 0, V, V + H);
    }
    _final(E) {
      r(this.size !== t, "Context is not initialized.");
      const H = this.size * 8, k = this.size & 31;
      k !== 0 && this._update(i, 32 - k);
      const V = H * (1 / 4294967296) >>> 0, T = H >>> 0;
      return U(n, T, 0), U(n, V, 4), this._f(n), this._f(this.sigma), this.state.copy(E, 0), this.state.fill(0), this.sigma.fill(0), this.block.fill(0), n.fill(0, 0, 8), this.size = t, E;
    }
    _transform(E, H) {
      const k = E.slice(H, H + 32);
      this._f(k), this._sum(k);
    }
    _shuffle(E, H) {
      const k = Buffer.alloc(32);
      H.copy(k, 0);
      for (let V = 0; V < 12; V++)
        A(k);
      I(k, E), A(k), I(this.state, k);
      for (let V = 0; V < 61; V++)
        A(this.state);
    }
    _f(E) {
      const H = Buffer.alloc(32);
      this.state.copy(H, 0);
      let k, V, T;
      k = y(w(this.state, E)), g(H, 0, k, this.S), V = B(this.state), T = B(B(E)), k = y(w(V, T)), g(H, 8, k, this.S), V = B(V), I(V, c), T = B(B(T)), k = y(w(V, T)), g(H, 16, k, this.S), V = B(V), T = B(B(T)), k = y(w(V, T)), g(H, 24, k, this.S), this._shuffle(E, H);
    }
    _sum(E) {
      let H = 0;
      for (let k = 0; k < 32; k++)
        H += this.sigma[k] + E[k], this.sigma[k] = H, H >>>= 8;
    }
    static hash() {
      return new h();
    }
    static hmac(E) {
      return new e(h, 32, [E]);
    }
    static digest(E, H) {
      return h.ctx.init(H).update(E).final();
    }
    static root(E, H, k) {
      return r(Buffer.isBuffer(E) && E.length === 32), r(Buffer.isBuffer(H) && H.length === 32), h.ctx.init(k).update(E).update(H).final();
    }
    static multi(E, H, k, V) {
      const { ctx: T } = h;
      return T.init(V), T.update(E), T.update(H), k && T.update(k), T.final();
    }
    static mac(E, H, k) {
      return h.hmac(k).init(H).update(E).final();
    }
  }
  h.native = 0, h.id = "GOST94", h.size = 32, h.bits = 256, h.blockSize = 32, h.zero = Buffer.alloc(32, 0), h.ctx = new h(), h.CRYPTOPRO = o, h.TEST = d, h.S2015 = l;
  function x(z, E) {
    let H = 0;
    for (let k = 0; k < 8; k++) {
      const V = 4 * k, T = (z & 15 << V) >>> V;
      H += E[k][T] << V;
    }
    return H >>> 0;
  }
  function b(z, E, H) {
    return _(x(z + E >>> 0, H), 11);
  }
  function g(z, E, H, k) {
    const V = new Uint32Array(8);
    let T = q(z, E + 0), ie = q(z, E + 4);
    for (let N = 0; N < 8; N++)
      V[N] = q(H, N * 4);
    for (let N = 0; N < 3; N++)
      for (let G = 0; G < 8; G++) {
        const F = ie ^ b(T, V[G], k);
        ie = T, T = F;
      }
    for (let N = 7; N >= 0; N--) {
      const G = ie ^ b(T, V[N], k);
      ie = T, T = G;
    }
    U(z, ie, E + 0), U(z, T, E + 4);
  }
  function w(z, E) {
    const H = Buffer.alloc(32);
    for (let k = 0; k < 32; k++)
      H[k] = z[k] ^ E[k];
    return H;
  }
  function I(z, E) {
    for (let H = 0; H < 32; H++)
      z[H] ^= E[H];
  }
  function B(z) {
    const E = Buffer.alloc(32);
    z.copy(E, 0, 8, 32);
    for (let H = 0; H < 8; H++)
      E[24 + H] = z[H] ^ z[H + 8];
    return E;
  }
  function y(z) {
    const E = Buffer.alloc(32);
    for (let H = 0; H < 4; H++)
      for (let k = 0; k < 8; k++)
        E[H + 4 * k] = z[8 * H + k];
    return E;
  }
  function A(z) {
    const E = Buffer.alloc(32);
    z.copy(E, 0, 2, 32), z.copy(E, 30, 0, 2), E[30] ^= z[2], E[31] ^= z[3], E[30] ^= z[4], E[31] ^= z[5], E[30] ^= z[6], E[31] ^= z[7], E[30] ^= z[24], E[31] ^= z[25], E[30] ^= z[30], E[31] ^= z[31], E.copy(z, 0);
  }
  function _(z, E) {
    return z << E | z >>> 32 - E;
  }
  function q(z, E) {
    return z[E++] + z[E++] * 256 + z[E++] * 65536 + z[E] * 16777216;
  }
  function U(z, E, H) {
    return z[H++] = E, E >>>= 8, z[H++] = E, E >>>= 8, z[H++] = E, E >>>= 8, z[H++] = E, H;
  }
  return Ph = h, Ph;
}
/*!
 * gost94.js - gost94 implementation for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Rh, L3;
function Ly() {
  if (L3)
    return Rh;
  L3 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.GOST94);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.GOST94);
    }
    static digest(c) {
      return r.digest(t.GOST94, c);
    }
    static root(c, o) {
      return r.root(t.GOST94, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.GOST94, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.GOST94, c, o);
    }
  }
  return i.native = 2, i.id = "GOST94", i.size = 32, i.bits = 256, i.blockSize = 32, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), Rh = i, Rh;
}
/*!
 * gost94.js - gost94 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Zu.exports = Dy() : Zu.exports = Ly();
var Ky = Zu.exports, Wu = { exports: {} };
/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */
var kh, K3;
function d7() {
  if (K3)
    return kh;
  K3 = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(8, 0), n = Buffer.alloc(64, 0);
  n[0] = 128;
  const c = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ]), o = new Uint8Array([
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ]), d = new Uint8Array([
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ]), l = new Uint8Array([
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ]);
  class h {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(16), this.block = Buffer.alloc(64), this.size = t;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(A) {
      return r(Buffer.isBuffer(A)), this._update(A, A.length), this;
    }
    final() {
      return this._final(Buffer.alloc(20));
    }
    _update(A, _) {
      r(this.size !== t, "Context is not initialized.");
      let q = this.size & 63, U = 0;
      if (this.size += _, q > 0) {
        let z = 64 - q;
        if (z > _ && (z = _), A.copy(this.block, q, U, U + z), q += z, _ -= z, U += z, q < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; _ >= 64; )
        this._transform(A, U), U += 64, _ -= 64;
      _ > 0 && A.copy(this.block, 0, U, U + _);
    }
    _final(A) {
      r(this.size !== t, "Context is not initialized.");
      const _ = this.size & 63, q = this.size * 8;
      B(i, q >>> 0, 0), B(i, q * (1 / 4294967296) >>> 0, 4), this._update(n, 1 + (119 - _ & 63)), this._update(i, 8);
      for (let U = 0; U < 5; U++)
        B(A, this.state[U], U * 4), this.state[U] = 0;
      for (let U = 0; U < 16; U++)
        this.msg[U] = 0;
      for (let U = 0; U < 64; U++)
        this.block[U] = 0;
      return this.size = t, A;
    }
    _transform(A, _) {
      const q = this.msg;
      let U = this.state[0], z = this.state[1], E = this.state[2], H = this.state[3], k = this.state[4], V = U, T = z, ie = E, N = H, G = k;
      for (let W = 0; W < 16; W++)
        q[W] = I(A, _ + W * 4);
      for (let W = 0; W < 80; W++) {
        let ce = U + b(W, z, E, H) + q[c[W]] + g(W), ne = x(ce, d[W]), xe = ne + k;
        U = k, k = H, H = x(E, 10), E = z, z = xe, ce = V + b(79 - W, T, ie, N) + q[o[W]] + w(W), ne = x(ce, l[W]), xe = ne + G, V = G, G = N, N = x(ie, 10), ie = T, T = xe;
      }
      const F = this.state[1] + E + N;
      this.state[1] = this.state[2] + H + G, this.state[2] = this.state[3] + k + V, this.state[3] = this.state[4] + U + T, this.state[4] = this.state[0] + z + ie, this.state[0] = F;
    }
    static hash() {
      return new h();
    }
    static hmac() {
      return new e(h, 64);
    }
    static digest(A) {
      return h.ctx.init().update(A).final();
    }
    static root(A, _) {
      return r(Buffer.isBuffer(A) && A.length === 20), r(Buffer.isBuffer(_) && _.length === 20), h.ctx.init().update(A).update(_).final();
    }
    static multi(A, _, q) {
      const { ctx: U } = h;
      return U.init(), U.update(A), U.update(_), q && U.update(q), U.final();
    }
    static mac(A, _) {
      return h.hmac().init(_).update(A).final();
    }
  }
  h.native = 0, h.id = "RIPEMD160", h.size = 20, h.bits = 160, h.blockSize = 64, h.zero = Buffer.alloc(20, 0), h.ctx = new h();
  function x(y, A) {
    return y << A | y >>> 32 - A;
  }
  function b(y, A, _, q) {
    return y <= 15 ? A ^ _ ^ q : y <= 31 ? A & _ | ~A & q : y <= 47 ? (A | ~_) ^ q : y <= 63 ? A & q | _ & ~q : A ^ (_ | ~q);
  }
  function g(y) {
    return y <= 15 ? 0 : y <= 31 ? 1518500249 : y <= 47 ? 1859775393 : y <= 63 ? 2400959708 : 2840853838;
  }
  function w(y) {
    return y <= 15 ? 1352829926 : y <= 31 ? 1548603684 : y <= 47 ? 1836072691 : y <= 63 ? 2053994217 : 0;
  }
  function I(y, A) {
    return y[A++] + y[A++] * 256 + y[A++] * 65536 + y[A] * 16777216;
  }
  function B(y, A, _) {
    return y[_++] = A, A >>>= 8, y[_++] = A, A >>>= 8, y[_++] = A, A >>>= 8, y[_++] = A, _;
  }
  return kh = h, kh;
}
/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
var qh, $3;
function $y() {
  if ($3)
    return qh;
  $3 = 1;
  const r = _e, e = Eo(), t = d7(), i = Rr, n = new t();
  class c {
    constructor() {
      this.ctx = new e();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(d) {
      return this.ctx.update(d), this;
    }
    final() {
      const d = Buffer.alloc(32);
      return this.ctx._final(d), n.init(), n.update(d), n._final(d), d.slice(0, 20);
    }
    static hash() {
      return new c();
    }
    static hmac() {
      return new i(c, 64);
    }
    static digest(d) {
      return c.ctx.init().update(d).final();
    }
    static root(d, l) {
      return r(Buffer.isBuffer(d) && d.length === 20), r(Buffer.isBuffer(l) && l.length === 20), c.ctx.init().update(d).update(l).final();
    }
    static multi(d, l, h) {
      const { ctx: x } = c;
      return x.init(), x.update(d), x.update(l), h && x.update(h), x.final();
    }
    static mac(d, l) {
      return c.hmac().init(l).update(d).final();
    }
  }
  return c.native = 0, c.id = "HASH160", c.size = 20, c.bits = 160, c.blockSize = 64, c.zero = Buffer.alloc(20, 0), c.ctx = new c(), qh = c, qh;
}
/*!
 * hash160.js - hash160 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var zh, H3;
function Hy() {
  if (H3)
    return zh;
  H3 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.HASH160);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.HASH160);
    }
    static digest(c) {
      return r.digest(t.HASH160, c);
    }
    static root(c, o) {
      return r.root(t.HASH160, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.HASH160, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.HASH160, c, o);
    }
  }
  return i.native = 2, i.id = "HASH160", i.size = 20, i.bits = 160, i.blockSize = 64, i.zero = Buffer.alloc(20, 0), i.ctx = new i(), zh = i, zh;
}
/*!
 * hash160.js - hash160 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Wu.exports = $y() : Wu.exports = Hy();
var Fy = Wu.exports, ju = { exports: {} };
/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
var Uh, F3;
function Vy() {
  if (F3)
    return Uh;
  F3 = 1;
  const r = _e, e = Eo(), t = Rr;
  class i {
    constructor() {
      this.ctx = new e();
    }
    init() {
      return this.ctx.init(), this;
    }
    update(c) {
      return this.ctx.update(c), this;
    }
    final() {
      const c = Buffer.alloc(32);
      return this.ctx._final(c), this.ctx.init(), this.ctx.update(c), this.ctx._final(c), c;
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new t(i, 64);
    }
    static digest(c) {
      return i.ctx.init().update(c).final();
    }
    static root(c, o) {
      return r(Buffer.isBuffer(c) && c.length === 32), r(Buffer.isBuffer(o) && o.length === 32), i.ctx.init().update(c).update(o).final();
    }
    static multi(c, o, d) {
      const { ctx: l } = i;
      return l.init(), l.update(c), l.update(o), d && l.update(d), l.final();
    }
    static mac(c, o) {
      return i.hmac().init(o).update(c).final();
    }
  }
  return i.native = 0, i.id = "HASH256", i.size = 32, i.bits = 256, i.blockSize = 64, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), Uh = i, Uh;
}
/*!
 * hash256.js - hash256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ch, V3;
function Gy() {
  if (V3)
    return Ch;
  V3 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.HASH256);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.HASH256);
    }
    static digest(c) {
      return r.digest(t.HASH256, c);
    }
    static root(c, o) {
      return r.root(t.HASH256, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.HASH256, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.HASH256, c, o);
    }
  }
  return i.native = 2, i.id = "HASH256", i.size = 32, i.bits = 256, i.blockSize = 64, i.zero = Buffer.alloc(32, 0), i.ctx = new i(), Ch = i, Ch;
}
/*!
 * hash256.js - hash256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? ju.exports = Vy() : ju.exports = Gy();
var Yy = ju.exports, Qu = { exports: {} };
/*!
 * hash-drbg.js - hash-drbg implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on cryptocoinjs/drbg.js:
 *   Copyright (c) 2016 Kirill Fomichev
 *   https://github.com/cryptocoinjs/drbg.js
 *
 * Resources:
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/cryptocoinjs/drbg.js/blob/master/hash.js
 */
var Th, G3;
function Jy() {
  if (G3)
    return Th;
  G3 = 1;
  const r = _e, e = 281474976710656, t = Buffer.from([1]), i = Buffer.from([2]), n = Buffer.from([3]);
  class c {
    constructor(d, l, h, x) {
      r(d && typeof d.id == "string"), this.hash = d, this.minEntropy = d.id === "SHA1" ? 10 : 24, this.seedLen = d.size <= 32 ? 55 : 111, this.V = Buffer.alloc(this.seedLen), this.C = Buffer.alloc(this.seedLen), this.len = Buffer.alloc(8), this.rounds = 0, l && this.init(l, h, x);
    }
    init(d, l, h) {
      l == null && (l = Buffer.alloc(0)), h == null && (h = Buffer.alloc(0)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h));
      const x = Buffer.concat([d, l, h]);
      if (x.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.V = this.derive(x, this.seedLen, 255), this.C = this.derive(this.V, this.seedLen, 0), this.rounds = 1, this;
    }
    reseed(d, l) {
      if (l == null && (l = Buffer.alloc(0)), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      const h = Buffer.concat([this.V, d, l]);
      if (h.length < this.minEntropy)
        throw new Error("Not enough entropy.");
      return this.V = this.derive(h, this.seedLen, 1), this.C = this.derive(this.V, this.seedLen, 0), this.rounds = 1, this;
    }
    generate(d, l) {
      if (r(d >>> 0 === d), r(l == null || Buffer.isBuffer(l)), this.rounds === 0)
        throw new Error("DRBG not initialized.");
      if (this.rounds > e)
        throw new Error("Reseed is required.");
      l && l.length > 0 && this.sum(this.V, this.hash.multi(i, this.V, l));
      const h = Buffer.from(this.V), x = Math.ceil(d / this.hash.size), b = Buffer.alloc(x * this.hash.size);
      for (let g = 0; g < x; g++)
        this.hash.digest(h).copy(b, g * this.hash.size), this.sum(h, t);
      return this.update(), this.rounds += 1, b.slice(0, d);
    }
    randomBytes(d) {
      return this.generate(d);
    }
    /*
     * Helpers
     */
    update() {
      const d = this.hash.multi(n, this.V), l = this.rounds / 4294967296 >>> 0, h = this.rounds >>> 0;
      return this.len[0] = l >>> 24, this.len[1] = l >>> 16, this.len[2] = l >>> 8, this.len[3] = l, this.len[4] = h >>> 24, this.len[5] = h >>> 16, this.len[6] = h >>> 8, this.len[7] = h, this.sum(this.V, d, this.C, this.len), this;
    }
    derive(d, l, h) {
      r(Buffer.isBuffer(d)), r(l >>> 0 === l), r((h & 255) === h);
      const x = h !== 255 | 0, b = Buffer.alloc(5 + x + d.length);
      b[0] = 1, b[1] = l >>> 21, b[2] = l >>> 13, b[3] = l >>> 5, b[4] = (l & 31) << 3, x && (b[5] = h), d.copy(b, 5 + x);
      const g = Math.ceil(l / this.hash.size), w = Buffer.alloc(g * this.hash.size);
      for (let I = 0; I < g; I++)
        this.hash.digest(b).copy(w, I * this.hash.size), b[0] += 1;
      return w.slice(0, l);
    }
    sum(d, ...l) {
      for (const h of l) {
        let x = h.length - 1, b = d.length - 1, g = 0;
        for (; x >= 0; )
          g += h[x] + d[b], d[b] = g & 255, g >>>= 8, x -= 1, b -= 1;
        for (; g > 0 && b >= 0; )
          g += d[b], d[b] = g & 255, g >>>= 8, b -= 1;
      }
      return d;
    }
  }
  return c.native = 0, Th = c, Th;
}
/*!
 * hash-drbg.js - hash-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Dh, Y3;
function Xy() {
  if (Y3)
    return Dh;
  Y3 = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n, c, o, d) {
      this._handle = e.hash_drbg_create(e.hash(n)), c && this.init(c, o, d);
    }
    init(n, c, o) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c == null || Buffer.isBuffer(c)), r(o == null || Buffer.isBuffer(o)), c && o ? n = Buffer.concat([n, c, o]) : c ? n = Buffer.concat([n, c]) : o && (n = Buffer.concat([n, o])), e.hash_drbg_init(this._handle, n), this;
    }
    reseed(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c == null || Buffer.isBuffer(c)), c && (n = Buffer.concat([n, c])), e.hash_drbg_reseed(this._handle, n), this;
    }
    generate(n, c) {
      return c == null && (c = e.NULL), r(this instanceof t), r(n >>> 0 === n), r(Buffer.isBuffer(c)), e.hash_drbg_generate(this._handle, n, c);
    }
    randomBytes(n) {
      return this.generate(n);
    }
  }
  return t.native = 2, Dh = t, Dh;
}
/*!
 * hash-drbg.js - hash-drbg for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? Qu.exports = Jy() : Qu.exports = Xy();
var Zy = Qu.exports, e1 = { exports: {} }, xn = {};
/*!
 * hkdf.js - hkdf for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HKDF
 *   https://tools.ietf.org/html/rfc5869
 */
var J3;
function Wy() {
  if (J3)
    return xn;
  J3 = 1;
  const r = _e;
  function e(n, c, o) {
    return r(n && typeof n.id == "string"), c == null && (c = Buffer.alloc(0)), o == null && (o = Buffer.alloc(n.size, 0)), n.mac(c, o);
  }
  function t(n, c, o, d) {
    if (o == null && (o = Buffer.alloc(0)), r(n && typeof n.id == "string"), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(d >>> 0 === d), c.length !== n.size)
      throw new RangeError("Invalid PRK length.");
    const l = Math.ceil(d / n.size);
    if (l > 255)
      throw new RangeError("Invalid output length.");
    const h = Buffer.alloc(l * n.size), x = Buffer.from([0]), b = n.hmac();
    let g = Buffer.alloc(0), w = 0;
    for (let I = 0; I < l; I++)
      x[0] += 1, b.init(c), b.update(g), b.update(o), b.update(x), g = b.final(), w += g.copy(h, w);
    return h.slice(0, d);
  }
  function i(n, c, o, d, l) {
    const h = e(n, c, o);
    return t(n, h, d, l);
  }
  return xn.native = 0, xn.extract = e, xn.expand = t, xn.derive = i, xn;
}
var bn = {};
/*!
 * hkdf.js - hkdf for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var X3;
function jy() {
  if (X3)
    return bn;
  X3 = 1;
  const r = _e, e = Dt();
  function t(c, o, d) {
    return r(c && typeof c.id == "string"), o == null && (o = e.NULL), d == null && (d = Buffer.alloc(c.size, 0)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), e.hkdf_extract(e.hash(c), o, d);
  }
  function i(c, o, d, l) {
    return d == null && (d = e.NULL), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), e.hkdf_expand(e.hash(c), o, d, l);
  }
  function n(c, o, d, l, h) {
    const x = t(c, o, d);
    return i(c, x, l, h);
  }
  return bn.native = 2, bn.extract = t, bn.expand = i, bn.derive = n, bn;
}
/*!
 * hkdf.js - hkdf for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? e1.exports = Wy() : e1.exports = jy();
var Qy = e1.exports;
/*!
 * keccak224.js - Keccak-224 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const u7 = fn;
class mi extends u7 {
  constructor() {
    super();
  }
  init() {
    return super.init(224);
  }
  final() {
    return super.final(1, null);
  }
  static hash() {
    return new mi();
  }
  static hmac() {
    return super.hmac(224, 1, null);
  }
  static digest(e) {
    return super.digest(e, 224, 1, null);
  }
  static root(e, t) {
    return super.root(e, t, 224, 1, null);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 224, 1, null);
  }
  static mac(e, t) {
    return super.mac(e, t, 224, 1, null);
  }
}
mi.native = u7.native;
mi.id = "KECCAK224";
mi.size = 28;
mi.bits = 224;
mi.blockSize = 144;
mi.zero = Buffer.alloc(28, 0);
mi.ctx = new mi();
var eS = mi;
/*!
 * keccak256.js - Keccak-256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const l7 = fn;
class gi extends l7 {
  constructor() {
    super();
  }
  init() {
    return super.init(256);
  }
  final() {
    return super.final(1, null);
  }
  static hash() {
    return new gi();
  }
  static hmac() {
    return super.hmac(256, 1, null);
  }
  static digest(e) {
    return super.digest(e, 256, 1, null);
  }
  static root(e, t) {
    return super.root(e, t, 256, 1, null);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 256, 1, null);
  }
  static mac(e, t) {
    return super.mac(e, t, 256, 1, null);
  }
}
gi.native = l7.native;
gi.id = "KECCAK256";
gi.size = 32;
gi.bits = 256;
gi.blockSize = 136;
gi.zero = Buffer.alloc(32, 0);
gi.ctx = new gi();
var tS = gi;
/*!
 * keccak384.js - Keccak-384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const x7 = fn;
class wi extends x7 {
  constructor() {
    super();
  }
  init() {
    return super.init(384);
  }
  final() {
    return super.final(1, null);
  }
  static hash() {
    return new wi();
  }
  static hmac() {
    return super.hmac(384, 1, null);
  }
  static digest(e) {
    return super.digest(e, 384, 1, null);
  }
  static root(e, t) {
    return super.root(e, t, 384, 1, null);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 384, 1, null);
  }
  static mac(e, t) {
    return super.mac(e, t, 384, 1, null);
  }
}
wi.native = x7.native;
wi.id = "KECCAK384";
wi.size = 48;
wi.bits = 384;
wi.blockSize = 104;
wi.zero = Buffer.alloc(48, 0);
wi.ctx = new wi();
var rS = wi;
/*!
 * keccak512.js - Keccak-512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const b7 = fn;
class yi extends b7 {
  constructor() {
    super();
  }
  init() {
    return super.init(512);
  }
  final() {
    return super.final(1, null);
  }
  static hash() {
    return new yi();
  }
  static hmac() {
    return super.hmac(512, 1, null);
  }
  static digest(e) {
    return super.digest(e, 512, 1, null);
  }
  static root(e, t) {
    return super.root(e, t, 512, 1, null);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 512, 1, null);
  }
  static mac(e, t) {
    return super.mac(e, t, 512, 1, null);
  }
}
yi.native = b7.native;
yi.id = "KECCAK512";
yi.size = 32;
yi.bits = 512;
yi.blockSize = 72;
yi.zero = Buffer.alloc(32, 0);
yi.ctx = new yi();
var iS = yi;
/*!
 * kmac.js - KMAC implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.inc
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.c
 *   https://github.com/XKCP/XKCP/blob/8f447eb/tests/UnitTests/testSP800-185.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */
const Us = _e, p7 = vo, sS = Rr, nS = Buffer.from("KMAC", "binary"), fS = Buffer.alloc(0);
let hs = class Hs extends p7 {
  constructor() {
    super();
  }
  init(e, t, i) {
    return t == null && (t = fS), Us(Buffer.isBuffer(t)), super.init(e, nS, i), super.bytePad([t], this.rate / 8), this;
  }
  final(e) {
    return e == null && (e = 100 - this.rate / 8 / 2), super.rightEncode(e * 8), super.final(e);
  }
  static hash() {
    return new Hs();
  }
  static hmac(e, t, i, n) {
    e == null && (e = 256), Us(e >>> 0 === e), Us(e === 128 || e === 256);
    const c = 1600 - e * 2;
    return new sS(Hs, c / 8, [e, t, i], [n]);
  }
  static digest(e, t, i, n, c) {
    return Hs.ctx.init(t, i, n).update(e).final(c);
  }
  static root(e, t, i, n, c, o) {
    i == null && (i = 256), o == null && (o = 0), o === 0 && (Us(i >>> 0 === i), o = i >>> 3), Us(o >>> 0 === o), Us(Buffer.isBuffer(e) && e.length === o), Us(Buffer.isBuffer(t) && t.length === o);
    const { ctx: d } = Hs;
    return d.init(i, n, c), d.update(e), d.update(t), d.final(o);
  }
  static multi(e, t, i, n, c, o, d) {
    const { ctx: l } = Hs;
    return l.init(n, c, o), l.update(e), l.update(t), i && l.update(i), l.final(d);
  }
  static mac(e, t, i, n, c, o) {
    return Hs.hmac(i, n, c, o).init(t).update(e).final();
  }
};
hs.native = p7.native;
hs.id = "KMAC256";
hs.size = 32;
hs.bits = 256;
hs.blockSize = 136;
hs.zero = Buffer.alloc(32, 0);
hs.ctx = new hs();
var yl = hs;
/*!
 * kmac128.js - KMAC128 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const m7 = yl;
class Si extends m7 {
  constructor() {
    super();
  }
  init(e, t) {
    return super.init(128, e, t);
  }
  static hash() {
    return new Si();
  }
  static hmac(e, t, i) {
    return super.hmac(128, e, t, i);
  }
  static digest(e, t, i, n) {
    return super.digest(e, 128, t, i, n);
  }
  static root(e, t, i, n, c) {
    return super.root(e, t, 128, i, n, c);
  }
  static multi(e, t, i, n, c, o) {
    return super.multi(e, t, i, 128, n, c, o);
  }
  static mac(e, t, i, n, c) {
    return super.mac(e, t, 128, i, n, c);
  }
}
Si.native = m7.native;
Si.id = "KMAC128";
Si.size = 16;
Si.bits = 128;
Si.blockSize = 168;
Si.zero = Buffer.alloc(16, 0);
Si.ctx = new Si();
var cS = Si;
/*!
 * kmac256.js - KMAC256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const g7 = yl;
class Bi extends g7 {
  constructor() {
    super();
  }
  init(e, t) {
    return super.init(256, e, t);
  }
  static hash() {
    return new Bi();
  }
  static hmac(e, t, i) {
    return super.hmac(256, e, t, i);
  }
  static digest(e, t, i, n) {
    return super.digest(e, 256, t, i, n);
  }
  static root(e, t, i, n, c) {
    return super.root(e, t, 256, i, n, c);
  }
  static multi(e, t, i, n, c, o) {
    return super.multi(e, t, i, 256, n, c, o);
  }
  static mac(e, t, i, n, c) {
    return super.mac(e, t, 256, i, n, c);
  }
}
Bi.native = g7.native;
Bi.id = "KMAC256";
Bi.size = 32;
Bi.bits = 256;
Bi.blockSize = 136;
Bi.zero = Buffer.alloc(32, 0);
Bi.ctx = new Bi();
var oS = Bi, t1 = { exports: {} };
/*!
 * md2.js - MD2 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD2_(hash_function)
 *   https://tools.ietf.org/html/rfc1319
 *   https://github.com/RustCrypto/hashes/blob/master/md2/src/lib.rs
 */
var Lh, Z3;
function aS() {
  if (Z3)
    return Lh;
  Z3 = 1;
  const r = _e, e = Rr, t = -1, i = new Uint8Array([
    41,
    46,
    67,
    201,
    162,
    216,
    124,
    1,
    61,
    54,
    84,
    161,
    236,
    240,
    6,
    19,
    98,
    167,
    5,
    243,
    192,
    199,
    115,
    140,
    152,
    147,
    43,
    217,
    188,
    76,
    130,
    202,
    30,
    155,
    87,
    60,
    253,
    212,
    224,
    22,
    103,
    66,
    111,
    24,
    138,
    23,
    229,
    18,
    190,
    78,
    196,
    214,
    218,
    158,
    222,
    73,
    160,
    251,
    245,
    142,
    187,
    47,
    238,
    122,
    169,
    104,
    121,
    145,
    21,
    178,
    7,
    63,
    148,
    194,
    16,
    137,
    11,
    34,
    95,
    33,
    128,
    127,
    93,
    154,
    90,
    144,
    50,
    39,
    53,
    62,
    204,
    231,
    191,
    247,
    151,
    3,
    255,
    25,
    48,
    179,
    72,
    165,
    181,
    209,
    215,
    94,
    146,
    42,
    172,
    86,
    170,
    198,
    79,
    184,
    56,
    210,
    150,
    164,
    125,
    182,
    118,
    252,
    107,
    226,
    156,
    116,
    4,
    241,
    69,
    157,
    112,
    89,
    100,
    113,
    135,
    32,
    134,
    91,
    207,
    101,
    230,
    45,
    168,
    2,
    27,
    96,
    37,
    173,
    174,
    176,
    185,
    246,
    28,
    70,
    97,
    105,
    52,
    64,
    126,
    15,
    85,
    71,
    163,
    35,
    221,
    81,
    175,
    58,
    195,
    92,
    249,
    206,
    186,
    197,
    234,
    38,
    44,
    83,
    13,
    110,
    133,
    40,
    132,
    9,
    211,
    223,
    205,
    244,
    65,
    129,
    77,
    82,
    106,
    220,
    55,
    200,
    108,
    193,
    171,
    250,
    36,
    225,
    123,
    8,
    12,
    189,
    177,
    74,
    120,
    136,
    149,
    139,
    227,
    99,
    232,
    109,
    233,
    203,
    213,
    254,
    59,
    0,
    29,
    57,
    242,
    239,
    183,
    14,
    102,
    88,
    208,
    228,
    166,
    119,
    114,
    248,
    235,
    117,
    75,
    10,
    49,
    68,
    80,
    180,
    143,
    237,
    31,
    26,
    219,
    153,
    141,
    51,
    159,
    17,
    131,
    20
  ]);
  class n {
    constructor() {
      this.state = Buffer.alloc(48), this.checksum = Buffer.alloc(16), this.block = Buffer.alloc(16), this.size = t;
    }
    init() {
      return this.state.fill(0), this.checksum.fill(0), this.size = 0, this;
    }
    update(o) {
      return r(Buffer.isBuffer(o)), this._update(o, o.length), this;
    }
    final() {
      return this._final(Buffer.alloc(16));
    }
    _update(o, d) {
      r(this.size !== t, "Context is not initialized.");
      let l = this.size & 15, h = 0;
      if (this.size += d, l > 0) {
        let x = 16 - l;
        if (x > d && (x = d), o.copy(this.block, l, h, h + x), l += x, d -= x, h += x, l < 16)
          return;
        this._transform(this.block, 0);
      }
      for (; d >= 16; )
        this._transform(o, h), h += 16, d -= 16;
      d > 0 && o.copy(this.block, 0, h, h + d);
    }
    _final(o) {
      r(this.size !== t, "Context is not initialized.");
      const l = 16 - (this.size & 15), h = Buffer.alloc(l);
      for (let x = 0; x < h.length; x++)
        h[x] = l;
      return this._update(h, l), this._update(this.checksum, 16), this.state.copy(o, 0, 0, 16), this.state.fill(0), this.checksum.fill(0), this.block.fill(0), this.size = t, o;
    }
    _transform(o, d) {
      for (let x = 0; x < 16; x++)
        this.state[16 + x] = o[d + x], this.state[32 + x] = this.state[16 + x] ^ this.state[x];
      let l = 0;
      for (let x = 0; x < 18; x++) {
        for (let b = 0; b < 48; b++)
          this.state[b] ^= i[l], l = this.state[b];
        l = l + x & 255;
      }
      let h = this.checksum[15];
      for (let x = 0; x < 16; x++)
        this.checksum[x] ^= i[o[d + x] ^ h], h = this.checksum[x];
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new e(n, 16);
    }
    static digest(o) {
      return n.ctx.init().update(o).final();
    }
    static root(o, d) {
      return r(Buffer.isBuffer(o) && o.length === 16), r(Buffer.isBuffer(d) && d.length === 16), n.ctx.init().update(o).update(d).final();
    }
    static multi(o, d, l) {
      const { ctx: h } = n;
      return h.init(), h.update(o), h.update(d), l && h.update(l), h.final();
    }
    static mac(o, d) {
      return n.hmac().init(d).update(o).final();
    }
  }
  return n.native = 0, n.id = "MD2", n.size = 16, n.bits = 128, n.blockSize = 16, n.zero = Buffer.alloc(16, 0), n.ctx = new n(), Lh = n, Lh;
}
/*!
 * md2.js - MD2 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Kh, W3;
function hS() {
  if (W3)
    return Kh;
  W3 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.MD2);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.MD2);
    }
    static digest(c) {
      return r.digest(t.MD2, c);
    }
    static root(c, o) {
      return r.root(t.MD2, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.MD2, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.MD2, c, o);
    }
  }
  return i.native = 2, i.id = "MD2", i.size = 16, i.bits = 128, i.blockSize = 16, i.zero = Buffer.alloc(16, 0), i.ctx = new i(), Kh = i, Kh;
}
/*!
 * md2.js - md2 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? t1.exports = aS() : t1.exports = hS();
var dS = t1.exports, r1 = { exports: {} };
/*!
 * md4.js - MD4 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD4
 *   https://tools.ietf.org/html/rfc1320
 *   https://github.com/RustCrypto/hashes/blob/master/md4/src/lib.rs
 */
var $h, j3;
function uS() {
  if (j3)
    return $h;
  j3 = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(8, 0), n = Buffer.alloc(64, 0);
  n[0] = 128;
  const c = new Uint32Array([
    1732584193,
    4023233417,
    2562383102,
    271733878
  ]);
  class o {
    constructor() {
      this.state = new Uint32Array(4), this.msg = new Uint32Array(16), this.block = Buffer.alloc(64), this.size = t;
    }
    init() {
      return this.state[0] = c[0], this.state[1] = c[1], this.state[2] = c[2], this.state[3] = c[3], this.size = 0, this;
    }
    update(A) {
      return r(Buffer.isBuffer(A)), this._update(A, A.length), this;
    }
    final() {
      return this._final(Buffer.alloc(16));
    }
    _update(A, _) {
      r(this.size !== t, "Context is not initialized.");
      let q = this.size & 63, U = 0;
      if (this.size += _, q > 0) {
        let z = 64 - q;
        if (z > _ && (z = _), A.copy(this.block, q, U, U + z), q += z, _ -= z, U += z, q < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; _ >= 64; )
        this._transform(A, U), U += 64, _ -= 64;
      _ > 0 && A.copy(this.block, 0, U, U + _);
    }
    /**
     * Finalize MD4 context.
     * @private
     * @param {Buffer} out
     * @returns {Buffer}
     */
    _final(A) {
      r(this.size !== t, "Context is not initialized.");
      const _ = this.size & 63, q = this.size * 8;
      B(i, q >>> 0, 0), B(i, q * (1 / 4294967296) >>> 0, 4), this._update(n, 1 + (119 - _ & 63)), this._update(i, 8);
      for (let U = 0; U < 4; U++)
        B(A, this.state[U], U * 4), this.state[U] = 0;
      for (let U = 0; U < 16; U++)
        this.msg[U] = 0;
      for (let U = 0; U < 64; U++)
        this.block[U] = 0;
      return this.size = t, A;
    }
    _transform(A, _) {
      const q = this.msg;
      let U = this.state[0], z = this.state[1], E = this.state[2], H = this.state[3];
      for (let k = 0; k < 16; k++)
        q[k] = I(A, _ + k * 4);
      for (const k of [0, 4, 8, 12])
        U = x(U, z, E, H, q[k], 3), H = x(H, U, z, E, q[k + 1], 7), E = x(E, H, U, z, q[k + 2], 11), z = x(z, E, H, U, q[k + 3], 19);
      for (let k = 0; k < 4; k++)
        U = b(U, z, E, H, q[k], 3), H = b(H, U, z, E, q[k + 4], 5), E = b(E, H, U, z, q[k + 8], 9), z = b(z, E, H, U, q[k + 12], 13);
      for (const k of [0, 2, 1, 3])
        U = g(U, z, E, H, q[k], 3), H = g(H, U, z, E, q[k + 8], 9), E = g(E, H, U, z, q[k + 4], 11), z = g(z, E, H, U, q[k + 12], 15);
      this.state[0] += U, this.state[1] += z, this.state[2] += E, this.state[3] += H;
    }
    static hash() {
      return new o();
    }
    static hmac() {
      return new e(o, 64);
    }
    static digest(A) {
      return o.ctx.init().update(A).final();
    }
    static root(A, _) {
      return r(Buffer.isBuffer(A) && A.length === 16), r(Buffer.isBuffer(_) && _.length === 16), o.ctx.init().update(A).update(_).final();
    }
    static multi(A, _, q) {
      const { ctx: U } = o;
      return U.init(), U.update(A), U.update(_), q && U.update(q), U.final();
    }
    static mac(A, _) {
      return o.hmac().init(_).update(A).final();
    }
  }
  o.native = 0, o.id = "MD4", o.size = 16, o.bits = 128, o.blockSize = 64, o.zero = Buffer.alloc(16, 0), o.ctx = new o();
  function d(y, A, _) {
    return y & A | ~y & _;
  }
  function l(y, A, _) {
    return y & A | y & _ | A & _;
  }
  function h(y, A, _) {
    return y ^ A ^ _;
  }
  function x(y, A, _, q, U, z) {
    return w(y + d(A, _, q) + U, z);
  }
  function b(y, A, _, q, U, z) {
    return w(y + l(A, _, q) + U + 1518500249, z);
  }
  function g(y, A, _, q, U, z) {
    return w(y + h(A, _, q) + U + 1859775393, z);
  }
  function w(y, A) {
    return y << A | y >>> 32 - A;
  }
  function I(y, A) {
    return y[A++] + y[A++] * 256 + y[A++] * 65536 + y[A] * 16777216;
  }
  function B(y, A, _) {
    return y[_++] = A, A >>>= 8, y[_++] = A, A >>>= 8, y[_++] = A, A >>>= 8, y[_++] = A, _;
  }
  return $h = o, $h;
}
/*!
 * md4.js - MD4 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Hh, Q3;
function lS() {
  if (Q3)
    return Hh;
  Q3 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.MD4);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.MD4);
    }
    static digest(c) {
      return r.digest(t.MD4, c);
    }
    static root(c, o) {
      return r.root(t.MD4, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.MD4, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.MD4, c, o);
    }
  }
  return i.native = 2, i.id = "MD4", i.size = 16, i.bits = 128, i.blockSize = 64, i.zero = Buffer.alloc(16, 0), i.ctx = new i(), Hh = i, Hh;
}
/*!
 * md4.js - md4 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? r1.exports = uS() : r1.exports = lS();
var xS = r1.exports, i1 = { exports: {} };
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */
var Fh, eb;
function w7() {
  if (eb)
    return Fh;
  eb = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(8, 0), n = Buffer.alloc(64, 0);
  n[0] = 128;
  const c = new Uint32Array([
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ]);
  class o {
    constructor() {
      this.state = new Uint32Array(5), this.msg = new Uint32Array(80), this.block = Buffer.alloc(64), this.size = t;
    }
    init() {
      return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
    }
    update(B) {
      return r(Buffer.isBuffer(B)), this._update(B, B.length), this;
    }
    final() {
      return this._final(Buffer.alloc(20));
    }
    _update(B, y) {
      r(this.size !== t, "Context is not initialized.");
      let A = this.size & 63, _ = 0;
      if (this.size += y, A > 0) {
        let q = 64 - A;
        if (q > y && (q = y), B.copy(this.block, A, _, _ + q), A += q, y -= q, _ += q, A < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; y >= 64; )
        this._transform(B, _), _ += 64, y -= 64;
      y > 0 && B.copy(this.block, 0, _, _ + y);
    }
    _final(B) {
      r(this.size !== t, "Context is not initialized.");
      const y = this.size & 63, A = this.size * 8;
      w(i, A * (1 / 4294967296) >>> 0, 0), w(i, A >>> 0, 4), this._update(n, 1 + (119 - y & 63)), this._update(i, 8);
      for (let _ = 0; _ < 5; _++)
        w(B, this.state[_], _ * 4), this.state[_] = 0;
      for (let _ = 0; _ < 80; _++)
        this.msg[_] = 0;
      for (let _ = 0; _ < 64; _++)
        this.block[_] = 0;
      return this.size = t, B;
    }
    _transform(B, y) {
      const A = this.msg;
      let _ = this.state[0], q = this.state[1], U = this.state[2], z = this.state[3], E = this.state[4], H = 0;
      for (; H < 16; H++)
        A[H] = g(B, y + H * 4);
      for (; H < 80; H++)
        A[H] = d(A[H - 3] ^ A[H - 8] ^ A[H - 14] ^ A[H - 16], 1);
      for (H = 0; H < 80; H++) {
        const k = H / 20 | 0, V = d(_, 5) + l(k, q, U, z) + E + A[H] + c[k];
        E = z, z = U, U = d(q, 30), q = _, _ = V >>> 0;
      }
      this.state[0] += _, this.state[1] += q, this.state[2] += U, this.state[3] += z, this.state[4] += E;
    }
    static hash() {
      return new o();
    }
    static hmac() {
      return new e(o, 64);
    }
    static digest(B) {
      return o.ctx.init().update(B).final();
    }
    static root(B, y) {
      return r(Buffer.isBuffer(B) && B.length === 20), r(Buffer.isBuffer(y) && y.length === 20), o.ctx.init().update(B).update(y).final();
    }
    static multi(B, y, A) {
      const { ctx: _ } = o;
      return _.init(), _.update(B), _.update(y), A && _.update(A), _.final();
    }
    static mac(B, y) {
      return o.hmac().init(y).update(B).final();
    }
  }
  o.native = 0, o.id = "SHA1", o.size = 20, o.bits = 160, o.blockSize = 64, o.zero = Buffer.alloc(20, 0), o.ctx = new o();
  function d(I, B) {
    return I << B | I >>> 32 - B;
  }
  function l(I, B, y, A) {
    return I === 0 ? h(B, y, A) : I === 1 || I === 3 ? b(B, y, A) : I === 2 ? x(B, y, A) : 0;
  }
  function h(I, B, y) {
    return I & B ^ ~I & y;
  }
  function x(I, B, y) {
    return I & B ^ I & y ^ B & y;
  }
  function b(I, B, y) {
    return I ^ B ^ y;
  }
  function g(I, B) {
    return I[B++] * 16777216 + I[B++] * 65536 + I[B++] * 256 + I[B];
  }
  function w(I, B, y) {
    return I[y++] = B >>> 24, I[y++] = B >>> 16, I[y++] = B >>> 8, I[y++] = B, y;
  }
  return Fh = o, Fh;
}
/*!
 * md5sha1.js - MD5-SHA1 implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Vh, tb;
function bS() {
  if (tb)
    return Vh;
  tb = 1;
  const r = _e, e = Q5(), t = w7(), i = Rr;
  class n {
    constructor() {
      this.md5 = new e(), this.sha1 = new t();
    }
    init() {
      return this.md5.init(), this.sha1.init(), this;
    }
    update(o) {
      return this.md5.update(o), this.sha1.update(o), this;
    }
    final() {
      const o = Buffer.alloc(36);
      return this.md5.final().copy(o, 0), this.sha1.final().copy(o, 16), o;
    }
    static hash() {
      return new n();
    }
    static hmac() {
      return new i(n, 64);
    }
    static digest(o) {
      return n.ctx.init().update(o).final();
    }
    static root(o, d) {
      return r(Buffer.isBuffer(o) && o.length === 36), r(Buffer.isBuffer(d) && d.length === 36), n.ctx.init().update(o).update(d).final();
    }
    static multi(o, d, l) {
      const { ctx: h } = n;
      return h.init(), h.update(o), h.update(d), l && h.update(l), h.final();
    }
    static mac(o, d) {
      return n.hmac().init(d).update(o).final();
    }
  }
  return n.native = 0, n.id = "MD5SHA1", n.size = 36, n.bits = 288, n.blockSize = 64, n.zero = Buffer.alloc(36, 0), n.ctx = new n(), Vh = n, Vh;
}
/*!
 * md5sha1.js - MD5SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Gh, rb;
function pS() {
  if (rb)
    return Gh;
  rb = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.MD5SHA1);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.MD5SHA1);
    }
    static digest(c) {
      return r.digest(t.MD5SHA1, c);
    }
    static root(c, o) {
      return r.root(t.MD5SHA1, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.MD5SHA1, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.MD5SHA1, c, o);
    }
  }
  return i.native = 2, i.id = "MD5SHA1", i.size = 36, i.bits = 288, i.blockSize = 64, i.zero = Buffer.alloc(36, 0), i.ctx = new i(), Gh = i, Gh;
}
/*!
 * md5sha1.js - md5sha1 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? i1.exports = bS() : i1.exports = pS();
var mS = i1.exports, Xf = {};
/*!
 * merkle.js - merkle trees for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 */
const Q0 = _e;
function Sl(r, e) {
  Q0(r && typeof r.root == "function"), Q0(Array.isArray(e));
  const t = new Array(e.length);
  for (let o = 0; o < e.length; o++)
    t[o] = e[o];
  let i = t.length, n = !1, c = 0;
  if (i === 0)
    return t.push(r.zero), [t, n];
  for (; i > 1; ) {
    for (let o = 0; o < i; o += 2) {
      const d = Math.min(o + 1, i - 1), l = t[c + o], h = t[c + d];
      d === o + 1 && d + 1 === i && l.equals(h) && (n = !0);
      const x = r.root(l, h);
      t.push(x);
    }
    c += i, i = i + 1 >>> 1;
  }
  return [t, n];
}
function gS(r, e) {
  Q0(r && typeof r.root == "function"), Q0(Array.isArray(e));
  const [t, i] = Sl(r, e);
  return [t[t.length - 1], i];
}
function wS(r, e, t) {
  Q0(r && typeof r.root == "function"), Q0(e >>> 0 === e), Q0(Array.isArray(t)), Q0(e < t.length);
  let i = t.length;
  const [n] = Sl(r, t), c = [];
  let o = 0;
  for (; i > 1; ) {
    const d = Math.min(e ^ 1, i - 1);
    c.push(n[o + d]), e >>>= 1, o += i, i = i + 1 >>> 1;
  }
  return c;
}
function yS(r, e, t, i) {
  Q0(r && typeof r.root == "function"), Q0(Buffer.isBuffer(e)), Q0(Array.isArray(t)), Q0(i >>> 0 === i);
  let n = e;
  for (const c of t) {
    if (i & 1 && c.equals(n))
      return r.zero;
    i & 1 ? n = r.root(c, n) : n = r.root(n, c), i >>>= 1;
  }
  return n;
}
Xf.createTree = Sl;
Xf.createRoot = gS;
Xf.createBranch = wS;
Xf.deriveRoot = yS;
var Ms = {};
/*!
 * mrkl.js - merkle trees for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const ns = _e, SS = Buffer.alloc(0), BS = Buffer.from([1]), vS = Buffer.from([0]);
function Bl(r, e) {
  ns(r && typeof r.multi == "function"), ns(Array.isArray(e));
  const t = [], i = vl(r);
  for (const o of e) {
    const d = El(r, o);
    t.push(d);
  }
  let n = t.length, c = 0;
  if (n === 0)
    return t.push(i), t;
  for (; n > 1; ) {
    for (let o = 0; o < n; o += 2) {
      const d = o, l = o + 1, h = t[c + d];
      let x;
      l < n ? x = t[c + l] : x = i;
      const b = no(r, h, x);
      t.push(b);
    }
    c += n, n = n + 1 >>> 1;
  }
  return t;
}
function ES(r, e) {
  const t = Bl(r, e);
  return t[t.length - 1];
}
function IS(r, e, t) {
  ns(e >>> 0 === e);
  const i = Bl(r, t), n = vl(r), c = [];
  let o = t.length, d = 0;
  for (ns(e < t.length); o > 1; ) {
    const l = e ^ 1;
    l < o ? c.push(i[d + l]) : c.push(n), e >>>= 1, d += o, o = o + 1 >>> 1;
  }
  return c;
}
function AS(r, e, t, i) {
  ns(r && typeof r.multi == "function"), ns(Buffer.isBuffer(e)), ns(Array.isArray(t)), ns(i >>> 0 === i);
  let n = El(r, e);
  for (const c of t)
    i & 1 ? n = no(r, c, n) : n = no(r, n, c), i >>>= 1;
  return n;
}
function vl(r) {
  return r.digest(SS);
}
function El(r, e) {
  return r.multi(vS, e);
}
function no(r, e, t) {
  return ns(t != null), r.multi(BS, e, t);
}
Ms.createTree = Bl;
Ms.createRoot = ES;
Ms.createBranch = IS;
Ms.deriveRoot = AS;
Ms.hashEmpty = vl;
Ms.hashLeaf = El;
Ms.hashInternal = no;
var s1 = { exports: {} }, af = {};
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MurmurHash
 *   https://github.com/aappleby/smhasher
 */
var ib;
function _S() {
  if (ib)
    return af;
  ib = 1;
  const r = _e;
  function e(o, d) {
    r(Buffer.isBuffer(o)), r(typeof d == "number");
    const l = o.length - (o.length & 3), h = 3432918353, x = 461845907;
    let b = d | 0;
    for (let w = 0; w < l; w += 4) {
      let I = c(o, w);
      I = i(I, h), I = n(I, 15), I = i(I, x), b ^= I, b = n(b, 13), b = i(b, 5) + 3864292196 | 0;
    }
    let g = 0;
    switch (o.length & 3) {
      case 3:
        g ^= o[l + 2] << 16;
      case 2:
        g ^= o[l + 1] << 8;
      case 1:
        g ^= o[l + 0], g = i(g, h), g = n(g, 15), g = i(g, x), b ^= g;
    }
    return b ^= o.length, b ^= b >>> 16, b = i(b, 2246822507), b ^= b >>> 13, b = i(b, 3266489909), b ^= b >>> 16, b >>> 0;
  }
  function t(o, d, l) {
    r(typeof d == "number"), r(typeof l == "number");
    const h = i(d, 4221880213) + (l | 0);
    return e(o, h);
  }
  function i(o, d) {
    const l = o & 65535, h = d & 65535, x = o >>> 16, b = d >>> 16, g = l * h;
    return x * h + b * l + (g >>> 16) << 16 | g & 65535;
  }
  function n(o, d) {
    return o << d | o >>> 32 - d;
  }
  function c(o, d) {
    return o[d++] + o[d++] * 256 + o[d++] * 65536 + o[d] * 16777216;
  }
  return af.native = 0, af.sum = e, af.tweak = t, af;
}
var hf = {};
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var sb;
function MS() {
  if (sb)
    return hf;
  sb = 1;
  const r = _e, e = Dt();
  function t(n, c) {
    return r(Buffer.isBuffer(n)), e.murmur3_sum(n, c >>> 0);
  }
  function i(n, c, o) {
    return r(Buffer.isBuffer(n)), e.murmur3_tweak(n, c >>> 0, o >>> 0);
  }
  return hf.native = 2, hf.sum = t, hf.tweak = i, hf;
}
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? s1.exports = _S() : s1.exports = MS();
var NS = s1.exports, n1 = { exports: {} };
/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */
var Yh, nb;
function OS() {
  if (nb)
    return Yh;
  nb = 1;
  const r = _e, e = j1(), t = J0;
  class i {
    constructor(c, o) {
      this.curve = c, this.hash = o, this.rng = new e(this.curve, this.encode.bind(this));
    }
    check() {
      if (this.curve.p.andln(3) !== 3)
        throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
    }
    encode(c) {
      r(Buffer.isBuffer(c));
      const { fieldSize: o } = this.curve;
      if (c.length === 1 + o)
        return c;
      if (c.length !== 1 + o * 2)
        throw new Error("Invalid point.");
      const d = Buffer.alloc(1 + o);
      return d[0] = 2 | c[c.length - 1] & 1, c.copy(d, 1, 1, 1 + o), d;
    }
    hashInt(...c) {
      const o = new this.hash();
      o.init();
      for (const h of c)
        o.update(h);
      let d = o.final(this.curve.scalarSize);
      d.length > this.curve.scalarSize && (d = d.slice(0, this.curve.scalarSize));
      const l = t.decode(d, this.curve.endian);
      return l.iumaskn(this.curve.scalarBits), l.imod(this.curve.n);
    }
    hashNonce(c, o) {
      return this.hashInt(c, o);
    }
    hashChallenge(c, o, d) {
      return this.hashInt(c, this.encode(o), d);
    }
    sign(c, o) {
      return r(Buffer.isBuffer(c)), this.check(), this._sign(c, o);
    }
    _sign(c, o) {
      const { n: d } = this.curve, l = this.curve.g, h = this.curve.decodeScalar(o);
      if (h.isZero() || h.cmp(d) >= 0)
        throw new Error("Invalid private key.");
      const x = l.mulBlind(h), b = this.hashNonce(o, c);
      if (b.isZero())
        throw new Error("Signing failed (k' = 0).");
      const g = l.mulBlind(b);
      g.isSquare() || b.ineg().imod(d);
      const w = g.encodeX(), I = x.encode(), B = this.hashChallenge(w, I, c), y = b.add(B.mul(h)).imod(d);
      return Buffer.concat([w, this.curve.encodeScalar(y)]);
    }
    verify(c, o, d) {
      if (r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), this.check(), o.length !== this.curve.fieldSize + this.curve.scalarSize)
        return !1;
      try {
        return this._verify(c, o, d);
      } catch {
        return !1;
      }
    }
    _verify(c, o, d) {
      const { p: l, n: h } = this.curve, x = this.curve.g, b = o.slice(0, this.curve.fieldSize), g = o.slice(this.curve.fieldSize), w = this.curve.decodeField(b), I = this.curve.decodeScalar(g), B = this.curve.decodePoint(d);
      if (w.cmp(l) >= 0 || I.cmp(h) >= 0)
        return !1;
      const y = this.hashChallenge(b, d, c), A = x.jmulAdd(I, B, y.ineg().imod(h));
      return !(!A.isSquare() || !A.eqX(w));
    }
    verifyBatch(c) {
      r(Array.isArray(c)), this.check();
      for (const o of c) {
        r(Array.isArray(o) && o.length === 3);
        const [d, l, h] = o;
        if (r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h)), l.length !== this.curve.fieldSize + this.curve.scalarSize)
          return !1;
      }
      try {
        return this._verifyBatch(c);
      } catch {
        return !1;
      }
    }
    _verifyBatch(c) {
      const { n: o } = this.curve, d = this.curve.g, l = new Array(1 + c.length * 2), h = new Array(1 + c.length * 2), x = new t(0);
      this.rng.init(c), l[0] = d, h[0] = x;
      for (let b = 0; b < c.length; b++) {
        const [g, w, I] = c[b], B = w.slice(0, this.curve.fieldSize), y = w.slice(this.curve.fieldSize), A = this.curve.decodeSquare(B), _ = this.curve.decodeScalar(y), q = this.curve.decodePoint(I);
        if (_.cmp(o) >= 0)
          return !1;
        const U = this.hashChallenge(B, I, g), z = this.rng.generate(b), E = U.mul(z).imod(o);
        x.iadd(_.mul(z)).imod(o), l[1 + b * 2 + 0] = A, h[1 + b * 2 + 0] = z, l[1 + b * 2 + 1] = q, h[1 + b * 2 + 1] = E;
      }
      return x.ineg().imod(o), this.curve.jmulAll(l, h).isInfinity();
    }
  }
  return Yh = i, Yh;
}
/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */
var Jh, fb;
function Hn() {
  if (fb)
    return Jh;
  fb = 1;
  const r = _e, e = J0, t = B0, i = X1(), n = OS(), c = J1, o = So();
  class d {
    constructor(h, x, b, g) {
      r(typeof h == "string"), r(x), r(b), this.id = h, this.type = "ecdsa", this.hash = x, this.xof = b, this.native = 0, this._pre = g || null, this._curve = null, this._schnorr = null;
    }
    get curve() {
      return this._curve || (this._curve = o.curve(this.id, this._pre), this._curve.precompute(t), this._pre = null), this._curve;
    }
    get schnorr() {
      return this._schnorr || (this._schnorr = new n(this.curve, this.xof)), this._schnorr;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const h = this.curve.randomScalar(t);
      return this.curve.encodeScalar(h);
    }
    privateKeyVerify(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        x = this.curve.decodeScalar(h);
      } catch {
        return !1;
      }
      return !x.isZero() && x.cmp(this.curve.n) < 0;
    }
    privateKeyExport(h) {
      const x = this.publicKeyCreate(h, !1), { x: b, y: g } = this.publicKeyExport(x);
      return {
        d: Buffer.from(h),
        x: b,
        y: g
      };
    }
    privateKeyImport(h) {
      r(h && typeof h == "object");
      const x = e.decode(h.d, this.curve.endian);
      if (x.isZero() || x.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(x);
    }
    privateKeyTweakAdd(h, x) {
      const b = this.curve.decodeScalar(x);
      if (b.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const g = this.curve.decodeScalar(h);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const w = g.add(b).imod(this.curve.n);
      if (w.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(w);
    }
    privateKeyTweakMul(h, x) {
      const b = this.curve.decodeScalar(x);
      if (b.isZero() || b.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const g = this.curve.decodeScalar(h);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const w = g.mul(b).imod(this.curve.n);
      if (w.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(w);
    }
    privateKeyNegate(h) {
      const x = this.curve.decodeScalar(h);
      if (x.isZero() || x.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const b = x.neg().imod(this.curve.n);
      return this.curve.encodeScalar(b);
    }
    privateKeyInvert(h) {
      const x = this.curve.decodeScalar(h);
      if (x.isZero() || x.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const b = x.invert(this.curve.n);
      return this.curve.encodeScalar(b);
    }
    publicKeyCreate(h, x) {
      const b = this.curve.decodeScalar(h);
      if (b.isZero() || b.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.g.mulBlind(b).encode(x);
    }
    publicKeyConvert(h, x) {
      return this.curve.decodePoint(h).encode(x);
    }
    publicKeyFromUniform(h, x) {
      const b = this.curve.decodeUniform(h);
      return this.curve.pointFromUniform(b).encode(x);
    }
    publicKeyToUniform(h, x = t.randomInt()) {
      const b = this.curve.decodePoint(h), g = this.curve.pointToUniform(b, x);
      return this.curve.encodeUniform(g, x >>> 8);
    }
    publicKeyFromHash(h, x) {
      return this.curve.pointFromHash(h).encode(x);
    }
    publicKeyToHash(h) {
      const x = this.curve.decodePoint(h);
      return this.curve.pointToHash(x, 0, t);
    }
    publicKeyVerify(h) {
      r(Buffer.isBuffer(h));
      try {
        this.curve.decodePoint(h);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyExport(h) {
      const { x, y: b } = this.curve.decodePoint(h);
      return {
        x: this.curve.encodeField(x.fromRed()),
        y: this.curve.encodeField(b.fromRed())
      };
    }
    publicKeyImport(h, x) {
      r(h && typeof h == "object");
      const b = e.decode(h.x, this.curve.endian);
      if (b.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (h.y != null) {
        const w = e.decode(h.y, this.curve.endian);
        if (w.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const I = this.curve.point(b, w);
        if (!I.validate())
          throw new Error("Invalid point.");
        return I.encode(x);
      }
      return this.curve.pointFromX(b, h.sign).encode(x);
    }
    publicKeyTweakAdd(h, x, b) {
      const g = this.curve.decodeScalar(x);
      if (g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const w = this.curve.decodePoint(h);
      return this.curve.g.jmul(g).add(w).encode(b);
    }
    publicKeyTweakMul(h, x, b) {
      const g = this.curve.decodeScalar(x);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      return this.curve.decodePoint(h).mul(g).encode(b);
    }
    publicKeyCombine(h, x) {
      r(Array.isArray(h));
      let b = this.curve.jpoint();
      for (const g of h) {
        const w = this.curve.decodePoint(g);
        b = b.add(w);
      }
      return b.encode(x);
    }
    publicKeyNegate(h, x) {
      return this.curve.decodePoint(h).neg().encode(x);
    }
    signatureNormalize(h) {
      const [x, b] = this._decodeCompact(h);
      return b.cmp(this.curve.nh) > 0 && b.ineg().imod(this.curve.n), this._encodeCompact(x, b);
    }
    signatureNormalizeDER(h) {
      const [x, b] = this._decodeDER(h, !1);
      return b.cmp(this.curve.nh) > 0 && b.ineg().imod(this.curve.n), this._encodeDER(x, b);
    }
    signatureExport(h) {
      const [x, b] = this._decodeCompact(h);
      return this._encodeDER(x, b);
    }
    signatureImport(h) {
      const [x, b] = this._decodeDER(h, !1);
      return this._encodeCompact(x, b);
    }
    isLowS(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        [, x] = this._decodeCompact(h);
      } catch {
        return !1;
      }
      return x.cmp(this.curve.nh) <= 0;
    }
    isLowDER(h) {
      r(Buffer.isBuffer(h));
      let x;
      try {
        [, x] = this._decodeDER(h, !1);
      } catch {
        return !1;
      }
      return x.cmp(this.curve.nh) <= 0;
    }
    sign(h, x) {
      const [b, g] = this._sign(h, x);
      return this._encodeCompact(b, g);
    }
    signRecoverable(h, x) {
      const [b, g, w] = this._sign(h, x);
      return [this._encodeCompact(b, g), w];
    }
    signDER(h, x) {
      const [b, g] = this._sign(h, x);
      return this._encodeDER(b, g);
    }
    signRecoverableDER(h, x) {
      const [b, g, w] = this._sign(h, x);
      return [this._encodeDER(b, g), w];
    }
    _sign(h, x) {
      const { n: b, nh: g } = this.curve, w = this.curve.g, I = this.curve.decodeScalar(x);
      if (I.isZero() || I.cmp(b) >= 0)
        throw new Error("Invalid private key.");
      const B = this._reduce(h), y = this.curve.encodeScalar(B), A = new c(this.hash, x, y);
      for (; ; ) {
        const _ = A.generate(this.curve.scalarSize), q = this._truncate(_);
        if (q.isZero() || q.cmp(b) >= 0)
          continue;
        const U = w.mulBlind(q);
        if (U.isInfinity())
          continue;
        const z = U.getX(), E = z.mod(b);
        if (E.isZero())
          continue;
        const H = this.curve.randomScalar(t), k = q.mul(H).fermat(b), V = I.mul(H).imod(b), T = B.mul(H).imod(b), N = E.mul(V).iadd(T).imod(b).mul(k).imod(b);
        if (N.isZero())
          continue;
        let G = U.isOdd() | !z.eq(E) << 1;
        return N.cmp(g) > 0 && (N.ineg().imod(b), G ^= 1), [E, N, G];
      }
    }
    verify(h, x, b) {
      r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(Buffer.isBuffer(b));
      let g, w;
      try {
        [g, w] = this._decodeCompact(x);
      } catch {
        return !1;
      }
      try {
        return this._verify(h, g, w, b);
      } catch {
        return !1;
      }
    }
    verifyDER(h, x, b) {
      r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(Buffer.isBuffer(b));
      let g, w;
      try {
        [g, w] = this._decodeDER(x, !1);
      } catch {
        return !1;
      }
      try {
        return this._verify(h, g, w, b);
      } catch {
        return !1;
      }
    }
    _verify(h, x, b, g) {
      const { n: w } = this.curve, I = this.curve.g, B = this._reduce(h), y = this.curve.decodePoint(g);
      if (x.isZero() || x.cmp(w) >= 0 || b.isZero() || b.cmp(w) >= 0)
        return !1;
      const A = b.invert(w), _ = B.mul(A).imod(w), q = x.mul(A).imod(w);
      return I.jmulAdd(_, y, q).eqR(x);
    }
    recover(h, x, b, g) {
      r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(b >>> 0 === b), r((b & 3) === b, "The recovery param is more than two bits.");
      let w, I;
      try {
        [w, I] = this._decodeCompact(x);
      } catch {
        return null;
      }
      let B;
      try {
        B = this._recover(h, w, I, b);
      } catch {
        return null;
      }
      return B.encode(g);
    }
    recoverDER(h, x, b, g) {
      r(Buffer.isBuffer(h)), r(Buffer.isBuffer(x)), r(b >>> 0 === b), r((b & 3) === b, "The recovery param is more than two bits.");
      let w, I;
      try {
        [w, I] = this._decodeDER(x, !1);
      } catch {
        return null;
      }
      let B;
      try {
        B = this._recover(h, w, I, b);
      } catch {
        return null;
      }
      return B.encode(g);
    }
    _recover(h, x, b, g) {
      const { n: w, pmodn: I } = this.curve, B = this.curve.g, y = this._reduce(h);
      if (x.isZero() || x.cmp(w) >= 0)
        throw new Error("Invalid R value.");
      if (b.isZero() || b.cmp(w) >= 0)
        throw new Error("Invalid S value.");
      const A = (g & 1) !== 0, _ = g >>> 1;
      let q = x;
      if (_) {
        if (this.curve.highOrder)
          throw new Error("Invalid high bit.");
        if (q.cmp(I) >= 0)
          throw new Error("Invalid R value.");
        q = q.add(w);
      }
      const U = this.curve.pointFromX(q, A), z = x.invert(w), E = y.mul(z).ineg().imod(w), H = b.mul(z).imod(w), k = B.mulAdd(E, U, H);
      if (k.isInfinity())
        throw new Error("Invalid point.");
      return k;
    }
    derive(h, x, b) {
      const g = this.curve.decodePoint(h), w = this.curve.decodeScalar(x);
      if (w.isZero() || w.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      if (this.curve.h.cmpn(1) > 0 && g.isSmall())
        throw new Error("Invalid point.");
      return g.mulBlind(w, t).encode(b);
    }
    /*
     * Schnorr
     */
    schnorrSign(h, x) {
      return this.schnorr.sign(h, x);
    }
    schnorrVerify(h, x, b) {
      return this.schnorr.verify(h, x, b);
    }
    schnorrVerifyBatch(h) {
      return this.schnorr.verifyBatch(h);
    }
    /*
     * Helpers
     */
    _encodeCompact(h, x) {
      return Buffer.concat([
        this.curve.encodeScalar(h),
        this.curve.encodeScalar(x)
      ]);
    }
    _decodeCompact(h) {
      r(Buffer.isBuffer(h));
      const { n: x } = this.curve, b = this.curve.scalarSize;
      if (h.length !== b * 2)
        throw new Error("Invalid signature size.");
      const g = h.slice(0, b), w = h.slice(b, b * 2), I = this.curve.decodeScalar(g), B = this.curve.decodeScalar(w);
      if (I.cmp(x) >= 0 || B.cmp(x) >= 0)
        throw new Error("Invalid signature.");
      return [I, B];
    }
    _encodeDER(h, x) {
      const b = i.sizeInt(h) + i.sizeInt(x), g = Buffer.alloc(i.sizeSeq(b));
      let w = 0;
      return w = i.writeSeq(g, w, b), w = i.writeInt(g, w, h), w = i.writeInt(g, w, x), r(w === g.length), g;
    }
    _decodeDER(h, x) {
      r(Buffer.isBuffer(h)), r(typeof x == "boolean");
      const { n: b } = this.curve;
      let g = 0, w, I;
      if (g = i.readSeq(h, g, x), [w, g] = i.readInt(h, g, x), [I, g] = i.readInt(h, g, x), x && g !== h.length)
        throw new Error("Trailing bytes.");
      if (w.cmp(b) >= 0 || I.cmp(b) >= 0)
        throw new Error("Invalid signature.");
      return [w, I];
    }
    _truncate(h) {
      r(Buffer.isBuffer(h));
      const x = this.curve.n.bitLength(), b = x + 7 >>> 3;
      h.length > b && (h = h.slice(0, b));
      const g = e.decode(h, this.curve.endian), w = h.length * 8 - x;
      return w > 0 && g.iushrn(w), g;
    }
    _reduce(h) {
      return this._truncate(h).imod(this.curve.n);
    }
  }
  return Jh = d, Jh;
}
/*!
 * p192.js - ECDSA-P192 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Xh, cb;
function PS() {
  if (cb)
    return Xh;
  cb = 1;
  const r = Hn(), e = Ti;
  return Xh = new r("P192", e, e), Xh;
}
/*!
 * ecdsa.js - ecdsa wrapper for libtorsion
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Zh, ob;
function Fn() {
  if (ob)
    return Zh;
  ob = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n) {
      r(e.curves.wei[n] != null), this.id = n, this.type = "ecdsa", this.native = 2, this._ctx = null;
    }
    get _handle() {
      return this._ctx || (this._ctx = e.curve("wei", this.id)), this._ctx;
    }
    get size() {
      return r(this instanceof t), e.wei_curve_field_size(this._handle);
    }
    get bits() {
      return r(this instanceof t), e.wei_curve_field_bits(this._handle);
    }
    privateKeyGenerate() {
      return r(this instanceof t), e.ecdsa_privkey_generate(this._handle, e.entropy());
    }
    privateKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_privkey_verify(this._handle, n);
    }
    privateKeyExport(n) {
      r(this instanceof t), r(Buffer.isBuffer(n));
      const c = e.ecdsa_pubkey_create(this._handle, n, !1), [o, d] = e.ecdsa_pubkey_export(this._handle, c);
      return {
        d: e.copy(n),
        x: o,
        y: d
      };
    }
    privateKeyImport(n) {
      return r(this instanceof t), r(n && typeof n == "object"), r(Buffer.isBuffer(n.d)), e.ecdsa_privkey_import(this._handle, n.d);
    }
    privateKeyTweakAdd(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdsa_privkey_tweak_add(this._handle, n, c);
    }
    privateKeyTweakMul(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdsa_privkey_tweak_mul(this._handle, n, c);
    }
    privateKeyNegate(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_privkey_negate(this._handle, n);
    }
    privateKeyInvert(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_privkey_invert(this._handle, n);
    }
    publicKeyCreate(n, c = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.ecdsa_pubkey_create(this._handle, n, c);
    }
    publicKeyConvert(n, c = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.ecdsa_pubkey_convert(this._handle, n, c);
    }
    publicKeyFromUniform(n, c = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.ecdsa_pubkey_from_uniform(this._handle, n, c);
    }
    publicKeyToUniform(n, c = e.hint()) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c >>> 0 === c), e.ecdsa_pubkey_to_uniform(this._handle, n, c);
    }
    publicKeyFromHash(n, c = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.ecdsa_pubkey_from_hash(this._handle, n, c);
    }
    publicKeyToHash(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_pubkey_to_hash(this._handle, n, e.entropy());
    }
    publicKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_pubkey_verify(this._handle, n);
    }
    publicKeyExport(n) {
      r(this instanceof t), r(Buffer.isBuffer(n));
      const [c, o] = e.ecdsa_pubkey_export(this._handle, n);
      return { x: c, y: o };
    }
    publicKeyImport(n, c = !0) {
      r(this instanceof t), r(n && typeof n == "object"), r(typeof c == "boolean");
      let { x: o, y: d, sign: l } = n;
      return o == null && (o = e.NULL), d == null && (d = e.NULL), l = e.ternary(l), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), e.ecdsa_pubkey_import(this._handle, o, d, l, c);
    }
    publicKeyTweakAdd(n, c, o = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(typeof o == "boolean"), e.ecdsa_pubkey_tweak_add(this._handle, n, c, o);
    }
    publicKeyTweakMul(n, c, o = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(typeof o == "boolean"), e.ecdsa_pubkey_tweak_mul(this._handle, n, c, o);
    }
    publicKeyCombine(n, c = !0) {
      r(this instanceof t), r(Array.isArray(n)), r(typeof c == "boolean");
      for (const o of n)
        r(Buffer.isBuffer(o));
      return e.ecdsa_pubkey_combine(this._handle, n, c);
    }
    publicKeyNegate(n, c = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(typeof c == "boolean"), e.ecdsa_pubkey_negate(this._handle, n, c);
    }
    signatureNormalize(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_signature_normalize(this._handle, n);
    }
    signatureNormalizeDER(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_signature_normalize_der(this._handle, n);
    }
    signatureExport(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_signature_export(this._handle, n);
    }
    signatureImport(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_signature_import(this._handle, n);
    }
    isLowS(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_is_low_s(this._handle, n);
    }
    isLowDER(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.ecdsa_is_low_der(this._handle, n);
    }
    sign(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdsa_sign(this._handle, n, c);
    }
    signRecoverable(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdsa_sign_recoverable(this._handle, n, c);
    }
    signDER(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdsa_sign_der(this._handle, n, c);
    }
    signRecoverableDER(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.ecdsa_sign_recoverable_der(this._handle, n, c);
    }
    verify(n, c, o) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.ecdsa_verify(this._handle, n, c, o);
    }
    verifyDER(n, c, o) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.ecdsa_verify_der(this._handle, n, c, o);
    }
    recover(n, c, o, d = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(typeof d == "boolean"), e.ecdsa_recover(this._handle, n, c, o, d);
    }
    recoverDER(n, c, o, d = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(typeof d == "boolean"), e.ecdsa_recover_der(this._handle, n, c, o, d);
    }
    derive(n, c, o = !0) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(typeof o == "boolean"), e.ecdsa_derive(this._handle, n, c, o);
    }
    schnorrSign(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_legacy_sign(this._handle, n, c);
    }
    schnorrVerify(n, c, o) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.schnorr_legacy_verify(this._handle, n, c, o);
    }
    schnorrVerifyBatch(n) {
      r(this instanceof t), r(Array.isArray(n));
      for (const c of n)
        r(Array.isArray(c)), r(c.length === 3), r(Buffer.isBuffer(c[0])), r(Buffer.isBuffer(c[1])), r(Buffer.isBuffer(c[2]));
      return e.schnorr_legacy_verify_batch(this._handle, n);
    }
  }
  return Zh = t, Zh;
}
/*!
 * p192.js - ECDSA-P192 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Wh, ab;
function RS() {
  if (ab)
    return Wh;
  ab = 1;
  const r = Fn();
  return Wh = new r("P192"), Wh;
}
/*!
 * p192.js - ECDSA-P192 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? n1.exports = PS() : n1.exports = RS();
var kS = n1.exports, f1 = { exports: {} };
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var jh, hb;
function qS() {
  if (hb)
    return jh;
  hb = 1;
  const r = Hn(), e = Ti;
  return jh = new r("P224", e, e), jh;
}
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Qh, db;
function zS() {
  if (db)
    return Qh;
  db = 1;
  const r = Fn();
  return Qh = new r("P224"), Qh;
}
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? f1.exports = qS() : f1.exports = zS();
var US = f1.exports, c1 = { exports: {} };
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ed, ub;
function CS() {
  if (ub)
    return ed;
  ub = 1;
  const r = Hn(), e = Ti;
  return ed = new r("P256", e, e), ed;
}
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var td, lb;
function TS() {
  if (lb)
    return td;
  lb = 1;
  const r = Fn();
  return td = new r("P256"), td;
}
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? c1.exports = CS() : c1.exports = TS();
var y7 = c1.exports, o1 = { exports: {} }, a1 = { exports: {} };
/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */
var rd, xb;
function DS() {
  if (xb)
    return rd;
  xb = 1;
  const r = _e, e = d8(), t = Rr;
  class i extends e {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3418070365, this.state[1] = 3238371032, this.state[2] = 1654270250, this.state[3] = 914150663, this.state[4] = 2438529370, this.state[5] = 812702999, this.state[6] = 355462360, this.state[7] = 4144912697, this.state[8] = 1731405415, this.state[9] = 4290775857, this.state[10] = 2394180231, this.state[11] = 1750603025, this.state[12] = 3675008525, this.state[13] = 1694076839, this.state[14] = 1203062813, this.state[15] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 48);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new t(i, 128);
    }
    static digest(c) {
      return i.ctx.init().update(c).final();
    }
    static root(c, o) {
      return r(Buffer.isBuffer(c) && c.length === 48), r(Buffer.isBuffer(o) && o.length === 48), i.ctx.init().update(c).update(o).final();
    }
    static multi(c, o, d) {
      const { ctx: l } = i;
      return l.init(), l.update(c), l.update(o), d && l.update(d), l.final();
    }
    static mac(c, o) {
      return i.hmac().init(o).update(c).final();
    }
  }
  return i.native = 0, i.id = "SHA384", i.size = 48, i.bits = 384, i.blockSize = 128, i.zero = Buffer.alloc(48, 0), i.ctx = new i(), rd = i, rd;
}
/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var id, bb;
function LS() {
  if (bb)
    return id;
  bb = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.SHA384);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.SHA384);
    }
    static digest(c) {
      return r.digest(t.SHA384, c);
    }
    static root(c, o) {
      return r.root(t.SHA384, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.SHA384, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.SHA384, c, o);
    }
  }
  return i.native = 2, i.id = "SHA384", i.size = 48, i.bits = 384, i.blockSize = 128, i.zero = Buffer.alloc(48, 0), i.ctx = new i(), id = i, id;
}
/*!
 * sha384.js - SHA384 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? a1.exports = DS() : a1.exports = LS();
var Il = a1.exports;
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var sd, pb;
function KS() {
  if (pb)
    return sd;
  pb = 1;
  const r = Hn(), e = Il;
  return sd = new r("P384", e, e), sd;
}
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var nd, mb;
function $S() {
  if (mb)
    return nd;
  mb = 1;
  const r = Fn();
  return nd = new r("P384"), nd;
}
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? o1.exports = KS() : o1.exports = $S();
var S7 = o1.exports, h1 = { exports: {} };
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var fd, gb;
function HS() {
  if (gb)
    return fd;
  gb = 1;
  const r = Hn(), e = Cf, t = Io;
  return fd = new r("P521", e, t), fd;
}
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var cd, wb;
function FS() {
  if (wb)
    return cd;
  wb = 1;
  const r = Fn();
  return cd = new r("P521"), cd;
}
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? h1.exports = HS() : h1.exports = FS();
var B7 = h1.exports, d1 = { exports: {} }, df = {};
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PBKDF2
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc2898#section-5.2
 *   https://tools.ietf.org/html/rfc6070
 *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf
 *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 */
var yb;
function VS() {
  if (yb)
    return df;
  yb = 1;
  const r = _e, t = (Pn.crypto || Pn.msCrypto || {}).subtle || {};
  function i(o, d, l, h, x) {
    typeof d == "string" && (d = Buffer.from(d, "utf8")), typeof l == "string" && (l = Buffer.from(l, "utf8")), l == null && (l = Buffer.alloc(0)), r(o && typeof o.id == "string"), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), r(h >>> 0 === h), r(x >>> 0 === x);
    const b = o.size, g = Math.ceil(x / b), w = Buffer.alloc(g * b), I = Buffer.alloc(l.length + 4);
    l.copy(I, 0), d.length > o.blockSize && (d = o.digest(d), r(d.length <= o.blockSize));
    for (let B = 0; B < g; B++) {
      const y = B + 1;
      I[l.length + 0] = y >>> 24, I[l.length + 1] = y >>> 16, I[l.length + 2] = y >>> 8, I[l.length + 3] = y;
      const A = o.mac(I, d);
      let _ = A;
      for (let q = 1; q < h; q++) {
        _ = o.mac(_, d);
        for (let U = 0; U < b; U++)
          A[U] ^= _[U];
      }
      A.copy(w, B * b);
    }
    return w.slice(0, x);
  }
  async function n(o, d, l, h, x) {
    typeof d == "string" && (d = Buffer.from(d, "utf8")), typeof l == "string" && (l = Buffer.from(l, "utf8")), l == null && (l = Buffer.alloc(0)), r(o && typeof o.id == "string"), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), r(h >>> 0 === h), r(x >>> 0 === x);
    const b = c(o);
    if (!t.importKey || !t.deriveBits || !b)
      return i(o, d, l, h, x);
    const g = { name: "PBKDF2" }, w = ["deriveBits"], I = {
      name: "PBKDF2",
      salt: l,
      iterations: h,
      hash: b
    }, B = await t.importKey("raw", d, g, !1, w), y = await t.deriveBits(I, B, x * 8);
    return Buffer.from(y);
  }
  function c(o) {
    switch (o.id) {
      case "SHA1":
        return "SHA-1";
      case "SHA256":
        return "SHA-256";
      case "SHA384":
        return "SHA-384";
      case "SHA512":
        return "SHA-512";
      default:
        return null;
    }
  }
  return df.native = 0, df.derive = i, df.deriveAsync = n, df;
}
var uf = {};
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Sb;
function GS() {
  if (Sb)
    return uf;
  Sb = 1;
  const r = _e, e = Dt();
  function t(n, c, o, d, l) {
    return typeof c == "string" && (c = Buffer.from(c, "utf8")), typeof o == "string" && (o = Buffer.from(o, "utf8")), o == null && (o = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(d >>> 0 === d), r(l >>> 0 === l), e.pbkdf2_derive(e.hash(n), c, o, d, l);
  }
  async function i(n, c, o, d, l) {
    return typeof c == "string" && (c = Buffer.from(c, "utf8")), typeof o == "string" && (o = Buffer.from(o, "utf8")), o == null && (o = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(d >>> 0 === d), r(l >>> 0 === l), e.pbkdf2_derive_async(e.hash(n), c, o, d, l);
  }
  return uf.native = 2, uf.derive = t, uf.deriveAsync = i, uf;
}
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? d1.exports = VS() : d1.exports = GS();
var v7 = d1.exports, lr = {}, u1 = { exports: {} };
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var od, Bb;
function YS() {
  if (Bb)
    return od;
  Bb = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.SHA1);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.SHA1);
    }
    static digest(c) {
      return r.digest(t.SHA1, c);
    }
    static root(c, o) {
      return r.root(t.SHA1, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.SHA1, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.SHA1, c, o);
    }
  }
  return i.native = 2, i.id = "SHA1", i.size = 20, i.bits = 160, i.blockSize = 64, i.zero = Buffer.alloc(20, 0), i.ctx = new i(), od = i, od;
}
/*!
 * sha1.js - sha1 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? u1.exports = w7() : u1.exports = YS();
var E7 = u1.exports, l1 = { exports: {} };
/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ad, vb;
function JS() {
  if (vb)
    return ad;
  vb = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.RIPEMD160);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.RIPEMD160);
    }
    static digest(c) {
      return r.digest(t.RIPEMD160, c);
    }
    static root(c, o) {
      return r.root(t.RIPEMD160, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.RIPEMD160, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.RIPEMD160, c, o);
    }
  }
  return i.native = 2, i.id = "RIPEMD160", i.size = 20, i.bits = 160, i.blockSize = 64, i.zero = Buffer.alloc(20, 0), i.ctx = new i(), ad = i, ad;
}
/*!
 * ripemd160.js - ripemd160 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? l1.exports = d7() : l1.exports = JS();
var I7 = l1.exports, x1 = { exports: {} };
/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */
var hd, Eb;
function XS() {
  if (Eb)
    return hd;
  Eb = 1;
  const r = _e, e = Eo(), t = Rr;
  class i extends e {
    constructor() {
      super();
    }
    init() {
      return this.state[0] = 3238371032, this.state[1] = 914150663, this.state[2] = 812702999, this.state[3] = 4144912697, this.state[4] = 4290775857, this.state[5] = 1750603025, this.state[6] = 1694076839, this.state[7] = 3204075428, this.size = 0, this;
    }
    final() {
      return super.final().slice(0, 28);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new t(i, 64);
    }
    static digest(c) {
      return i.ctx.init().update(c).final();
    }
    static root(c, o) {
      return r(Buffer.isBuffer(c) && c.length === 28), r(Buffer.isBuffer(o) && o.length === 28), i.ctx.init().update(c).update(o).final();
    }
    static multi(c, o, d) {
      const { ctx: l } = i;
      return l.init(), l.update(c), l.update(o), d && l.update(d), l.final();
    }
    static mac(c, o) {
      return i.hmac().init(o).update(c).final();
    }
  }
  return i.native = 0, i.id = "SHA224", i.size = 28, i.bits = 224, i.blockSize = 64, i.zero = Buffer.alloc(28, 0), i.ctx = new i(), hd = i, hd;
}
/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var dd, Ib;
function ZS() {
  if (Ib)
    return dd;
  Ib = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.SHA224);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.SHA224);
    }
    static digest(c) {
      return r.digest(t.SHA224, c);
    }
    static root(c, o) {
      return r.root(t.SHA224, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.SHA224, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.SHA224, c, o);
    }
  }
  return i.native = 2, i.id = "SHA224", i.size = 28, i.bits = 224, i.blockSize = 64, i.zero = Buffer.alloc(28, 0), i.ctx = new i(), dd = i, dd;
}
/*!
 * sha224.js - SHA224 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? x1.exports = XS() : x1.exports = ZS();
var A7 = x1.exports, b1 = { exports: {} }, pn = {};
/*!
 * pgpdf.js - PGP derivation functions for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/crypto:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/crypto
 *
 * Resources:
 *   https://github.com/golang/crypto/tree/master/openpgp
 */
var Ab;
function WS() {
  if (Ab)
    return pn;
  Ab = 1;
  const r = _e, e = Buffer.alloc(0), t = Buffer.alloc(1, 0);
  function i(o, d, l) {
    return n(o, d, e, l);
  }
  function n(o, d, l, h) {
    r(o && typeof o.id == "string"), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), r(h >>> 0 === h);
    const x = new o(), b = Buffer.alloc(h);
    let g = 0, w = 0;
    for (; w < h; ) {
      x.init();
      for (let I = 0; I < g; I++)
        x.update(t);
      x.update(l), x.update(d), w += x.final().copy(b, w), g += 1;
    }
    return b;
  }
  function c(o, d, l, h, x) {
    r(o && typeof o.id == "string"), r(Buffer.isBuffer(d)), r(Buffer.isBuffer(l)), r(h >>> 0 === h), r(x >>> 0 === x);
    const b = new o(), g = Buffer.alloc(x), w = l.length + d.length;
    h < w && (h = w);
    let I = 0, B = 0;
    for (; B < x; ) {
      b.init();
      for (let A = 0; A < I; A++)
        b.update(t);
      let y = 0;
      for (; y < h; ) {
        if (y + w > h) {
          const A = h - y;
          A < l.length ? b.update(l.slice(0, A)) : (b.update(l), b.update(d.slice(0, A - l.length)));
          break;
        }
        b.update(l), b.update(d), y += w;
      }
      B += b.final().copy(g, B), I += 1;
    }
    return g;
  }
  return pn.native = 0, pn.deriveSimple = i, pn.deriveSalted = n, pn.deriveIterated = c, pn;
}
var mn = {};
/*!
 * pgpdf.js - PGP derivation functions for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var _b;
function jS() {
  if (_b)
    return mn;
  _b = 1;
  const r = _e, e = Dt();
  function t(c, o, d) {
    return r(Buffer.isBuffer(o)), r(d >>> 0 === d), e.pgpdf_derive_simple(e.hash(c), o, d);
  }
  function i(c, o, d, l) {
    return r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), e.pgpdf_derive_salted(e.hash(c), o, d, l);
  }
  function n(c, o, d, l, h) {
    return r(c && typeof c.id == "string"), r(Buffer.isBuffer(o)), r(Buffer.isBuffer(d)), r(l >>> 0 === l), r(h >>> 0 === h), e.pgpdf_derive_iterated(e.hash(c), o, d, l, h);
  }
  return mn.native = 2, mn.deriveSimple = t, mn.deriveSalted = i, mn.deriveIterated = n, mn;
}
/*!
 * pgpdf.js - pgpdf for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? b1.exports = WS() : b1.exports = jS();
var QS = b1.exports;
/*!
 * pgp.js - PGP for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/crypto:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/crypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP
 *   https://tools.ietf.org/html/rfc4880
 *   https://github.com/golang/crypto/tree/master/openpgp
 *   https://github.com/gpg/gnupg/blob/master/common/openpgpdefs.h
 *   https://github.com/gpg/gnupg/blob/master/g10/parse-packet.c
 */
const Y0 = _e, ni = Pe, { PEMBlock: Mb } = Yr, { countLeft: eB } = ti, Nb = Bo, _7 = gl, fo = E7, tB = I7, rB = A7, M7 = Ti, iB = Il, sB = Cf, ud = QS, Tr = {
  NONE: 0,
  PUBKEY_ENC: 1,
  SIGNATURE: 2,
  SYMKEY_ENC: 3,
  ONEPASS_SIG: 4,
  PRIVATE_KEY: 5,
  PUBLIC_KEY: 6,
  PRIVATE_SUBKEY: 7,
  COMPRESSED: 8,
  ENCRYPTED: 9,
  MARKER: 10,
  PLAINTEXT: 11,
  RING_TRUST: 12,
  USER_ID: 13,
  PUBLIC_SUBKEY: 14,
  OLD_COMMENT: 16,
  ATTRIBUTE: 17,
  ENCRYPTED_MDC: 18,
  MDC: 19,
  ENCRYPTED_AEAD: 20
}, N7 = {
  0: "NONE",
  1: "PUBKEY_ENC",
  2: "SIGNATURE",
  3: "SYMKEY_ENC",
  4: "ONEPASS_SIG",
  5: "PRIVATE_KEY",
  6: "PUBLIC_KEY",
  7: "PRIVATE_SUBKEY",
  8: "COMPRESSED",
  9: "ENCRYPTED",
  10: "MARKER",
  11: "PLAINTEXT",
  12: "RING_TRUST",
  13: "USER_ID",
  14: "PUBLIC_SUBKEY",
  16: "OLD_COMMENT",
  17: "ATTRIBUTE",
  18: "ENCRYPTED_MDC",
  19: "MDC",
  20: "ENCRYPTED_AEAD"
}, nB = {
  BINARY: 0,
  TEXT: 1,
  GENERIC_CERT: 16,
  PERSONA_CERT: 17,
  CASUAL_CERT: 18,
  POSITIVE_CERT: 19,
  SUBKEY_BINDING: 24,
  PRIMARY_KEY_BINDING: 25,
  DIRECT_SIGNATURE: 31,
  KEY_REVOCATION: 32,
  SUBKEY_REVOCATION: 40
}, fB = {
  0: "BINARY",
  1: "TEXT",
  16: "GENERIC_CERT",
  17: "PERSONA_CERT",
  18: "CASUAL_CERT",
  19: "POSITIVE_CERT",
  24: "SUBKEY_BINDING",
  25: "PRIMARY_KEY_BINDING",
  31: "DIRECT_SIGNATURE",
  32: "KEY_REVOCATION",
  40: "SUBKEY_REVOCATION"
}, We = {
  RSA: 1,
  RSA_ENCRYPT_ONLY: 2,
  RSA_SIGN_ONLY: 3,
  ELGAMAL: 16,
  DSA: 17,
  ECDH: 18,
  ECDSA: 19,
  ELGAMAL_LEGACY: 20,
  EDDSA: 22
}, O7 = {
  1: "RSA",
  2: "RSA_ENCRYPT_ONLY",
  3: "RSA_SIGN_ONLY",
  16: "ELGAMAL",
  17: "DSA",
  18: "ECDH",
  19: "ECDSA",
  20: "ELGAMAL_LEGACY",
  22: "EDDSA"
}, Zt = {
  NONE: 0,
  IDEA: 1,
  DES3: 2,
  CAST5: 3,
  BLOWFISH: 4,
  AES128: 7,
  AES192: 8,
  AES256: 9,
  TWOFISH: 10,
  CAMELLIA128: 11,
  CAMELLIA192: 12,
  CAMELLIA256: 13
}, P7 = {
  0: "NONE",
  1: "IDEA",
  2: "DES3",
  3: "CAST5",
  4: "BLOWFISH",
  7: "AES128",
  8: "AES192",
  9: "AES256",
  10: "TWOFISH",
  11: "CAMELLIA128",
  12: "CAMELLIA192",
  13: "CAMELLIA256"
}, cB = {
  MD5: 1,
  SHA1: 2,
  RIPEMD160: 3,
  SHA256: 8,
  SHA384: 9,
  SHA512: 10,
  SHA224: 11
}, R7 = {
  1: "MD5",
  2: "SHA1",
  3: "RIPEMD160",
  8: "SHA256",
  9: "SHA384",
  10: "SHA512",
  11: "SHA224"
}, oB = {
  1: _7,
  2: fo,
  3: tB,
  8: M7,
  9: iB,
  10: sB,
  11: rB
}, aB = {
  NONE: 0,
  ZIP: 1,
  ZLIB: 2,
  BZIP2: 3
}, hB = {
  0: "NONE",
  1: "ZIP",
  2: "ZLIB",
  3: "BZIP2"
}, Hr = {
  NONE: 0,
  P256: 1,
  P384: 2,
  P521: 3,
  SECP256K1: 4,
  X25519: 5,
  BRAINPOOLP256: 6,
  BRAINPOOLP384: 7,
  BRAINPOOLP512: 8,
  ED25519: 9
}, p1 = {
  0: "NONE",
  1: "P256",
  2: "P384",
  3: "P521",
  4: "SECP256K1",
  5: "X25519",
  6: "BRAINPOOLP256",
  7: "BRAINPOOLP384",
  8: "BRAINPOOLP512",
  9: "ED25519"
}, Fr = {
  P256: Buffer.from("2a8648ce3d030107", "hex"),
  P384: Buffer.from("2b81040022", "hex"),
  P521: Buffer.from("2b81040023", "hex"),
  SECP256K1: Buffer.from("2b8104000a", "hex"),
  X25519: Buffer.from("2b060104019755010501", "hex"),
  BRAINPOOLP256: Buffer.from("2b2403030208010107", "hex"),
  BRAINPOOLP384: Buffer.from("2b240303020801010b", "hex"),
  BRAINPOOLP512: Buffer.from("2b240303020801010d", "hex"),
  ED25519: Buffer.from("2b06010401da470f01", "hex")
}, Es = Buffer.alloc(0);
class dB extends ni.Struct {
  constructor() {
    super(), this.packets = [];
  }
  getSize() {
    let e = 0;
    for (const t of this.packets)
      e += t.getSize();
    return e;
  }
  write(e) {
    for (const t of this.packets)
      t.write(e);
    return e;
  }
  read(e) {
    for (; e.left(); ) {
      const t = k7.read(e);
      this.packets.push(t);
    }
    return this;
  }
  toString(e = "PGP MESSAGE") {
    Y0(typeof e == "string");
    const t = new Mb();
    return t.type = e, t.data = this.encode(), t.toString(!0);
  }
  fromString(e) {
    const t = Mb.fromString(e, !0);
    if (t.type.substring(0, 4) !== "PGP ")
      throw new Error("PEM type mismatch.");
    return this.decode(t.data);
  }
  format() {
    return {
      packets: this.packets
    };
  }
}
class k7 extends ni.Struct {
  constructor() {
    super(), this.type = 0, this.body = new c0();
  }
  getSize() {
    const e = this.body.getSize();
    let t = 0;
    return t += 1, e < 192 ? t += 1 : e < 8384 ? t += 2 : t += 5, t += e, t;
  }
  write(e) {
    let t = this.body.getSize();
    return e.writeU8(192 | this.type), t < 192 ? e.writeU8(t) : t < 8384 ? (t -= 192, e.writeU8(192 + (t >>> 8)), e.writeU8(t & 255)) : (e.writeU8(255), e.writeU32BE(t)), this.body.write(e), e;
  }
  read(e) {
    const t = e.readU8();
    if (!(t & 128))
      throw new Error("Hi bit unset in PGP packet header.");
    let i = 0, n = null;
    if (t & 64) {
      const c = t & 63, o = e.readU8();
      let d = 0;
      if (o < 192)
        d = o;
      else if (o < 224)
        d = (o - 192) * 256, d += e.readU8() + 192;
      else {
        if (o < 255)
          throw new Error("Cannot handle PGP partial length.");
        d = e.readU32BE();
      }
      i = c, n = e.readChild(d);
    } else {
      const c = (t & 63) >>> 2, o = 1 << (t & 3);
      let d = 0;
      switch (o) {
        case 1:
          d = e.readU8();
          break;
        case 2:
          d = e.readU16BE();
          break;
        case 4:
          d = e.readU32BE();
          break;
        case 8:
          d = e.left();
          break;
      }
      i = c, n = e.readChild(d);
    }
    switch (this.type = i, this.type) {
      case Tr.PUBKEY_ENC:
        this.body = c0.read(n);
        break;
      case Tr.SIGNATURE:
        this.body = c0.read(n);
        break;
      case Tr.SYMKEY_ENC:
        this.body = c0.read(n);
        break;
      case Tr.ONEPASS_SIG:
        this.body = c0.read(n);
        break;
      case Tr.PRIVATE_KEY:
        this.body = m1.read(n);
        break;
      case Tr.PUBLIC_KEY:
        this.body = _f.read(n);
        break;
      case Tr.PRIVATE_SUBKEY:
        this.body = m1.read(n);
        break;
      case Tr.COMPRESSED:
        this.body = c0.read(n);
        break;
      case Tr.ENCRYPTED:
        this.body = c0.read(n);
        break;
      case Tr.MARKER:
        this.body = c0.read(n);
        break;
      case Tr.PLAINTEXT:
        this.body = c0.read(n);
        break;
      case Tr.RING_TRUST:
        this.body = c0.read(n);
        break;
      case Tr.USER_ID:
        this.body = C7.read(n);
        break;
      case Tr.PUBLIC_SUBKEY:
        this.body = _f.read(n);
        break;
      case Tr.OLD_COMMENT:
        this.body = _f.read(n);
        break;
      case Tr.ATTRIBUTE:
        this.body = c0.read(n);
        break;
      case Tr.ENCRYPTED_MDC:
        this.body = c0.read(n);
        break;
      case Tr.MDC:
        this.body = c0.read(n);
        break;
      case Tr.ENCRYPTED_AEAD:
        this.body = c0.read(n);
        break;
      default:
        this.body = c0.read(n);
        break;
    }
    return this;
  }
  format() {
    return {
      type: N7[this.type] || "UNKNOWN",
      body: this.body
    };
  }
}
class Zf extends ni.Struct {
  constructor() {
    super();
  }
}
class c0 extends Zf {
  constructor() {
    super(), this.data = Es;
  }
  getSize() {
    return this.data.length;
  }
  write(e) {
    return e.writeBytes(this.data), e;
  }
  read(e) {
    return this.data = e.readBytes(e.left()), this;
  }
  format() {
    return {
      data: this.data.toString("hex")
    };
  }
}
class _f extends Zf {
  constructor() {
    super(), this.version = 4, this.algorithm = 0, this.expires = 0, this.timestamp = 0, this.n = new V0(), this.e = new V0(), this.p = new V0(), this.g = new V0(), this.y = new V0(), this.p, this.q = new V0(), this.g, this.y, this.oid = Es, this.point = new V0(), this.kdfHash = 0, this.kdfAlg = 0, this.oid, this.point, this.data = Es;
  }
  get curve() {
    return this.oid.equals(Fr.P256) ? Hr.P256 : this.oid.equals(Fr.P384) ? Hr.P384 : this.oid.equals(Fr.P521) ? Hr.P521 : this.oid.equals(Fr.SECP256K1) ? Hr.SECP256K1 : this.oid.equals(Fr.X25519) ? Hr.X25519 : this.oid.equals(Fr.BRAINPOOLP256) ? Hr.BRAINPOOLP256 : this.oid.equals(Fr.BRAINPOOLP384) ? Hr.BRAINPOOLP384 : this.oid.equals(Fr.BRAINPOOLP512) ? Hr.BRAINPOOLP512 : this.oid.equals(Fr.ED25519) ? Hr.ED25519 : 0;
  }
  set curve(e) {
    switch (e) {
      case Hr.P256:
        this.oid = Fr.P256;
        break;
      case Hr.P384:
        this.oid = Fr.P384;
        break;
      case Hr.P521:
        this.oid = Fr.P521;
        break;
      case Hr.SECP256K1:
        this.oid = Fr.SECP256K1;
        break;
      case Hr.X25519:
        this.oid = Fr.X25519;
        break;
      case Hr.BRAINPOOLP256:
        this.oid = Fr.BRAINPOOLP256;
        break;
      case Hr.BRAINPOOLP384:
        this.oid = Fr.BRAINPOOLP384;
        break;
      case Hr.BRAINPOOLP512:
        this.oid = Fr.BRAINPOOLP512;
        break;
      case Hr.ED25519:
        this.oid = Fr.ED25519;
        break;
    }
  }
  isRSA() {
    switch (this.algorithm) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY:
        return !0;
    }
    return !1;
  }
  isElgamal() {
    switch (this.algorithm) {
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY:
        return !0;
    }
    return !1;
  }
  getSize() {
    let e = 0;
    switch (e += 1, this.version) {
      case 2:
      case 3: {
        e += 4, e += 2, e += 1;
        break;
      }
      case 4: {
        e += 4, e += 1;
        break;
      }
      default:
        throw new Error("Unknown PGP key version.");
    }
    switch (this.algorithm) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY: {
        e += this.n.getSize(), e += this.e.getSize();
        break;
      }
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY: {
        e += this.p.getSize(), e += this.g.getSize(), e += this.y.getSize();
        break;
      }
      case We.DSA: {
        e += this.p.getSize(), e += this.q.getSize(), e += this.g.getSize(), e += this.y.getSize();
        break;
      }
      case We.ECDH: {
        e += 1, e += this.oid.length, e += this.point.getSize(), e += 4;
        break;
      }
      case We.ECDSA:
      case We.EDDSA: {
        e += 1, e += this.oid.length, e += this.point.getSize();
        break;
      }
      default: {
        e += this.data.length;
        break;
      }
    }
    return e;
  }
  write(e) {
    switch (e.writeU8(this.version), this.version) {
      case 2:
      case 3: {
        if (!this.isRSA())
          throw new Error("Unknown PGP key algorithm.");
        e.writeU32BE(this.timestamp), e.writeU16BE(this.expires), e.writeU8(this.algorithm);
        break;
      }
      case 4: {
        e.writeU32BE(this.timestamp), e.writeU8(this.algorithm);
        break;
      }
      default:
        throw new Error("Unknown PGP key version.");
    }
    switch (this.algorithm) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY: {
        this.n.write(e), this.e.write(e);
        break;
      }
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY: {
        this.p.write(e), this.g.write(e), this.y.write(e);
        break;
      }
      case We.DSA: {
        this.p.write(e), this.q.write(e), this.g.write(e), this.y.write(e);
        break;
      }
      case We.ECDH: {
        e.writeU8(this.oid.length), e.writeBytes(this.oid), this.point.write(e), e.writeU8(3), e.writeU8(1), e.writeU8(this.kdfHash), e.writeU8(this.kdfAlg);
        break;
      }
      case We.ECDSA:
      case We.EDDSA: {
        e.writeU8(this.oid.length), e.writeBytes(this.oid), this.point.write(e);
        break;
      }
      default: {
        e.writeBytes(this.data);
        break;
      }
    }
    return e;
  }
  read(e) {
    switch (this.version = e.readU8(), this.version) {
      case 2:
      case 3: {
        if (this.timestamp = e.readU32BE(), this.expires = e.readU16BE(), this.algorithm = e.readU8(), !this.isRSA())
          if (this.version === 3 && this.isElgamal())
            this.expires = 0, this.version = 4;
          else
            throw new Error("Unknown PGP key algorithm.");
        break;
      }
      case 4: {
        this.timestamp = e.readU32BE(), this.algorithm = e.readU8();
        break;
      }
      default:
        throw new Error("Unknown PGP key version.");
    }
    switch (this.algorithm) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY: {
        this.n.read(e), this.e.read(e);
        break;
      }
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY: {
        this.p.read(e), this.g.read(e), this.y.read(e);
        break;
      }
      case We.DSA: {
        this.p.read(e), this.q.read(e), this.g.read(e), this.y.read(e);
        break;
      }
      case We.ECDH: {
        this.oid = e.readBytes(e.readU8()), this.point.read(e);
        const t = e.readU8();
        if (t < 3 || t > e.left())
          throw new Error("Invalid ECDH params.");
        if (e.readU8() !== 1)
          throw new Error("Invalid ECDH reserved byte.");
        this.kdfHash = e.readU8(), this.kdfAlg = e.readU8();
        break;
      }
      case We.ECDSA:
      case We.EDDSA: {
        this.oid = e.readBytes(e.readU8()), this.point.read(e);
        break;
      }
      default: {
        this.data = e.readBytes(e.left());
        break;
      }
    }
    return this;
  }
  fingerprint() {
    switch (this.version) {
      case 2:
      case 3: {
        if (!this.isRSA())
          throw new Error("Unknown PGP key algorithm.");
        const e = ni.concat(this.n.data, this.e.data);
        return _7.digest(e);
      }
      case 4: {
        const e = this.getSize(), t = ni.write(3 + e);
        return t.writeU8(153), t.writeU16BE(e), this.write(t), fo.digest(t.render());
      }
      default:
        throw new Error("Unknown PGP key version.");
    }
  }
  id() {
    switch (this.version) {
      case 2:
      case 3: {
        if (!this.isRSA())
          throw new Error("Unknown PGP key algorithm.");
        if (this.n.data.length < 8)
          throw new Error("Unknown PGP key algorithm.");
        return this.n.data.slice(this.n.data.length - 8);
      }
      case 4:
        return this.fingerprint().slice(12, 20);
      default:
        throw new Error("Unknown PGP key version.");
    }
  }
  long() {
    return this.id();
  }
  short() {
    return this.id().slice(4, 8);
  }
  matches(e) {
    switch (typeof e == "string" && (e = T7(e)), e.length) {
      case 4:
        return this.short().equals(e);
      case 8:
        return this.long().equals(e);
      case 16:
      case 20:
        return this.fingerprint().equals(e);
      default:
        return !1;
    }
  }
  keyHash() {
    let e = 6;
    this.version !== 4 && (e += 2);
    const t = this.encode().slice(e - 1);
    return t[0] = this.algorithm, M7.digest(t);
  }
  format() {
    const e = O7[this.algorithm] || "UNKNOWN", t = this.version, i = this.timestamp, n = this.expires;
    switch (this.algorithm) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY:
        return {
          version: t,
          algorithm: e,
          timestamp: i,
          expires: n,
          n: this.n.data.toString("hex"),
          e: this.e.data.toString("hex")
        };
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY:
        return {
          version: t,
          algorithm: e,
          timestamp: i,
          expires: n,
          p: this.p.data.toString("hex"),
          g: this.g.data.toString("hex"),
          y: this.y.data.toString("hex")
        };
      case We.DSA:
        return {
          version: t,
          algorithm: e,
          timestamp: i,
          expires: n,
          p: this.p.data.toString("hex"),
          q: this.q.data.toString("hex"),
          g: this.g.data.toString("hex"),
          y: this.y.data.toString("hex")
        };
      case We.ECDH:
        return {
          version: t,
          algorithm: e,
          timestamp: i,
          expires: n,
          curve: p1[this.curve] || "UNKNOWN",
          point: this.point.data.toString("hex"),
          kdfHash: this.kdfHash,
          kdfAlg: this.kdfAlg
        };
      case We.ECDSA:
      case We.EDDSA:
        return {
          version: t,
          algorithm: e,
          timestamp: i,
          expires: n,
          curve: p1[this.curve] || "UNKNOWN",
          point: this.point.data.toString("hex")
        };
      default:
        return {
          version: t,
          algorithm: e,
          timestamp: i,
          expires: n,
          data: this.data.toString("hex")
        };
    }
  }
}
class m1 extends Zf {
  constructor() {
    super(), this.key = new _f(), this.params = new q7(), this.data = Es;
  }
  secret(e) {
    let t = this.data;
    if (this.params.encrypted) {
      if (e == null)
        throw new Error("Key requires a passphrase.");
      t = this.params.decrypt(t, e);
    }
    return U7.decode(t, this.key.algorithm);
  }
  getSize() {
    let e = 0;
    return e += this.key.getSize(), e += this.params.getSize(), e += this.data.length, e;
  }
  write(e) {
    return this.key.write(e), this.params.write(e), e.writeBytes(this.data), e;
  }
  read(e) {
    return this.key.read(e), this.params.read(e), this.data = e.readBytes(e.left()), this;
  }
  format() {
    let e = null, t = null;
    return this.params.encrypted ? (e = this.params, t = this.data.toString("hex")) : (e = null, t = this.secret()), {
      key: this.key,
      params: e,
      data: t
    };
  }
}
class q7 extends ni.Struct {
  constructor() {
    super(), this.encrypted = !1, this.checksum = !1, this.cipher = 0, this.s2k = new z7(), this.iv = Es;
  }
  blockSize() {
    switch (this.cipher) {
      case Zt.IDEA:
      case Zt.DES3:
      case Zt.CAST5:
      case Zt.BLOWFISH:
        return 8;
      case Zt.AES128:
      case Zt.AES192:
      case Zt.AES256:
      case Zt.TWOFISH:
      case Zt.CAMELLIA128:
      case Zt.CAMELLIA192:
      case Zt.CAMELLIA256:
        return 16;
      default:
        throw new Error("Unknown cipher type.");
    }
  }
  keySize() {
    switch (this.cipher) {
      case Zt.IDEA:
        return 16;
      case Zt.DES3:
        return 24;
      case Zt.CAST5:
        return 16;
      case Zt.BLOWFISH:
        return 16;
      case Zt.AES128:
        return 16;
      case Zt.AES192:
        return 24;
      case Zt.AES256:
        return 32;
      case Zt.TWOFISH:
        return 32;
      case Zt.CAMELLIA128:
        return 16;
      case Zt.CAMELLIA192:
        return 24;
      case Zt.CAMELLIA256:
        return 32;
      default:
        throw new Error("Unknown cipher type.");
    }
  }
  algName() {
    switch (this.cipher) {
      case Zt.IDEA:
        return "IDEA-CFB";
      case Zt.DES3:
        return "DES-EDE3-CFB";
      case Zt.CAST5:
        return "CAST5-CFB";
      case Zt.BLOWFISH:
        return "BF-CFB";
      case Zt.AES128:
        return "AES-128-CFB";
      case Zt.AES192:
        return "AES-192-CFB";
      case Zt.AES256:
        return "AES-256-CFB";
      case Zt.TWOFISH:
        return "TWOFISH-256-CFB";
      case Zt.CAMELLIA128:
        return "CAMELLIA-128-CFB";
      case Zt.CAMELLIA192:
        return "CAMELLIA-192-CFB";
      case Zt.CAMELLIA256:
        return "CAMELLIA-256-CFB";
      default:
        throw new Error("Unknown cipher type.");
    }
  }
  derive(e) {
    if (!this.encrypted)
      throw new Error("Cannot derive passphrase.");
    return this.s2k.derive(e, this.keySize());
  }
  encipher(e, t) {
    Y0(Buffer.isBuffer(e));
    const i = this.algName(), n = this.checksum ? 20 : 2, c = Buffer.alloc(e.length + n);
    if (e.copy(c, 0), this.checksum)
      fo.digest(e).copy(c, e.length);
    else {
      let o = 0;
      for (let d = 0; d < e.length; d++)
        o += e[d], o &= 65535;
      ni.writeU16BE(c, o, e.length);
    }
    return Nb.encrypt(i, t, this.iv, c);
  }
  decipher(e, t) {
    const i = this.algName(), n = Nb.decrypt(i, t, this.iv, e);
    if (this.checksum) {
      if (n.length < 20)
        throw new Error("Truncated data.");
      const l = n.slice(0, -20), h = n.slice(-20);
      if (!fo.digest(l).equals(h))
        throw new Error("Invalid checksum.");
      return l;
    }
    if (n.length < 2)
      throw new Error("Truncated data.");
    const c = n.slice(0, -2), o = ni.readU16BE(n, n.length - 2);
    let d = 0;
    for (let l = 0; l < c.length; l++)
      d += c[l], d &= 65535;
    if (d !== o)
      throw new Error("Invalid checksum.");
    return c;
  }
  encrypt(e, t) {
    const i = this.derive(t);
    return this.encipher(e, i);
  }
  decrypt(e, t) {
    const i = this.derive(t);
    return this.decipher(e, i);
  }
  getSize() {
    let e = 0;
    return this.encrypted ? (e += 1, e += 1, e += this.s2k.getSize(), e += this.iv.length) : e += 1, e;
  }
  write(e) {
    return this.encrypted ? (Y0(this.iv.length === this.blockSize()), e.writeU8(this.checksum ? 254 : 255), e.writeU8(this.cipher), this.s2k.write(e), e.writeBytes(this.iv)) : e.writeU8(0), e;
  }
  read(e) {
    const t = e.readU8();
    switch (t) {
      case 0:
        break;
      case 254:
      case 255:
        this.encrypted = !0, this.checksum = t === 254, this.cipher = e.readU8(), this.s2k.read(e), this.iv = e.readBytes(this.blockSize());
        break;
      default:
        throw new Error("Unknown S2K type.");
    }
    return this;
  }
  format() {
    return {
      encrypted: this.encrypted,
      checksum: this.checksum,
      cipher: P7[this.cipher] || "UNKNOWN",
      s2k: this.s2k,
      iv: this.iv.toString("hex")
    };
  }
}
class z7 extends ni.Struct {
  constructor() {
    super(), this.mode = 0, this.hash = 0, this.count = 0, this.salt = Es, this.serial = Es;
  }
  derive(e, t) {
    Y0(typeof e == "string"), Y0(t >>> 0 === t);
    const { salt: i, count: n } = this, c = Buffer.from(e, "binary"), o = oB[this.hash];
    if (!o)
      throw new Error("Unknown hash.");
    switch (this.mode) {
      case 0:
        return ud.deriveSimple(o, c, t);
      case 1:
        return ud.deriveSalted(o, c, i, t);
      case 3:
        return ud.deriveIterated(o, c, i, n, t);
      default:
        throw new Error("Unknown S2K mode.");
    }
  }
  getSize() {
    let e = 2;
    switch (this.mode) {
      case 0:
        break;
      case 1:
        e += 8;
        break;
      case 3:
        e += 8, e += 1;
        break;
      case 1001:
        e += 3, e += 1;
        break;
      case 1002:
        e += 3, e += 1, e += 1, e += this.serial.length;
        break;
      default:
        throw new Error("Unknown S2K function.");
    }
    return e;
  }
  write(e) {
    switch (e.writeU8(this.mode > 255 ? 101 : this.mode), e.writeU8(this.hash), this.mode) {
      case 0:
        break;
      case 1:
        e.writeBytes(this.salt);
        break;
      case 3:
        e.writeBytes(this.salt), e.writeU8(lB(this.count));
        break;
      case 1001:
        e.writeString("GNU", "binary"), e.writeU8(1);
        break;
      case 1002:
        e.writeString("GNU", "binary"), e.writeU8(2), e.writeU8(this.serial.length), e.writeBytes(this.serial);
        break;
      default:
        throw new Error("Unknown S2K function.");
    }
    return e;
  }
  read(e) {
    switch (this.mode = e.readU8(), this.hash = e.readU8(), this.mode) {
      case 0:
        break;
      case 1: {
        this.salt = e.readBytes(8);
        break;
      }
      case 3: {
        this.salt = e.readBytes(8), this.count = D7(e.readU8());
        break;
      }
      case 101: {
        if (e.readString(3, "binary") !== "GNU")
          throw new Error("Unknown S2K function.");
        switch (this.mode = 1e3 + e.readU8(), this.mode) {
          case 1001:
            break;
          case 1002:
            this.serial = e.readBytes(Math.min(e.readU8(), 16));
            break;
          default:
            throw new Error("Unknown S2K function.");
        }
        break;
      }
      default:
        throw new Error("Unknown S2K function.");
    }
    return this;
  }
  format() {
    return {
      mode: this.mode,
      hash: R7[this.hash] || "UNKNOWN",
      count: this.count,
      salt: this.salt.toString("hex"),
      serial: this.serial.toString("hex")
    };
  }
}
class U7 extends ni.Struct {
  constructor() {
    super(), this.d = new V0(), this.q = new V0(), this.p = new V0(), this.qi = new V0(), this.x = new V0(), this.x, this.d;
  }
  getSize(e) {
    Y0((e & 255) === e);
    let t = 0;
    switch (e) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY: {
        t += this.d.getSize(), t += this.q.getSize(), t += this.p.getSize(), t += this.qi.getSize();
        break;
      }
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY: {
        t += this.x.getSize();
        break;
      }
      case We.DSA: {
        t += this.x.getSize();
        break;
      }
      case We.ECDSA:
      case We.EDDSA: {
        t += this.d.getSize();
        break;
      }
      default:
        throw new Error("Unknown key type.");
    }
    return t;
  }
  write(e, t) {
    switch (Y0((t & 255) === t), t) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY: {
        this.d.write(e), this.q.write(e), this.p.write(e), this.qi.write(e);
        break;
      }
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY: {
        this.x.write(e);
        break;
      }
      case We.DSA: {
        this.x.write(e);
        break;
      }
      case We.ECDSA:
      case We.EDDSA: {
        this.d.write(e);
        break;
      }
      default:
        throw new Error("Unknown key type.");
    }
    return e;
  }
  read(e, t) {
    switch (Y0((t & 255) === t), t) {
      case We.RSA:
      case We.RSA_ENCRYPT_ONLY:
      case We.RSA_SIGN_ONLY: {
        this.d.read(e), this.q.read(e), this.p.read(e), this.qi.read(e);
        break;
      }
      case We.ELGAMAL:
      case We.ELGAMAL_LEGACY: {
        this.x.read(e);
        break;
      }
      case We.DSA: {
        this.x.read(e);
        break;
      }
      case We.ECDSA:
      case We.EDDSA: {
        this.d.read(e);
        break;
      }
      default:
        throw new Error("Unknown key type.");
    }
    return this;
  }
  format() {
    return this.p.data.length > 0 ? {
      d: this.d.data.toString("hex"),
      q: this.q.data.toString("hex"),
      p: this.p.data.toString("hex"),
      qi: this.qi.data.toString("hex")
    } : this.x.data.length > 0 ? {
      x: this.x.data.toString("hex")
    } : this.d.data.length > 0 ? {
      d: this.d.data.toString("hex")
    } : {
      d: this.d.data.toString("hex"),
      q: this.q.data.toString("hex"),
      p: this.p.data.toString("hex"),
      qi: this.qi.data.toString("hex"),
      x: this.x.data.toString("hex")
    };
  }
}
class C7 extends Zf {
  constructor() {
    super(), this.id = "";
  }
  getSize() {
    return Buffer.byteLength(this.id, "utf8");
  }
  write(e) {
    return e.writeString(this.id, "utf8"), e;
  }
  read(e) {
    return this.id = e.readString(e.left(), "utf8"), this;
  }
  format() {
    return {
      id: this.id
    };
  }
}
class V0 extends ni.Struct {
  constructor(e) {
    super(), this.bits = 0, this.data = Es, e != null && this.fromOptions(e);
  }
  get() {
    return this.data;
  }
  set(e) {
    return this.fromOptions(e);
  }
  fromOptions(e) {
    return Y0(Buffer.isBuffer(e)), this.bits = eB(e), this.data = e, this;
  }
  getSize() {
    return 2 + this.data.length;
  }
  write(e) {
    return e.writeU16BE(this.bits), e.writeBytes(this.data), e;
  }
  read(e) {
    if (e.left() === 0)
      return this;
    const t = e.readU16BE(), i = t + 7 >>> 3, n = Math.min(i, e.left()), c = e.readBytes(n);
    return this.bits = t, this.data = c, this;
  }
}
function uB(r) {
  switch (Y0(Buffer.isBuffer(r)), r.length) {
    case 4:
    case 8:
    case 16:
    case 20:
      break;
    default:
      throw new Error("Invalid PGP key id/fingerprint.");
  }
  return `0x${r.toString("hex").toUpperCase()}`;
}
function T7(r) {
  if (Y0(typeof r == "string"), r = r.replace(/[\t ]/g, ""), r.length >= 2 && r.charCodeAt(0) === 48 && (r.charCodeAt(1) | 32) === 120 && (r = r.substring(2)), r.length > 40)
    throw new Error("Invalid PGP key id/fingerprint.");
  const e = Buffer.from(r, "hex");
  if (e.length !== r.length >>> 1)
    throw new Error("Invalid PGP key id/fingerprint.");
  switch (e.length) {
    case 4:
    case 8:
    case 16:
    case 20:
      break;
    default:
      throw new Error("Invalid PGP key id/fingerprint.");
  }
  return e;
}
function lB(r) {
  if (Y0(r >>> 0 === r), r < 1024 || r > 65011712)
    throw new RangeError("Invalid iteration count.");
  for (let e = 0; e < 256; e++)
    if (D7(e) >= r)
      return e;
  return 255;
}
function D7(r) {
  return Y0((r & 255) === r), 16 + (r & 15) << (r >>> 4) + 6;
}
lr.packetTypes = Tr;
lr.packetTypesByVal = N7;
lr.sigTypes = nB;
lr.sigTypesByVal = fB;
lr.keyTypes = We;
lr.keyTypesByVal = O7;
lr.cipherTypes = Zt;
lr.cipherTypesByVal = P7;
lr.hashTypes = cB;
lr.hashTypesByVal = R7;
lr.compressTypes = aB;
lr.compressTypesByVal = hB;
lr.curveTypes = Hr;
lr.curveTypesByVal = p1;
lr.oids = Fr;
lr.PGPMessage = dB;
lr.PGPPacket = k7;
lr.PGPBody = Zf;
lr.PGPUnknown = c0;
lr.PGPPublicKey = _f;
lr.PGPPrivateKey = m1;
lr.CipherParams = q7;
lr.S2K = z7;
lr.SecretKey = U7;
lr.PGPUserID = C7;
lr.MPI = V0;
lr.encodeID = uB;
lr.decodeID = T7;
var g1 = { exports: {} }, Sr = {}, x0 = {};
/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */
const js = _e;
function xB(r, e) {
  if (js(Buffer.isBuffer(r)), js(Buffer.isBuffer(e)), Un(r.length, 0))
    return Un(e.length, 0);
  let t = r.length ^ e.length;
  for (let i = 0; i < e.length; i++)
    t |= r[i % r.length] ^ e[i];
  return t - 1 >>> 31;
}
function bB(r, e) {
  if (js(Buffer.isBuffer(r)), js(Buffer.isBuffer(e)), !Un(r.length, e.length))
    return 0;
  let t = 0;
  for (let i = 0; i < r.length; i++)
    t |= r[i] ^ e[i];
  return t - 1 >>> 31;
}
function pB(r, e) {
  return Un(r & 255, e & 255);
}
function Un(r, e) {
  return (r ^ e) - 1 >>> 31;
}
function Al(r, e, t) {
  return r & t - 1 | e & ~(t - 1);
}
function L7(r, e) {
  return r - e >>> 31;
}
function mB(r, e) {
  return r - e - 1 >>> 31;
}
function K7(r, e) {
  return e - r >>> 31;
}
function gB(r, e) {
  return e - r - 1 >>> 31;
}
function wB(r, e) {
  return Al(r, e, L7(e, r));
}
function yB(r, e) {
  return Al(r, e, K7(e, r));
}
function SB(r) {
  return (r | 0) * (r >> 31 | 1);
}
function BB(r) {
  return (r >> 31 | -r >> 31) & 1;
}
function vB(r, e, t) {
  js(Buffer.isBuffer(r)), js(Buffer.isBuffer(e)), js(Un(r.length, e.length));
  const i = t - 1 & 255, n = ~(t - 1) & 255;
  for (let c = 0; c < r.length; c++)
    r[c] = r[c] & i | e[c] & n;
}
x0.safeCompare = xB;
x0.safeEqual = bB;
x0.safeEqualByte = pB;
x0.safeEqualInt = Un;
x0.safeSelect = Al;
x0.safeLT = L7;
x0.safeLTE = mB;
x0.safeGT = K7;
x0.safeGTE = gB;
x0.safeMin = wB;
x0.safeMax = yB;
x0.safeAbs = SB;
x0.safeBool = BB;
x0.safeCopy = vB;
/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c
 *
 * References:
 *
 *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2
 *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch
 *     https://tools.ietf.org/html/rfc8017
 *
 *   [FIPS186] Federal Information Processing Standards Publication 186-4
 *     National Institute of Standards and Technology
 *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */
var Ob;
function EB() {
  if (Ob)
    return Sr;
  Ob = 1;
  const r = _e, e = J0, t = B0, { randomPrime: i } = z8(), n = Fo, c = X1(), o = x0, { safeEqual: d, safeEqualByte: l, safeSelect: h, safeLTE: x } = o, b = 2048, g = 65537, w = 512, I = 16384, B = 3, y = 2 ** 33 - 1, A = 33, _ = 0, q = -1, U = Buffer.alloc(8, 0), z = Buffer.alloc(0), E = {
    __proto__: null,
    BLAKE2B160: Buffer.from("3027300f060b2b060104018d3a0c02010505000414", "hex"),
    BLAKE2B256: Buffer.from("3033300f060b2b060104018d3a0c02010805000420", "hex"),
    BLAKE2B384: Buffer.from("3043300f060b2b060104018d3a0c02010c05000430", "hex"),
    BLAKE2B512: Buffer.from("3053300f060b2b060104018d3a0c02011005000440", "hex"),
    BLAKE2S128: Buffer.from("3023300f060b2b060104018d3a0c02020405000410", "hex"),
    BLAKE2S160: Buffer.from("3027300f060b2b060104018d3a0c02020505000414", "hex"),
    BLAKE2S224: Buffer.from("302f300f060b2b060104018d3a0c0202070500041c", "hex"),
    BLAKE2S256: Buffer.from("3033300f060b2b060104018d3a0c02020805000420", "hex"),
    GOST94: Buffer.from("302e300a06062a850302021405000420", "hex"),
    HASH160: Buffer.from([20]),
    HASH256: Buffer.from([32]),
    KECCAK224: Buffer.from([28]),
    KECCAK256: Buffer.from([32]),
    KECCAK384: Buffer.from([48]),
    KECCAK512: Buffer.from([64]),
    MD2: Buffer.from("3020300c06082a864886f70d020205000410", "hex"),
    MD4: Buffer.from("3020300c06082a864886f70d020405000410", "hex"),
    MD5: Buffer.from("3020300c06082a864886f70d020505000410", "hex"),
    MD5SHA1: Buffer.from([36]),
    RIPEMD160: Buffer.from("3021300906052b2403020105000414", "hex"),
    SHA1: Buffer.from("3021300906052b0e03021a05000414", "hex"),
    SHA224: Buffer.from("302d300d06096086480165030402040500041c", "hex"),
    SHA256: Buffer.from("3031300d060960864801650304020105000420", "hex"),
    SHA384: Buffer.from("3041300d060960864801650304020205000430", "hex"),
    SHA512: Buffer.from("3051300d060960864801650304020305000440", "hex"),
    SHA3_224: Buffer.from("302d300d06096086480165030402070500041c", "hex"),
    SHA3_256: Buffer.from("3031300d060960864801650304020805000420", "hex"),
    SHA3_384: Buffer.from("3041300d060960864801650304020905000430", "hex"),
    SHA3_512: Buffer.from("3051300d060960864801650304020a05000440", "hex"),
    SHAKE128: Buffer.from("3021300d060960864801650304020b05000410", "hex"),
    SHAKE256: Buffer.from("3031300d060960864801650304020c05000420", "hex"),
    WHIRLPOOL: Buffer.from("304e300a060628cf0603003705000440", "hex")
  };
  class H {
    constructor() {
      this.n = new e(0), this.e = new e(0);
    }
    bits() {
      return this.n.bitLength();
    }
    size() {
      return this.n.byteLength();
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= I && this.e.bitLength() <= A;
    }
    verify() {
      return !(!this.isSane() || this.n.bitLength() < w || !this.n.isOdd() || this.e.cmpn(B) < 0 || !this.e.isOdd());
    }
    encrypt(O) {
      r(Buffer.isBuffer(O));
      const { n: $, e: u } = this, S = e.decode(O);
      if (S.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      return S.powm(u, $).encode("be", $.byteLength());
    }
    encode() {
      const O = c.sizeInt(this.n) + c.sizeInt(this.e), $ = Buffer.alloc(c.sizeSeq(O));
      let u = 0;
      return u = c.writeSeq($, u, O), u = c.writeInt($, u, this.n), u = c.writeInt($, u, this.e), r(u === $.length), $;
    }
    decode(O) {
      let $ = 0;
      if ($ = c.readSeq(O, $), [this.n, $] = c.readInt(O, $), [this.e, $] = c.readInt(O, $), $ !== O.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static decode(O) {
      return new H().decode(O);
    }
  }
  class k extends H {
    constructor() {
      super(), this.d = new e(0), this.p = new e(0), this.q = new e(0), this.dp = new e(0), this.dq = new e(0), this.qi = new e(0);
    }
    isSane() {
      return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= I && this.e.bitLength() <= A && this.d.bitLength() <= I && this.p.bitLength() <= I && this.q.bitLength() <= I && this.dp.bitLength() <= I && this.dq.bitLength() <= I && this.qi.bitLength() <= I;
    }
    verify() {
      if (!this.isSane() || this.n.bitLength() < w || !this.n.isOdd() || this.e.cmpn(B) < 0 || !this.e.isOdd() || this.p.cmpn(3) < 0 || !this.p.isOdd() || this.q.cmpn(3) < 0 || !this.q.isOdd())
        return !1;
      const O = this.p.subn(1), $ = this.q.subn(1), u = O.mul($);
      if (this.d.cmpn(2) < 0 || this.d.cmp(u) >= 0 || this.dp.sign() === 0 || this.dp.cmp(O) >= 0 || this.dq.sign() === 0 || this.dq.cmp($) >= 0 || this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0 || this.p.cmp(this.q) === 0 || this.p.mul(this.q).cmp(this.n) !== 0)
        return !1;
      const S = u.div(O.gcd($));
      return !(this.e.mul(this.d).imod(S).cmpn(1) !== 0 || this.d.mod(O).cmp(this.dp) !== 0 || this.d.mod($).cmp(this.dq) !== 0 || this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0);
    }
    decrypt(O) {
      r(Buffer.isBuffer(O));
      const { n: $, e: u, p: S, q: M, dp: Y, dq: J, qi: X } = this, re = e.decode(O);
      if (re.cmp($) >= 0)
        throw new Error("Invalid RSA message size.");
      let ae, de;
      for (; ; ) {
        const Ie = e.random(t, 1, $);
        try {
          de = Ie.invert($);
        } catch {
          continue;
        }
        ae = Ie.powm(u, $);
        break;
      }
      re.imul(ae).imod($);
      const ge = re.powm(Y, S, !0), Be = re.powm(J, M, !0), Oe = ge.sub(Be).mul(X).imod(S).mul(M).iadd(Be).imod($);
      if (Oe.powm(u, $).cmp(re) !== 0)
        throw new Error("Invalid RSA private key.");
      return Oe.imul(de).imod($), Oe.encode("be", $.byteLength());
    }
    generate(O, $) {
      r(O >>> 0 === O), r(Number.isSafeInteger($) && $ >= 0), r(O >= 64), r($ >= 3 && ($ & 1) !== 0);
      const u = new e($);
      for (; ; ) {
        const S = i((O >>> 1) + (O & 1)), M = i(O >>> 1);
        if (S.cmp(M) === 0 || (S.cmp(M) < 0 && S.swap(M), S.sub(M).bitLength() <= (O >>> 1) - 99))
          continue;
        const Y = S.mul(M);
        if (Y.bitLength() !== O)
          continue;
        const J = S.subn(1), X = M.subn(1), re = J.mul(X);
        if (u.gcd(re).cmpn(1) !== 0)
          continue;
        const ae = re.div(J.gcd(X)), de = u.invert(ae);
        if (de.bitLength() <= O + 1 >>> 1)
          continue;
        const ge = de.mod(J), Be = de.mod(X), ve = M.invert(S);
        return this.n = Y, this.e = u, this.d = de, this.p = S, this.q = M, this.dp = ge, this.dq = Be, this.qi = ve, this;
      }
    }
    async _generateSubtle(O, $) {
      r(O >>> 0 === O), r(Number.isSafeInteger($) && $ >= 0), r(O >= 64), r($ >= 3 && ($ & 1) !== 0);
      const u = Pn.crypto || Pn.msCrypto;
      if (!u)
        throw new Error("Crypto API not available.");
      const { subtle: S } = u;
      if (!S || !S.generateKey || !S.exportKey)
        throw new Error("Subtle API not available.");
      const M = new e($), Y = {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: O,
        publicExponent: M.toArrayLike(Uint8Array, "be", 8),
        hash: { name: "SHA-256" }
      }, J = await S.generateKey(Y, !0, ["sign"]), X = await S.exportKey("jwk", J.privateKey), re = e.decode(n.decodeURL(X.p)), ae = e.decode(n.decodeURL(X.q));
      return this.fromPQE(re, ae, M);
    }
    async generateAsync(O, $) {
      try {
        return await this._generateSubtle(O, $);
      } catch {
        return this.generate(O, $);
      }
    }
    fromPQE(O, $, u) {
      if (r(O instanceof e), r($ instanceof e), r(u instanceof e), O.cmp($) < 0 && ([O, $] = [$, O]), O.cmp($) === 0)
        throw new Error("Invalid RSA private key.");
      if (O.cmpn(3) < 0 || O.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      if (u.cmpn(B) < 0 || u.bitLength() > A)
        throw new Error("Invalid RSA private key.");
      if (!O.isOdd() || !$.isOdd() || !u.isOdd())
        throw new Error("Invalid RSA private key.");
      const S = O.mul($);
      if (r(S.isOdd()), S.bitLength() < w || S.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      const M = O.subn(1), Y = $.subn(1), J = M.lcm(Y), X = u.invert(J), re = X.mod(M), ae = X.mod(Y), de = $.invert(O);
      return this.n = S, this.e = u, this.d = X, this.p = O, this.q = $, this.dp = re, this.dq = ae, this.qi = de, this;
    }
    fromPQD(O, $, u) {
      if (r(O instanceof e), r($ instanceof e), r(u instanceof e), O.cmpn(3) < 0 || O.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(3) < 0 || $.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      if (!O.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const S = O.subn(1), M = $.subn(1), Y = S.mul(M);
      if (u.cmpn(2) < 0 || u.cmp(Y) >= 0)
        throw new Error("Invalid RSA private key.");
      const J = Y.div(S.gcd(M)), X = u.invert(J);
      return this.fromPQE(O, $, X);
    }
    fromNED(O, $, u) {
      if (r(O instanceof e), r($ instanceof e), r(u instanceof e), O.sign() < 0)
        throw new Error("Invalid RSA private key.");
      if (O.bitLength() < w || O.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      if ($.cmpn(B) < 0 || $.bitLength() > A)
        throw new Error("Invalid RSA private key.");
      if (u.cmpn(2) < 0 || u.bitLength() > I)
        throw new Error("Invalid RSA private key.");
      if (!O.isOdd() || !$.isOdd())
        throw new Error("Invalid RSA private key.");
      const S = $.mul(u).isubn(1), M = O.subn(1), Y = S.zeroBits(), J = S.ushrn(Y);
      for (let X = 0; X < 64; X++) {
        let ae = e.random(t, 2, M).powm(J, O);
        if (!(ae.cmpn(1) === 0 || ae.cmp(M) === 0))
          for (let de = 1; de < Y; de++) {
            const ge = ae.sqr().imod(O);
            if (ge.cmpn(1) === 0) {
              const Be = O.gcd(ae.subn(1)), ve = O.gcd(ae.addn(1));
              return this.fromPQE(Be, ve, $);
            }
            if (ge.cmp(M) === 0)
              break;
            ae = ge;
          }
      }
      throw new Error("Invalid RSA private key.");
    }
    toPublic() {
      const O = new H();
      return O.n = this.n, O.e = this.e, O;
    }
    encode() {
      let O = 0;
      O += c.sizeVersion(0), O += c.sizeInt(this.n), O += c.sizeInt(this.e), O += c.sizeInt(this.d), O += c.sizeInt(this.p), O += c.sizeInt(this.q), O += c.sizeInt(this.dp), O += c.sizeInt(this.dq), O += c.sizeInt(this.qi);
      const $ = Buffer.alloc(c.sizeSeq(O));
      let u = 0;
      return u = c.writeSeq($, u, O), u = c.writeVersion($, u, 0), u = c.writeInt($, u, this.n), u = c.writeInt($, u, this.e), u = c.writeInt($, u, this.d), u = c.writeInt($, u, this.p), u = c.writeInt($, u, this.q), u = c.writeInt($, u, this.dp), u = c.writeInt($, u, this.dq), u = c.writeInt($, u, this.qi), r(u === $.length), $;
    }
    decode(O) {
      let $ = 0;
      if ($ = c.readSeq(O, $), $ = c.readVersion(O, $, 0), [this.n, $] = c.readInt(O, $), [this.e, $] = c.readInt(O, $), [this.d, $] = c.readInt(O, $), [this.p, $] = c.readInt(O, $), [this.q, $] = c.readInt(O, $), [this.dp, $] = c.readInt(O, $), [this.dq, $] = c.readInt(O, $), [this.qi, $] = c.readInt(O, $), $ !== O.length)
        throw new Error("Trailing bytes.");
      return this;
    }
    static generate(O, $) {
      return new k().generate(O, $);
    }
    static async generateAsync(O, $) {
      return new k().generateAsync(O, $);
    }
    static fromPQE(O, $, u) {
      return new k().fromPQE(O, $, u);
    }
    static fromPQD(O, $, u) {
      return new k().fromPQD(O, $, u);
    }
    static fromNED(O, $, u) {
      return new k().fromNED(O, $, u);
    }
    static decode(O) {
      return new k().decode(O);
    }
  }
  function V(K, O) {
    if (K == null && (K = b), O == null && (O = g), r(K >>> 0 === K), r(Number.isSafeInteger(O) && O >= 0), K < w || K > I)
      throw new RangeError(`"bits" ranges from ${w} to ${I}.`);
    if (O < B || O > y)
      throw new RangeError(`"exponent" ranges from ${B} to ${y}.`);
    if (O === 1 || !(O & 1))
      throw new RangeError('"exponent" must be odd.');
    return k.generate(K, O).encode();
  }
  async function T(K, O) {
    if (K == null && (K = b), O == null && (O = g), r(K >>> 0 === K), r(Number.isSafeInteger(O) && O >= 0), K < w || K > I)
      throw new RangeError(`"bits" ranges from ${w} to ${I}.`);
    if (O < B || O > y)
      throw new RangeError(`"exponent" ranges from ${B} to ${y}.`);
    if (O === 1 || !(O & 1))
      throw new RangeError('"exponent" must be odd.');
    return (await k.generateAsync(K, O)).encode();
  }
  function ie(K) {
    const O = k.decode(K);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    return O.bits();
  }
  function N(K) {
    r(Buffer.isBuffer(K));
    let O;
    try {
      O = k.decode(K);
    } catch {
      return !1;
    }
    return O.verify();
  }
  function G(K) {
    r(K && typeof K == "object");
    let O = new k();
    return K.n != null && (O.n = e.decode(K.n)), K.e != null && (O.e = e.decode(K.e)), K.d != null && (O.d = e.decode(K.d)), K.p != null && (O.p = e.decode(K.p)), K.q != null && (O.q = e.decode(K.q)), K.dp != null && (O.dp = e.decode(K.dp)), K.dq != null && (O.dq = e.decode(K.dq)), K.qi != null && (O.qi = e.decode(K.qi)), O.verify() || (!O.p.isZero() && !O.q.isZero() ? O.e.isZero() ? O = k.fromPQD(O.p, O.q, O.d) : O = k.fromPQE(O.p, O.q, O.e) : O = k.fromNED(O.n, O.e, O.d)), O.encode();
  }
  function F(K) {
    const O = k.decode(K);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    return {
      n: O.n.encode(),
      e: O.e.encode(),
      d: O.d.encode(),
      p: O.p.encode(),
      q: O.q.encode(),
      dp: O.dp.encode(),
      dq: O.dq.encode(),
      qi: O.qi.encode()
    };
  }
  function W(K) {
    const O = k.decode(K);
    if (!O.verify())
      throw new Error("Invalid RSA private key.");
    return O.toPublic().encode();
  }
  function ce(K) {
    const O = H.decode(K);
    if (!O.verify())
      throw new Error("Invalid RSA public key.");
    return O.bits();
  }
  function ne(K) {
    r(Buffer.isBuffer(K));
    let O;
    try {
      O = H.decode(K);
    } catch {
      return !1;
    }
    return O.verify();
  }
  function xe(K) {
    r(K && typeof K == "object");
    const O = new H();
    if (K.n != null && (O.n = e.decode(K.n)), K.e != null && (O.e = e.decode(K.e)), !O.verify())
      throw new Error("Invalid RSA public key.");
    return O.encode();
  }
  function he(K) {
    const O = H.decode(K);
    if (!O.verify())
      throw new Error("Invalid RSA public key.");
    return {
      n: O.n.encode(),
      e: O.e.encode()
    };
  }
  function me(K, O, $) {
    K && typeof K.id == "string" && (K = K.id), r(K == null || typeof K == "string"), r(Buffer.isBuffer(O));
    const [u, S] = a(K, O);
    if (!u)
      throw new Error("Unknown RSA hash function.");
    if (O.length !== S)
      throw new Error("Invalid RSA message size.");
    const M = k.decode($);
    if (!M.verify())
      throw new Error("Invalid RSA private key.");
    const Y = u.length + S, J = M.size();
    if (J < Y + 11)
      throw new Error("Invalid RSA message size.");
    const X = Buffer.alloc(J);
    X[0] = 0, X[1] = 1;
    for (let re = 2; re < J - Y - 1; re++)
      X[re] = 255;
    return X[J - Y - 1] = 0, u.copy(X, J - Y), O.copy(X, J - S), M.decrypt(X);
  }
  function Ne(K, O, $, u) {
    K && typeof K.id == "string" && (K = K.id), r(K == null || typeof K == "string"), r(Buffer.isBuffer(O)), r(Buffer.isBuffer($)), r(Buffer.isBuffer(u));
    try {
      return Je(K, O, $, u);
    } catch {
      return !1;
    }
  }
  function Je(K, O, $, u) {
    const [S, M] = a(K, O);
    if (!S || O.length !== M)
      return !1;
    const Y = H.decode(u);
    if (!Y.verify())
      return !1;
    const J = Y.size();
    if ($.length !== J)
      return !1;
    const X = S.length + M;
    if (J < X + 11)
      return !1;
    const re = Y.encrypt($);
    let ae = 1;
    ae &= l(re[0], 0), ae &= l(re[1], 1);
    for (let de = 2; de < J - X - 1; de++)
      ae &= l(re[de], 255);
    return ae &= l(re[J - X - 1], 0), ae &= d(re.slice(J - X, J - M), S), ae &= d(re.slice(J - M, J), O), ae === 1;
  }
  function Ze(K, O) {
    r(Buffer.isBuffer(K));
    const $ = H.decode(O);
    if (!$.verify())
      throw new Error("Invalid RSA public key.");
    const u = $.size();
    if (K.length > u - 11)
      throw new Error("Invalid RSA message size.");
    const S = Buffer.alloc(u), M = K.length, Y = u - M - 3;
    S[0] = 0, S[1] = 2, t.randomFill(S, 2, Y);
    for (let J = 2; J < 2 + Y; J++)
      for (; S[J] === 0; )
        t.randomFill(S, J, 1);
    return S[u - M - 1] = 0, K.copy(S, u - M), $.encrypt(S);
  }
  function ht(K, O) {
    r(Buffer.isBuffer(K));
    const $ = k.decode(O);
    if (!$.verify())
      throw new Error("Invalid RSA private key.");
    const u = $.size();
    if (u < 11)
      throw new Error("Invalid RSA private key.");
    if (K.length !== u)
      throw new Error("Invalid RSA message size.");
    const S = $.decrypt(K), M = l(S[0], 0), Y = l(S[1], 2);
    let J = 0, X = 1;
    for (let ge = 2; ge < S.length; ge++) {
      const Be = l(S[ge], 0);
      J = h(J, ge, X & Be), X = h(X, 0, Be);
    }
    const re = x(2 + 8, J), ae = M & Y & (X ^ 1) & re, de = h(0, J + 1, ae);
    if (ae === 0)
      throw new Error("Invalid RSA ciphertext.");
    return S.slice(de);
  }
  function dt(K, O, $, u) {
    if (u == null && (u = q), r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r((u | 0) === u), O.length !== K.size)
      throw new Error("Invalid RSA message size.");
    const S = k.decode($);
    if (!S.verify())
      throw new Error("Invalid RSA private key.");
    const M = S.bits(), Y = M + 7 >>> 3, J = M + 6 >>> 3;
    if (u === _ ? u = J - 2 - K.size : u === q && (u = K.size), u < 0 || u > Y)
      throw new Error("Invalid PSS salt length.");
    const X = t.randomBytes(u), re = v(K, O, M - 1, X);
    return S.decrypt(re);
  }
  function Se(K, O, $, u, S) {
    S == null && (S = q), r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r(Buffer.isBuffer($)), r(Buffer.isBuffer(u)), r((S | 0) === S);
    try {
      return we(K, O, $, u, S);
    } catch {
      return !1;
    }
  }
  function we(K, O, $, u, S) {
    if (O.length !== K.size)
      return !1;
    const M = H.decode(u);
    if (!M.verify())
      return !1;
    const Y = M.bits(), J = Y + 7 >>> 3;
    if ($.length !== J || (S === _ ? S = 0 : S === q && (S = K.size), S < 0 || S > J))
      return !1;
    let X = M.encrypt($);
    if (!(Y - 1 & 7)) {
      if (X[0] !== 0)
        return !1;
      X = X.slice(1);
    }
    return C(K, O, X, Y - 1, S);
  }
  function Z(K, O, $, u) {
    u == null && (u = z), r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r(Buffer.isBuffer(u));
    const S = H.decode($);
    if (!S.verify())
      throw new Error("Invalid RSA public key.");
    const M = S.size(), Y = O.length, J = K.size;
    if (Y > M - 2 * J - 2)
      throw new Error("Invalid RSA message size.");
    const X = Buffer.alloc(M), re = K.digest(u), ae = X.slice(1, 1 + J), de = X.slice(1 + J), ge = de.length;
    return X[0] = 0, t.randomFill(ae, 0, ae.length), re.copy(de, 0), de.fill(0, J, ge - Y - 1), de[ge - Y - 1] = 1, O.copy(de, ge - Y), p(K, de, ae), p(K, ae, de), S.encrypt(X);
  }
  function L(K, O, $, u) {
    u == null && (u = z), r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r(Buffer.isBuffer(u));
    const S = k.decode($);
    if (!S.verify())
      throw new Error("Invalid RSA private key.");
    const M = S.size(), Y = O.length, J = K.size;
    if (M < J * 2 + 2)
      throw new Error("Invalid RSA private key size.");
    if (Y !== M)
      throw new Error("Invalid RSA message size.");
    const X = S.decrypt(O), re = K.digest(u), ae = l(X[0], 0), de = X.slice(1, J + 1), ge = X.slice(J + 1);
    p(K, de, ge), p(K, ge, de);
    const Be = ge.slice(0, J), ve = d(Be, re), Oe = ge.slice(J);
    let Ie = 1, Re = 0, ft = 0;
    for (let Fe = 0; Fe < Oe.length; Fe++) {
      const Le = l(Oe[Fe], 0), He = l(Oe[Fe], 1);
      Re = h(Re, Fe, Ie & He), Ie = h(Ie, 0, He), ft = h(ft, 1, Ie & (Le ^ 1));
    }
    if ((ae & ve & (ft ^ 1) & (Ie ^ 1)) === 0)
      throw new Error("Invalid RSA ciphertext.");
    return Oe.slice(Re + 1);
  }
  function oe(K, O, $) {
    r(Buffer.isBuffer(K)), r(O >>> 0 === O);
    const u = H.decode($);
    if (!u.verify())
      throw new Error("Invalid RSA public key.");
    if (K.length !== u.size())
      throw new Error("Invalid RSA ciphertext.");
    if (O < u.bits())
      throw new Error("Cannot make ciphertext smaller.");
    const S = O + 7 >>> 3, M = e.decode(K);
    if (M.cmp(u.n) >= 0)
      throw new Error("Invalid RSA ciphertext.");
    const Y = e.shift(1, O), J = Y.sub(M).iadd(u.n).isubn(1).div(u.n);
    r(J.sign() > 0);
    let X = Y;
    for (; X.cmp(Y) >= 0; ) {
      const re = e.random(t, 0, J);
      X = M.add(re.mul(u.n));
    }
    return r(X.mod(u.n).cmp(M) === 0), r(X.bitLength() <= O), X.encode("be", S);
  }
  function s(K, O, $) {
    r(Buffer.isBuffer(K)), r(O >>> 0 === O);
    const u = H.decode($);
    if (!u.verify())
      throw new Error("Invalid RSA public key.");
    const S = u.size();
    if (K.length < S)
      throw new Error("Invalid RSA ciphertext.");
    const M = e.decode(K);
    if (O !== 0 && M.bitLength() > O)
      throw new Error("Invalid RSA ciphertext.");
    return M.imod(u.n).encode("be", S);
  }
  function a(K, O) {
    if (r(K == null || typeof K == "string"), r(Buffer.isBuffer(O)), K == null)
      return [z, O.length];
    const $ = E[K];
    return $ == null ? [null, 0] : $.length === 1 ? [z, $[0]] : [
      $,
      $[$.length - 1]
    ];
  }
  function p(K, O, $) {
    r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r(Buffer.isBuffer($));
    const u = Buffer.alloc(4, 0);
    let S = 0;
    for (; S < O.length; ) {
      const M = K.multi($, u);
      let Y = 0;
      for (; S < O.length && Y < M.length; )
        O[S++] ^= M[Y++];
      for (Y = 3; Y >= 0 && (u[Y] += 1, u[Y] === 0); Y--)
        ;
    }
  }
  function v(K, O, $, u) {
    r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r($ >>> 0 === $), r(Buffer.isBuffer(u));
    const S = K.size, M = u.length, Y = $ + 7 >>> 3;
    if (O.length !== S)
      throw new Error("Invalid RSA message size.");
    if (Y < S + M + 2)
      throw new Error("Message too long.");
    const J = Buffer.alloc(Y), X = J.slice(0, Y - S - 1), re = J.slice(Y - S - 1, Y - 1), ae = K.multi(U, O, u), de = 255 >>> 8 * Y - $;
    return X.fill(0, 0, Y - M - S - 2), X[Y - M - S - 2] = 1, u.copy(X, Y - M - S - 1), ae.copy(re, 0), J[Y - 1] = 188, p(K, X, re), X[0] &= de, J;
  }
  function C(K, O, $, u, S) {
    r(K && typeof K.id == "string"), r(Buffer.isBuffer(O)), r(Buffer.isBuffer($)), r(u >>> 0 === u), r(S >>> 0 === S);
    const M = K.size, Y = u + 7 >>> 3;
    if (O.length !== M || Y < M + S + 2 || $[Y - 1] !== 188)
      return !1;
    const J = $.slice(0, Y - M - 1), X = $.slice(Y - M - 1, Y - 1), re = 255 >>> 8 * Y - u;
    if ($[0] & ~re)
      return !1;
    if (p(K, J, X), J[0] &= re, S === 0) {
      S = -1;
      for (let ge = 0; ge < J.length; ge++)
        if (J[ge] !== 0) {
          if (J[ge] === 1) {
            S = J.length - (ge + 1);
            break;
          }
          return !1;
        }
      if (S === -1)
        return !1;
    } else {
      const ge = J.length - S - 1;
      for (let Be = 0; Be < ge; Be++)
        if (J[Be] !== 0)
          return !1;
      if (J[ge] !== 1)
        return !1;
    }
    const ae = J.slice(J.length - S);
    return K.multi(U, O, ae).equals(X);
  }
  return Sr.native = 0, Sr.SALT_LENGTH_AUTO = _, Sr.SALT_LENGTH_HASH = q, Sr.privateKeyGenerate = V, Sr.privateKeyGenerateAsync = T, Sr.privateKeyBits = ie, Sr.privateKeyVerify = N, Sr.privateKeyImport = G, Sr.privateKeyExport = F, Sr.publicKeyCreate = W, Sr.publicKeyBits = ce, Sr.publicKeyVerify = ne, Sr.publicKeyImport = xe, Sr.publicKeyExport = he, Sr.sign = me, Sr.verify = Ne, Sr.encrypt = Ze, Sr.decrypt = ht, Sr.signPSS = dt, Sr.verifyPSS = Se, Sr.encryptOAEP = Z, Sr.decryptOAEP = L, Sr.veil = oe, Sr.unveil = s, Sr;
}
var Br = {};
/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Pb;
function IB() {
  if (Pb)
    return Br;
  Pb = 1;
  const r = _e, e = Dt(), t = 2048, i = 65537, n = 512, c = 16384, o = 3, d = 2 ** 33 - 1;
  function l(G, F) {
    if (G == null && (G = t), F == null && (F = i), r(G >>> 0 === G), r(Number.isSafeInteger(F) && F >= 0), G < n || G > c)
      throw new RangeError(`"bits" ranges from ${n} to ${c}.`);
    if (F < o || F > d)
      throw new RangeError(`"exponent" ranges from ${o} to ${d}.`);
    if (F === 1 || !(F & 1))
      throw new RangeError('"exponent" must be odd.');
    return e.rsa_privkey_generate(G, F, e.entropy());
  }
  async function h(G, F) {
    if (G == null && (G = t), F == null && (F = i), r(G >>> 0 === G), r(Number.isSafeInteger(F) && F >= 0), G < n || G > c)
      throw new RangeError(`"bits" ranges from ${n} to ${c}.`);
    if (F < o || F > d)
      throw new RangeError(`"exponent" ranges from ${o} to ${d}.`);
    if (F === 1 || !(F & 1))
      throw new RangeError('"exponent" must be odd.');
    return e.rsa_privkey_generate_async(G, F, e.entropy());
  }
  function x(G) {
    return r(Buffer.isBuffer(G)), e.rsa_privkey_bits(G);
  }
  function b(G) {
    return r(Buffer.isBuffer(G)), e.rsa_privkey_verify(G);
  }
  function g(G) {
    r(G && typeof G == "object");
    const F = e.encode([
      G.n,
      G.e,
      G.d,
      G.p,
      G.q,
      G.dp,
      G.dq,
      G.qi
    ]);
    return e.rsa_privkey_import(F, e.entropy());
  }
  function w(G) {
    r(Buffer.isBuffer(G));
    const F = e.rsa_privkey_export(G), W = e.decode(F, 8);
    return {
      n: W[0],
      e: W[1],
      d: W[2],
      p: W[3],
      q: W[4],
      dp: W[5],
      dq: W[6],
      qi: W[7]
    };
  }
  function I(G) {
    return r(Buffer.isBuffer(G)), e.rsa_pubkey_create(G);
  }
  function B(G) {
    return r(Buffer.isBuffer(G)), e.rsa_pubkey_bits(G);
  }
  function y(G) {
    return r(Buffer.isBuffer(G)), e.rsa_pubkey_verify(G);
  }
  function A(G) {
    r(G && typeof G == "object");
    const F = e.encode([
      G.n,
      G.e
    ]);
    return e.rsa_pubkey_import(F);
  }
  function _(G) {
    r(Buffer.isBuffer(G));
    const F = e.rsa_pubkey_export(G), W = e.decode(F, 2);
    return {
      n: W[0],
      e: W[1]
    };
  }
  function q(G, F, W) {
    return G && typeof G.id == "string" && (G = G.id), G == null ? G = e.hashes.NONE : G = e.hashes[G], r((G | 0) === G), r(Buffer.isBuffer(F)), r(Buffer.isBuffer(W)), e.rsa_sign(G, F, W, e.entropy());
  }
  function U(G, F, W, ce) {
    return G && typeof G.id == "string" && (G = G.id), G == null ? G = e.hashes.NONE : G = e.hashes[G], r((G | 0) === G), r(Buffer.isBuffer(F)), r(Buffer.isBuffer(ce)), e.rsa_verify(G, F, W, ce);
  }
  function z(G, F) {
    return r(Buffer.isBuffer(G)), r(Buffer.isBuffer(F)), e.rsa_encrypt(G, F, e.entropy());
  }
  function E(G, F) {
    return r(Buffer.isBuffer(G)), r(Buffer.isBuffer(F)), e.rsa_decrypt(G, F, e.entropy());
  }
  function H(G, F, W, ce = -1) {
    return r(Buffer.isBuffer(F)), r(Buffer.isBuffer(W)), r((ce | 0) === ce), e.rsa_sign_pss(e.hash(G), F, W, ce, e.entropy());
  }
  function k(G, F, W, ce, ne = -1) {
    return r(Buffer.isBuffer(F)), r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), r((ne | 0) === ne), e.rsa_verify_pss(e.hash(G), F, W, ce, ne);
  }
  function V(G, F, W, ce) {
    return ce == null && (ce = e.NULL), r(Buffer.isBuffer(F)), r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), e.rsa_encrypt_oaep(e.hash(G), F, W, ce, e.entropy());
  }
  function T(G, F, W, ce) {
    return ce == null && (ce = e.NULL), r(Buffer.isBuffer(F)), r(Buffer.isBuffer(W)), r(Buffer.isBuffer(ce)), e.rsa_decrypt_oaep(e.hash(G), F, W, ce, e.entropy());
  }
  function ie(G, F, W) {
    return r(Buffer.isBuffer(G)), r(F >>> 0 === F), r(Buffer.isBuffer(W)), e.rsa_veil(G, F, W, e.entropy());
  }
  function N(G, F, W) {
    return r(Buffer.isBuffer(G)), r(F >>> 0 === F), r(Buffer.isBuffer(W)), e.rsa_unveil(G, F, W);
  }
  return Br.native = 2, Br.SALT_LENGTH_AUTO = 0, Br.SALT_LENGTH_HASH = -1, Br.privateKeyGenerate = l, Br.privateKeyGenerateAsync = h, Br.privateKeyBits = x, Br.privateKeyVerify = b, Br.privateKeyImport = g, Br.privateKeyExport = w, Br.publicKeyCreate = I, Br.publicKeyBits = B, Br.publicKeyVerify = y, Br.publicKeyImport = A, Br.publicKeyExport = _, Br.sign = q, Br.verify = U, Br.encrypt = z, Br.decrypt = E, Br.signPSS = H, Br.verifyPSS = k, Br.encryptOAEP = V, Br.decryptOAEP = T, Br.veil = ie, Br.unveil = N, Br;
}
/*!
 * rsa.js - RSA for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? g1.exports = EB() : g1.exports = IB();
var $7 = g1.exports, _l = {};
/*!
 * rsaies.js - rsaies for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const En = _e, In = $7, Rb = B0, H7 = Lf;
function AB(r, e, t, i = null, n = null) {
  En(r && typeof r.id == "string"), En(Buffer.isBuffer(e));
  const c = Rb.randomBytes(32);
  let o = In.encryptOAEP(r, c, t, n);
  i != null && (o = In.veil(o, i, t));
  const d = Rb.randomBytes(24), l = H7.seal(e, c, d);
  return Buffer.concat([o, d, l]);
}
function _B(r, e, t, i = null, n = null) {
  En(r && typeof r.id == "string"), En(Buffer.isBuffer(e)), En(Buffer.isBuffer(t)), i == null && (i = In.privateKeyBits(t)), En(i >>> 0 === i);
  const c = i + 7 >>> 3;
  if (e.length < c + 24)
    throw new Error("Invalid ciphertext.");
  const o = In.publicKeyCreate(t), d = In.unveil(e.slice(0, c), i, o), l = In.decryptOAEP(r, d, t, n), h = e.slice(c, c + 24), x = e.slice(c + 24);
  return H7.open(x, l, h);
}
_l.encrypt = AB;
_l.decrypt = _B;
var w1 = { exports: {} };
const MB = {
  width: 9,
  points: [
    [
      "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
      "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
    ],
    [
      "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
      "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
    ],
    [
      "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
      "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
    ],
    [
      "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
      "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
    ],
    [
      "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
      "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
    ],
    [
      "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
      "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
    ],
    [
      "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
      "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
    ],
    [
      "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
      "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
    ],
    [
      "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
      "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
    ],
    [
      "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
      "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
    ],
    [
      "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
      "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
    ],
    [
      "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
      "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
    ],
    [
      "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
      "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
    ],
    [
      "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
      "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
    ],
    [
      "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
      "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
    ],
    [
      "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
      "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
    ],
    [
      "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
      "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
    ],
    [
      "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
      "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
    ],
    [
      "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
      "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
    ],
    [
      "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
      "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
    ],
    [
      "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
      "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
    ],
    [
      "049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
      "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
    ],
    [
      "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
      "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
    ],
    [
      "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
      "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
    ],
    [
      "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
      "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
    ],
    [
      "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
      "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
    ],
    [
      "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
      "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
    ],
    [
      "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
      "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
    ],
    [
      "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
      "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
    ],
    [
      "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
      "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
    ],
    [
      "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
      "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
    ],
    [
      "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
      "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
    ],
    [
      "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
      "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
    ],
    [
      "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
      "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
    ],
    [
      "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
      "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
    ],
    [
      "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
      "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
    ],
    [
      "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
      "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
    ],
    [
      "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
      "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
    ],
    [
      "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
      "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
    ],
    [
      "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
      "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
    ],
    [
      "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
      "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
    ],
    [
      "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
      "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
    ],
    [
      "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
      "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
    ],
    [
      "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
      "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
    ],
    [
      "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
      "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
    ],
    [
      "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
      "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
    ],
    [
      "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
      "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
    ],
    [
      "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
      "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
    ],
    [
      "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
      "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
    ],
    [
      "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
      "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
    ],
    [
      "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
      "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
    ],
    [
      "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
      "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
    ],
    [
      "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
      "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
    ],
    [
      "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
      "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
    ],
    [
      "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
      "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
    ],
    [
      "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
      "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
    ],
    [
      "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
      "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
    ],
    [
      "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
      "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
    ],
    [
      "078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
      "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
    ],
    [
      "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
      "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
    ],
    [
      "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
      "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
    ],
    [
      "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
      "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
    ],
    [
      "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
      "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
    ],
    [
      "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
      "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
    ],
    [
      "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
      "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
    ],
    [
      "0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
      "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
    ],
    [
      "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
      "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
    ],
    [
      "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
      "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
    ],
    [
      "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
      "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
    ],
    [
      "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
      "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
    ],
    [
      "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
      "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
    ],
    [
      "04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
      "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
    ],
    [
      "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
      "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
    ],
    [
      "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
      "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
    ],
    [
      "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
      "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
    ],
    [
      "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
      "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
    ],
    [
      "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
      "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
    ],
    [
      "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
      "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
    ],
    [
      "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
      "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
    ],
    [
      "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
      "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
    ],
    [
      "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
      "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
    ],
    [
      "0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
      "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
    ],
    [
      "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
      "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
    ],
    [
      "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
      "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
    ],
    [
      "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
      "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
    ],
    [
      "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
      "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
    ],
    [
      "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
      "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
    ],
    [
      "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
      "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
    ],
    [
      "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
      "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
    ],
    [
      "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
      "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
    ],
    [
      "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
      "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
    ],
    [
      "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
      "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
    ],
    [
      "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
      "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
    ],
    [
      "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
      "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
    ],
    [
      "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
      "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
    ],
    [
      "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
      "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
    ],
    [
      "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
      "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
    ],
    [
      "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
      "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
    ],
    [
      "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
      "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
    ],
    [
      "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
      "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
    ],
    [
      "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
      "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
    ],
    [
      "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
      "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
    ],
    [
      "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
      "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
    ],
    [
      "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
      "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
    ],
    [
      "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
      "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
    ],
    [
      "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
      "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
    ],
    [
      "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
      "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
    ],
    [
      "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
      "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
    ],
    [
      "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
      "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
    ],
    [
      "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
      "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
    ],
    [
      "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
      "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
    ],
    [
      "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
      "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
    ],
    [
      "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
      "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
    ],
    [
      "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
      "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
    ],
    [
      "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
      "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
    ],
    [
      "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
      "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
    ],
    [
      "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
      "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
    ],
    [
      "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
      "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
    ],
    [
      "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
      "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
    ],
    [
      "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
      "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
    ],
    [
      "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
      "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
    ],
    [
      "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
      "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
    ],
    [
      "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
      "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
    ],
    [
      "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
      "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
    ],
    [
      "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
      "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
    ],
    [
      "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
      "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
    ],
    [
      "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
      "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
    ]
  ]
}, NB = {
  step: 4,
  points: [
    [
      "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
      "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
    ],
    [
      "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
      "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
    ],
    [
      "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
      "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
    ],
    [
      "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
      "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
    ],
    [
      "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
      "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
    ],
    [
      "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
      "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
    ],
    [
      "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
      "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
    ],
    [
      "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
      "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
    ],
    [
      "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
      "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
    ],
    [
      "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
      "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
    ],
    [
      "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
      "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
    ],
    [
      "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
      "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
    ],
    [
      "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
      "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
    ],
    [
      "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
      "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
    ],
    [
      "06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
      "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
    ],
    [
      "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
      "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
    ],
    [
      "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
      "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
    ],
    [
      "0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
      "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
    ],
    [
      "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
      "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
    ],
    [
      "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
      "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
    ],
    [
      "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
      "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
    ],
    [
      "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
      "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
    ],
    [
      "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
      "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
    ],
    [
      "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
      "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
    ],
    [
      "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
      "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
    ],
    [
      "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
      "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
    ],
    [
      "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
      "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
    ],
    [
      "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
      "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
    ],
    [
      "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
      "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
    ],
    [
      "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
      "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
    ],
    [
      "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
      "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
    ],
    [
      "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
      "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
    ],
    [
      "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
      "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
    ],
    [
      "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
      "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
    ],
    [
      "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
      "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
    ],
    [
      "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
      "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
    ],
    [
      "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
      "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
    ],
    [
      "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
      "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
    ],
    [
      "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
      "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
    ],
    [
      "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
      "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
    ],
    [
      "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
      "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
    ],
    [
      "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
      "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
    ],
    [
      "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
      "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
    ],
    [
      "0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
      "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
    ],
    [
      "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
      "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
    ],
    [
      "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
      "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
    ],
    [
      "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
      "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
    ],
    [
      "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
      "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
    ],
    [
      "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
      "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
    ],
    [
      "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
      "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
    ],
    [
      "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
      "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
    ],
    [
      "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
      "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
    ],
    [
      "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
      "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
    ],
    [
      "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
      "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
    ],
    [
      "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
      "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
    ],
    [
      "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
      "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
    ],
    [
      "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
      "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
    ],
    [
      "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
      "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
    ],
    [
      "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
      "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
    ],
    [
      "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
      "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
    ],
    [
      "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
      "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
    ],
    [
      "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
      "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
    ],
    [
      "08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
      "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
    ],
    [
      "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
      "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
    ],
    [
      "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
      "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
    ]
  ]
}, F7 = {
  naf: MB,
  doubles: NB
};
/*!
 * schnorr.js - bip340 for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bips/bip-0340:
 *   Copyright (c) 2018-2020, Pieter Wuille (2-clause BSD License).
 *   https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py
 *
 * Parts of this software are based on bitcoin-core/secp256k1:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/bitcoin-core/secp256k1
 *
 * Resources:
 *   https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *   https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py
 *   https://github.com/bitcoin/bips/blob/master/bip-0340/test-vectors.csv
 *
 * References:
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 */
var ld, kb;
function OB() {
  if (kb)
    return ld;
  kb = 1;
  const r = _e, e = j1(), t = J0, i = B0, n = Ti, c = Io, o = So(), d = F7;
  class l {
    constructor(b, g, w) {
      r(typeof b == "string"), r(g), this.id = b, this.type = "schnorr", this.hash = g, this.native = 0, this._pre = w || null, this._curve = null, this._rng = null, this._auxTag = null, this._nonceTag = null, this._challengeTag = null;
    }
    get curve() {
      return this._curve || (this._curve = o.curve(this.id, this._pre), this._curve.precompute(i), this._pre = null), this._curve;
    }
    get rng() {
      return this._rng || (this._rng = new e(this.curve)), this._rng;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    hashInt(...b) {
      const g = new this.hash();
      g.init();
      for (const B of b)
        g.update(B);
      let w = g.final(this.curve.scalarSize);
      w.length > this.curve.scalarSize && (w = w.slice(0, this.curve.scalarSize));
      const I = t.decode(w, this.curve.endian);
      return I.iumaskn(this.curve.scalarBits), I.imod(this.curve.n);
    }
    hashAux(b, g) {
      r(Buffer.isBuffer(b)), r(Buffer.isBuffer(g)), r(b.length === this.curve.scalarSize), r(g.length === 32), this._auxTag || (this._auxTag = h(this.hash, "BIP0340/aux"));
      const w = new this.hash();
      w.init(), w.update(this._auxTag), w.update(g);
      const I = w.final(this.curve.scalarSize), B = Buffer.alloc(this.curve.scalarSize);
      for (let y = 0; y < this.curve.scalarSize; y++)
        B[y] = b[y] ^ I[y];
      return B;
    }
    hashNonce(b, g, w, I) {
      return this._nonceTag || (this._nonceTag = h(this.hash, "BIP0340/nonce")), I == null ? this.hashInt(this._nonceTag, b, g, w) : this.hashInt(this._nonceTag, this.hashAux(b, I), g, w);
    }
    hashChallenge(b, g, w) {
      return this._challengeTag || (this._challengeTag = h(this.hash, "BIP0340/challenge")), this.hashInt(this._challengeTag, b, g, w);
    }
    privateKeyGenerate() {
      const b = this.curve.randomScalar(i);
      return this.curve.encodeScalar(b);
    }
    privateKeyVerify(b) {
      r(Buffer.isBuffer(b));
      let g;
      try {
        g = this.curve.decodeScalar(b);
      } catch {
        return !1;
      }
      return !g.isZero() && g.cmp(this.curve.n) < 0;
    }
    privateKeyExport(b) {
      const g = this.curve.decodeScalar(b);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      let w = this.curve.g.mul(g);
      return w.isEven() || (g.ineg().imod(this.curve.n), w = w.neg()), {
        d: this.curve.encodeScalar(g),
        x: this.curve.encodeField(w.x.fromRed()),
        y: this.curve.encodeField(w.y.fromRed())
      };
    }
    privateKeyImport(b) {
      r(b && typeof b == "object");
      const g = t.decode(b.d, this.curve.endian);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(g);
    }
    privateKeyTweakAdd(b, g) {
      const w = this.curve.decodeScalar(g);
      if (w.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const I = this.curve.decodeScalar(b);
      if (I.isZero() || I.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      this.curve.g.mul(I).isEven() || I.ineg().imod(this.curve.n);
      const y = I.add(w).imod(this.curve.n);
      if (y.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(y);
    }
    privateKeyTweakMul(b, g) {
      const w = this.curve.decodeScalar(g);
      if (w.isZero() || w.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const I = this.curve.decodeScalar(b);
      if (I.isZero() || I.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const B = I.mul(w).imod(this.curve.n);
      if (B.isZero())
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(B);
    }
    privateKeyInvert(b) {
      const g = this.curve.decodeScalar(b);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      const w = g.invert(this.curve.n);
      return this.curve.encodeScalar(w);
    }
    publicKeyCreate(b) {
      const g = this.curve.decodeScalar(b);
      if (g.isZero() || g.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return this.curve.g.mulBlind(g).encodeX();
    }
    publicKeyFromUniform(b) {
      const g = this.curve.decodeUniform(b);
      return this.curve.pointFromUniform(g).encodeX();
    }
    publicKeyToUniform(b, g = i.randomInt()) {
      const w = this.curve.decodeEven(b), I = this.curve.pointToUniform(w, g);
      return this.curve.encodeUniform(I, g >>> 8);
    }
    publicKeyFromHash(b) {
      return this.curve.pointFromHash(b).encodeX();
    }
    publicKeyToHash(b) {
      const g = this.curve.decodeEven(b);
      return this.curve.pointToHash(g, 0, i);
    }
    publicKeyVerify(b) {
      r(Buffer.isBuffer(b));
      try {
        this.curve.decodeEven(b);
      } catch {
        return !1;
      }
      return !0;
    }
    publicKeyExport(b) {
      const { x: g, y: w } = this.curve.decodeEven(b);
      return {
        x: this.curve.encodeField(g.fromRed()),
        y: this.curve.encodeField(w.fromRed())
      };
    }
    publicKeyImport(b) {
      r(b && typeof b == "object");
      const g = t.decode(b.x, this.curve.endian);
      if (g.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (b.y != null) {
        const I = t.decode(b.y, this.curve.endian);
        if (I.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const B = this.curve.point(g, I);
        if (!B.validate())
          throw new Error("Invalid point.");
        return B.encodeX();
      }
      return this.curve.pointFromX(g).encodeX();
    }
    publicKeyTweakAdd(b, g) {
      const w = this.curve.decodeScalar(g);
      if (w.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const I = this.curve.decodeEven(b);
      return this.curve.g.jmul(w).add(I).encodeX();
    }
    publicKeyTweakMul(b, g) {
      const w = this.curve.decodeScalar(g);
      if (w.isZero() || w.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      return this.curve.decodeEven(b).mul(w).encodeX();
    }
    publicKeyTweakSum(b, g) {
      const w = this.curve.decodeScalar(g);
      if (w.cmp(this.curve.n) >= 0)
        throw new Error("Invalid scalar.");
      const I = this.curve.decodeEven(b), y = this.curve.g.jmul(w).add(I);
      return [y.encodeX(), y.isOdd()];
    }
    publicKeyTweakCheck(b, g, w, I) {
      r(Buffer.isBuffer(b)), r(Buffer.isBuffer(g)), r(Buffer.isBuffer(w)), r(typeof I == "boolean");
      let B, y;
      try {
        [B, y] = this.publicKeyTweakSum(b, g);
      } catch {
        return !1;
      }
      return B.equals(w) && y === I;
    }
    publicKeyCombine(b) {
      r(Array.isArray(b));
      let g = this.curve.jpoint();
      for (const w of b) {
        const I = this.curve.decodeEven(w);
        g = g.add(I);
      }
      return g.encodeX();
    }
    sign(b, g, w = i.randomBytes(32)) {
      return r(Buffer.isBuffer(b)), w != null && (r(Buffer.isBuffer(w)), r(w.length === 32)), this._sign(b, g, w);
    }
    _sign(b, g, w) {
      const { n: I } = this.curve, B = this.curve.g, y = this.curve.decodeScalar(g);
      if (y.isZero() || y.cmp(I) >= 0)
        throw new Error("Invalid private key.");
      const A = B.mulBlind(y);
      A.isEven() || y.ineg().imod(I);
      const _ = this.curve.encodeScalar(y), q = A.encodeX(), U = this.hashNonce(_, q, b, w);
      if (U.isZero())
        throw new Error("Signing failed (k' = 0).");
      const z = B.mulBlind(U);
      z.isEven() || U.ineg().imod(I);
      const E = z.encodeX(), H = this.hashChallenge(E, q, b), k = U.add(H.mul(y)).imod(I);
      return Buffer.concat([E, this.curve.encodeScalar(k)]);
    }
    verify(b, g, w) {
      if (r(Buffer.isBuffer(b)), r(Buffer.isBuffer(g)), r(Buffer.isBuffer(w)), g.length !== this.curve.fieldSize + this.curve.scalarSize || w.length !== this.curve.fieldSize)
        return !1;
      try {
        return this._verify(b, g, w);
      } catch {
        return !1;
      }
    }
    _verify(b, g, w) {
      const { p: I, n: B } = this.curve, y = this.curve.g, A = g.slice(0, this.curve.fieldSize), _ = g.slice(this.curve.fieldSize), q = this.curve.decodeField(A), U = this.curve.decodeScalar(_), z = this.curve.decodeEven(w);
      if (q.cmp(I) >= 0 || U.cmp(B) >= 0)
        return !1;
      const E = this.hashChallenge(A, w, b), H = y.mulAdd(U, z, E.ineg().imod(B));
      return !(!H.isEven() || !H.eqX(q));
    }
    verifyBatch(b) {
      r(Array.isArray(b));
      for (const g of b) {
        r(Array.isArray(g) && g.length === 3);
        const [w, I, B] = g;
        if (r(Buffer.isBuffer(w)), r(Buffer.isBuffer(I)), r(Buffer.isBuffer(B)), I.length !== this.curve.fieldSize + this.curve.scalarSize || B.length !== this.curve.fieldSize)
          return !1;
      }
      try {
        return this._verifyBatch(b);
      } catch {
        return !1;
      }
    }
    _verifyBatch(b) {
      const { n: g } = this.curve, w = this.curve.g, I = new Array(1 + b.length * 2), B = new Array(1 + b.length * 2), y = new t(0);
      this.rng.init(b), I[0] = w, B[0] = y;
      for (let A = 0; A < b.length; A++) {
        const [_, q, U] = b[A], z = q.slice(0, this.curve.fieldSize), E = q.slice(this.curve.fieldSize), H = this.curve.decodeEven(z), k = this.curve.decodeScalar(E), V = this.curve.decodeEven(U);
        if (k.cmp(g) >= 0)
          return !1;
        const T = this.hashChallenge(z, U, _), ie = this.rng.generate(A), N = T.mul(ie).imod(g);
        y.iadd(k.mul(ie)).imod(g), I[1 + A * 2 + 0] = H, B[1 + A * 2 + 0] = ie, I[1 + A * 2 + 1] = V, B[1 + A * 2 + 1] = N;
      }
      return y.ineg().imod(g), this.curve.jmulAll(I, B).isInfinity();
    }
    derive(b, g) {
      const w = this.curve.decodeEven(b), I = this.curve.decodeScalar(g);
      if (I.isZero() || I.cmp(this.curve.n) >= 0)
        throw new Error("Invalid private key.");
      return w.mulConst(I, i).encodeX();
    }
  }
  function h(x, b) {
    const g = Buffer.from(b, "binary");
    let w;
    return x.size !== x.blockSize / 2 ? w = c.digest(g, x.blockSize / 2) : w = x.digest(g), Buffer.concat([w, w]);
  }
  return ld = new l("SECP256K1", n, d), ld;
}
var pc = { exports: {} }, fr = {};
/*!
 * schnorr-libsecp256k1.js - schnorr for bcrypto (libsecp256k1)
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var qb;
function PB() {
  if (qb)
    return fr;
  qb = 1;
  const r = _e, e = Dt(), t = e.secp256k1;
  function i() {
    return e.secp256k1_seckey_generate(t(), e.entropy());
  }
  function n(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_seckey_verify(t(), N);
  }
  function c(N) {
    r(Buffer.isBuffer(N));
    const [G, F, W] = e.secp256k1_xonly_seckey_export(t(), N);
    return { d: G, x: F, y: W };
  }
  function o(N) {
    return r(N && typeof N == "object"), r(Buffer.isBuffer(N.d)), e.secp256k1_seckey_import(t(), N.d);
  }
  function d(N, G) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), e.secp256k1_xonly_seckey_tweak_add(t(), N, G);
  }
  function l(N, G) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), e.secp256k1_seckey_tweak_mul(t(), N, G);
  }
  function h(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_seckey_negate(t(), N);
  }
  function x(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_seckey_invert(t(), N);
  }
  function b(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_xonly_create(t(), N);
  }
  function g(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_xonly_from_uniform(t(), N);
  }
  function w(N, G = e.hint()) {
    return r(Buffer.isBuffer(N)), r(G >>> 0 === G), e.secp256k1_xonly_to_uniform(t(), N, G);
  }
  function I(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_xonly_from_hash(t(), N);
  }
  function B(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_xonly_to_hash(t(), N, e.entropy());
  }
  function y(N) {
    return r(Buffer.isBuffer(N)), e.secp256k1_xonly_verify(t(), N);
  }
  function A(N) {
    r(Buffer.isBuffer(N));
    const [G, F] = e.secp256k1_xonly_export(t(), N);
    return { x: G, y: F };
  }
  function _(N) {
    r(N && typeof N == "object");
    let { x: G, y: F } = N;
    return G == null && (G = e.NULL), F == null && (F = e.NULL), r(Buffer.isBuffer(G)), r(Buffer.isBuffer(F)), e.secp256k1_xonly_import(t(), G, F);
  }
  function q(N, G) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), e.secp256k1_xonly_tweak_add(t(), N, G);
  }
  function U(N, G) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), e.secp256k1_xonly_tweak_mul(t(), N, G);
  }
  function z(N, G) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), e.secp256k1_xonly_tweak_sum(t(), N, G);
  }
  function E(N, G, F, W) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(Buffer.isBuffer(F)), r(typeof W == "boolean"), e.secp256k1_xonly_tweak_check(t(), N, G, F, W);
  }
  function H(N) {
    r(Array.isArray(N));
    for (const G of N)
      r(Buffer.isBuffer(G));
    return e.secp256k1_xonly_combine(t(), N);
  }
  function k(N, G, F = e.entropy(32)) {
    return F == null && (F = e.NULL), r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(Buffer.isBuffer(F)), e.secp256k1_schnorr_sign(t(), N, G, F);
  }
  function V(N, G, F) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), r(Buffer.isBuffer(F)), e.secp256k1_schnorr_verify(t(), N, G, F);
  }
  function T(N) {
    r(Array.isArray(N));
    for (const G of N)
      r(Array.isArray(G)), r(G.length === 3), r(Buffer.isBuffer(G[0])), r(Buffer.isBuffer(G[1])), r(Buffer.isBuffer(G[2]));
    return e.secp256k1_schnorr_verify_batch(t(), N);
  }
  function ie(N, G) {
    return r(Buffer.isBuffer(N)), r(Buffer.isBuffer(G)), e.secp256k1_xonly_derive(t(), N, G);
  }
  return fr.id = "SECP256K1", fr.type = "schnorr", fr.size = 32, fr.bits = 256, fr.native = 2, fr.privateKeyGenerate = i, fr.privateKeyVerify = n, fr.privateKeyExport = c, fr.privateKeyImport = o, fr.privateKeyTweakAdd = d, fr.privateKeyTweakMul = l, fr.privateKeyNegate = h, fr.privateKeyInvert = x, fr.publicKeyCreate = b, fr.publicKeyFromUniform = g, fr.publicKeyToUniform = w, fr.publicKeyFromHash = I, fr.publicKeyToHash = B, fr.publicKeyVerify = y, fr.publicKeyExport = A, fr.publicKeyImport = _, fr.publicKeyTweakAdd = q, fr.publicKeyTweakMul = U, fr.publicKeyTweakSum = z, fr.publicKeyTweakCheck = E, fr.publicKeyCombine = H, fr.sign = k, fr.verify = V, fr.verifyBatch = T, fr.derive = ie, fr;
}
/*!
 * schnorr-torsion.js - schnorr for bcrypto (libtorsion)
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var xd, zb;
function RB() {
  if (zb)
    return xd;
  zb = 1;
  const r = _e, e = Dt();
  class t {
    constructor(n) {
      r(e.curves.wei[n] != null), this.id = n, this.type = "schnorr", this.native = 2, this._ctx = null;
    }
    get _handle() {
      return this._ctx || (this._ctx = e.curve("wei", this.id)), this._ctx;
    }
    get size() {
      return r(this instanceof t), e.wei_curve_field_size(this._handle);
    }
    get bits() {
      return r(this instanceof t), e.wei_curve_field_bits(this._handle);
    }
    privateKeyGenerate() {
      return r(this instanceof t), e.schnorr_privkey_generate(this._handle, e.entropy());
    }
    privateKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_privkey_verify(this._handle, n);
    }
    privateKeyExport(n) {
      r(this instanceof t), r(Buffer.isBuffer(n));
      const [c, o, d] = e.schnorr_privkey_export(this._handle, n);
      return { d: c, x: o, y: d };
    }
    privateKeyImport(n) {
      return r(this instanceof t), r(n && typeof n == "object"), r(Buffer.isBuffer(n.d)), e.schnorr_privkey_import(this._handle, n.d);
    }
    privateKeyTweakAdd(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_privkey_tweak_add(this._handle, n, c);
    }
    privateKeyTweakMul(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_privkey_tweak_mul(this._handle, n, c);
    }
    privateKeyInvert(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_privkey_invert(this._handle, n);
    }
    publicKeyCreate(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_pubkey_create(this._handle, n);
    }
    publicKeyFromUniform(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_pubkey_from_uniform(this._handle, n);
    }
    publicKeyToUniform(n, c = e.hint()) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(c >>> 0 === c), e.schnorr_pubkey_to_uniform(this._handle, n, c);
    }
    publicKeyFromHash(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_pubkey_from_hash(this._handle, n);
    }
    publicKeyToHash(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_pubkey_to_hash(this._handle, n, e.entropy());
    }
    publicKeyVerify(n) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), e.schnorr_pubkey_verify(this._handle, n);
    }
    publicKeyExport(n) {
      r(this instanceof t), r(Buffer.isBuffer(n));
      const [c, o] = e.schnorr_pubkey_export(this._handle, n);
      return { x: c, y: o };
    }
    publicKeyImport(n) {
      r(this instanceof t), r(n && typeof n == "object");
      let { x: c, y: o } = n;
      return c == null && (c = e.NULL), o == null && (o = e.NULL), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.schnorr_pubkey_import(this._handle, c, o);
    }
    publicKeyTweakAdd(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_pubkey_tweak_add(this._handle, n, c);
    }
    publicKeyTweakMul(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_pubkey_tweak_mul(this._handle, n, c);
    }
    publicKeyTweakSum(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_pubkey_tweak_sum(this._handle, n, c);
    }
    publicKeyTweakCheck(n, c, o, d) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), r(typeof d == "boolean"), e.schnorr_pubkey_tweak_check(this._handle, n, c, o, d);
    }
    publicKeyCombine(n) {
      r(this instanceof t), r(Array.isArray(n));
      for (const c of n)
        r(Buffer.isBuffer(c));
      return e.schnorr_pubkey_combine(this._handle, n);
    }
    sign(n, c, o = e.entropy(32)) {
      return o == null && (o = e.NULL), r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.schnorr_sign(this._handle, n, c, o);
    }
    verify(n, c, o) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(Buffer.isBuffer(o)), e.schnorr_verify(this._handle, n, c, o);
    }
    verifyBatch(n) {
      r(this instanceof t), r(Array.isArray(n));
      for (const c of n)
        r(Array.isArray(c)), r(c.length === 3), r(Buffer.isBuffer(c[0])), r(Buffer.isBuffer(c[1])), r(Buffer.isBuffer(c[2]));
      return e.schnorr_verify_batch(this._handle, n);
    }
    derive(n, c) {
      return r(this instanceof t), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), e.schnorr_derive(this._handle, n, c);
    }
  }
  return xd = new t("SECP256K1"), xd;
}
/*!
 * schnorr.js - schnorr for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Ub;
function kB() {
  return Ub || (Ub = 1, Dt().USE_SECP256K1 && process.env.BCRYPTO_FORCE_TORSION !== "1" ? pc.exports = PB() : pc.exports = RB()), pc.exports;
}
/*!
 * schnorr.js - schnorr for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? w1.exports = OB() : w1.exports = kB();
var qB = w1.exports, y1 = { exports: {} }, lf = {};
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.
 *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.
 *   Copyright (c) 2014, Sean Kelly. All rights reserved.
 *   https://github.com/Tarsnap/scrypt
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Scrypt
 *   http://www.tarsnap.com/scrypt.html
 *   http://www.tarsnap.com/scrypt/scrypt.pdf
 *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 */
var Cb;
function zB() {
  if (Cb)
    return lf;
  Cb = 1;
  const r = _e, e = v7, t = Ti, i = Buffer.alloc(64), n = new Uint32Array(16), c = new Uint32Array(16);
  function o(U, z, E, H, k, V) {
    if (typeof U == "string" && (U = Buffer.from(U, "utf8")), typeof z == "string" && (z = Buffer.from(z, "utf8")), z == null && (z = Buffer.alloc(0)), r(Buffer.isBuffer(U)), r(Buffer.isBuffer(z)), r(E >>> 0 === E), r(H >>> 0 === H), r(k >>> 0 === k), r(V >>> 0 === V), H * k >= 1 << 30)
      throw new Error("EFBIG");
    if (E & E - 1 || E === 0)
      throw new Error("EINVAL");
    if (E > 4294967295)
      throw new Error("EINVAL");
    const T = Buffer.alloc(256 * H), ie = Buffer.alloc(128 * H * E), N = e.derive(t, U, z, 1, k * 128 * H);
    for (let G = 0; G < k; G++)
      g(N, G * 128 * H, H, E, ie, T);
    return A(), e.derive(t, U, N, 1, V);
  }
  async function d(U, z, E, H, k, V) {
    if (typeof U == "string" && (U = Buffer.from(U, "utf8")), typeof z == "string" && (z = Buffer.from(z, "utf8")), z == null && (z = Buffer.alloc(0)), r(Buffer.isBuffer(U)), r(Buffer.isBuffer(z)), r(E >>> 0 === E), r(H >>> 0 === H), r(k >>> 0 === k), r(V >>> 0 === V), H * k >= 1 << 30)
      throw new Error("EFBIG");
    if (E & E - 1 || E === 0)
      throw new Error("EINVAL");
    if (E > 4294967295)
      throw new Error("EINVAL");
    const T = Buffer.alloc(256 * H), ie = Buffer.alloc(128 * H * E), N = await e.deriveAsync(t, U, z, 1, k * 128 * H);
    for (let G = 0; G < k; G++)
      await w(N, G * 128 * H, H, E, ie, T);
    return A(), e.deriveAsync(t, U, N, 1, V);
  }
  function l(U) {
    const z = n, E = c;
    for (let H = 0; H < 16; H++)
      z[H] = _(U, H * 4);
    for (let H = 0; H < 16; H++)
      E[H] = z[H];
    for (let H = 0; H < 8; H += 2)
      E[4] ^= h(E[0] + E[12], 7), E[8] ^= h(E[4] + E[0], 9), E[12] ^= h(E[8] + E[4], 13), E[0] ^= h(E[12] + E[8], 18), E[9] ^= h(E[5] + E[1], 7), E[13] ^= h(E[9] + E[5], 9), E[1] ^= h(E[13] + E[9], 13), E[5] ^= h(E[1] + E[13], 18), E[14] ^= h(E[10] + E[6], 7), E[2] ^= h(E[14] + E[10], 9), E[6] ^= h(E[2] + E[14], 13), E[10] ^= h(E[6] + E[2], 18), E[3] ^= h(E[15] + E[11], 7), E[7] ^= h(E[3] + E[15], 9), E[11] ^= h(E[7] + E[3], 13), E[15] ^= h(E[11] + E[7], 18), E[1] ^= h(E[0] + E[3], 7), E[2] ^= h(E[1] + E[0], 9), E[3] ^= h(E[2] + E[1], 13), E[0] ^= h(E[3] + E[2], 18), E[6] ^= h(E[5] + E[4], 7), E[7] ^= h(E[6] + E[5], 9), E[4] ^= h(E[7] + E[6], 13), E[5] ^= h(E[4] + E[7], 18), E[11] ^= h(E[10] + E[9], 7), E[8] ^= h(E[11] + E[10], 9), E[9] ^= h(E[8] + E[11], 13), E[10] ^= h(E[9] + E[8], 18), E[12] ^= h(E[15] + E[14], 7), E[13] ^= h(E[12] + E[15], 9), E[14] ^= h(E[13] + E[12], 13), E[15] ^= h(E[14] + E[13], 18);
    for (let H = 0; H < 16; H++)
      z[H] += E[H];
    for (let H = 0; H < 16; H++)
      q(U, z[H], 4 * H);
  }
  function h(U, z) {
    return U << z | U >>> 32 - z;
  }
  function x(U, z, E, H) {
    const k = i;
    I(k, U, 0, (2 * H - 1) * 64, 64);
    for (let V = 0; V < 2 * H; V++)
      B(k, U, 0, V * 64, 64), l(k), I(z, k, E + V * 64, 0, 64);
    for (let V = 0; V < H; V++)
      I(U, z, V * 64, E + V * 2 * 64, 64);
    for (let V = 0; V < H; V++)
      I(U, z, (V + H) * 64, E + (V * 2 + 1) * 64, 64);
  }
  function b(U, z) {
    return _(U, (2 * z - 1) * 64);
  }
  function g(U, z, E, H, k, V) {
    const T = V, ie = V;
    I(T, U, 0, z, 128 * E);
    for (let N = 0; N < H; N++)
      I(k, T, N * (128 * E), 0, 128 * E), x(T, ie, 128 * E, E);
    for (let N = 0; N < H; N++) {
      const G = b(T, E) & H - 1;
      B(T, k, 0, G * (128 * E), 128 * E), x(T, ie, 128 * E, E);
    }
    I(U, T, z, 0, 128 * E);
  }
  async function w(U, z, E, H, k, V) {
    const T = V, ie = V;
    I(T, U, 0, z, 128 * E);
    for (let N = 0; N < H; N++)
      I(k, T, N * (128 * E), 0, 128 * E), x(T, ie, 128 * E, E), await y();
    for (let N = 0; N < H; N++) {
      const G = b(T, E) & H - 1;
      B(T, k, 0, G * (128 * E), 128 * E), x(T, ie, 128 * E, E), await y();
    }
    I(U, T, z, 0, 128 * E);
  }
  function I(U, z, E, H, k) {
    z.copy(U, E, H, H + k);
  }
  function B(U, z, E, H, k) {
    for (let V = 0; V < k; V++)
      U[E + V] ^= z[H + V];
  }
  function y() {
    return new Promise((U) => setImmediate(U));
  }
  function A() {
    for (let U = 0; U < 64; U++)
      i[U] = 0;
    for (let U = 0; U < 16; U++)
      n[U] = 0, c[U] = 0;
  }
  function _(U, z) {
    return U[z++] + U[z++] * 256 + U[z++] * 65536 + U[z] * 16777216;
  }
  function q(U, z, E) {
    return U[E++] = z, z >>>= 8, U[E++] = z, z >>>= 8, U[E++] = z, z >>>= 8, U[E++] = z, E;
  }
  return lf.native = 0, lf.derive = o, lf.deriveAsync = d, lf;
}
var xf = {};
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Tb;
function UB() {
  if (Tb)
    return xf;
  Tb = 1;
  const r = _e, e = Dt();
  function t(n, c, o, d, l, h) {
    return typeof n == "string" && (n = Buffer.from(n, "utf8")), typeof c == "string" && (c = Buffer.from(c, "utf8")), c == null && (c = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(d >>> 0 === d), r(l >>> 0 === l), r(h >>> 0 === h), e.scrypt_derive(n, c, o, d, l, h);
  }
  async function i(n, c, o, d, l, h) {
    return typeof n == "string" && (n = Buffer.from(n, "utf8")), typeof c == "string" && (c = Buffer.from(c, "utf8")), c == null && (c = e.NULL), r(Buffer.isBuffer(n)), r(Buffer.isBuffer(c)), r(o >>> 0 === o), r(d >>> 0 === d), r(l >>> 0 === l), r(h >>> 0 === h), e.scrypt_derive_async(n, c, o, d, l, h);
  }
  return xf.native = 2, xf.derive = t, xf.deriveAsync = i, xf;
}
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? y1.exports = zB() : y1.exports = UB();
var CB = y1.exports, S1 = { exports: {} };
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var bd, Db;
function TB() {
  if (Db)
    return bd;
  Db = 1;
  const r = Hn(), e = Ti, t = F7;
  return bd = new r("SECP256K1", e, e, t), bd;
}
var mc = { exports: {} }, yt = {};
/*!
 * secp256k1-libsecp256k1.js - secp256k1 for bcrypto (libsecp256k1)
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Lb;
function DB() {
  if (Lb)
    return yt;
  Lb = 1;
  const r = _e, e = Dt(), t = e.secp256k1;
  function i() {
    return e.secp256k1_seckey_generate(t(), e.entropy());
  }
  function n(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_seckey_verify(t(), Se);
  }
  function c(Se) {
    r(Buffer.isBuffer(Se));
    const we = e.secp256k1_pubkey_create(t(), Se, !1), [Z, L] = e.secp256k1_pubkey_export(t(), we);
    return {
      d: e.copy(Se),
      x: Z,
      y: L
    };
  }
  function o(Se) {
    return r(Se && typeof Se == "object"), r(Buffer.isBuffer(Se.d)), e.secp256k1_seckey_import(t(), Se.d);
  }
  function d(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_seckey_tweak_add(t(), Se, we);
  }
  function l(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_seckey_tweak_mul(t(), Se, we);
  }
  function h(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_seckey_negate(t(), Se);
  }
  function x(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_seckey_invert(t(), Se);
  }
  function b(Se, we = !0) {
    return r(Buffer.isBuffer(Se)), r(typeof we == "boolean"), e.secp256k1_pubkey_create(t(), Se, we);
  }
  function g(Se, we = !0) {
    return r(Buffer.isBuffer(Se)), r(typeof we == "boolean"), e.secp256k1_pubkey_convert(t(), Se, we);
  }
  function w(Se, we = !0) {
    return r(Buffer.isBuffer(Se)), r(typeof we == "boolean"), e.secp256k1_pubkey_from_uniform(t(), Se, we);
  }
  function I(Se, we = e.hint()) {
    return r(Buffer.isBuffer(Se)), r(we >>> 0 === we), e.secp256k1_pubkey_to_uniform(t(), Se, we);
  }
  function B(Se, we = !0) {
    return r(Buffer.isBuffer(Se)), r(typeof we == "boolean"), e.secp256k1_pubkey_from_hash(t(), Se, we);
  }
  function y(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_pubkey_to_hash(t(), Se, e.entropy());
  }
  function A(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_pubkey_verify(t(), Se);
  }
  function _(Se) {
    r(Buffer.isBuffer(Se));
    const [we, Z] = e.secp256k1_pubkey_export(t(), Se);
    return { x: we, y: Z };
  }
  function q(Se, we = !0) {
    r(Se && typeof Se == "object"), r(typeof we == "boolean");
    let { x: Z, y: L, sign: oe } = Se;
    return Z == null && (Z = e.NULL), L == null && (L = e.NULL), oe = e.ternary(oe), r(Buffer.isBuffer(Z)), r(Buffer.isBuffer(L)), e.secp256k1_pubkey_import(t(), Z, L, oe, we);
  }
  function U(Se, we, Z = !0) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(typeof Z == "boolean"), e.secp256k1_pubkey_tweak_add(t(), Se, we, Z);
  }
  function z(Se, we, Z = !0) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(typeof Z == "boolean"), e.secp256k1_pubkey_tweak_mul(t(), Se, we, Z);
  }
  function E(Se, we = !0) {
    r(Array.isArray(Se)), r(typeof we == "boolean");
    for (const Z of Se)
      r(Buffer.isBuffer(Z));
    return e.secp256k1_pubkey_combine(t(), Se, we);
  }
  function H(Se, we = !0) {
    return r(Buffer.isBuffer(Se)), r(typeof we == "boolean"), e.secp256k1_pubkey_negate(t(), Se, we);
  }
  function k(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_signature_normalize(t(), Se);
  }
  function V(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_signature_normalize_der(t(), Se);
  }
  function T(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_signature_export(t(), Se);
  }
  function ie(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_signature_import(t(), Se);
  }
  function N(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_is_low_s(t(), Se);
  }
  function G(Se) {
    return r(Buffer.isBuffer(Se)), e.secp256k1_is_low_der(t(), Se);
  }
  function F(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_sign(t(), Se, we);
  }
  function W(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_sign_recoverable(t(), Se, we);
  }
  function ce(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_sign_der(t(), Se, we);
  }
  function ne(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_sign_recoverable_der(t(), Se, we);
  }
  function xe(Se, we, Z) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(Buffer.isBuffer(Z)), e.secp256k1_verify(t(), Se, we, Z);
  }
  function he(Se, we, Z) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(Buffer.isBuffer(Z)), e.secp256k1_verify_der(t(), Se, we, Z);
  }
  function me(Se, we, Z, L = !0) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(Z >>> 0 === Z), r(typeof L == "boolean"), e.secp256k1_recover(t(), Se, we, Z, L);
  }
  function Ne(Se, we, Z, L = !0) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(Z >>> 0 === Z), r(typeof L == "boolean"), e.secp256k1_recover_der(t(), Se, we, Z, L);
  }
  function Je(Se, we, Z = !0) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(typeof Z == "boolean"), e.secp256k1_derive(t(), Se, we, Z);
  }
  function Ze(Se, we) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), e.secp256k1_schnorr_legacy_sign(t(), Se, we);
  }
  function ht(Se, we, Z) {
    return r(Buffer.isBuffer(Se)), r(Buffer.isBuffer(we)), r(Buffer.isBuffer(Z)), e.secp256k1_schnorr_legacy_verify(t(), Se, we, Z);
  }
  function dt(Se) {
    r(Array.isArray(Se));
    for (const we of Se)
      r(Array.isArray(we)), r(we.length === 3), r(Buffer.isBuffer(we[0])), r(Buffer.isBuffer(we[1])), r(Buffer.isBuffer(we[2]));
    return e.secp256k1_schnorr_legacy_verify_batch(t(), Se);
  }
  return yt.id = "SECP256K1", yt.type = "ecdsa", yt.size = 32, yt.bits = 256, yt.native = 2, yt.privateKeyGenerate = i, yt.privateKeyVerify = n, yt.privateKeyExport = c, yt.privateKeyImport = o, yt.privateKeyTweakAdd = d, yt.privateKeyTweakMul = l, yt.privateKeyNegate = h, yt.privateKeyInvert = x, yt.publicKeyCreate = b, yt.publicKeyConvert = g, yt.publicKeyFromUniform = w, yt.publicKeyToUniform = I, yt.publicKeyFromHash = B, yt.publicKeyToHash = y, yt.publicKeyVerify = A, yt.publicKeyExport = _, yt.publicKeyImport = q, yt.publicKeyTweakAdd = U, yt.publicKeyTweakMul = z, yt.publicKeyCombine = E, yt.publicKeyNegate = H, yt.signatureNormalize = k, yt.signatureNormalizeDER = V, yt.signatureExport = T, yt.signatureImport = ie, yt.isLowS = N, yt.isLowDER = G, yt.sign = F, yt.signRecoverable = W, yt.signDER = ce, yt.signRecoverableDER = ne, yt.verify = xe, yt.verifyDER = he, yt.recover = me, yt.recoverDER = Ne, yt.derive = Je, yt.schnorrSign = Ze, yt.schnorrVerify = ht, yt.schnorrVerifyBatch = dt, yt;
}
/*!
 * secp256k1-torsion.js - secp256k1 for bcrypto (libtorsion)
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var pd, Kb;
function LB() {
  if (Kb)
    return pd;
  Kb = 1;
  const r = Fn();
  return pd = new r("SECP256K1"), pd;
}
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var $b;
function KB() {
  return $b || ($b = 1, Dt().USE_SECP256K1 && process.env.BCRYPTO_FORCE_TORSION !== "1" ? mc.exports = DB() : mc.exports = LB()), mc.exports;
}
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? S1.exports = TB() : S1.exports = KB();
var $B = S1.exports, cn = {};
/*!
 * ssh.js - SSH keys for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/openssh/openssh-portable/blob/master/cipher.c
 *   https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key
 */
const An = _e, Qs = Pe, Hb = Fo, { padLeft: Fc, padRight: HB } = ti, FB = l8, V7 = Bo, VB = B0, Fb = Yf, { PEMBlock: Vb } = Yr, Gb = Go, Yb = Yo, Jb = Zo, Xb = y7, Zb = S7, Wb = B7, GB = $8, md = J0, ze = {
  DSA: "ssh-dss",
  RSA: "ssh-rsa",
  P256: "ecdsa-sha2-nistp256",
  P384: "ecdsa-sha2-nistp384",
  P521: "ecdsa-sha2-nistp521",
  ED25519: "ssh-ed25519"
}, G7 = {
  [ze.DSA]: "DSA",
  [ze.RSA]: "RSA",
  [ze.P256]: "P256",
  [ze.P384]: "P384",
  [ze.P521]: "P521",
  [ze.ED25519]: "ED25519"
}, en = {
  [ze.P256]: "nistp256",
  [ze.P384]: "nistp384",
  [ze.P521]: "nistp521"
}, jb = {
  "3des-cbc": ["DES-EDE3-CBC", 24, 8],
  "aes128-cbc": ["AES-128-CBC", 16, 16],
  "aes192-cbc": ["AES-192-CBC", 24, 16],
  "aes256-cbc": ["AES-256-CBC", 32, 16],
  "rijndael-cbc@lysator.liu.se": ["AES-256-CBC", 32, 16],
  "aes128-ctr": ["AES-128-CTR", 16, 16],
  "aes192-ctr": ["AES-192-CTR", 24, 16],
  "aes256-ctr": ["AES-256-CTR", 32, 16]
}, Qb = "openssh-key-v1", hr = Buffer.alloc(0), co = Buffer.alloc(32, 0);
class B1 extends Qs.Struct {
  constructor() {
    super(), this.type = ze.ED25519, this.p = hr, this.q = hr, this.g = hr, this.y = hr, this.n = hr, this.e = hr, this.point = co, this.comment = "";
  }
  getCurve() {
    if (!en.hasOwnProperty(this.type))
      throw new Error("No curve available.");
    return en[this.type];
  }
  getSize() {
    let e = 0;
    switch (e += Mf(this.type), this.type) {
      case ze.DSA: {
        e += _r(this.p), e += _r(this.q), e += _r(this.g), e += _r(this.y);
        break;
      }
      case ze.RSA: {
        e += _r(this.e), e += _r(this.n);
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        e += _r(this.getCurve()), e += _r(this.point);
        break;
      }
      case ze.ED25519: {
        e += _r(this.point);
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    return e;
  }
  write(e) {
    switch (Bs(e, this.type), this.type) {
      case ze.DSA: {
        Er(e, this.p), Er(e, this.q), Er(e, this.g), Er(e, this.y);
        break;
      }
      case ze.RSA: {
        Er(e, this.e), Er(e, this.n);
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        Bs(e, this.getCurve()), Er(e, this.point);
        break;
      }
      case ze.ED25519: {
        Er(e, this.point);
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    return e;
  }
  read(e) {
    switch (this.type = tn(e), this.type) {
      case ze.DSA: {
        this.p = vr(e), this.q = vr(e), this.g = vr(e), this.y = vr(e);
        break;
      }
      case ze.RSA: {
        this.e = vr(e), this.n = vr(e);
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        if (tn(e) !== this.getCurve())
          throw new Error("Invalid curve prefix.");
        this.point = vr(e);
        break;
      }
      case ze.ED25519: {
        this.point = vr(e);
        break;
      }
      default:
        throw new Error("Invalid key type.");
    }
    return this;
  }
  toString() {
    const e = this.encode();
    let t = this.comment;
    return t.length > 0 && (t = " " + t), `${this.type} ${Hb.encode(e)}${t}`;
  }
  fromString(e) {
    An(typeof e == "string");
    const t = e.split(" ", 3);
    if (t.length < 2)
      throw new Error("Invalid SSH key text.");
    const [i, n] = t;
    if (!G7.hasOwnProperty(i))
      throw new Error(`Unknown SSH public key type: ${i}.`);
    const c = Hb.decode(n);
    if (this.decode(c), this.type !== i)
      throw new Error("Key type mismatch.");
    return t.length > 2 && (this.comment = t[2].trim()), this;
  }
  format() {
    switch (this.type) {
      case ze.DSA:
        return {
          type: this.type,
          p: this.p.toString("hex"),
          q: this.q.toString("hex"),
          g: this.g.toString("hex"),
          y: this.y.toString("hex"),
          comment: this.comment
        };
      case ze.RSA:
        return {
          type: this.type,
          n: this.n.toString("hex"),
          e: this.e.toString("hex"),
          comment: this.comment
        };
      case ze.P256:
      case ze.P384:
      case ze.P521:
      case ze.ED25519:
        return {
          type: this.type,
          point: this.point.toString("hex"),
          comment: this.comment
        };
      default:
        return this;
    }
  }
}
class YB extends Qs.Struct {
  constructor() {
    super(), this.type = ze.ED25519, this.p = hr, this.q = hr, this.g = hr, this.y = hr, this.x = hr, this.n = hr, this.e = hr, this.d = hr, this.p = hr, this.q = hr, this.dp = hr, this.dq = hr, this.qi = hr, this.key = co, this.comment = "", this.modern = !1;
  }
  getCurve() {
    if (!en.hasOwnProperty(this.type))
      throw new Error("No curve available.");
    return en[this.type];
  }
  encodeSSH(e) {
    An(e == null || typeof e == "string");
    const t = new v1(), i = new B1(), n = new E1(), c = Qs.write(8192);
    switch (c.writeString(Qb), c.writeU8(0), e != null ? (t.name = "bcrypt", t.salt = VB.randomBytes(16), t.rounds = 16, Bs(c, "aes256-ctr")) : Bs(c, "none"), t.write(c), zf(c, 1), i.type = this.type, Er(c, i.encode()), n.type = this.type, this.type) {
      case ze.DSA: {
        n.p = this.p, n.q = this.q, n.g = this.g, n.y = this.y, n.x = this.x;
        break;
      }
      case ze.RSA: {
        n.n = this.n, n.e = this.e, n.d = this.d, n.p = this.p, n.q = this.q, n.qi = this.qi;
        break;
      }
      case ze.P256: {
        n.point = Xb.publicKeyCreate(this.key, !1), n.key = this.key;
        break;
      }
      case ze.P384: {
        n.point = Zb.publicKeyCreate(this.key, !1), n.key = this.key;
        break;
      }
      case ze.P521: {
        n.point = Wb.publicKeyCreate(this.key, !1), n.key = this.key;
        break;
      }
      case ze.ED25519: {
        n.point = GB.publicKeyCreate(this.key), n.key = this.key;
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    n.comment = this.comment;
    let o = n.encode(e != null);
    return e != null && (o = JB(o, "aes256-ctr", e, t.salt, t.rounds)), Er(c, o), c.slice();
  }
  decodeSSH(e, t) {
    const i = Qs.read(e);
    if (i.readString(14, "binary") !== Qb || i.readU8() !== 0)
      throw new Error("Invalid magic prefix for SSH key.");
    const c = tn(i), o = v1.read(i);
    if (oo(i) !== 1)
      throw new Error("Too many SSH keys.");
    const d = vr(i), l = B1.decode(d);
    let h = vr(i);
    if (c !== "none") {
      if (t == null)
        throw new Error("Cannot decrypt without passphrase.");
      if (o.name !== "bcrypt")
        throw new Error("Invalid KDF.");
      h = XB(h, c, t, o.salt, o.rounds);
    }
    const x = E1.decode(h);
    if (x.type !== l.type)
      throw new Error("Public/private mismatch.");
    switch (this.type = l.type, this.type) {
      case ze.DSA: {
        this.p = x.p, this.q = x.q, this.g = x.g, this.y = x.y, this.x = x.x;
        break;
      }
      case ze.RSA: {
        this.n = x.n, this.e = x.e, this.d = x.d, this.p = x.p, this.q = x.q, this.qi = x.qi;
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521:
      case ze.ED25519: {
        this.key = x.key;
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    if (this.type === ze.RSA) {
      const b = md.decode(this.p), g = md.decode(this.q), w = md.decode(this.d), I = w.mod(b.subn(1)), B = w.mod(g.subn(1));
      this.dp = I.encode(), this.dq = B.encode();
    }
    return this.comment = x.comment, this.modern = !0, this;
  }
  encode(e) {
    if (this.modern || this.type === ze.ED25519)
      return this.encodeSSH(e);
    switch (this.type) {
      case ze.DSA:
        return new Fb.DSAPrivateKey(0, this.p, this.q, this.g, this.y, this.x).encode();
      case ze.RSA:
        return new Yb.RSAPrivateKey(0, this.n, this.e, this.d, this.p, this.q, this.dp, this.dq, this.qi).encode();
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        let t = null, i = null;
        switch (this.type) {
          case ze.P256:
            t = "P256", i = Xb.publicKeyCreate(this.key, !1);
            break;
          case ze.P384:
            t = "P384", i = Zb.publicKeyCreate(this.key, !1);
            break;
          case ze.P521:
            t = "P521", i = Wb.publicKeyCreate(this.key, !1);
            break;
        }
        return new Jb.ECPrivateKey(1, this.key, t, i).encode();
      }
      default:
        throw new Error("Invalid key.");
    }
  }
  toString(e) {
    const t = new Vb();
    if (this.modern || this.type === ze.ED25519)
      return t.type = "OPENSSH PRIVATE KEY", t.data = this.encode(e), t.toString();
    switch (this.type) {
      case ze.DSA: {
        t.type = "DSA PRIVATE KEY";
        break;
      }
      case ze.RSA: {
        t.type = "RSA PRIVATE KEY";
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        t.type = "EC PRIVATE KEY";
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    return t.data = this.encode(null), e != null && Gb.encrypt(t, "AES-128-CBC", e), t.toString();
  }
  fromString(e, t) {
    const i = Vb.fromString(e);
    if (i.isEncrypted()) {
      if (t == null)
        throw new Error("Private key requires a passphrase.");
      Gb.decrypt(i, t);
    }
    switch (i.type) {
      case "DSA PRIVATE KEY": {
        const n = Fb.DSAPrivateKey.decode(i.data);
        return this.type = ze.DSA, this.p = n.p.value, this.q = n.q.value, this.g = n.g.value, this.y = n.y.value, this.x = n.x.value, this;
      }
      case "RSA PRIVATE KEY": {
        const n = Yb.RSAPrivateKey.decode(i.data);
        return this.type = ze.RSA, this.n = n.n.value, this.e = n.e.value, this.d = n.d.value, this.p = n.p.value, this.q = n.q.value, this.dp = n.dp.value, this.dq = n.dq.value, this.qi = n.qi.value, this;
      }
      case "EC PRIVATE KEY": {
        const n = Jb.ECPrivateKey.decode(i.data), c = n.namedCurveOID.getCurveName();
        if (!c)
          throw new Error(`Unknown curve: ${n.namedCurveOID.toString()}.`);
        let o = null, d = 0;
        switch (c) {
          case "P256":
            o = ze.P256, d = 32;
            break;
          case "P384":
            o = ze.P384, d = 48;
            break;
          case "P521":
            o = ze.P521, d = 66;
            break;
          case "ED25519":
            o = ze.ED25519, d = 32;
            break;
          default:
            throw new Error(`Unsupported curve: ${c}.`);
        }
        return this.type = o, this.key = c === "ED25519" ? HB(n.privateKey.value, d) : Fc(n.privateKey.value, d), this;
      }
      case "OPENSSH PRIVATE KEY":
        return this.decodeSSH(i.data, t);
      default:
        throw new Error(`Unknown private key type: ${i.type}.`);
    }
  }
  format() {
    switch (this.type) {
      case ze.DSA:
        return {
          type: this.type,
          p: this.p.toString("hex"),
          q: this.q.toString("hex"),
          g: this.g.toString("hex"),
          y: this.y.toString("hex"),
          x: this.x.toString("hex"),
          comment: this.comment,
          modern: this.modern
        };
      case ze.RSA:
        return {
          type: this.type,
          n: this.n.toString("hex"),
          e: this.q.toString("hex"),
          d: this.d.toString("hex"),
          p: this.p.toString("hex"),
          q: this.q.toString("hex"),
          dp: this.dp.toString("hex"),
          dq: this.dq.toString("hex"),
          qi: this.qi.toString("hex"),
          comment: this.comment,
          modern: this.modern
        };
      case ze.P256:
      case ze.P384:
      case ze.P521:
      case ze.ED25519:
        return {
          type: this.type,
          key: this.key.toString("hex"),
          comment: this.comment,
          modern: this.modern
        };
      default:
        return this;
    }
  }
}
class v1 extends Qs.Struct {
  constructor() {
    super(), this.name = "none", this.salt = hr, this.rounds = 0;
  }
  getBodySize() {
    let e = 0;
    switch (this.name) {
      case "none":
        break;
      case "bcrypt":
        e += _r(this.salt), e += Nf(this.rounds);
        break;
      default:
        throw new Error(`Unknown KDF: ${this.name}.`);
    }
    return e;
  }
  getSize() {
    let e = 0;
    return e += Mf(this.name), e += Nf(), e += this.getBodySize(), e;
  }
  write(e) {
    switch (Bs(e, this.name), zf(e, this.getBodySize()), this.name) {
      case "none":
        break;
      case "bcrypt":
        Er(e, this.salt), zf(e, this.rounds);
        break;
      default:
        throw new Error(`Unknown KDF: ${this.name}.`);
    }
    return e;
  }
  read(e) {
    this.name = tn(e);
    const t = ZB(e);
    switch (this.name) {
      case "none":
        break;
      case "bcrypt":
        this.salt = vr(t), this.rounds = oo(t);
        break;
      default:
        throw new Error(`Unknown KDF: ${this.name}.`);
    }
    return this;
  }
}
class E1 extends Qs.Struct {
  constructor() {
    super(), this.type = ze.ED25519, this.p = hr, this.q = hr, this.g = hr, this.y = hr, this.x = hr, this.n = hr, this.e = hr, this.d = hr, this.p = hr, this.q = hr, this.qi = hr, this.point = co, this.key = co, this.comment = "";
  }
  getSize(e) {
    let t = 0;
    switch (t += Nf(), t += Nf(), t += Mf(this.type), this.type) {
      case ze.DSA: {
        t += _r(this.p), t += _r(this.q), t += _r(this.g), t += _r(this.y), t += _r(this.x);
        break;
      }
      case ze.RSA: {
        t += _r(this.n), t += _r(this.e), t += _r(this.d), t += _r(this.qi), t += _r(this.p), t += _r(this.q);
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        t += Mf(en[this.type]), t += _r(this.point), t += _r(this.key);
        break;
      }
      case ze.ED25519: {
        t += _r(this.point), t += Nf(), t += this.key.length, t += this.point.length;
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    return t += Mf(this.comment), t += 8 - (t & 7), t;
  }
  write(e, t) {
    const i = e.offset;
    let n = 0;
    switch (t && (n = Math.random() * 4294967296 >>> 0), zf(e, n), zf(e, n), Bs(e, this.type), this.type) {
      case ze.DSA: {
        Er(e, this.p), Er(e, this.q), Er(e, this.g), Er(e, this.y), Er(e, this.x);
        break;
      }
      case ze.RSA: {
        Er(e, this.n), Er(e, this.e), Er(e, this.d), Er(e, this.qi), Er(e, this.p), Er(e, this.q);
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        Bs(e, en[this.type]), Er(e, this.point), Er(e, this.key);
        break;
      }
      case ze.ED25519: {
        Er(e, this.point), Er(e, Qs.concat(this.key, this.point));
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    Bs(e, this.comment);
    let c = e.offset - i, o = 1;
    for (; c & 7; )
      e.writeU8(o), c += 1, o += 1;
    return e;
  }
  read(e) {
    if (e.left() & 7)
      throw new Error("Invalid padding.");
    if (oo(e) !== oo(e))
      throw new Error("Decryption failed.");
    switch (this.type = tn(e), this.type) {
      case ze.DSA: {
        this.p = vr(e), this.q = vr(e), this.g = vr(e), this.y = vr(e), this.x = vr(e);
        break;
      }
      case ze.RSA: {
        this.n = vr(e), this.e = vr(e), this.d = vr(e), this.qi = vr(e), this.p = vr(e), this.q = vr(e);
        break;
      }
      case ze.P256:
      case ze.P384:
      case ze.P521: {
        if (tn(e) !== en[this.type])
          throw new Error("Invalid curve.");
        this.point = vr(e), this.key = vr(e), this.type === ze.P256 ? this.key = Fc(this.key, 32) : this.type === ze.P384 ? this.key = Fc(this.key, 48) : this.key = Fc(this.key, 66);
        break;
      }
      case ze.ED25519: {
        const i = vr(e), n = vr(e);
        if (n.length !== 64)
          throw new Error("Invalid key pair.");
        const c = n.slice(0, 32), o = n.slice(32, 64);
        if (!i.equals(o))
          throw new Error("Public key mismatch.");
        this.point = i, this.key = c;
        break;
      }
      default:
        throw new Error("Invalid key.");
    }
    this.comment = tn(e);
    const t = e.readBytes(e.left(), !0);
    for (let i = 0; i < t.length; i++)
      if (t[i] !== i + 1)
        throw new Error("Invalid padding.");
    return this;
  }
}
function Y7(r, e, t, i) {
  if (An(typeof r == "string"), An(typeof e == "string"), An(Buffer.isBuffer(t)), An(i >>> 0 === i), !jb.hasOwnProperty(r))
    throw new Error(`Unknown cipher: ${r}.`);
  const [n, c, o] = jb[r], d = c + o, l = FB.pbkdf(e, t, i, d), h = l.slice(0, c), x = l.slice(c, c + o);
  return [n, h, x];
}
function JB(r, e, t, i, n) {
  const [c, o, d] = Y7(e, t, i, n);
  return V7.encrypt(c, o, d, r);
}
function XB(r, e, t, i, n) {
  const [c, o, d] = Y7(e, t, i, n);
  return V7.decrypt(c, o, d, r);
}
function tn(r) {
  return r.readString(r.readU32BE(), "binary");
}
function vr(r) {
  return r.readBytes(r.readU32BE());
}
function ZB(r) {
  return r.readChild(r.readU32BE());
}
function oo(r) {
  return r.readU32BE();
}
function Mf(r) {
  return 4 + r.length;
}
function Bs(r, e) {
  return r.writeU32BE(e.length), r.writeString(e, "binary"), r;
}
function _r(r) {
  return 4 + r.length;
}
function Er(r, e) {
  return r.writeU32BE(e.length), r.writeBytes(e), r;
}
function Nf(r) {
  return 4;
}
function zf(r, e) {
  return r.writeU32BE(e), r;
}
cn.keyTypes = ze;
cn.keyTypesByVal = G7;
cn.SSHPublicKey = B1;
cn.SSHPrivateKey = YB;
cn.KDFOptions = v1;
cn.RawPrivateKey = E1;
var I1 = { exports: {} };
/*!
 * sha3.js - SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */
var gd, e6;
function WB() {
  if (e6)
    return gd;
  e6 = 1;
  const r = O8();
  class e extends r {
    constructor() {
      super();
    }
    final() {
      return super.final(6, null);
    }
    static hash() {
      return new e();
    }
    static hmac(i) {
      return super.hmac(i, 6, null);
    }
    static digest(i, n) {
      return super.digest(i, n, 6, null);
    }
    static root(i, n, c) {
      return super.root(i, n, c, 6, null);
    }
    static multi(i, n, c, o) {
      return super.multi(i, n, c, o, 6, null);
    }
    static mac(i, n, c) {
      return super.mac(i, n, c, 6, null);
    }
  }
  return e.native = 0, e.id = "SHA3_256", e.size = 32, e.bits = 256, e.blockSize = 136, e.zero = Buffer.alloc(32, 0), e.ctx = new e(), gd = e, gd;
}
/*!
 * sha3.js - SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var wd, t6;
function jB() {
  if (t6)
    return wd;
  t6 = 1;
  const r = P8();
  class e extends r {
    constructor() {
      super();
    }
    final() {
      return super.final(6, null);
    }
    static hash() {
      return new e();
    }
    static hmac(i) {
      return super.hmac(i, 6, null);
    }
    static digest(i, n) {
      return super.digest(i, n, 6, null);
    }
    static root(i, n, c) {
      return super.root(i, n, c, 6, null);
    }
    static multi(i, n, c, o) {
      return super.multi(i, n, c, o, 6, null);
    }
    static mac(i, n, c) {
      return super.mac(i, n, c, 6, null);
    }
  }
  return e.native = 2, e.id = "SHA3_256", e.size = 32, e.bits = 256, e.blockSize = 136, e.zero = Buffer.alloc(32, 0), e.ctx = new e(), wd = e, wd;
}
/*!
 * sha3.js - sha3 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? I1.exports = WB() : I1.exports = jB();
var Wf = I1.exports;
/*!
 * sha3-224.js - sha3-224 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const J7 = Wf;
class vi extends J7 {
  constructor() {
    super();
  }
  init() {
    return super.init(224);
  }
  static hash() {
    return new vi();
  }
  static hmac() {
    return super.hmac(224);
  }
  static digest(e) {
    return super.digest(e, 224);
  }
  static root(e, t) {
    return super.root(e, t, 224);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 224);
  }
  static mac(e, t) {
    return super.mac(e, t, 224);
  }
}
vi.native = J7.native;
vi.id = "SHA3_224";
vi.size = 28;
vi.bits = 224;
vi.blockSize = 144;
vi.zero = Buffer.alloc(28, 0);
vi.ctx = new vi();
var QB = vi;
/*!
 * sha3-256.js - sha3-256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const X7 = Wf;
class Ei extends X7 {
  constructor() {
    super();
  }
  init() {
    return super.init(256);
  }
  static hash() {
    return new Ei();
  }
  static hmac() {
    return super.hmac(256);
  }
  static digest(e) {
    return super.digest(e, 256);
  }
  static root(e, t) {
    return super.root(e, t, 256);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 256);
  }
  static mac(e, t) {
    return super.mac(e, t, 256);
  }
}
Ei.native = X7.native;
Ei.id = "SHA3_256";
Ei.size = 32;
Ei.bits = 256;
Ei.blockSize = 136;
Ei.zero = Buffer.alloc(32, 0);
Ei.ctx = new Ei();
var ev = Ei;
/*!
 * sha3-384.js - sha3-384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const Z7 = Wf;
class Ii extends Z7 {
  constructor() {
    super();
  }
  init() {
    return super.init(384);
  }
  static hash() {
    return new Ii();
  }
  static hmac() {
    return super.hmac(384);
  }
  static digest(e) {
    return super.digest(e, 384);
  }
  static root(e, t) {
    return super.root(e, t, 384);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 384);
  }
  static mac(e, t) {
    return super.mac(e, t, 384);
  }
}
Ii.native = Z7.native;
Ii.id = "SHA3_384";
Ii.size = 48;
Ii.bits = 384;
Ii.blockSize = 104;
Ii.zero = Buffer.alloc(48, 0);
Ii.ctx = new Ii();
var tv = Ii;
/*!
 * sha3-512.js - sha3-512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const W7 = Wf;
class Ai extends W7 {
  constructor() {
    super();
  }
  init() {
    return super.init(512);
  }
  static hash() {
    return new Ai();
  }
  static hmac() {
    return super.hmac(512);
  }
  static digest(e) {
    return super.digest(e, 512);
  }
  static root(e, t) {
    return super.root(e, t, 512);
  }
  static multi(e, t, i) {
    return super.multi(e, t, i, 512);
  }
  static mac(e, t) {
    return super.mac(e, t, 512);
  }
}
Ai.native = W7.native;
Ai.id = "SHA3_512";
Ai.size = 64;
Ai.bits = 512;
Ai.blockSize = 72;
Ai.zero = Buffer.alloc(64, 0);
Ai.ctx = new Ai();
var rv = Ai;
/*!
 * shake128.js - SHAKE128 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const j7 = Q1;
class _i extends j7 {
  constructor() {
    super();
  }
  init() {
    return super.init(128);
  }
  static hash() {
    return new _i();
  }
  static hmac(e) {
    return super.hmac(128, e);
  }
  static digest(e, t) {
    return super.digest(e, 128, t);
  }
  static root(e, t, i) {
    return super.root(e, t, 128, i);
  }
  static multi(e, t, i, n) {
    return super.multi(e, t, i, 128, n);
  }
  static mac(e, t, i) {
    return super.mac(e, t, 128, i);
  }
}
_i.native = j7.native;
_i.id = "SHAKE128";
_i.size = 16;
_i.bits = 128;
_i.blockSize = 168;
_i.zero = Buffer.alloc(16, 0);
_i.ctx = new _i();
var iv = _i, A1 = { exports: {} }, Zi = {};
/*!
 * siphash.js - siphash for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SipHash
 *   https://131002.net/siphash/
 *   https://131002.net/siphash/siphash.pdf
 *   https://github.com/bitcoin/bitcoin/blob/master/src/crypto/siphash.cpp
 */
var r6;
function sv() {
  if (r6)
    return Zi;
  r6 = 1;
  const r = _e, e = 1 / 4294967296;
  function t(B, y) {
    r(Buffer.isBuffer(B)), r(Buffer.isBuffer(y) && y.length >= 16);
    const A = B.length >>> 3, _ = new b(1936682341, 1886610805), q = new b(1685025377, 1852075885), U = new b(1819895653, 1852142177), z = new b(1952801890, 2037671283), E = new b(B.length << 24, 0), H = new b(0, 255), k = b.decode(y, 0), V = b.decode(y, 8), T = _.ixor(k), ie = q.ixor(V), N = U.ixor(k), G = z.ixor(V);
    let F = 0;
    for (let W = 0; W < A; W++) {
      const ce = b.decode(B, F);
      G.ixor(ce), g(T, ie, N, G), g(T, ie, N, G), T.ixor(ce), F += 8;
    }
    switch (B.length & 7) {
      case 7:
        E.hi |= B[F + 6] << 16;
      case 6:
        E.hi |= B[F + 5] << 8;
      case 5:
        E.hi |= B[F + 4];
      case 4:
        E.lo |= B[F + 3] << 24;
      case 3:
        E.lo |= B[F + 2] << 16;
      case 2:
        E.lo |= B[F + 1] << 8;
      case 1:
        E.lo |= B[F];
    }
    return G.ixor(E), g(T, ie, N, G), g(T, ie, N, G), T.ixor(E), N.ixor(H), g(T, ie, N, G), g(T, ie, N, G), g(T, ie, N, G), g(T, ie, N, G), T.ixor(ie), T.ixor(N), T.ixor(G), [T.hi, T.lo];
  }
  function i(B, y, A) {
    r(typeof B == "number"), r(typeof y == "number"), r(Buffer.isBuffer(A) && A.length >= 16);
    const _ = new b(1936682341, 1886610805), q = new b(1685025377, 1852075885), U = new b(1819895653, 1852142177), z = new b(1952801890, 2037671283), E = new b(B, y), H = new b(0, 255), k = b.decode(A, 0), V = b.decode(A, 8), T = _.ixor(k), ie = q.ixor(V), N = U.ixor(k), G = z.ixor(V);
    return G.ixor(E), g(T, ie, N, G), g(T, ie, N, G), T.ixor(E), N.ixor(H), g(T, ie, N, G), g(T, ie, N, G), g(T, ie, N, G), g(T, ie, N, G), T.ixor(ie), T.ixor(N), T.ixor(G), [T.hi, T.lo];
  }
  function n(B, y, A) {
    r(typeof B == "number"), r(typeof y == "number"), r(Buffer.isBuffer(A) && A.length >= 32);
    const _ = new b(B, y), q = new b(0, 255), U = b.decode(A, 0), z = b.decode(A, 8), E = b.decode(A, 16), H = b.decode(A, 24), k = U, V = z, T = E, ie = H;
    return ie.ixor(_), g(k, V, T, ie), g(k, V, T, ie), k.ixor(_), T.ixor(q), g(k, V, T, ie), g(k, V, T, ie), g(k, V, T, ie), g(k, V, T, ie), k.ixor(V), k.ixor(T), k.ixor(ie), [k.hi, k.lo];
  }
  function c(B, y) {
    return t(B, y);
  }
  function o(B, y) {
    return i(0, B, y)[1];
  }
  function d(B, y, A) {
    return i(B, y, A);
  }
  function l(B, y) {
    return n(0, B, y)[1];
  }
  function h(B, y, A) {
    return n(B, y, A);
  }
  function x(B, y, A, _) {
    const [q, U] = t(B, y);
    return w(q, U, A, _);
  }
  class b {
    constructor(y, A) {
      this.hi = y | 0, this.lo = A | 0;
    }
    isum(y, A) {
      const _ = this, q = _.lo + A | 0, U = q >> 31, z = _.lo >> 31, E = A >> 31, H = (z & E | ~U & (z ^ E)) & 1, k = (_.hi + y | 0) + H;
      return _.hi = k | 0, _.lo = q, _;
    }
    iadd(y) {
      return this.isum(y.hi, y.lo);
    }
    ixor(y) {
      return this.hi ^= y.hi, this.lo ^= y.lo, this;
    }
    irotl(y) {
      let A = this.hi, _ = this.lo, q = this.hi, U = this.lo;
      return y < 32 ? (A <<= y, A |= _ >>> 32 - y, _ <<= y) : (A = _ << y - 32, _ = 0), y = 64 - y, y < 32 ? (U >>>= y, U |= q << 32 - y, q >>>= y) : (U = q >>> y - 32, q = 0), this.hi = A | q, this.lo = _ | U, this;
    }
    static mul(y, A) {
      const _ = y >>> 16, q = y & 65535, U = A >>> 16, z = A & 65535;
      let E = 0, H = 0, k = 0, V = 0;
      V += q * z, k += V >>> 16, V &= 65535, k += _ * z, H += k >>> 16, k &= 65535, k += q * U, H += k >>> 16, k &= 65535, E += H >>> 16, H &= 65535, H += _ * U, E += H >>> 16, H &= 65535, E += H >>> 16, E &= 65535;
      const T = E << 16 | H, ie = k << 16 | V;
      return new b(T, ie);
    }
    static decode(y, A) {
      const _ = I(y, A), q = I(y, A + 4);
      return new b(q, _);
    }
  }
  function g(B, y, A, _) {
    B.iadd(y), y.irotl(13), y.ixor(B), B.irotl(32), A.iadd(_), _.irotl(16), _.ixor(A), B.iadd(_), _.irotl(21), _.ixor(B), A.iadd(y), y.irotl(17), y.ixor(A), A.irotl(32);
  }
  function w(B, y, A, _) {
    const q = b.mul(B, A), U = b.mul(B, _), z = b.mul(A, y), E = b.mul(y, _), H = (U.lo >>> 0) + (z.lo >>> 0) + (E.hi >>> 0), k = (U.hi >>> 0) + (z.hi >>> 0) + (H * e >>> 0), { hi: V, lo: T } = q.isum(k * e | 0, k | 0);
    return [V, T];
  }
  function I(B, y) {
    return B[y++] + B[y++] * 256 + B[y++] * 65536 + B[y] * 16777216;
  }
  return Zi.native = 0, Zi.siphash = c, Zi.siphash32 = o, Zi.siphash64 = d, Zi.siphash32k256 = l, Zi.siphash64k256 = h, Zi.sipmod = x, Zi;
}
var Wi = {};
/*!
 * siphash.js - siphash for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var i6;
function nv() {
  if (i6)
    return Wi;
  i6 = 1;
  const r = _e, e = Dt();
  function t(l, h) {
    r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h));
    const x = e.siphash_sum(l, h);
    return x[0] |= 0, x[1] |= 0, x;
  }
  function i(l, h) {
    return n(0, l, h)[1];
  }
  function n(l, h, x) {
    r(Buffer.isBuffer(x));
    const b = e.siphash128_sum(l >>> 0, h >>> 0, x);
    return b[0] |= 0, b[1] |= 0, b;
  }
  function c(l, h) {
    return o(0, l, h)[1];
  }
  function o(l, h, x) {
    r(Buffer.isBuffer(x));
    const b = e.siphash256_sum(l >>> 0, h >>> 0, x);
    return b[0] |= 0, b[1] |= 0, b;
  }
  function d(l, h, x, b) {
    r(Buffer.isBuffer(l)), r(Buffer.isBuffer(h));
    const g = e.siphash_mod(l, h, x >>> 0, b >>> 0);
    return g[0] |= 0, g[1] |= 0, g;
  }
  return Wi.native = 2, Wi.siphash = t, Wi.siphash32 = i, Wi.siphash64 = n, Wi.siphash32k256 = c, Wi.siphash64k256 = o, Wi.sipmod = d, Wi;
}
/*!
 * siphash.js - siphash for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? A1.exports = sv() : A1.exports = nv();
var fv = A1.exports, _1 = { exports: {} };
/*!
 * whirlpool.js - Whirlpool implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Whirlpool_(hash_function)
 *   https://www.iso.org/standard/39876.html
 *   https://github.com/jzelinskie/whirlpool/blob/master/whirlpool.go
 *   https://github.com/RustCrypto/hashes/blob/master/whirlpool/src/consts.rs
 *   https://github.com/RustCrypto/hashes/blob/master/whirlpool/src/lib.rs
 *   https://github.com/RustCrypto/hashes/blob/master/whirlpool/src/utils.rs
 */
var yd, s6;
function cv() {
  if (s6)
    return yd;
  s6 = 1;
  const r = _e, e = Rr, t = -1, i = Buffer.alloc(32, 0), n = Buffer.alloc(64, 0);
  n[0] = 128;
  const c = new Uint32Array([
    0,
    0,
    404997864,
    2276983119,
    916902645,
    2037354834,
    1622973326,
    2735504181,
    501274562,
    776732247,
    360134629,
    2683325146,
    1489578250,
    2980080517,
    3176993012,
    3409839463,
    3827777931,
    2810025432,
    4226710630,
    3709290398,
    3391995655,
    2908390195
  ]), o = new Uint32Array([
    404250648,
    3229102296,
    589532195,
    95372838,
    3334881222,
    2130284984,
    3907553256,
    326094331,
    2273781383,
    1285624779,
    3099122360,
    2841799953,
    16843777,
    134545929,
    1330585935,
    1114545677,
    909563958,
    2918083739,
    2795938470,
    1493455359,
    3537006546,
    3736975628,
    4126536693,
    4211537678,
    2038036857,
    4018205334,
    1869586799,
    1607392816,
    2442231441,
    4243537773,
    1381127506,
    2852627704,
    1616944480,
    670941255,
    3166489276,
    2306237749,
    2610648731,
    2899127095,
    2391671438,
    76284298,
    2745415331,
    1897225170,
    202125324,
    1614551148,
    2071720315,
    4287297156,
    892720181,
    3051448960,
    488469533,
    3899210485,
    3772819424,
    1397218739,
    3621223383,
    4138513185,
    3267506114,
    1592629660,
    774813742,
    1838570563,
    1263219019,
    1652201001,
    4278116350,
    2736906589,
    1465336151,
    2182524629,
    353719317,
    2822843069,
    2004337015,
    2679566056,
    926407735,
    2783669906,
    3857036261,
    2069288862,
    2678015647,
    2363040531,
    4042319856,
    3541564707,
    1246377290,
    1786745888,
    3671740378,
    2660608324,
    1482194264,
    4196774050,
    3385394121,
    113938383,
    690594857,
    1435325052,
    168437770,
    1344410714,
    2981232305,
    3780083536,
    2694888096,
    1763335625,
    1802219883,
    2145048084,
    2240097925,
    1554716633,
    3183333053,
    2171823932,
    1566402909,
    3526670991,
    269500432,
    2152734864,
    4109694964,
    4077122823,
    3419081675,
    381717469,
    1044314174,
    3989208275,
    84218885,
    672205357,
    1734836583,
    535219832,
    3840194532,
    1934874007,
    656907303,
    633032194,
    1094785345,
    844661363,
    2341148299,
    748489639,
    2812782247,
    1359041526,
    2105403773,
    3482647218,
    2509598357,
    3707451209,
    3638052824,
    2392829270,
    4227582971,
    2335239024,
    4008615918,
    594657741,
    2088562044,
    3348232379,
    1717994854,
    400804977,
    3722269661,
    2794366843,
    387406871,
    3091934895,
    1195835719,
    38178373,
    2661171870,
    2229018906,
    3402239946,
    516262356,
    757969965,
    1972984408,
    3217016511,
    2440651566,
    117906439,
    941297215,
    2913832621,
    19089324,
    1515877722,
    3928994992,
    2206414467,
    1823808495,
    859032627,
    2248107702,
    1667469667,
    1072875100,
    33687554,
    269091858,
    2863305386,
    959990163,
    1903286641,
    2947080926,
    3368552392,
    248483270,
    421094425,
    3363648209,
    1229535561,
    1919980091,
    3654894553,
    2258284383,
    4076007410,
    3273521457,
    3823348707,
    1263066024,
    1532719451,
    3794450105,
    2290621064,
    881987004,
    2593804954,
    2764581182,
    640063526,
    767446027,
    842188850,
    2381997247,
    2964388528,
    3913973081,
    3924394985,
    459984882,
    252656655,
    2016616055,
    3587535829,
    3869685555,
    2155887232,
    1958354420,
    3200172734,
    2575065383,
    3452769229,
    652117995,
    875876404,
    3185862793,
    1212693832,
    2054524978,
    4294958079,
    2871321428,
    2054878586,
    4153406605,
    2425387664,
    4108991844,
    1600086367,
    3258891933,
    539000864,
    497041469,
    1751694696,
    1742065679,
    437938202,
    3497145546,
    2930672302,
    422330807,
    3031755444,
    3378410877,
    1414810964,
    2585372878,
    2475914899,
    3974445951,
    572688418,
    229262383,
    1684311396,
    132761699,
    4059161585,
    3675455274,
    1936970099,
    3215124172,
    303187986,
    2421826690,
    1077943616,
    979206266,
    134750216,
    1076367432,
    3284347843,
    1458084757,
    3974928364,
    863749599,
    3688582107,
    2526063437,
    2711731873,
    1629446080,
    2374831757,
    478349201,
    1027470397,
    4123622088,
    2543281815,
    3438359387,
    0,
    0,
    3486456783,
    919897081,
    724282411,
    1166497390,
    1987495286,
    2545151201,
    2189570690,
    1689262566,
    3604381654,
    4272533800,
    454781979,
    3631691459,
    3048599221,
    3243997044,
    2947516079,
    287916990,
    1785378154,
    2011157533,
    1347444048,
    3121455338,
    1162152261,
    307006039,
    4092849139,
    3407412024,
    808501296,
    2649776301,
    4025457647,
    729072580,
    1061157951,
    3854794458,
    1431652693,
    2451352263,
    2728571554,
    2031114715,
    3941240810,
    57002473,
    1701153125,
    267176554,
    3132805818,
    3110627587,
    791657519,
    1704156746,
    3233818560,
    1323801998,
    3739115486,
    3196166496,
    471625756,
    3765188860,
    4261270525,
    3140413254,
    1296902477,
    1382324767,
    2459071122,
    3839900022,
    1970653557,
    2411522810,
    101062662,
    807275574,
    2324304522,
    613943726,
    2998071986,
    4181752139,
    3873882086,
    1666830725,
    235812878,
    1882594430,
    522157087,
    4167253735,
    1650627938,
    938984533,
    3570694100,
    4003706170,
    2829621928,
    691162497,
    2526438038,
    3304337746,
    4193895417,
    2604330850,
    3318035397,
    1727436707,
    623219749,
    900811280,
    1499035993,
    4062229163,
    2223254148,
    1420694992,
    1920128370,
    3081233605,
    960095289,
    3588059884,
    1280060748,
    1516345366,
    1583244638,
    3392912532,
    2021195128,
    3884314783,
    943251512,
    3721949413,
    2357987980,
    344327576,
    3520160721,
    3333603095,
    2779098789,
    1091262436,
    3806506978,
    1129175457,
    1633786209,
    804831822,
    3014915763,
    4047862594,
    555844641,
    363151924,
    2627488412,
    2497062152,
    505313310,
    4033232110,
    1128468803,
    575833697,
    3351722951,
    1996264369,
    4244428796,
    3005998415,
    67375108,
    538183716,
    1364285777,
    2986910435,
    2576965273,
    3167170341,
    1835903341,
    1338300962,
    218969101,
    1748572773,
    4210741242,
    2201348473,
    3755957215,
    3062145897,
    2122245502,
    3617324201,
    606375972,
    1035225113,
    993782843,
    3319232254,
    2880149163,
    826100634,
    3469615054,
    1053917680,
    286344209,
    2287280793,
    2408515215,
    210305923,
    1313744206,
    1248566276,
    3082282679,
    3511776102,
    3958082539,
    190893024,
    1010626620,
    4258035905,
    2172731009,
    2092900349,
    2492754580,
    3573429568,
    4160224247,
    3943494428,
    3115966137,
    2707910424,
    320031763,
    2556372619,
    741126188,
    2107398225,
    3553848275,
    3602430725,
    3890723815,
    1801245580,
    1852745070,
    1472977977,
    3301193668,
    1861457322,
    50531331,
    403637787,
    1448494422,
    2316545244,
    1145310532,
    441026654,
    2139087231,
    3751739040,
    2846465705,
    557272968,
    707438634,
    1300386919,
    3149649595,
    2976738058,
    3250660289,
    1189257095,
    1397969235,
    2718082801,
    3705427932,
    2928387442,
    185281547,
    1478956627,
    2644332189,
    2631083777,
    1819061612,
    1203886123,
    825345073,
    2515886756,
    1953811828,
    2277107955,
    4143382518,
    3809079573,
    1178993990,
    172198988,
    2896988844,
    153503141,
    2307464841,
    1016532917,
    336875540,
    2688821428,
    3789661153,
    1531109306,
    370563094,
    2957913254,
    976939066,
    3453121783,
    1768536425,
    1875956230,
    151593993,
    1210913345,
    1886444912,
    2813190359,
    3065438902,
    3646189935,
    3503318992,
    3468147998,
    3991770093,
    998164438,
    3435927500,
    786138594,
    1111627074,
    710378600,
    2560121496,
    3032624428,
    2762255012,
    1225676269,
    673751080,
    1569214581,
    1549561180,
    3660691590,
    4177053688,
    2470440299,
    2256937606,
    1151603138
  ]), d = new Uint32Array([
    3625457760,
    415266864,
    639837068,
    587575110,
    3100034623,
    3330210193,
    4226345095,
    3893587917,
    3414656806,
    2269946131,
    297318618,
    3098108525,
    151060740,
    17302786,
    223301409,
    1329753758,
    2604021464,
    917368428,
    4289111714,
    2790851665,
    215143023,
    3537812921,
    251000307,
    4126869239,
    2524543481,
    2045739250,
    812609441,
    1868549854,
    1838256510,
    2449272639,
    4166144597,
    1386874788,
    1197498525,
    1613233600,
    901561546,
    3163125349,
    932944726,
    2611793195,
    2324598274,
    2382662657,
    3533939638,
    2742097243,
    1812728880,
    207633432,
    2222685169,
    2080344822,
    2150970836,
    901112170,
    4112326004,
    501770554,
    3017859239,
    3763554269,
    567793531,
    3623267507,
    2630009391,
    3261001113,
    1127100088,
    778933852,
    692800305,
    1264745110,
    1576992479,
    4272103905,
    3579270977,
    1468143278,
    3172275540,
    363348266,
    3900143553,
    2006955758,
    2453092316,
    933620590,
    2665866675,
    3850065623,
    329228102,
    2676807971,
    602992871,
    4040366077,
    541739573,
    1248493460,
    1155193423,
    3667826089,
    2723698813,
    1492788656,
    3486107907,
    3372665487,
    2083072420,
    693472594,
    1510607400,
    173023764,
    1353822718,
    2984333183,
    3382747322,
    2691242589,
    342584241,
    1803541206,
    3649406254,
    2237442839,
    1019067854,
    3179377511,
    2405260649,
    1574057146,
    2416971840,
    276844576,
    133494007,
    4109566965,
    3721120523,
    3407265931,
    3544071928,
    1055770236,
    755303700,
    86511882,
    2020042625,
    1730143950,
    2548360375,
    3832763349,
    36120476,
    656784206,
    1933656345,
    1093818498,
    2810940182,
    2334956811,
    4138182566,
    2807103827,
    2994568681,
    2110756090,
    1234539886,
    2514287415,
    1457051719,
    3633225645,
    1895562187,
    4220203243,
    3454987935,
    3995300289,
    3145497837,
    2093453816,
    1902536325,
    1712841676,
    2078137683,
    3718680231,
    2937526108,
    397953838,
    1162299137,
    1191331470,
    446602818,
    2659507233,
    3570059791,
    3391014281,
    1479355828,
    762681690,
    784318406,
    3213982051,
    1057425180,
    121117454,
    2897063310,
    2902532935,
    2958711413,
    1525297076,
    4018373430,
    2204939547,
    3056808908,
    864419686,
    1550017425,
    1665135302,
    302121480,
    34605572,
    2477435538,
    2855876681,
    3731976665,
    1907337442,
    3335047175,
    3356413837,
    3508083044,
    432569650,
    994658617,
    1232236690,
    1608112451,
    3649477295,
    838005487,
    4072873465,
    2833507243,
    3813361883,
    3109772145,
    1541548726,
    3163064346,
    2285146637,
    1050319442,
    2594490409,
    187049624,
    640532044,
    3207738056,
    848165476,
    1504751866,
    2968078973,
    4075415939,
    3910888143,
    1997475644,
    259535646,
    869651827,
    3588662967,
    4102062138,
    2155133469,
    666812098,
    3197729889,
    3956133139,
    3441876615,
    2301899984,
    884860008,
    843597885,
    1215985040,
    1426063323,
    4289406179,
    2373614325,
    2063044596,
    1687195770,
    2431969853,
    2640273249,
    1606565566,
    1025515648,
    538812480,
    258500797,
    1751635408,
    3390708328,
    449868340,
    3081678466,
    2920885313,
    2108994794,
    3033095797,
    3461633101,
    1419385256,
    2140377974,
    2481775931,
    790766216,
    571320900,
    1667523725,
    1678240200,
    720499171,
    4057666303,
    3430118353,
    1941938918,
    2182222408,
    311450148,
    2051031069,
    1077566848,
    1208485920,
    138422288,
    2512634667,
    3277252763,
    3756846231,
    3962796997,
    1306254155,
    3684077739,
    3231818174,
    2707496799,
    2441973006,
    2367456007,
    3359456756,
    1039518074,
    1536661350,
    2546790707,
    0,
    0,
    4191145755,
    3476477059,
    1848322988,
    725976918,
    3782637253,
    1989653484,
    3867312690,
    2187636761,
    685168255,
    3607013809,
    3273333612,
    467171126,
    1958065646,
    3049347959,
    3199184774,
    2937137475,
    493513397,
    1786240980,
    3931131997,
    1354370464,
    1464157449,
    1158827146,
    955511787,
    4090173691,
    2905616576,
    815657056,
    3304058779,
    4012602563,
    3661578236,
    1072022398,
    3344258377,
    1435638954,
    3684868786,
    2725843033,
    3924486799,
    3926091209,
    1785030025,
    1695542474,
    62569170,
    3132713065,
    1244606396,
    795186014,
    2394996775,
    3226396573,
    1625218655,
    3737026977,
    4229700720,
    484469816,
    1191050707,
    4256902887,
    525159721,
    1297245338,
    1989317234,
    2464473145,
    4202001865,
    1972354282,
    906364440,
    103816716,
    2928314898,
    2317654025,
    1270002418,
    3002679417,
    2246502079,
    3865270737,
    2114850360,
    242234908,
    3877576572,
    536372030,
    1432511125,
    1647835076,
    987026551,
    3572409269,
    2175314074,
    2821272141,
    1385600610,
    2529489969,
    1660549571,
    4187699951,
    2747647283,
    3311859351,
    270869908,
    624275786,
    2874759545,
    1509040306,
    3498345514,
    2220142101,
    3312612053,
    1924638692,
    3963173348,
    970317170,
    374098989,
    1280991640,
    2489212517,
    1590311868,
    2675472637,
    2028439024,
    3845667040,
    954062960,
    2559347722,
    2350155269,
    399626595,
    3519460031,
    3836061102,
    2772503383,
    2716000943,
    3796061657,
    1315004825,
    1630533826,
    1119073270,
    3018933627,
    874586500,
    555066690,
    144481354,
    2626999845,
    3994951288,
    519071292,
    1631798033,
    1126322822,
    2982659899,
    3346463891,
    1341979863,
    4239600613,
    604242960,
    69211144,
    3813757273,
    1370622114,
    630823262,
    2579285807,
    577596841,
    1833944282,
    1695354164,
    224934170,
    2046491343,
    4202903017,
    1776279387,
    3753280675,
    2843639525,
    2128059388,
    421799056,
    608023624,
    4265294828,
    1002821494,
    2594941846,
    2872130891,
    4040085023,
    3460223361,
    2568032580,
    294147362,
    2207223558,
    2399963395,
    72240677,
    1313500060,
    1723316198,
    3083948403,
    3773557643,
    3943391435,
    3241950448,
    1023265912,
    4253122878,
    2172436255,
    1083479146,
    2496986677,
    486012923,
    4159376627,
    414824926,
    3114362735,
    2333283148,
    328752934,
    1361849520,
    746429528,
    97768299,
    3554064571,
    2364008379,
    3882573011,
    963538597,
    1851247580,
    2865022007,
    3295605653,
    453182220,
    51908358,
    3696645701,
    1451889580,
    1581532173,
    1142573448,
    2692710369,
    2145361662,
    2292820382,
    2837526351,
    1730816680,
    709722708,
    180075478,
    3148967275,
    2277622051,
    3242648223,
    4048769873,
    1403126438,
    1927076951,
    3702426533,
    1393232684,
    190326550,
    27106638,
    2644300583,
    728525997,
    1816642008,
    2754687428,
    831911266,
    4084495565,
    1955052008,
    368506623,
    4142074353,
    1279673861,
    1175077772,
    2779557002,
    2886280773,
    3045689630,
    2302449423,
    3021214800,
    346047528,
    3135365539,
    3780854495,
    2786465368,
    380653100,
    4147788520,
    986567284,
    107571641,
    1768935634,
    1091111204,
    155725074,
    3614470365,
    1890037216,
    1874245346,
    3067696241,
    517001319,
    3503208381,
    3605917075,
    3980099271,
    3805072407,
    3425622917,
    1749172757,
    1110071172,
    748197978,
    2561983021,
    3986990250,
    2756251221,
    1965566112,
    677218384,
    2254199917,
    1557803448,
    1811478727,
    4170399725,
    3263596066,
    2252645393
  ]), l = new Uint32Array([
    819468312,
    1612234872,
    1176904483,
    2351105455,
    2444805830,
    1069973241,
    3455838440,
    2280133487,
    332105607,
    646401185,
    1829877944,
    3669535074,
    34144513,
    67176453,
    2651672399,
    558842478,
    1822111286,
    3627462126,
    1375708838,
    2728810756,
    3104625362,
    1876090557,
    4144952821,
    4092984070,
    4069947769,
    4185517952,
    3727716207,
    2708430798,
    1064145297,
    2123496687,
    2767737426,
    1431480839,
    3225903200,
    2640324605,
    1698020540,
    3401353590,
    725064603,
    1453042893,
    25857678,
    42861708,
    1540531107,
    3064164629,
    409734156,
    806117436,
    4135877499,
    4051435402,
    1786787125,
    3560289761,
    989142301,
    1948117097,
    3719553248,
    2816496455,
    3005339607,
    2077750956,
    2577187522,
    801267437,
    1547906606,
    3090050454,
    2519288651,
    827023994,
    3781033726,
    3758007073,
    2933217111,
    1096253974,
    717034773,
    1410705473,
    4008212343,
    3245842358,
    1855076151,
    3694634475,
    3617514981,
    3018160982,
    588488607,
    1184861401,
    4246991088,
    3891319575,
    2485144138,
    894069375,
    2839861978,
    1339727509,
    2963429464,
    2102983205,
    2412759497,
    63506122,
    1383868713,
    2754172301,
    341445130,
    671764514,
    2135994801,
    4273070415,
    1573494944,
    3131074842,
    3591662443,
    2976612314,
    400131461,
    780491947,
    1732033981,
    3468525939,
    3129957725,
    1767756340,
    546312208,
    1074823248,
    4110939380,
    4160025347,
    2346568651,
    197859008,
    2094218814,
    4164873670,
    170722565,
    335882257,
    3463997287,
    2171019238,
    3583501540,
    3085202259,
    1308763943,
    2619811259,
    2188591425,
    423703128,
    195529611,
    378219677,
    1408673703,
    2795983105,
    4206001533,
    3917336468,
    927569301,
    1855315195,
    2908149976,
    1205374623,
    3950050299,
    3422260016,
    3251498734,
    2683183985,
    4173036668,
    3984377745,
    3429983846,
    2238060515,
    2809912797,
    1407035022,
    783226647,
    1545058379,
    2386904903,
    21430854,
    555392670,
    1117684956,
    2312424138,
    264904389,
    1515728173,
    3022878105,
    1664008127,
    3334443385,
    239011591,
    470235163,
    1202498989,
    2393702691,
    3031456346,
    1968892463,
    468681603,
    914582709,
    1723216691,
    3425928703,
    3327943523,
    2439200754,
    68289026,
    134352906,
    1234414250,
    2460629304,
    3806228849,
    3648106408,
    2378614984,
    130551503,
    852564249,
    1679411325,
    2453358921,
    961114736,
    2942294489,
    1138329242,
    4180800242,
    4025664285,
    3685278691,
    2883799880,
    3065600859,
    1901847082,
    230459528,
    445133970,
    691968666,
    1385866440,
    1275799078,
    2552638910,
    1690251826,
    3358756346,
    2103029936,
    4205898058,
    3488803305,
    2213092202,
    511119119,
    1007646771,
    3073627605,
    1943398054,
    502562944,
    981497018,
    1629994686,
    3267271036,
    2280377805,
    332211934,
    1753822260,
    3493117412,
    2419214408,
    1028160117,
    3813998591,
    3690965796,
    4102912634,
    4118476687,
    1030000784,
    2056320234,
    3197984607,
    1633665598,
    1077747744,
    2149588384,
    3490670696,
    3177736149,
    885660186,
    1746587762,
    1102556846,
    2192447788,
    1971172532,
    3937716574,
    2832094292,
    1297390105,
    998216595,
    1989405925,
    1143939618,
    2283933098,
    3361956964,
    2372143081,
    4281004529,
    3824278290,
    3872158579,
    3514023842,
    612504082,
    1209176154,
    2155495488,
    490748509,
    273156104,
    537411624,
    2610283459,
    734222056,
    3319786732,
    2548839291,
    2874006491,
    1272682128,
    1606459809,
    3198247199,
    126979469,
    244128899,
    2059943229,
    4097701321,
    861640599,
    1721224433,
    0,
    0,
    2214186959,
    466564820,
    1450060587,
    2888516999,
    3974198902,
    3312883635,
    434537090,
    847406256,
    2972243670,
    2144796329,
    918756123,
    1813764215,
    2004137397,
    4004888923,
    1136570287,
    2259620137,
    3558697578,
    3043653599,
    2699710544,
    1565571597,
    2320975173,
    155521612,
    4214813683,
    3958623e3,
    1621962800,
    3224411632,
    3284463599,
    2616142708,
    2128232255,
    4232046019,
    2865190229,
    1230344732,
    1507566242,
    2996992272,
    3387550442,
    2414478181,
    3395970405,
    2305101804,
    1761852090,
    3535452520,
    1581920047,
    3157222803,
    2643378368,
    666914535,
    2707480286,
    1608433281,
    956046364,
    1880940652,
    3880189437,
    3556621102,
    2585742669,
    692933220,
    964072082,
    1922229472,
    3942282613,
    3379924924,
    204867078,
    403058718,
    162433674,
    311043224,
    2035004082,
    4071815488,
    3515213542,
    3219546969,
    478023182,
    940470326,
    1055334175,
    2082469987,
    3293930082,
    2506242039,
    3040531668,
    2010443427,
    1300342952,
    2594711858,
    827496086,
    1654047988,
    4016241145,
    3287915322,
    2544092613,
    868574966,
    1242572069,
    2485466545,
    2997573977,
    2035937824,
    365986948,
    713315502,
    3838145138,
    3581065127,
    1928083769,
    3828995549,
    2551598156,
    759978593,
    3163840094,
    1700710971,
    4036982904,
    4252559237,
    1894070328,
    3761823192,
    93883532,
    176952454,
    3206009297,
    1674692274,
    1474602405,
    2930065675,
    3651265250,
    2950841165,
    3259916641,
    2573283320,
    2067968947,
    4138987845,
    1110712609,
    2216760741,
    621321372,
    1251775702,
    1022238238,
    2015293542,
    2254521155,
    289612370,
    2477901767,
    1002927868,
    3847224572,
    3623662379,
    136578052,
    268705812,
    2732806481,
    1498526216,
    790993305,
    1587133639,
    3659689325,
    2842513348,
    442830093,
    873293881,
    3917085434,
    3489301301,
    2741624799,
    1541387908,
    4238966398,
    3850295195,
    1209607204,
    2418294196,
    1996372795,
    3963340247,
    1268427691,
    2527801661,
    2180042446,
    533610193,
    580456721,
    1141999701,
    58953615,
    110038153,
    2617527886,
    625887851,
    1936111543,
    3870806353,
    3420515307,
    2347436896,
    2025929788,
    4030528972,
    536707457,
    1048673471,
    893424788,
    1788138750,
    4078761975,
    4227328780,
    1863891385,
    3736707431,
    646648595,
    1276352607,
    1481714732,
    2955705756,
    3137721299,
    1809045176,
    3549226983,
    3152505692,
    3694751342,
    2775472075,
    2510996676,
    935620339,
    102433539,
    201529359,
    2900121174,
    1163299347,
    2287879236,
    222566985,
    4271931263,
    3783253918,
    1334356393,
    2661884215,
    1416047146,
    2821344642,
    1795865531,
    3602624877,
    2676474305,
    599869154,
    2800833363,
    1364435458,
    2775768284,
    1474080395,
    374541067,
    738940967,
    654417309,
    1318952147,
    3626724460,
    2909554625,
    1654927665,
    3291583989,
    3908269172,
    3446966201,
    4044748534,
    4294370057,
    2353808966,
    88476227,
    1168485548,
    2326530342,
    263555465,
    512310423,
    682890260,
    1343529028,
    3753566689,
    2749455170,
    749082134,
    1477881934,
    1962359354,
    3896167890,
    3523635561,
    3110694864,
    306252041,
    604588077,
    3772215408,
    3715147693,
    1903146678,
    3803634004,
    3172913360,
    1741737655,
    3352751597,
    2481798014,
    2246233292,
    399257307,
    2221425218,
    356657751,
    757897368,
    1519957186,
    1441637540,
    2862893326,
    1349855272,
    2686999944,
    3095813212,
    1834801713,
    3983276280,
    3354956607,
    297961094,
    579224740
  ]), h = new Uint32Array([
    2016466968,
    408950976,
    2940610083,
    596386565,
    4187076806,
    3326068350,
    1875770344,
    3901220883,
    2702429063,
    2267449164,
    1651315128,
    3101341865,
    84019457,
    17039624,
    1855851855,
    1327583042,
    4000095030,
    920139437,
    72482726,
    2795677273,
    3183021266,
    3530543838,
    116854517,
    4126406139,
    2163381881,
    2046392815,
    3470667887,
    1872850783,
    4013911441,
    2440991228,
    128251986,
    1381323434,
    4257236832,
    1620926503,
    1986344380,
    3167403145,
    3442161563,
    2606144428,
    2348911246,
    2382532100,
    358339235,
    2746655601,
    1008233484,
    204475488,
    2331411579,
    2079423487,
    3781853237,
    903099829,
    1765471517,
    494149096,
    1205711840,
    3769098323,
    2897420759,
    3615217654,
    3986267330,
    3257909854,
    2522628910,
    783822445,
    2056661323,
    1261521762,
    568417790,
    4276092579,
    380556631,
    1463900034,
    1093319957,
    357832104,
    3069110391,
    2009167775,
    3949892151,
    937179045,
    1456971493,
    3853772155,
    3642954655,
    2672205708,
    402465776,
    4041732307,
    2140414026,
    1245006442,
    2510898394,
    3662666398,
    632332888,
    1484609786,
    3398422473,
    3372468486,
    2370993193,
    698624341,
    571759114,
    170396240,
    1333743793,
    2986258913,
    442354080,
    2696585321,
    3671463019,
    1806789503,
    2870466949,
    2234418524,
    1936145597,
    3184442753,
    884641629,
    1567186386,
    1344311312,
    272633984,
    66390004,
    4109890803,
    3230391755,
    3406547734,
    3330069310,
    1056456429,
    285879557,
    85198120,
    3872290919,
    1736533791,
    1406506980,
    3837256819,
    3142451751,
    664545061,
    1484944193,
    1092174130,
    2634786699,
    2333510444,
    22279847,
    2812716881,
    2499457661,
    2112454095,
    4214704533,
    2507052508,
    2678937304,
    3628587150,
    820736251,
    4224449419,
    1908526574,
    4003458595,
    2448997244,
    2095938759,
    3821826406,
    1720018455,
    2393340893,
    3713260966,
    1261350679,
    391911352,
    1183728967,
    1191266050,
    3693157022,
    2655166084,
    3314144458,
    3390032414,
    2572834861,
    766782837,
    2036543167,
    3217473425,
    453918471,
    119277368,
    591899821,
    2911808769,
    800370778,
    1517640426,
    3038506883,
    2201387884,
    4284921395,
    869020549,
    4073086051,
    1670472511,
    168038914,
    34079248,
    944346026,
    2861738553,
    2833440369,
    1910075823,
    3482175176,
    3355953166,
    2100482329,
    425990600,
    1888631625,
    1228491122,
    2595184601,
    3645102470,
    502870514,
    4075811523,
    1222355171,
    3819692875,
    716618075,
    1534155746,
    2450373768,
    2283440180,
    3358146202,
    2589104804,
    3192654630,
    647505453,
    4200906546,
    851980941,
    1249728944,
    2969219305,
    1792013033,
    3917736219,
    857634575,
    255594360,
    2797024213,
    3581138406,
    3122525312,
    2151317620,
    2086741950,
    3200433817,
    3733449677,
    3440626982,
    3832056116,
    886060221,
    1972384328,
    1211975802,
    618878207,
    4292607915,
    2415168890,
    2062908151,
    3929891984,
    2423951604,
    1052679519,
    1600217026,
    2688564512,
    545267741,
    3587182440,
    1757243495,
    1916062234,
    443030224,
    742504366,
    2927799833,
    1584758196,
    3035280585,
    430493268,
    1414354074,
    3845881747,
    2474021868,
    2856595234,
    579346957,
    3922223972,
    1686987783,
    318712561,
    4058247643,
    2733034611,
    1943106495,
    1512342034,
    306713232,
    1568700992,
    1075658810,
    672155656,
    136316992,
    3902510531,
    3274425174,
    2076565484,
    3969379379,
    2427145691,
    3679181718,
    526368929,
    2713624929,
    2198311309,
    2366541084,
    3380267069,
    1039416821,
    4046674839,
    2540083148,
    0,
    0,
    3565418959,
    3474706230,
    2270588459,
    732703557,
    3018645878,
    1992652439,
    2954487426,
    2184348260,
    2846959830,
    3598702334,
    2000077595,
    460069848,
    1534555317,
    3052320193,
    692305583,
    2944839441,
    3755220330,
    1790274167,
    228649552,
    1348292794,
    1284134725,
    1158235410,
    419117299,
    4092326859,
    4032867632,
    817901725,
    1958986991,
    4019973931,
    3279870527,
    1073496037,
    480954197,
    1430869394,
    274324386,
    2729615993,
    1707731434,
    3935300099,
    3972688485,
    1703503119,
    1751712698,
    3134372537,
    2472430127,
    800862053,
    3885862592,
    3223830606,
    2174836958,
    3730824894,
    1815673884,
    477109472,
    786908925,
    4258528699,
    1687822157,
    1294552402,
    3761862290,
    2456982244,
    3169516149,
    1976137103,
    504116742,
    102237744,
    2550771338,
    2316470820,
    1081691058,
    3002249977,
    1506903526,
    3871336035,
    907836942,
    238554736,
    1665066783,
    528228344,
    4156839266,
    1653957175,
    2746563284,
    3564623086,
    843940264,
    2828707881,
    4096873110,
    2523043524,
    988766969,
    4190370203,
    4137132997,
    3308504422,
    2974421029,
    630465845,
    548580185,
    1501125106,
    2920665220,
    2217378900,
    2816787826,
    1926591159,
    3715296313,
    971258325,
    1637357132,
    1278037082,
    1002214494,
    1583701706,
    2247139192,
    2029877479,
    3631277368,
    954218717,
    2248513676,
    2349501460,
    2998867921,
    3512979910,
    190309541,
    2779686209,
    1306108386,
    3803177539,
    4173483617,
    1637441839,
    1165705907,
    3019289585,
    2772579361,
    562307349,
    3592751260,
    2622135444,
    1715269150,
    511188720,
    1384538435,
    1125204770,
    4237537735,
    3342583670,
    736448508,
    4242013363,
    336077828,
    68158496,
    144892753,
    1364808114,
    3341755801,
    2573113788,
    3302629997,
    1839820111,
    958031117,
    221515112,
    904493562,
    4207934083,
    2225301983,
    3747340214,
    2617026942,
    2128969431,
    3024623908,
    613426237,
    3614899771,
    1005337541,
    1028364971,
    2878778161,
    3514953934,
    3458190910,
    1428330769,
    289673608,
    2298708879,
    2399571724,
    1805386830,
    1311067722,
    1366517431,
    3085350865,
    1623974123,
    3951815435,
    3430465852,
    1022377213,
    3206544769,
    2168357244,
    4264902804,
    2490012884,
    217259255,
    4160485355,
    1735334073,
    3118381473,
    1596361491,
    323752856,
    2623033644,
    749743229,
    3099264467,
    3547059158,
    1557368039,
    3887851371,
    3420207470,
    1856335447,
    4086672068,
    3291989102,
    252058371,
    51118872,
    330095702,
    1447384714,
    1233673796,
    1141720090,
    2667487359,
    2145484767,
    927959209,
    2845747489,
    2186569514,
    715663949,
    1835731643,
    3151412145,
    3802105793,
    3240345926,
    44495187,
    1397838754,
    2342875868,
    3696745646,
    655774475,
    187435864,
    3542548893,
    2639175068,
    3252169580,
    1823304775,
    4116882481,
    834941333,
    3119051636,
    1959621767,
    166794742,
    4143970019,
    1133268038,
    1174750730,
    642098604,
    2894769161,
    2534389129,
    2300479804,
    1143518228,
    340792480,
    1121958625,
    3785613659,
    1311548950,
    374871728,
    3530880826,
    988297933,
    3503425129,
    1773758831,
    756171017,
    153356616,
    2917193584,
    1893560487,
    1416720310,
    3068311257,
    3082624720,
    3496464590,
    2127025901,
    3985894715,
    3682984652,
    3424111662,
    1468295234,
    1108689450,
    3257740440,
    2556074164,
    240512420,
    2762646601,
    2286974248,
    681584733,
    834176604,
    1550671066,
    1072524280,
    4173854867,
    2752627334,
    2250409540
  ]), x = new Uint32Array([
    3229102296,
    404250648,
    95372838,
    589532195,
    2130284984,
    3334881222,
    326094331,
    3907553256,
    1285624779,
    2273781383,
    2841799953,
    3099122360,
    134545929,
    16843777,
    1114545677,
    1330585935,
    2918083739,
    909563958,
    1493455359,
    2795938470,
    3736975628,
    3537006546,
    4211537678,
    4126536693,
    4018205334,
    2038036857,
    1607392816,
    1869586799,
    4243537773,
    2442231441,
    2852627704,
    1381127506,
    670941255,
    1616944480,
    2306237749,
    3166489276,
    2899127095,
    2610648731,
    76284298,
    2391671438,
    1897225170,
    2745415331,
    1614551148,
    202125324,
    4287297156,
    2071720315,
    3051448960,
    892720181,
    3899210485,
    488469533,
    1397218739,
    3772819424,
    4138513185,
    3621223383,
    1592629660,
    3267506114,
    1838570563,
    774813742,
    1652201001,
    1263219019,
    2736906589,
    4278116350,
    2182524629,
    1465336151,
    2822843069,
    353719317,
    2679566056,
    2004337015,
    2783669906,
    926407735,
    2069288862,
    3857036261,
    2363040531,
    2678015647,
    3541564707,
    4042319856,
    1786745888,
    1246377290,
    2660608324,
    3671740378,
    4196774050,
    1482194264,
    113938383,
    3385394121,
    1435325052,
    690594857,
    1344410714,
    168437770,
    3780083536,
    2981232305,
    1763335625,
    2694888096,
    2145048084,
    1802219883,
    1554716633,
    2240097925,
    2171823932,
    3183333053,
    3526670991,
    1566402909,
    2152734864,
    269500432,
    4077122823,
    4109694964,
    381717469,
    3419081675,
    3989208275,
    1044314174,
    672205357,
    84218885,
    535219832,
    1734836583,
    1934874007,
    3840194532,
    633032194,
    656907303,
    844661363,
    1094785345,
    748489639,
    2341148299,
    1359041526,
    2812782247,
    3482647218,
    2105403773,
    3707451209,
    2509598357,
    2392829270,
    3638052824,
    2335239024,
    4227582971,
    594657741,
    4008615918,
    3348232379,
    2088562044,
    400804977,
    1717994854,
    2794366843,
    3722269661,
    3091934895,
    387406871,
    38178373,
    1195835719,
    2229018906,
    2661171870,
    516262356,
    3402239946,
    1972984408,
    757969965,
    2440651566,
    3217016511,
    941297215,
    117906439,
    19089324,
    2913832621,
    3928994992,
    1515877722,
    1823808495,
    2206414467,
    2248107702,
    859032627,
    1072875100,
    1667469667,
    269091858,
    33687554,
    959990163,
    2863305386,
    2947080926,
    1903286641,
    248483270,
    3368552392,
    3363648209,
    421094425,
    1919980091,
    1229535561,
    2258284383,
    3654894553,
    3273521457,
    4076007410,
    1263066024,
    3823348707,
    3794450105,
    1532719451,
    881987004,
    2290621064,
    2764581182,
    2593804954,
    767446027,
    640063526,
    2381997247,
    842188850,
    3913973081,
    2964388528,
    459984882,
    3924394985,
    2016616055,
    252656655,
    3869685555,
    3587535829,
    1958354420,
    2155887232,
    2575065383,
    3200172734,
    652117995,
    3452769229,
    3185862793,
    875876404,
    2054524978,
    1212693832,
    2871321428,
    4294958079,
    4153406605,
    2054878586,
    4108991844,
    2425387664,
    3258891933,
    1600086367,
    497041469,
    539000864,
    1742065679,
    1751694696,
    3497145546,
    437938202,
    422330807,
    2930672302,
    3378410877,
    3031755444,
    2585372878,
    1414810964,
    3974445951,
    2475914899,
    229262383,
    572688418,
    132761699,
    1684311396,
    3675455274,
    4059161585,
    3215124172,
    1936970099,
    2421826690,
    303187986,
    979206266,
    1077943616,
    1076367432,
    134750216,
    1458084757,
    3284347843,
    863749599,
    3974928364,
    2526063437,
    3688582107,
    1629446080,
    2711731873,
    478349201,
    2374831757,
    4123622088,
    1027470397,
    3438359387,
    2543281815,
    0,
    0,
    919897081,
    3486456783,
    1166497390,
    724282411,
    2545151201,
    1987495286,
    1689262566,
    2189570690,
    4272533800,
    3604381654,
    3631691459,
    454781979,
    3243997044,
    3048599221,
    287916990,
    2947516079,
    2011157533,
    1785378154,
    3121455338,
    1347444048,
    307006039,
    1162152261,
    3407412024,
    4092849139,
    2649776301,
    808501296,
    729072580,
    4025457647,
    3854794458,
    1061157951,
    2451352263,
    1431652693,
    2031114715,
    2728571554,
    57002473,
    3941240810,
    267176554,
    1701153125,
    3110627587,
    3132805818,
    1704156746,
    791657519,
    1323801998,
    3233818560,
    3196166496,
    3739115486,
    3765188860,
    471625756,
    3140413254,
    4261270525,
    1382324767,
    1296902477,
    3839900022,
    2459071122,
    2411522810,
    1970653557,
    807275574,
    101062662,
    613943726,
    2324304522,
    4181752139,
    2998071986,
    1666830725,
    3873882086,
    1882594430,
    235812878,
    4167253735,
    522157087,
    938984533,
    1650627938,
    4003706170,
    3570694100,
    691162497,
    2829621928,
    3304337746,
    2526438038,
    2604330850,
    4193895417,
    1727436707,
    3318035397,
    900811280,
    623219749,
    4062229163,
    1499035993,
    1420694992,
    2223254148,
    3081233605,
    1920128370,
    3588059884,
    960095289,
    1516345366,
    1280060748,
    3392912532,
    1583244638,
    3884314783,
    2021195128,
    3721949413,
    943251512,
    344327576,
    2357987980,
    3333603095,
    3520160721,
    1091262436,
    2779098789,
    1129175457,
    3806506978,
    804831822,
    1633786209,
    4047862594,
    3014915763,
    363151924,
    555844641,
    2497062152,
    2627488412,
    4033232110,
    505313310,
    575833697,
    1128468803,
    1996264369,
    3351722951,
    3005998415,
    4244428796,
    538183716,
    67375108,
    2986910435,
    1364285777,
    3167170341,
    2576965273,
    1338300962,
    1835903341,
    1748572773,
    218969101,
    2201348473,
    4210741242,
    3062145897,
    3755957215,
    3617324201,
    2122245502,
    1035225113,
    606375972,
    3319232254,
    993782843,
    826100634,
    2880149163,
    1053917680,
    3469615054,
    2287280793,
    286344209,
    210305923,
    2408515215,
    1248566276,
    1313744206,
    3511776102,
    3082282679,
    190893024,
    3958082539,
    4258035905,
    1010626620,
    2092900349,
    2172731009,
    3573429568,
    2492754580,
    3943494428,
    4160224247,
    2707910424,
    3115966137,
    2556372619,
    320031763,
    2107398225,
    741126188,
    3602430725,
    3553848275,
    1801245580,
    3890723815,
    1472977977,
    1852745070,
    1861457322,
    3301193668,
    403637787,
    50531331,
    2316545244,
    1448494422,
    441026654,
    1145310532,
    3751739040,
    2139087231,
    557272968,
    2846465705,
    1300386919,
    707438634,
    2976738058,
    3149649595,
    1189257095,
    3250660289,
    2718082801,
    1397969235,
    2928387442,
    3705427932,
    1478956627,
    185281547,
    2631083777,
    2644332189,
    1203886123,
    1819061612,
    2515886756,
    825345073,
    2277107955,
    1953811828,
    3809079573,
    4143382518,
    172198988,
    1178993990,
    153503141,
    2896988844,
    1016532917,
    2307464841,
    2688821428,
    336875540,
    1531109306,
    3789661153,
    2957913254,
    370563094,
    3453121783,
    976939066,
    1875956230,
    1768536425,
    1210913345,
    151593993,
    2813190359,
    1886444912,
    3646189935,
    3065438902,
    3468147998,
    3503318992,
    998164438,
    3991770093,
    786138594,
    3435927500,
    710378600,
    1111627074,
    3032624428,
    2560121496,
    1225676269,
    2762255012,
    1569214581,
    673751080,
    3660691590,
    1549561180,
    2470440299,
    4177053688,
    1151603138,
    2256937606
  ]), b = new Uint32Array([
    415266864,
    3625457760,
    587575110,
    639837068,
    3330210193,
    3100034623,
    3893587917,
    4226345095,
    2269946131,
    3414656806,
    3098108525,
    297318618,
    17302786,
    151060740,
    1329753758,
    223301409,
    917368428,
    2604021464,
    2790851665,
    4289111714,
    3537812921,
    215143023,
    4126869239,
    251000307,
    2045739250,
    2524543481,
    1868549854,
    812609441,
    2449272639,
    1838256510,
    1386874788,
    4166144597,
    1613233600,
    1197498525,
    3163125349,
    901561546,
    2611793195,
    932944726,
    2382662657,
    2324598274,
    2742097243,
    3533939638,
    207633432,
    1812728880,
    2080344822,
    2222685169,
    901112170,
    2150970836,
    501770554,
    4112326004,
    3763554269,
    3017859239,
    3623267507,
    567793531,
    3261001113,
    2630009391,
    778933852,
    1127100088,
    1264745110,
    692800305,
    4272103905,
    1576992479,
    1468143278,
    3579270977,
    363348266,
    3172275540,
    2006955758,
    3900143553,
    933620590,
    2453092316,
    3850065623,
    2665866675,
    2676807971,
    329228102,
    4040366077,
    602992871,
    1248493460,
    541739573,
    3667826089,
    1155193423,
    1492788656,
    2723698813,
    3372665487,
    3486107907,
    693472594,
    2083072420,
    173023764,
    1510607400,
    2984333183,
    1353822718,
    2691242589,
    3382747322,
    1803541206,
    342584241,
    2237442839,
    3649406254,
    3179377511,
    1019067854,
    1574057146,
    2405260649,
    276844576,
    2416971840,
    4109566965,
    133494007,
    3407265931,
    3721120523,
    1055770236,
    3544071928,
    86511882,
    755303700,
    1730143950,
    2020042625,
    3832763349,
    2548360375,
    656784206,
    36120476,
    1093818498,
    1933656345,
    2334956811,
    2810940182,
    2807103827,
    4138182566,
    2110756090,
    2994568681,
    2514287415,
    1234539886,
    3633225645,
    1457051719,
    4220203243,
    1895562187,
    3995300289,
    3454987935,
    2093453816,
    3145497837,
    1712841676,
    1902536325,
    3718680231,
    2078137683,
    397953838,
    2937526108,
    1191331470,
    1162299137,
    2659507233,
    446602818,
    3391014281,
    3570059791,
    762681690,
    1479355828,
    3213982051,
    784318406,
    121117454,
    1057425180,
    2902532935,
    2897063310,
    1525297076,
    2958711413,
    2204939547,
    4018373430,
    864419686,
    3056808908,
    1665135302,
    1550017425,
    34605572,
    302121480,
    2855876681,
    2477435538,
    1907337442,
    3731976665,
    3356413837,
    3335047175,
    432569650,
    3508083044,
    1232236690,
    994658617,
    3649477295,
    1608112451,
    4072873465,
    838005487,
    3813361883,
    2833507243,
    1541548726,
    3109772145,
    2285146637,
    3163064346,
    2594490409,
    1050319442,
    640532044,
    187049624,
    848165476,
    3207738056,
    2968078973,
    1504751866,
    3910888143,
    4075415939,
    259535646,
    1997475644,
    3588662967,
    869651827,
    2155133469,
    4102062138,
    3197729889,
    666812098,
    3441876615,
    3956133139,
    884860008,
    2301899984,
    1215985040,
    843597885,
    4289406179,
    1426063323,
    2063044596,
    2373614325,
    2431969853,
    1687195770,
    1606565566,
    2640273249,
    538812480,
    1025515648,
    1751635408,
    258500797,
    449868340,
    3390708328,
    2920885313,
    3081678466,
    3033095797,
    2108994794,
    1419385256,
    3461633101,
    2481775931,
    2140377974,
    571320900,
    790766216,
    1678240200,
    1667523725,
    4057666303,
    720499171,
    1941938918,
    3430118353,
    311450148,
    2182222408,
    1077566848,
    2051031069,
    138422288,
    1208485920,
    3277252763,
    2512634667,
    3962796997,
    3756846231,
    3684077739,
    1306254155,
    2707496799,
    3231818174,
    2367456007,
    2441973006,
    1039518074,
    3359456756,
    2546790707,
    1536661350,
    0,
    0,
    3476477059,
    4191145755,
    725976918,
    1848322988,
    1989653484,
    3782637253,
    2187636761,
    3867312690,
    3607013809,
    685168255,
    467171126,
    3273333612,
    3049347959,
    1958065646,
    2937137475,
    3199184774,
    1786240980,
    493513397,
    1354370464,
    3931131997,
    1158827146,
    1464157449,
    4090173691,
    955511787,
    815657056,
    2905616576,
    4012602563,
    3304058779,
    1072022398,
    3661578236,
    1435638954,
    3344258377,
    2725843033,
    3684868786,
    3926091209,
    3924486799,
    1695542474,
    1785030025,
    3132713065,
    62569170,
    795186014,
    1244606396,
    3226396573,
    2394996775,
    3737026977,
    1625218655,
    484469816,
    4229700720,
    4256902887,
    1191050707,
    1297245338,
    525159721,
    2464473145,
    1989317234,
    1972354282,
    4202001865,
    103816716,
    906364440,
    2317654025,
    2928314898,
    3002679417,
    1270002418,
    3865270737,
    2246502079,
    242234908,
    2114850360,
    536372030,
    3877576572,
    1647835076,
    1432511125,
    3572409269,
    987026551,
    2821272141,
    2175314074,
    2529489969,
    1385600610,
    4187699951,
    1660549571,
    3311859351,
    2747647283,
    624275786,
    270869908,
    1509040306,
    2874759545,
    2220142101,
    3498345514,
    1924638692,
    3312612053,
    970317170,
    3963173348,
    1280991640,
    374098989,
    1590311868,
    2489212517,
    2028439024,
    2675472637,
    954062960,
    3845667040,
    2350155269,
    2559347722,
    3519460031,
    399626595,
    2772503383,
    3836061102,
    3796061657,
    2716000943,
    1630533826,
    1315004825,
    3018933627,
    1119073270,
    555066690,
    874586500,
    2626999845,
    144481354,
    519071292,
    3994951288,
    1126322822,
    1631798033,
    3346463891,
    2982659899,
    4239600613,
    1341979863,
    69211144,
    604242960,
    1370622114,
    3813757273,
    2579285807,
    630823262,
    1833944282,
    577596841,
    224934170,
    1695354164,
    4202903017,
    2046491343,
    3753280675,
    1776279387,
    2128059388,
    2843639525,
    608023624,
    421799056,
    1002821494,
    4265294828,
    2872130891,
    2594941846,
    3460223361,
    4040085023,
    294147362,
    2568032580,
    2399963395,
    2207223558,
    1313500060,
    72240677,
    3083948403,
    1723316198,
    3943391435,
    3773557643,
    1023265912,
    3241950448,
    2172436255,
    4253122878,
    2496986677,
    1083479146,
    4159376627,
    486012923,
    3114362735,
    414824926,
    328752934,
    2333283148,
    746429528,
    1361849520,
    3554064571,
    97768299,
    3882573011,
    2364008379,
    1851247580,
    963538597,
    3295605653,
    2865022007,
    51908358,
    453182220,
    1451889580,
    3696645701,
    1142573448,
    1581532173,
    2145361662,
    2692710369,
    2837526351,
    2292820382,
    709722708,
    1730816680,
    3148967275,
    180075478,
    3242648223,
    2277622051,
    1403126438,
    4048769873,
    3702426533,
    1927076951,
    190326550,
    1393232684,
    2644300583,
    27106638,
    1816642008,
    728525997,
    831911266,
    2754687428,
    1955052008,
    4084495565,
    4142074353,
    368506623,
    1175077772,
    1279673861,
    2886280773,
    2779557002,
    2302449423,
    3045689630,
    346047528,
    3021214800,
    3780854495,
    3135365539,
    380653100,
    2786465368,
    986567284,
    4147788520,
    1768935634,
    107571641,
    155725074,
    1091111204,
    1890037216,
    3614470365,
    3067696241,
    1874245346,
    3503208381,
    517001319,
    3980099271,
    3605917075,
    3425622917,
    3805072407,
    1110071172,
    1749172757,
    2561983021,
    748197978,
    2756251221,
    3986990250,
    677218384,
    1965566112,
    1557803448,
    2254199917,
    4170399725,
    1811478727,
    2252645393,
    3263596066
  ]), g = new Uint32Array([
    1612234872,
    819468312,
    2351105455,
    1176904483,
    1069973241,
    2444805830,
    2280133487,
    3455838440,
    646401185,
    332105607,
    3669535074,
    1829877944,
    67176453,
    34144513,
    558842478,
    2651672399,
    3627462126,
    1822111286,
    2728810756,
    1375708838,
    1876090557,
    3104625362,
    4092984070,
    4144952821,
    4185517952,
    4069947769,
    2708430798,
    3727716207,
    2123496687,
    1064145297,
    1431480839,
    2767737426,
    2640324605,
    3225903200,
    3401353590,
    1698020540,
    1453042893,
    725064603,
    42861708,
    25857678,
    3064164629,
    1540531107,
    806117436,
    409734156,
    4051435402,
    4135877499,
    3560289761,
    1786787125,
    1948117097,
    989142301,
    2816496455,
    3719553248,
    2077750956,
    3005339607,
    801267437,
    2577187522,
    3090050454,
    1547906606,
    827023994,
    2519288651,
    3758007073,
    3781033726,
    1096253974,
    2933217111,
    1410705473,
    717034773,
    3245842358,
    4008212343,
    3694634475,
    1855076151,
    3018160982,
    3617514981,
    1184861401,
    588488607,
    3891319575,
    4246991088,
    894069375,
    2485144138,
    1339727509,
    2839861978,
    2102983205,
    2963429464,
    63506122,
    2412759497,
    2754172301,
    1383868713,
    671764514,
    341445130,
    4273070415,
    2135994801,
    3131074842,
    1573494944,
    2976612314,
    3591662443,
    780491947,
    400131461,
    3468525939,
    1732033981,
    1767756340,
    3129957725,
    1074823248,
    546312208,
    4160025347,
    4110939380,
    197859008,
    2346568651,
    4164873670,
    2094218814,
    335882257,
    170722565,
    2171019238,
    3463997287,
    3085202259,
    3583501540,
    2619811259,
    1308763943,
    423703128,
    2188591425,
    378219677,
    195529611,
    2795983105,
    1408673703,
    3917336468,
    4206001533,
    1855315195,
    927569301,
    1205374623,
    2908149976,
    3422260016,
    3950050299,
    2683183985,
    3251498734,
    3984377745,
    4173036668,
    2238060515,
    3429983846,
    1407035022,
    2809912797,
    1545058379,
    783226647,
    21430854,
    2386904903,
    1117684956,
    555392670,
    264904389,
    2312424138,
    3022878105,
    1515728173,
    3334443385,
    1664008127,
    470235163,
    239011591,
    2393702691,
    1202498989,
    1968892463,
    3031456346,
    914582709,
    468681603,
    3425928703,
    1723216691,
    2439200754,
    3327943523,
    134352906,
    68289026,
    2460629304,
    1234414250,
    3648106408,
    3806228849,
    130551503,
    2378614984,
    1679411325,
    852564249,
    961114736,
    2453358921,
    1138329242,
    2942294489,
    4025664285,
    4180800242,
    2883799880,
    3685278691,
    1901847082,
    3065600859,
    445133970,
    230459528,
    1385866440,
    691968666,
    2552638910,
    1275799078,
    3358756346,
    1690251826,
    4205898058,
    2103029936,
    2213092202,
    3488803305,
    1007646771,
    511119119,
    1943398054,
    3073627605,
    981497018,
    502562944,
    3267271036,
    1629994686,
    332211934,
    2280377805,
    3493117412,
    1753822260,
    1028160117,
    2419214408,
    3690965796,
    3813998591,
    4118476687,
    4102912634,
    2056320234,
    1030000784,
    1633665598,
    3197984607,
    2149588384,
    1077747744,
    3177736149,
    3490670696,
    1746587762,
    885660186,
    2192447788,
    1102556846,
    3937716574,
    1971172532,
    1297390105,
    2832094292,
    1989405925,
    998216595,
    2283933098,
    1143939618,
    2372143081,
    3361956964,
    3824278290,
    4281004529,
    3514023842,
    3872158579,
    1209176154,
    612504082,
    490748509,
    2155495488,
    537411624,
    273156104,
    734222056,
    2610283459,
    2548839291,
    3319786732,
    1272682128,
    2874006491,
    3198247199,
    1606459809,
    244128899,
    126979469,
    4097701321,
    2059943229,
    1721224433,
    861640599,
    0,
    0,
    466564820,
    2214186959,
    2888516999,
    1450060587,
    3312883635,
    3974198902,
    847406256,
    434537090,
    2144796329,
    2972243670,
    1813764215,
    918756123,
    4004888923,
    2004137397,
    2259620137,
    1136570287,
    3043653599,
    3558697578,
    1565571597,
    2699710544,
    155521612,
    2320975173,
    3958623e3,
    4214813683,
    3224411632,
    1621962800,
    2616142708,
    3284463599,
    4232046019,
    2128232255,
    1230344732,
    2865190229,
    2996992272,
    1507566242,
    2414478181,
    3387550442,
    2305101804,
    3395970405,
    3535452520,
    1761852090,
    3157222803,
    1581920047,
    666914535,
    2643378368,
    1608433281,
    2707480286,
    1880940652,
    956046364,
    3556621102,
    3880189437,
    692933220,
    2585742669,
    1922229472,
    964072082,
    3379924924,
    3942282613,
    403058718,
    204867078,
    311043224,
    162433674,
    4071815488,
    2035004082,
    3219546969,
    3515213542,
    940470326,
    478023182,
    2082469987,
    1055334175,
    2506242039,
    3293930082,
    2010443427,
    3040531668,
    2594711858,
    1300342952,
    1654047988,
    827496086,
    3287915322,
    4016241145,
    868574966,
    2544092613,
    2485466545,
    1242572069,
    2035937824,
    2997573977,
    713315502,
    365986948,
    3581065127,
    3838145138,
    3828995549,
    1928083769,
    759978593,
    2551598156,
    1700710971,
    3163840094,
    4252559237,
    4036982904,
    3761823192,
    1894070328,
    176952454,
    93883532,
    1674692274,
    3206009297,
    2930065675,
    1474602405,
    2950841165,
    3651265250,
    2573283320,
    3259916641,
    4138987845,
    2067968947,
    2216760741,
    1110712609,
    1251775702,
    621321372,
    2015293542,
    1022238238,
    289612370,
    2254521155,
    1002927868,
    2477901767,
    3623662379,
    3847224572,
    268705812,
    136578052,
    1498526216,
    2732806481,
    1587133639,
    790993305,
    2842513348,
    3659689325,
    873293881,
    442830093,
    3489301301,
    3917085434,
    1541387908,
    2741624799,
    3850295195,
    4238966398,
    2418294196,
    1209607204,
    3963340247,
    1996372795,
    2527801661,
    1268427691,
    533610193,
    2180042446,
    1141999701,
    580456721,
    110038153,
    58953615,
    625887851,
    2617527886,
    3870806353,
    1936111543,
    2347436896,
    3420515307,
    4030528972,
    2025929788,
    1048673471,
    536707457,
    1788138750,
    893424788,
    4227328780,
    4078761975,
    3736707431,
    1863891385,
    1276352607,
    646648595,
    2955705756,
    1481714732,
    1809045176,
    3137721299,
    3152505692,
    3549226983,
    2775472075,
    3694751342,
    935620339,
    2510996676,
    201529359,
    102433539,
    1163299347,
    2900121174,
    222566985,
    2287879236,
    3783253918,
    4271931263,
    2661884215,
    1334356393,
    2821344642,
    1416047146,
    3602624877,
    1795865531,
    599869154,
    2676474305,
    1364435458,
    2800833363,
    1474080395,
    2775768284,
    738940967,
    374541067,
    1318952147,
    654417309,
    2909554625,
    3626724460,
    3291583989,
    1654927665,
    3446966201,
    3908269172,
    4294370057,
    4044748534,
    88476227,
    2353808966,
    2326530342,
    1168485548,
    512310423,
    263555465,
    1343529028,
    682890260,
    2749455170,
    3753566689,
    1477881934,
    749082134,
    3896167890,
    1962359354,
    3110694864,
    3523635561,
    604588077,
    306252041,
    3715147693,
    3772215408,
    3803634004,
    1903146678,
    1741737655,
    3172913360,
    2481798014,
    3352751597,
    399257307,
    2246233292,
    356657751,
    2221425218,
    1519957186,
    757897368,
    2862893326,
    1441637540,
    2686999944,
    1349855272,
    1834801713,
    3095813212,
    3354956607,
    3983276280,
    579224740,
    297961094
  ]), w = new Uint32Array([
    408950976,
    2016466968,
    596386565,
    2940610083,
    3326068350,
    4187076806,
    3901220883,
    1875770344,
    2267449164,
    2702429063,
    3101341865,
    1651315128,
    17039624,
    84019457,
    1327583042,
    1855851855,
    920139437,
    4000095030,
    2795677273,
    72482726,
    3530543838,
    3183021266,
    4126406139,
    116854517,
    2046392815,
    2163381881,
    1872850783,
    3470667887,
    2440991228,
    4013911441,
    1381323434,
    128251986,
    1620926503,
    4257236832,
    3167403145,
    1986344380,
    2606144428,
    3442161563,
    2382532100,
    2348911246,
    2746655601,
    358339235,
    204475488,
    1008233484,
    2079423487,
    2331411579,
    903099829,
    3781853237,
    494149096,
    1765471517,
    3769098323,
    1205711840,
    3615217654,
    2897420759,
    3257909854,
    3986267330,
    783822445,
    2522628910,
    1261521762,
    2056661323,
    4276092579,
    568417790,
    1463900034,
    380556631,
    357832104,
    1093319957,
    2009167775,
    3069110391,
    937179045,
    3949892151,
    3853772155,
    1456971493,
    2672205708,
    3642954655,
    4041732307,
    402465776,
    1245006442,
    2140414026,
    3662666398,
    2510898394,
    1484609786,
    632332888,
    3372468486,
    3398422473,
    698624341,
    2370993193,
    170396240,
    571759114,
    2986258913,
    1333743793,
    2696585321,
    442354080,
    1806789503,
    3671463019,
    2234418524,
    2870466949,
    3184442753,
    1936145597,
    1567186386,
    884641629,
    272633984,
    1344311312,
    4109890803,
    66390004,
    3406547734,
    3230391755,
    1056456429,
    3330069310,
    85198120,
    285879557,
    1736533791,
    3872290919,
    3837256819,
    1406506980,
    664545061,
    3142451751,
    1092174130,
    1484944193,
    2333510444,
    2634786699,
    2812716881,
    22279847,
    2112454095,
    2499457661,
    2507052508,
    4214704533,
    3628587150,
    2678937304,
    4224449419,
    820736251,
    4003458595,
    1908526574,
    2095938759,
    2448997244,
    1720018455,
    3821826406,
    3713260966,
    2393340893,
    391911352,
    1261350679,
    1191266050,
    1183728967,
    2655166084,
    3693157022,
    3390032414,
    3314144458,
    766782837,
    2572834861,
    3217473425,
    2036543167,
    119277368,
    453918471,
    2911808769,
    591899821,
    1517640426,
    800370778,
    2201387884,
    3038506883,
    869020549,
    4284921395,
    1670472511,
    4073086051,
    34079248,
    168038914,
    2861738553,
    944346026,
    1910075823,
    2833440369,
    3355953166,
    3482175176,
    425990600,
    2100482329,
    1228491122,
    1888631625,
    3645102470,
    2595184601,
    4075811523,
    502870514,
    3819692875,
    1222355171,
    1534155746,
    716618075,
    2283440180,
    2450373768,
    2589104804,
    3358146202,
    647505453,
    3192654630,
    851980941,
    4200906546,
    2969219305,
    1249728944,
    3917736219,
    1792013033,
    255594360,
    857634575,
    3581138406,
    2797024213,
    2151317620,
    3122525312,
    3200433817,
    2086741950,
    3440626982,
    3733449677,
    886060221,
    3832056116,
    1211975802,
    1972384328,
    4292607915,
    618878207,
    2062908151,
    2415168890,
    2423951604,
    3929891984,
    1600217026,
    1052679519,
    545267741,
    2688564512,
    1757243495,
    3587182440,
    443030224,
    1916062234,
    2927799833,
    742504366,
    3035280585,
    1584758196,
    1414354074,
    430493268,
    2474021868,
    3845881747,
    579346957,
    2856595234,
    1686987783,
    3922223972,
    4058247643,
    318712561,
    1943106495,
    2733034611,
    306713232,
    1512342034,
    1075658810,
    1568700992,
    136316992,
    672155656,
    3274425174,
    3902510531,
    3969379379,
    2076565484,
    3679181718,
    2427145691,
    2713624929,
    526368929,
    2366541084,
    2198311309,
    1039416821,
    3380267069,
    2540083148,
    4046674839,
    0,
    0,
    3474706230,
    3565418959,
    732703557,
    2270588459,
    1992652439,
    3018645878,
    2184348260,
    2954487426,
    3598702334,
    2846959830,
    460069848,
    2000077595,
    3052320193,
    1534555317,
    2944839441,
    692305583,
    1790274167,
    3755220330,
    1348292794,
    228649552,
    1158235410,
    1284134725,
    4092326859,
    419117299,
    817901725,
    4032867632,
    4019973931,
    1958986991,
    1073496037,
    3279870527,
    1430869394,
    480954197,
    2729615993,
    274324386,
    3935300099,
    1707731434,
    1703503119,
    3972688485,
    3134372537,
    1751712698,
    800862053,
    2472430127,
    3223830606,
    3885862592,
    3730824894,
    2174836958,
    477109472,
    1815673884,
    4258528699,
    786908925,
    1294552402,
    1687822157,
    2456982244,
    3761862290,
    1976137103,
    3169516149,
    102237744,
    504116742,
    2316470820,
    2550771338,
    3002249977,
    1081691058,
    3871336035,
    1506903526,
    238554736,
    907836942,
    528228344,
    1665066783,
    1653957175,
    4156839266,
    3564623086,
    2746563284,
    2828707881,
    843940264,
    2523043524,
    4096873110,
    4190370203,
    988766969,
    3308504422,
    4137132997,
    630465845,
    2974421029,
    1501125106,
    548580185,
    2217378900,
    2920665220,
    1926591159,
    2816787826,
    971258325,
    3715296313,
    1278037082,
    1637357132,
    1583701706,
    1002214494,
    2029877479,
    2247139192,
    954218717,
    3631277368,
    2349501460,
    2248513676,
    3512979910,
    2998867921,
    2779686209,
    190309541,
    3803177539,
    1306108386,
    1637441839,
    4173483617,
    3019289585,
    1165705907,
    562307349,
    2772579361,
    2622135444,
    3592751260,
    511188720,
    1715269150,
    1125204770,
    1384538435,
    3342583670,
    4237537735,
    4242013363,
    736448508,
    68158496,
    336077828,
    1364808114,
    144892753,
    2573113788,
    3341755801,
    1839820111,
    3302629997,
    221515112,
    958031117,
    4207934083,
    904493562,
    3747340214,
    2225301983,
    2128969431,
    2617026942,
    613426237,
    3024623908,
    1005337541,
    3614899771,
    2878778161,
    1028364971,
    3458190910,
    3514953934,
    289673608,
    1428330769,
    2399571724,
    2298708879,
    1311067722,
    1805386830,
    3085350865,
    1366517431,
    3951815435,
    1623974123,
    1022377213,
    3430465852,
    2168357244,
    3206544769,
    2490012884,
    4264902804,
    4160485355,
    217259255,
    3118381473,
    1735334073,
    323752856,
    1596361491,
    749743229,
    2623033644,
    3547059158,
    3099264467,
    3887851371,
    1557368039,
    1856335447,
    3420207470,
    3291989102,
    4086672068,
    51118872,
    252058371,
    1447384714,
    330095702,
    1141720090,
    1233673796,
    2145484767,
    2667487359,
    2845747489,
    927959209,
    715663949,
    2186569514,
    3151412145,
    1835731643,
    3240345926,
    3802105793,
    1397838754,
    44495187,
    3696745646,
    2342875868,
    187435864,
    655774475,
    2639175068,
    3542548893,
    1823304775,
    3252169580,
    834941333,
    4116882481,
    1959621767,
    3119051636,
    4143970019,
    166794742,
    1174750730,
    1133268038,
    2894769161,
    642098604,
    2300479804,
    2534389129,
    340792480,
    1143518228,
    3785613659,
    1121958625,
    374871728,
    1311548950,
    988297933,
    3530880826,
    1773758831,
    3503425129,
    153356616,
    756171017,
    1893560487,
    2917193584,
    3068311257,
    1416720310,
    3496464590,
    3082624720,
    3985894715,
    2127025901,
    3424111662,
    3682984652,
    1108689450,
    1468295234,
    2556074164,
    3257740440,
    2762646601,
    240512420,
    681584733,
    2286974248,
    1550671066,
    834176604,
    4173854867,
    1072524280,
    2250409540,
    2752627334
  ]);
  class I {
    constructor() {
      this.state = new Uint32Array(16), this.msg = new Uint32Array(16), this.block = Buffer.alloc(64), this.size = t;
    }
    init() {
      for (let _ = 0; _ < 16; _++)
        this.state[_] = 0;
      return this.size = 0, this;
    }
    update(_) {
      return r(Buffer.isBuffer(_)), this._update(_, _.length), this;
    }
    final() {
      return this._final(Buffer.alloc(64));
    }
    _update(_, q) {
      r(this.size !== t, "Context is not initialized.");
      let U = this.size & 63, z = 0;
      if (this.size += q, U > 0) {
        let E = 64 - U;
        if (E > q && (E = q), _.copy(this.block, U, z, z + E), U += E, q -= E, z += E, U < 64)
          return;
        this._transform(this.block, 0);
      }
      for (; q >= 64; )
        this._transform(_, z), z += 64, q -= 64;
      q > 0 && _.copy(this.block, 0, z, z + q);
    }
    _final(_) {
      r(this.size !== t, "Context is not initialized.");
      const q = this.size & 63, U = this.size * 8;
      y(i, U * (1 / 4294967296) >>> 0, 24), y(i, U >>> 0, 28), this._update(n, 1 + (95 - q & 63)), this._update(i, 32);
      for (let z = 0; z < 16; z++)
        y(_, this.state[z], z * 4), this.state[z] = 0;
      for (let z = 0; z < 16; z++)
        this.msg[z] = 0;
      for (let z = 0; z < 64; z++)
        this.block[z] = 0;
      return this.size = t, _;
    }
    _transform(_, q) {
      const U = this.msg;
      for (let k = 0; k < 16; k++)
        U[k] = B(_, q + k * 4);
      const z = new Uint32Array(16), E = new Uint32Array(16), H = new Uint32Array(16);
      for (let k = 0; k < 16; k++)
        z[k] = this.state[k], H[k] = U[k] ^ z[k];
      for (let k = 1; k < 10 + 1; k++) {
        for (let V = 0; V < 8; V++)
          E[V * 2 + 0] = 0 ^ o[(z[(0 + V) % 8 * 2 + 0] >>> 24 & 255) * 2 + 0] ^ d[(z[(7 + V) % 8 * 2 + 0] >>> 16 & 255) * 2 + 0] ^ l[(z[(6 + V) % 8 * 2 + 0] >>> 8 & 255) * 2 + 0] ^ h[(z[(5 + V) % 8 * 2 + 0] >>> 0 & 255) * 2 + 0] ^ x[(z[(4 + V) % 8 * 2 + 1] >>> 24 & 255) * 2 + 0] ^ b[(z[(3 + V) % 8 * 2 + 1] >>> 16 & 255) * 2 + 0] ^ g[(z[(2 + V) % 8 * 2 + 1] >>> 8 & 255) * 2 + 0] ^ w[(z[(1 + V) % 8 * 2 + 1] >>> 0 & 255) * 2 + 0] ^ (V === 0 ? c[k * 2 + 0] : 0), E[V * 2 + 1] = 0 ^ o[(z[(0 + V) % 8 * 2 + 0] >>> 24 & 255) * 2 + 1] ^ d[(z[(7 + V) % 8 * 2 + 0] >>> 16 & 255) * 2 + 1] ^ l[(z[(6 + V) % 8 * 2 + 0] >>> 8 & 255) * 2 + 1] ^ h[(z[(5 + V) % 8 * 2 + 0] >>> 0 & 255) * 2 + 1] ^ x[(z[(4 + V) % 8 * 2 + 1] >>> 24 & 255) * 2 + 1] ^ b[(z[(3 + V) % 8 * 2 + 1] >>> 16 & 255) * 2 + 1] ^ g[(z[(2 + V) % 8 * 2 + 1] >>> 8 & 255) * 2 + 1] ^ w[(z[(1 + V) % 8 * 2 + 1] >>> 0 & 255) * 2 + 1] ^ (V === 0 ? c[k * 2 + 1] : 0);
        for (let V = 0; V < 16; V++)
          z[V] = E[V];
        for (let V = 0; V < 8; V++)
          E[V * 2 + 0] = 0 ^ o[(H[(0 + V) % 8 * 2 + 0] >>> 24 & 255) * 2 + 0] ^ d[(H[(7 + V) % 8 * 2 + 0] >>> 16 & 255) * 2 + 0] ^ l[(H[(6 + V) % 8 * 2 + 0] >>> 8 & 255) * 2 + 0] ^ h[(H[(5 + V) % 8 * 2 + 0] >>> 0 & 255) * 2 + 0] ^ x[(H[(4 + V) % 8 * 2 + 1] >>> 24 & 255) * 2 + 0] ^ b[(H[(3 + V) % 8 * 2 + 1] >>> 16 & 255) * 2 + 0] ^ g[(H[(2 + V) % 8 * 2 + 1] >>> 8 & 255) * 2 + 0] ^ w[(H[(1 + V) % 8 * 2 + 1] >>> 0 & 255) * 2 + 0] ^ z[V * 2 + 0], E[V * 2 + 1] = 0 ^ o[(H[(0 + V) % 8 * 2 + 0] >>> 24 & 255) * 2 + 1] ^ d[(H[(7 + V) % 8 * 2 + 0] >>> 16 & 255) * 2 + 1] ^ l[(H[(6 + V) % 8 * 2 + 0] >>> 8 & 255) * 2 + 1] ^ h[(H[(5 + V) % 8 * 2 + 0] >>> 0 & 255) * 2 + 1] ^ x[(H[(4 + V) % 8 * 2 + 1] >>> 24 & 255) * 2 + 1] ^ b[(H[(3 + V) % 8 * 2 + 1] >>> 16 & 255) * 2 + 1] ^ g[(H[(2 + V) % 8 * 2 + 1] >>> 8 & 255) * 2 + 1] ^ w[(H[(1 + V) % 8 * 2 + 1] >>> 0 & 255) * 2 + 1] ^ z[V * 2 + 1];
        for (let V = 0; V < 16; V++)
          H[V] = E[V];
      }
      for (let k = 0; k < 16; k++)
        this.state[k] ^= H[k] ^ U[k];
    }
    static hash() {
      return new I();
    }
    static hmac() {
      return new e(I, 64);
    }
    static digest(_) {
      return I.ctx.init().update(_).final();
    }
    static root(_, q) {
      return r(Buffer.isBuffer(_) && _.length === 64), r(Buffer.isBuffer(q) && q.length === 64), I.ctx.init().update(_).update(q).final();
    }
    static multi(_, q, U) {
      const { ctx: z } = I;
      return z.init(), z.update(_), z.update(q), U && z.update(U), z.final();
    }
    static mac(_, q) {
      return I.hmac().init(q).update(_).final();
    }
  }
  I.native = 0, I.id = "WHIRLPOOL", I.size = 64, I.bits = 512, I.blockSize = 64, I.zero = Buffer.alloc(64, 0), I.ctx = new I();
  function B(A, _) {
    return A[_++] * 16777216 + A[_++] * 65536 + A[_++] * 256 + A[_];
  }
  function y(A, _, q) {
    return A[q++] = _ >>> 24, A[q++] = _ >>> 16, A[q++] = _ >>> 8, A[q++] = _, q;
  }
  return yd = I, yd;
}
/*!
 * whirlpool.js - whirlpool implementation for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var Sd, n6;
function ov() {
  if (n6)
    return Sd;
  n6 = 1;
  const { Hash: r, HMAC: e, hashes: t } = q0();
  class i extends r {
    constructor() {
      super(t.WHIRLPOOL);
    }
    static hash() {
      return new i();
    }
    static hmac() {
      return new e(t.WHIRLPOOL);
    }
    static digest(c) {
      return r.digest(t.WHIRLPOOL, c);
    }
    static root(c, o) {
      return r.root(t.WHIRLPOOL, c, o);
    }
    static multi(c, o, d) {
      return r.multi(t.WHIRLPOOL, c, o, d);
    }
    static mac(c, o) {
      return e.digest(t.WHIRLPOOL, c, o);
    }
  }
  return i.native = 2, i.id = "WHIRLPOOL", i.size = 64, i.bits = 512, i.blockSize = 64, i.zero = Buffer.alloc(64, 0), i.ctx = new i(), Sd = i, Sd;
}
/*!
 * whirlpool.js - whirlpool for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? _1.exports = cv() : _1.exports = ov();
var av = _1.exports, M1 = { exports: {} };
/*!
 * x448.js - x448 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Curve448
 *   https://eprint.iacr.org/2015/625.pdf
 *   https://tools.ietf.org/html/rfc7748#section-5
 */
var Bd, f6;
function hv() {
  if (f6)
    return Bd;
  f6 = 1;
  const r = I8();
  return Bd = new r("X448", "ED448"), Bd;
}
/*!
 * x448.js - x448 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var vd, c6;
function dv() {
  if (c6)
    return vd;
  c6 = 1;
  const r = _8();
  return vd = new r("X448"), vd;
}
/*!
 * x448.js - x448 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
process.env.NODE_BACKEND === "js" ? M1.exports = hv() : M1.exports = dv();
var uv = M1.exports;
/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
(function(r) {
  r.AEAD = Vp, r.aes = Xp, r.ARC4 = jp, r.bcrypt = l8, r.BLAKE2b = Tf, r.BLAKE2b160 = nm, r.BLAKE2b256 = fm, r.BLAKE2b384 = cm, r.BLAKE2b512 = om, r.BLAKE2s = Df, r.BLAKE2s128 = dm, r.BLAKE2s160 = um, r.BLAKE2s224 = lm, r.BLAKE2s256 = xm, r.BN = J0, r.box = yo, r.ChaCha20 = N8, r.cipher = Bo, r.cleanse = Km, r.CSHAKE = vo, r.CSHAKE128 = Fm, r.CSHAKE256 = Vm, r.CtrDRBG = Jm, r.dsa = U8, r.dsaies = Z1, r.eb2k = D8, r.ecies = W1, r.ed25519 = $8, r.ed448 = wg, r.encoding = Dr, r.GOST94 = Ky, r.Hash160 = Fy, r.Hash256 = Yy, r.HashDRBG = Zy, r.hkdf = Qy, r.HmacDRBG = J1, r.Keccak = fn, r.Keccak224 = eS, r.Keccak256 = tS, r.Keccak384 = rS, r.Keccak512 = iS, r.KMAC = yl, r.KMAC128 = cS, r.KMAC256 = oS, r.MD2 = dS, r.MD4 = xS, r.MD5 = gl, r.MD5SHA1 = mS, r.merkle = Xf, r.mrkl = Ms, r.murmur3 = NS, r.p192 = kS, r.p224 = US, r.p256 = y7, r.p384 = S7, r.p521 = B7, r.pbkdf2 = v7, r.pgp = lr, r.Poly1305 = E8, r.random = B0, r.RIPEMD160 = I7, r.rsa = $7, r.rsaies = _l, r.safe = x0, r.Salsa20 = v8, r.schnorr = qB, r.scrypt = CB, r.secp256k1 = $B, r.secretbox = Lf, r.ssh = cn, r.SHA1 = E7, r.SHA224 = A7, r.SHA256 = Ti, r.SHA384 = Il, r.SHA512 = Cf, r.SHA3 = Wf, r.SHA3_224 = QB, r.SHA3_256 = ev, r.SHA3_384 = tv, r.SHA3_512 = rv, r.SHAKE = Q1, r.SHAKE128 = iv, r.SHAKE256 = Io, r.siphash = fv, r.Whirlpool = av, r.x25519 = M8, r.x448 = uv, r.version = "5.5.1", r.native = r.SHA256.native;
})(If);
const tN = (r, e, t = "tsp", i = 0) => {
  const n = Pf.toWords(Buffer.concat([r, e]));
  return n.unshift(i), Pf.encode(t, n, 116);
}, rN = (r, e = "tsp") => {
  const { prefix: t, words: i } = Pf.decode(r, 1023);
  if (t != e)
    throw new Error("Invalid prefix!");
  if (i.shift() != 0)
    throw new Error("Invalid version!");
  const c = Buffer.from(Pf.fromWords(i));
  return {
    scanKey: c.slice(0, 33),
    spendKey: c.slice(33)
  };
};
/*!
 * assert.js - assertions for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bsert
 */
class l0 extends Error {
  constructor(e) {
    typeof e == "string" && (e = { message: e }), (e === null || typeof e != "object") && (e = {});
    let t = null, i = "fail", n = !!e.generatedMessage;
    if (e.message != null && (t = lv(e.message)), typeof e.operator == "string" && (i = e.operator), t == null) {
      if (i === "fail")
        t = "Assertion failed.";
      else {
        const o = lo(e.actual), d = lo(e.expected);
        t = `${o} ${i} ${d}`;
      }
      n = !0;
    }
    super(t);
    let c = this.constructor;
    typeof e.stackStartFunction == "function" ? c = e.stackStartFunction : typeof e.stackStartFn == "function" && (c = e.stackStartFn), this.type = "AssertionError", this.name = "AssertionError [ERR_ASSERTION]", this.code = "ERR_ASSERTION", this.generatedMessage = n, this.actual = e.actual, this.expected = e.expected, this.operator = i, Error.captureStackTrace && Error.captureStackTrace(this, c);
  }
}
function wr(r, e) {
  if (!r) {
    let t = !1;
    if (arguments.length === 0)
      e = "No value argument passed to `assert()`.", t = !0;
    else if (e == null)
      e = "Assertion failed.", t = !0;
    else if (Mi(e))
      throw e;
    throw new l0({
      message: e,
      actual: r,
      expected: !0,
      operator: "==",
      generatedMessage: t,
      stackStartFn: wr
    });
  }
}
function Ml(r, e, t) {
  if (!Object.is(r, e))
    throw Mi(t) ? t : new l0({
      message: t,
      actual: r,
      expected: e,
      operator: "strictEqual",
      stackStartFn: Ml
    });
}
function Nl(r, e, t) {
  if (Object.is(r, e))
    throw Mi(t) ? t : new l0({
      message: t,
      actual: r,
      expected: e,
      operator: "notStrictEqual",
      stackStartFn: Nl
    });
}
function Q7(r) {
  let e = !1;
  throw Mi(r) ? r : (r == null && (r = "Assertion failed.", e = !0), new l0({
    message: r,
    actual: !1,
    expected: !0,
    operator: "fail",
    generatedMessage: e,
    stackStartFn: Q7
  }));
}
function N1(r, e, t) {
  typeof e == "string" && (t = e, e = void 0);
  let i = !1, n = null;
  Ui(typeof r == "function", "func", "function");
  try {
    r();
  } catch (c) {
    i = !0, n = c;
  }
  if (!i) {
    let c = !1;
    throw t == null && (t = "Missing expected exception.", c = !0), new l0({
      message: t,
      actual: void 0,
      expected: e,
      operator: "throws",
      generatedMessage: c,
      stackStartFn: N1
    });
  }
  if (!Wo(n, e, t, N1))
    throw n;
}
function ao(r, e, t) {
  typeof e == "string" && (t = e, e = void 0);
  let i = !1, n = null;
  Ui(typeof r == "function", "func", "function");
  try {
    r();
  } catch (c) {
    i = !0, n = c;
  }
  if (i) {
    if (Wo(n, e, t, ao)) {
      let c = !1;
      throw t == null && (t = "Got unwanted exception.", c = !0), new l0({
        message: t,
        actual: n,
        expected: e,
        operator: "doesNotThrow",
        generatedMessage: c,
        stackStartFn: ao
      });
    }
    throw n;
  }
}
async function ho(r, e, t) {
  typeof e == "string" && (t = e, e = void 0);
  let i = !1, n = null;
  typeof r != "function" && Ui(xo(r), "func", "promise");
  try {
    xo(r) ? await r : await r();
  } catch (c) {
    i = !0, n = c;
  }
  if (!i) {
    let c = !1;
    throw t == null && (t = "Missing expected rejection.", c = !0), new l0({
      message: t,
      actual: void 0,
      expected: e,
      operator: "rejects",
      generatedMessage: c,
      stackStartFn: ho
    });
  }
  if (!Wo(n, e, t, ho))
    throw n;
}
async function uo(r, e, t) {
  typeof e == "string" && (t = e, e = void 0);
  let i = !1, n = null;
  typeof r != "function" && Ui(xo(r), "func", "promise");
  try {
    xo(r) ? await r : await r();
  } catch (c) {
    i = !0, n = c;
  }
  if (i) {
    if (Wo(n, e, t, uo)) {
      let c = !1;
      throw t == null && (t = "Got unwanted rejection.", c = !0), new l0({
        message: t,
        actual: void 0,
        expected: e,
        operator: "doesNotReject",
        generatedMessage: c,
        stackStartFn: uo
      });
    }
    throw n;
  }
}
function e9(r) {
  if (r != null) {
    let e = "ifError got unwanted exception: ";
    throw typeof r == "object" && typeof r.message == "string" ? r.message.length === 0 && r.constructor ? e += r.constructor.name : e += r.message : e += lo(r), new l0({
      message: e,
      actual: r,
      expected: null,
      operator: "ifError",
      generatedMessage: !0,
      stackStartFn: e9
    });
  }
}
function Ol(r, e, t) {
  if (!Rl(r, e, !1))
    throw Mi(t) ? t : new l0({
      message: t,
      actual: r,
      expected: e,
      operator: "deepStrictEqual",
      stackStartFn: Ol
    });
}
function Pl(r, e, t) {
  if (Rl(r, e, !0))
    throw Mi(t) ? t : new l0({
      message: t,
      actual: r,
      expected: e,
      operator: "notDeepStrictEqual",
      stackStartFn: Pl
    });
}
function t9(r, e, t, i) {
  if (kl(t) || (i = t, t = null), t == null && (t = "hex"), e = n9(r, e, t), Ui(fs(r), "actual", "buffer"), Ui(fs(e), "expected", "buffer"), r !== e && !r.equals(e))
    throw Mi(i) ? i : new l0({
      message: i,
      actual: r.toString(t),
      expected: e.toString(t),
      operator: "bufferEqual",
      stackStartFn: t9
    });
}
function r9(r, e, t, i) {
  if (kl(t) || (i = t, t = null), t == null && (t = "hex"), e = n9(r, e, t), Ui(fs(r), "actual", "buffer"), Ui(fs(e), "expected", "buffer"), r === e || r.equals(e))
    throw Mi(i) ? i : new l0({
      message: i,
      actual: r.toString(t),
      expected: e.toString(t),
      operator: "notBufferEqual",
      stackStartFn: r9
    });
}
function Ui(r, e, t) {
  if (!r) {
    let i;
    e == null ? i = "Invalid type for parameter." : t == null ? i = `Invalid type for "${e}".` : i = `"${e}" must be a(n) ${t}.`;
    const n = new TypeError(i);
    throw Error.captureStackTrace && Error.captureStackTrace(n, Ui), n;
  }
}
function i9(r, e) {
  if (!r) {
    const t = e != null ? `"${e}" is out of range.` : "Parameter is out of range.", i = new RangeError(t);
    throw Error.captureStackTrace && Error.captureStackTrace(i, i9), i;
  }
}
function lo(r) {
  switch (typeof r) {
    case "undefined":
      return "undefined";
    case "object":
      return r === null ? "null" : `[${pv(r)}]`;
    case "boolean":
      return `${r}`;
    case "number":
      return `${r}`;
    case "string":
      return r.length > 80 && (r = `${r.substring(0, 77)}...`), JSON.stringify(r);
    case "symbol":
      return s9(r);
    case "function":
      return `[${mv(r)}]`;
    case "bigint":
      return `${r}n`;
    default:
      return `[${typeof r}]`;
  }
}
function lv(r) {
  return typeof r == "string" ? r : Mi(r) ? s9(r) : lo(r);
}
function s9(r) {
  try {
    return String(r);
  } catch {
    return "Object";
  }
}
function Wo(r, e, t, i) {
  if (e == null)
    return !0;
  if (R1(e))
    return e.test(r);
  if (typeof e != "function") {
    if (i === ao || i === uo)
      throw new TypeError('"expected" must not be an object.');
    if (typeof e != "object")
      throw new TypeError('"expected" must be an object.');
    let n = !1;
    if (t == null && (t = `Missing expected ${i === ho ? "rejection" : "exception"}.`, n = !0), r == null || typeof r != "object")
      throw new l0({
        actual: r,
        expected: e,
        message: t,
        operator: i.name,
        generatedMessage: n,
        stackStartFn: i
      });
    const c = Object.keys(e);
    if (Mi(e) && c.push("name", "message"), c.length === 0)
      throw new TypeError('"expected" may not be an empty object.');
    for (const o of c) {
      const d = e[o], l = r[o];
      if (!(typeof l == "string" && R1(d) && d.test(l)) && !(o in r && Rl(l, d, !1)))
        throw new l0({
          actual: r,
          expected: e,
          message: t,
          operator: i.name,
          generatedMessage: n,
          stackStartFn: i
        });
    }
    return !0;
  }
  return e.prototype !== void 0 && r instanceof e ? !0 : Error.isPrototypeOf(e) ? !1 : e.call({}, r) === !0;
}
function Rl(r, e, t) {
  try {
    return Vc(r, e, null);
  } catch {
    return t;
  }
}
function Vc(r, e, t) {
  if (Object.is(r, e))
    return !0;
  if (!P1(r) || !P1(e) || O1(r) !== O1(e) || Object.getPrototypeOf(r) !== Object.getPrototypeOf(e))
    return !1;
  if (fs(r) && fs(e))
    return r.equals(e);
  if (yv(r))
    return Object.is(r.getTime(), e.getTime());
  if (R1(r))
    return r.source === e.source && r.global === e.global && r.multiline === e.multiline && r.lastIndex === e.lastIndex && r.ignoreCase === e.ignoreCase;
  if (Mi(r) && r.message !== e.message)
    return !1;
  if (wv(r) && (r = new Uint8Array(r), e = new Uint8Array(e)), vv(r) && !fs(r)) {
    if (fs(e))
      return !1;
    const n = new Uint8Array(r.buffer), c = new Uint8Array(e.buffer);
    if (n.length !== c.length)
      return !1;
    for (let o = 0; o < n.length; o++)
      if (n[o] !== c[o])
        return !1;
    return !0;
  }
  if (Bv(r))
    return r.size !== e.size ? !1 : (/* @__PURE__ */ new Set([...r, ...e])).size === r.size;
  if (!t)
    t = {
      a: /* @__PURE__ */ new Map(),
      b: /* @__PURE__ */ new Map(),
      p: 0
    };
  else {
    const n = t.a.get(r);
    if (n != null) {
      const c = t.b.get(e);
      if (c != null)
        return n === c;
    }
    t.p += 1;
  }
  t.a.set(r, t.p), t.b.set(e, t.p);
  const i = xv(r, e, t);
  return t.a.delete(r), t.b.delete(e), i;
}
function xv(r, e, t) {
  if (Sv(r)) {
    if (r.size !== e.size)
      return !1;
    const o = /* @__PURE__ */ new Set([...r.keys(), ...e.keys()]);
    if (o.size !== r.size)
      return !1;
    for (const d of o)
      if (!Vc(r.get(d), e.get(d), t))
        return !1;
    return !0;
  }
  if (gv(r)) {
    if (r.length !== e.length)
      return !1;
    for (let o = 0; o < r.length; o++)
      if (!Vc(r[o], e[o], t))
        return !1;
    return !0;
  }
  const i = o6(r), n = o6(e);
  if (i.length !== n.length)
    return !1;
  const c = /* @__PURE__ */ new Set([...i, ...n]);
  if (c.size !== i.length)
    return !1;
  for (const o of c)
    if (!Vc(r[o], e[o], t))
      return !1;
  return !0;
}
function o6(r) {
  const e = Object.keys(r);
  if (!Object.getOwnPropertySymbols || !Object.getOwnPropertyDescriptor)
    return e;
  const t = Object.getOwnPropertySymbols(r);
  for (const i of t) {
    const n = Object.getOwnPropertyDescriptor(r, i);
    n && n.enumerable && e.push(i);
  }
  return e;
}
function O1(r) {
  if (r === void 0)
    return "[object Undefined]";
  if (r === null)
    return "[object Null]";
  try {
    return Object.prototype.toString.call(r);
  } catch {
    return "[object Object]";
  }
}
function bv(r) {
  return O1(r).slice(8, -1);
}
function pv(r) {
  const e = bv(r);
  if (r == null || e !== "Object" && e !== "Error")
    return e;
  let t, i;
  try {
    t = r.constructor;
  } catch {
  }
  if (t == null)
    return e;
  try {
    i = t.name;
  } catch {
    return e;
  }
  return typeof i != "string" || i.length === 0 ? e : i;
}
function mv(r) {
  let e;
  try {
    e = r.name;
  } catch {
  }
  return typeof e != "string" || e.length === 0 ? "Function" : `Function: ${e}`;
}
function gv(r) {
  return Array.isArray(r);
}
function wv(r) {
  return r instanceof ArrayBuffer;
}
function fs(r) {
  return P1(r) && typeof r.writeUInt32LE == "function" && typeof r.equals == "function";
}
function yv(r) {
  return r instanceof Date;
}
function Mi(r) {
  return r instanceof Error;
}
function Sv(r) {
  return r instanceof Map;
}
function P1(r) {
  return r && typeof r == "object";
}
function xo(r) {
  return r instanceof Promise;
}
function R1(r) {
  return r instanceof RegExp;
}
function Bv(r) {
  return r instanceof Set;
}
function vv(r) {
  return ArrayBuffer.isView(r);
}
function kl(r) {
  if (typeof r != "string")
    return !1;
  switch (r) {
    case "ascii":
    case "binary":
    case "base64":
    case "hex":
    case "latin1":
    case "ucs2":
    case "utf8":
    case "utf16le":
      return !0;
  }
  return !1;
}
function n9(r, e, t) {
  if (typeof e == "string") {
    if (!fs(r))
      return null;
    const { constructor: i } = r;
    if (!i || typeof i.from != "function" || !kl(t) || t === "hex" && e.length & 1)
      return null;
    const n = i.from(e, t);
    return t === "hex" && n.length !== e.length >>> 1 ? null : n;
  }
  return e;
}
wr.AssertionError = l0;
wr.assert = wr;
wr.strict = wr;
wr.ok = wr;
wr.equal = Ml;
wr.notEqual = Nl;
wr.strictEqual = Ml;
wr.notStrictEqual = Nl;
wr.fail = Q7;
wr.throws = N1;
wr.doesNotThrow = ao;
wr.rejects = ho;
wr.doesNotReject = uo;
wr.ifError = e9;
wr.deepEqual = Ol;
wr.notDeepEqual = Pl;
wr.deepStrictEqual = Ol;
wr.notDeepStrictEqual = Pl;
wr.bufferEqual = t9;
wr.notBufferEqual = r9;
wr.enforce = Ui;
wr.range = i9;
var Ar = wr;
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
function f9(r, e) {
  if (!r) {
    const t = new Error(e || "Assertion failed");
    throw Error.captureStackTrace && Error.captureStackTrace(t, f9), t;
  }
}
var Jr = f9;
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */
const gn = Jr;
let Ev = class {
  /**
   * Create an HMAC.
   * @param {Function} Hash
   * @param {Number} size
   * @param {Array} [x=[]]
   * @param {Array} [y=[]]
   */
  constructor(e, t, i = [], n = []) {
    gn(typeof e == "function"), gn(t >>> 0 === t), gn(Array.isArray(i)), gn(Array.isArray(n)), this.hash = e, this.size = t, this.x = i, this.y = n, this.inner = new e(), this.outer = new e();
  }
  /**
   * Initialize HMAC context.
   * @param {Buffer} data
   */
  init(e) {
    if (gn(Buffer.isBuffer(e)), e.length > this.size) {
      const i = this.hash, n = new i();
      n.init(...this.x), n.update(e), e = n.final(...this.y), gn(e.length <= this.size);
    }
    const t = Buffer.alloc(this.size);
    for (let i = 0; i < e.length; i++)
      t[i] = e[i] ^ 54;
    for (let i = e.length; i < t.length; i++)
      t[i] = 54;
    this.inner.init(...this.x), this.inner.update(t);
    for (let i = 0; i < e.length; i++)
      t[i] = e[i] ^ 92;
    for (let i = e.length; i < t.length; i++)
      t[i] = 92;
    return this.outer.init(...this.x), this.outer.update(t), this;
  }
  /**
   * Update HMAC context.
   * @param {Buffer} data
   */
  update(e) {
    return this.inner.update(e), this;
  }
  /**
   * Finalize HMAC context.
   * @returns {Buffer}
   */
  final() {
    return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y);
  }
};
var jf = Ev;
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */
const bf = Jr, Iv = jf, gc = -1, Ed = Buffer.alloc(8, 0), c9 = Buffer.alloc(64, 0);
c9[0] = 128;
const Av = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
let ds = class Fs {
  constructor() {
    this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = Buffer.alloc(64), this.size = gc;
  }
  init() {
    return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this;
  }
  update(e) {
    return bf(Buffer.isBuffer(e)), this._update(e, e.length), this;
  }
  final() {
    return this._final(Buffer.alloc(32));
  }
  _update(e, t) {
    bf(this.size !== gc, "Context is not initialized.");
    let i = this.size & 63, n = 0;
    if (this.size += t, i > 0) {
      let c = 64 - i;
      if (c > t && (c = t), e.copy(this.block, i, n, n + c), i += c, t -= c, n += c, i < 64)
        return;
      this._transform(this.block, 0);
    }
    for (; t >= 64; )
      this._transform(e, n), n += 64, t -= 64;
    t > 0 && e.copy(this.block, 0, n, n + t);
  }
  _final(e) {
    bf(this.size !== gc, "Context is not initialized.");
    const t = this.size & 63, i = this.size * 8;
    Id(Ed, i * (1 / 4294967296) >>> 0, 0), Id(Ed, i >>> 0, 4), this._update(c9, 1 + (119 - t & 63)), this._update(Ed, 8);
    for (let n = 0; n < 8; n++)
      Id(e, this.state[n], n * 4), this.state[n] = 0;
    for (let n = 0; n < 64; n++)
      this.msg[n] = 0;
    for (let n = 0; n < 64; n++)
      this.block[n] = 0;
    return this.size = gc, e;
  }
  _transform(e, t) {
    const i = this.msg;
    let n = this.state[0], c = this.state[1], o = this.state[2], d = this.state[3], l = this.state[4], h = this.state[5], x = this.state[6], b = this.state[7], g = 0;
    for (; g < 16; g++)
      i[g] = kv(e, t + g * 4);
    for (; g < 64; g++)
      i[g] = Ov(i[g - 2]) + i[g - 7] + Nv(i[g - 15]) + i[g - 16];
    for (g = 0; g < 64; g++) {
      const w = b + Mv(l) + Pv(l, h, x) + Av[g] + i[g], I = _v(n) + Rv(n, c, o);
      b = x, x = h, h = l, l = d + w >>> 0, d = o, o = c, c = n, n = w + I >>> 0;
    }
    this.state[0] += n, this.state[1] += c, this.state[2] += o, this.state[3] += d, this.state[4] += l, this.state[5] += h, this.state[6] += x, this.state[7] += b;
  }
  static hash() {
    return new Fs();
  }
  static hmac() {
    return new Iv(Fs, 64);
  }
  static digest(e) {
    return Fs.ctx.init().update(e).final();
  }
  static root(e, t) {
    return bf(Buffer.isBuffer(e) && e.length === 32), bf(Buffer.isBuffer(t) && t.length === 32), Fs.ctx.init().update(e).update(t).final();
  }
  static multi(e, t, i) {
    const { ctx: n } = Fs;
    return n.init(), n.update(e), n.update(t), i && n.update(i), n.final();
  }
  static mac(e, t) {
    return Fs.hmac().init(t).update(e).final();
  }
};
ds.native = 0;
ds.id = "SHA256";
ds.size = 32;
ds.bits = 256;
ds.blockSize = 64;
ds.zero = Buffer.alloc(32, 0);
ds.ctx = new ds();
function _v(r) {
  return (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10);
}
function Mv(r) {
  return (r >>> 6 | r << 26) ^ (r >>> 11 | r << 21) ^ (r >>> 25 | r << 7);
}
function Nv(r) {
  return (r >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3;
}
function Ov(r) {
  return (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10;
}
function Pv(r, e, t) {
  return t ^ r & (e ^ t);
}
function Rv(r, e, t) {
  return r & e | t & (r | e);
}
function kv(r, e) {
  return r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function Id(r, e, t) {
  return r[t++] = e >>> 24, r[t++] = e >>> 16, r[t++] = e >>> 8, r[t++] = e, t;
}
var ql = ds;
/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
const a6 = Jr, qv = ql, zv = jf;
class a0 {
  constructor() {
    this.ctx = new qv();
  }
  init() {
    return this.ctx.init(), this;
  }
  update(e) {
    return this.ctx.update(e), this;
  }
  final() {
    const e = Buffer.alloc(32);
    return this.ctx._final(e), this.ctx.init(), this.ctx.update(e), this.ctx._final(e), e;
  }
  static hash() {
    return new a0();
  }
  static hmac() {
    return new zv(a0, 64);
  }
  static digest(e) {
    return a0.ctx.init().update(e).final();
  }
  static root(e, t) {
    return a6(Buffer.isBuffer(e) && e.length === 32), a6(Buffer.isBuffer(t) && t.length === 32), a0.ctx.init().update(e).update(t).final();
  }
  static multi(e, t, i) {
    const { ctx: n } = a0;
    return n.init(), n.update(e), n.update(t), i && n.update(i), n.final();
  }
  static mac(e, t) {
    return a0.hmac().init(t).update(e).final();
  }
}
a0.native = 0;
a0.id = "HASH256";
a0.size = 32;
a0.bits = 256;
a0.blockSize = 64;
a0.zero = Buffer.alloc(32, 0);
a0.ctx = new a0();
var Uv = a0;
/*!
 * hash256.js - hash256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var jo = Uv, Me = {}, zl = {};
zl.custom = "inspect";
var Ce = {};
/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
function o9(r, e, t) {
  if (!r) {
    const i = new TypeError(`'${e}' must be a(n) ${t}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(i, o9), i;
  }
}
var Vn = o9;
/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
let Cv = class a9 extends Error {
  /**
   * Create an encoding error.
   * @constructor
   * @param {Number} offset
   * @param {String} reason
   */
  constructor(e, t, i) {
    super(), this.type = "EncodingError", this.name = "EncodingError", this.code = "ERR_ENCODING", this.message = `${t} (offset=${e}).`, Error.captureStackTrace && Error.captureStackTrace(this, i || a9);
  }
};
var Qf = Cv;
/*!
 * encoding.js - encoding utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const wt = Vn, E0 = Qf, Gn = 1 / 4294967296, { MAX_SAFE_INTEGER: Tv } = Number, Yn = new Float32Array(1), e0 = new Uint8Array(Yn.buffer), ec = new Float64Array(1), or = new Uint8Array(ec.buffer);
Yn[0] = -1;
const Ns = e0[3] === 0;
function Dv(r, e, t) {
  switch (t) {
    case 8:
      return Ul(r, e);
    case 7:
      return h9(r, e);
    case 6:
      return d9(r, e);
    case 5:
      return u9(r, e);
    case 4:
      return Is(r, e);
    case 3:
      return Cl(r, e);
    case 2:
      return Tl(r, e);
    case 1:
      return Dl(r, e);
    default:
      throw new E0(e, "Invalid read length");
  }
}
function Ul(r, e) {
  const t = Is(r, e + 4), i = Is(r, e);
  return P0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function h9(r, e) {
  const t = Cl(r, e + 4), i = Is(r, e);
  return P0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function d9(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e++] * 16777216 + r[e++] * 4294967296 + r[e] * 1099511627776;
}
function u9(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e++] * 16777216 + r[e] * 4294967296;
}
function Is(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216;
}
function Cl(r, e) {
  return r[e++] + r[e++] * 256 + r[e] * 65536;
}
function Tl(r, e) {
  return r[e++] + r[e] * 256;
}
function Dl(r, e) {
  return r[e];
}
function Lv(r, e, t) {
  switch (t) {
    case 8:
      return l9(r, e);
    case 7:
      return x9(r, e);
    case 6:
      return b9(r, e);
    case 5:
      return p9(r, e);
    case 4:
      return nn(r, e);
    case 3:
      return Ll(r, e);
    case 2:
      return m9(r, e);
    case 1:
      return Dl(r, e);
    default:
      throw new E0(e, "Invalid read length");
  }
}
function l9(r, e) {
  const t = nn(r, e), i = nn(r, e + 4);
  return P0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function x9(r, e) {
  const t = Ll(r, e), i = nn(r, e + 3);
  return P0((t & 4292870144) === 0, e, "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function b9(r, e) {
  return r[e++] * 1099511627776 + r[e++] * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function p9(r, e) {
  return r[e++] * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function nn(r, e) {
  return r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function Ll(r, e) {
  return r[e++] * 65536 + r[e++] * 256 + r[e];
}
function m9(r, e) {
  return r[e++] * 256 + r[e];
}
function Kv(r, e, t) {
  switch (t) {
    case 8:
      return g9(r, e);
    case 7:
      return w9(r, e);
    case 6:
      return y9(r, e);
    case 5:
      return S9(r, e);
    case 4:
      return Kl(r, e);
    case 3:
      return $l(r, e);
    case 2:
      return B9(r, e);
    case 1:
      return Hl(r, e);
    default:
      throw new E0(e, "Invalid read length");
  }
}
function g9(r, e) {
  const t = Kl(r, e + 4), i = Is(r, e);
  return P0(da(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function w9(r, e) {
  const t = $l(r, e + 4), i = Is(r, e);
  return P0(da(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function y9(r, e) {
  const t = r[e + 4] + r[e + 5] * 256;
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216 + (t | (t & 32768) * 131070) * 4294967296;
}
function S9(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e++] * 16777216 + (r[e] | (r[e] & 128) * 33554430) * 4294967296;
}
function Kl(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + (r[e] << 24);
}
function $l(r, e) {
  const t = r[e++] + r[e++] * 256 + r[e] * 65536;
  return t | (t & 8388608) * 510;
}
function B9(r, e) {
  const t = r[e++] + r[e] * 256;
  return t | (t & 32768) * 131070;
}
function Hl(r, e) {
  const t = r[e];
  return t | (t & 128) * 33554430;
}
function $v(r, e, t) {
  switch (t) {
    case 8:
      return v9(r, e);
    case 7:
      return E9(r, e);
    case 6:
      return I9(r, e);
    case 5:
      return A9(r, e);
    case 4:
      return Fl(r, e);
    case 3:
      return Vl(r, e);
    case 2:
      return _9(r, e);
    case 1:
      return Hl(r, e);
    default:
      throw new E0(e, "Invalid read length");
  }
}
function v9(r, e) {
  const t = Fl(r, e), i = nn(r, e + 4);
  return P0(da(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function E9(r, e) {
  const t = Vl(r, e), i = nn(r, e + 3);
  return P0(da(t, i), "Number exceeds 2^53-1"), t * 4294967296 + i;
}
function I9(r, e) {
  const t = r[e++] * 256 + r[e++];
  return (t | (t & 32768) * 131070) * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function A9(r, e) {
  const t = r[e++];
  return (t | (t & 128) * 33554430) * 4294967296 + r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function Fl(r, e) {
  return (r[e++] << 24) + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function Vl(r, e) {
  const t = r[e++] * 65536 + r[e++] * 256 + r[e];
  return t | (t & 8388608) * 510;
}
function _9(r, e) {
  const t = r[e++] * 256 + r[e];
  return t | (t & 32768) * 131070;
}
function M9(r, e) {
  return e0[3] = r[e++], e0[2] = r[e++], e0[1] = r[e++], e0[0] = r[e], Yn[0];
}
function N9(r, e) {
  return e0[0] = r[e++], e0[1] = r[e++], e0[2] = r[e++], e0[3] = r[e], Yn[0];
}
function O9(r, e) {
  return or[7] = r[e++], or[6] = r[e++], or[5] = r[e++], or[4] = r[e++], or[3] = r[e++], or[2] = r[e++], or[1] = r[e++], or[0] = r[e], ec[0];
}
function P9(r, e) {
  return or[0] = r[e++], or[1] = r[e++], or[2] = r[e++], or[3] = r[e++], or[4] = r[e++], or[5] = r[e++], or[6] = r[e++], or[7] = r[e], ec[0];
}
const Hv = Ns ? M9 : N9, Fv = Ns ? N9 : M9, Vv = Ns ? O9 : P9, Gv = Ns ? P9 : O9;
function Yv(r, e, t, i) {
  switch (i) {
    case 8:
      return tc(r, e, t);
    case 7:
      return Qo(r, e, t);
    case 6:
      return ea(r, e, t);
    case 5:
      return ta(r, e, t);
    case 4:
      return rc(r, e, t);
    case 3:
      return ra(r, e, t);
    case 2:
      return ic(r, e, t);
    case 1:
      return Jn(r, e, t);
    default:
      throw new E0(t, "Invalid write length");
  }
}
function tc(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), D9(r, e, t, !1);
}
function Qo(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), L9(r, e, t, !1);
}
function ea(r, e, t) {
  wt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Gn | 0;
  return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, r[t++] = i, r[t++] = i >>> 8, t;
}
function ta(r, e, t) {
  wt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Gn | 0;
  return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, r[t++] = i, t;
}
function rc(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t;
}
function ra(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t;
}
function ic(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e, r[t++] = e >>> 8, t;
}
function Jn(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t] = e, t + 1;
}
function Jv(r, e, t, i) {
  switch (i) {
    case 8:
      return ia(r, e, t);
    case 7:
      return sa(r, e, t);
    case 6:
      return na(r, e, t);
    case 5:
      return fa(r, e, t);
    case 4:
      return ca(r, e, t);
    case 3:
      return oa(r, e, t);
    case 2:
      return aa(r, e, t);
    case 1:
      return Jn(r, e, t);
    default:
      throw new E0(t, "Invalid write length");
  }
}
function ia(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), D9(r, e, t, !0);
}
function sa(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), L9(r, e, t, !0);
}
function na(r, e, t) {
  wt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Gn | 0;
  return r[t++] = i >>> 8, r[t++] = i, r[t + 3] = e, e >>>= 8, r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 4;
}
function fa(r, e, t) {
  wt(Number.isSafeInteger(e), "num", "integer");
  const i = e * Gn | 0;
  return r[t++] = i, r[t + 3] = e, e >>>= 8, r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 4;
}
function ca(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t + 3] = e, e >>>= 8, r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 4;
}
function oa(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t + 2] = e, e >>>= 8, r[t + 1] = e, e >>>= 8, r[t] = e, t + 3;
}
function aa(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), r[t++] = e >>> 8, r[t++] = e, t;
}
function Xv(r, e, t, i) {
  switch (i) {
    case 8:
      return tc(r, e, t);
    case 7:
      return Qo(r, e, t);
    case 6:
      return ea(r, e, t);
    case 5:
      return ta(r, e, t);
    case 4:
      return ra(r, e, t);
    case 3:
      return rc(r, e, t);
    case 2:
      return ic(r, e, t);
    case 1:
      return Jn(r, e, t);
    default:
      throw new E0(t, "Invalid write length");
  }
}
function Zv(r, e, t) {
  return tc(r, e, t);
}
function Wv(r, e, t) {
  return Qo(r, e, t);
}
function jv(r, e, t) {
  return ea(r, e, t);
}
function Qv(r, e, t) {
  return ta(r, e, t);
}
function bo(r, e, t) {
  return rc(r, e, t);
}
function R9(r, e, t) {
  return ra(r, e, t);
}
function eE(r, e, t) {
  return ic(r, e, t);
}
function tE(r, e, t) {
  return Jn(r, e, t);
}
function rE(r, e, t, i) {
  switch (i) {
    case 8:
      return ia(r, e, t);
    case 7:
      return sa(r, e, t);
    case 6:
      return na(r, e, t);
    case 5:
      return fa(r, e, t);
    case 4:
      return ca(r, e, t);
    case 3:
      return oa(r, e, t);
    case 2:
      return aa(r, e, t);
    case 1:
      return Jn(r, e, t);
    default:
      throw new E0(t, "Invalid write length");
  }
}
function iE(r, e, t) {
  return ia(r, e, t);
}
function sE(r, e, t) {
  return sa(r, e, t);
}
function nE(r, e, t) {
  return na(r, e, t);
}
function fE(r, e, t) {
  return fa(r, e, t);
}
function po(r, e, t) {
  return ca(r, e, t);
}
function k9(r, e, t) {
  return oa(r, e, t);
}
function cE(r, e, t) {
  return aa(r, e, t);
}
function q9(r, e, t) {
  return wt(ua(e), "num", "number"), ec[0] = e, r[t++] = or[0], r[t++] = or[1], r[t++] = or[2], r[t++] = or[3], r[t++] = or[4], r[t++] = or[5], r[t++] = or[6], r[t++] = or[7], t;
}
function z9(r, e, t) {
  return wt(ua(e), "num", "number"), ec[0] = e, r[t++] = or[7], r[t++] = or[6], r[t++] = or[5], r[t++] = or[4], r[t++] = or[3], r[t++] = or[2], r[t++] = or[1], r[t++] = or[0], t;
}
function U9(r, e, t) {
  return wt(ua(e), "num", "number"), Yn[0] = e, r[t++] = e0[0], r[t++] = e0[1], r[t++] = e0[2], r[t++] = e0[3], t;
}
function C9(r, e, t) {
  return wt(ua(e), "num", "number"), Yn[0] = e, r[t++] = e0[3], r[t++] = e0[2], r[t++] = e0[1], r[t++] = e0[0], t;
}
const oE = Ns ? C9 : U9, aE = Ns ? U9 : C9, hE = Ns ? z9 : q9, dE = Ns ? q9 : z9;
function uE(r, e) {
  let t, i;
  switch (Xs(e < r.length, e), r[e]) {
    case 255:
      i = 9, Xs(e + i <= r.length, e), t = Ul(r, e + 1), P0(t > 4294967295, e, "Non-canonical varint");
      break;
    case 254:
      i = 5, Xs(e + i <= r.length, e), t = Is(r, e + 1), P0(t > 65535, e, "Non-canonical varint");
      break;
    case 253:
      i = 3, Xs(e + i <= r.length, e), t = Tl(r, e + 1), P0(t >= 253, e, "Non-canonical varint");
      break;
    default:
      i = 1, t = r[e];
      break;
  }
  return new K9(i, t);
}
function lE(r, e, t) {
  return wt(Number.isSafeInteger(e), "num", "integer"), e < 253 ? (r[t++] = e, t) : e <= 65535 ? (r[t++] = 253, ic(r, e, t)) : e <= 4294967295 ? (r[t++] = 254, rc(r, e, t)) : (r[t++] = 255, tc(r, e, t));
}
function ha(r) {
  return wt(Number.isSafeInteger(r), "num", "integer"), r < 253 ? 1 : r <= 65535 ? 3 : r <= 4294967295 ? 5 : 9;
}
function xE(r, e) {
  let t = 0, i = 0;
  for (; ; ) {
    Xs(e < r.length, e);
    const n = r[e++];
    if (i += 1, P0(t <= 70368744177663 - (n & 127), e, "Number exceeds 2^53-1"), t = t * 128 + (n & 127), !(n & 128))
      break;
    P0(t !== Tv, e, "Number exceeds 2^53-1"), t += 1;
  }
  return new K9(i, t);
}
function bE(r, e, t) {
  wt(Number.isSafeInteger(e), "num", "integer");
  const i = [];
  let n = 0;
  for (; i[n] = e & 127 | (n ? 128 : 0), !(e <= 127); )
    e = (e - e % 128) / 128 - 1, n += 1;
  Xs(t + n + 1 <= r.length, t);
  do
    r[t++] = i[n];
  while (n--);
  return t;
}
function pE(r) {
  wt(Number.isSafeInteger(r), "num", "integer");
  let e = 0;
  for (; e += 1, !(r <= 127); )
    r = (r - r % 128) / 128 - 1;
  return e;
}
function mE(r, e, t) {
  if (wt(Buffer.isBuffer(r), "data", "buffer"), wt(e >>> 0 === e, "off", "integer"), wt(t >>> 0 === t, "size", "integer"), e + t > r.length)
    throw new E0(e, "Out of bounds read");
  return r.slice(e, e + t);
}
function gE(r, e, t) {
  if (wt(Buffer.isBuffer(r), "data", "buffer"), wt(e >>> 0 === e, "off", "integer"), wt(t >>> 0 === t, "size", "integer"), e + t > r.length)
    throw new E0(e, "Out of bounds read");
  const i = Buffer.allocUnsafeSlow(t);
  return r.copy(i, 0, e, e + t), i;
}
function wE(r, e, t) {
  if (wt(Buffer.isBuffer(r), "data", "buffer"), wt(Buffer.isBuffer(e), "value", "buffer"), wt(t >>> 0 === t, "off", "integer"), t + e.length > r.length)
    throw new E0(t, "Out of bounds write");
  return e.copy(r, t, 0, e.length);
}
function yE(r, e, t, i) {
  if (i == null && (i = "binary"), wt(Buffer.isBuffer(r), "data", "buffer"), wt(e >>> 0 === e, "off", "integer"), wt(t >>> 0 === t, "size", "integer"), wt(typeof i == "string", "enc", "string"), e + t > r.length)
    throw new E0(e, "Out of bounds read");
  return r.toString(i, e, e + t);
}
function SE(r, e, t, i) {
  if (i == null && (i = "binary"), wt(Buffer.isBuffer(r), "data", "buffer"), wt(typeof e == "string", "str", "string"), wt(t >>> 0 === t, "off", "integer"), wt(typeof i == "string", "enc", "string"), e.length === 0)
    return 0;
  const n = Buffer.byteLength(e, i);
  if (t + n > r.length)
    throw new E0(t, "Out of bounds write");
  return r.write(e, t, i);
}
function T9(r, e) {
  wt(Buffer.isBuffer(r), "data", "buffer");
  const t = Buffer.allocUnsafeSlow(e);
  return r.copy(t, 0), t;
}
function BE(r) {
  return wt(Buffer.isBuffer(r), "data", "buffer"), T9(r, r.length);
}
function vE(r, e) {
  wt(Buffer.isBuffer(r), "a", "buffer"), wt(Buffer.isBuffer(e), "b", "buffer");
  const t = r.length + e.length, i = Buffer.allocUnsafeSlow(t);
  return r.copy(i, 0), e.copy(i, r.length), i;
}
function EE(r) {
  return wt(Buffer.isBuffer(r), "data", "buffer"), ha(r.length) + r.length;
}
function IE(r) {
  return ha(r) + r;
}
function AE(r, e) {
  if (e == null && (e = "binary"), wt(typeof r == "string", "str", "string"), wt(typeof e == "string", "enc", "string"), r.length === 0)
    return 1;
  const t = Buffer.byteLength(r, e);
  return ha(t) + t;
}
function da(r, e) {
  return r < 0 && (r = ~r, e === 0 && (r += 1)), (r & 4292870144) === 0;
}
function D9(r, e, t, i) {
  let n = !1;
  e < 0 && (e = -e, n = !0);
  let c = e * Gn | 0, o = e | 0;
  return n && (o === 0 ? c = ~c + 1 | 0 : (c = ~c, o = ~o + 1)), i ? (t = po(r, c, t), t = po(r, o, t)) : (t = bo(r, o, t), t = bo(r, c, t)), t;
}
function L9(r, e, t, i) {
  let n = !1;
  e < 0 && (e = -e, n = !0);
  let c = e * Gn | 0, o = e | 0;
  return n && (o === 0 ? c = ~c + 1 | 0 : (c = ~c, o = ~o + 1)), i ? (t = k9(r, c, t), t = po(r, o, t)) : (t = bo(r, o, t), t = R9(r, c, t)), t;
}
class K9 {
  constructor(e, t) {
    this.size = e, this.value = t;
  }
}
function ua(r) {
  return typeof r == "number" && isFinite(r);
}
function Xs(r, e) {
  if (!r)
    throw new E0(e, "Out of bounds read", Xs);
}
function P0(r, e, t) {
  if (!r)
    throw new E0(e, t, P0);
}
Ce.readU = Dv;
Ce.readU64 = Ul;
Ce.readU56 = h9;
Ce.readU48 = d9;
Ce.readU40 = u9;
Ce.readU32 = Is;
Ce.readU24 = Cl;
Ce.readU16 = Tl;
Ce.readU8 = Dl;
Ce.readUBE = Lv;
Ce.readU64BE = l9;
Ce.readU56BE = x9;
Ce.readU48BE = b9;
Ce.readU40BE = p9;
Ce.readU32BE = nn;
Ce.readU24BE = Ll;
Ce.readU16BE = m9;
Ce.readI = Kv;
Ce.readI64 = g9;
Ce.readI56 = w9;
Ce.readI48 = y9;
Ce.readI40 = S9;
Ce.readI32 = Kl;
Ce.readI24 = $l;
Ce.readI16 = B9;
Ce.readI8 = Hl;
Ce.readIBE = $v;
Ce.readI64BE = v9;
Ce.readI56BE = E9;
Ce.readI48BE = I9;
Ce.readI40BE = A9;
Ce.readI32BE = Fl;
Ce.readI24BE = Vl;
Ce.readI16BE = _9;
Ce.readFloat = Hv;
Ce.readFloatBE = Fv;
Ce.readDouble = Vv;
Ce.readDoubleBE = Gv;
Ce.writeU = Yv;
Ce.writeU64 = tc;
Ce.writeU56 = Qo;
Ce.writeU48 = ea;
Ce.writeU40 = ta;
Ce.writeU32 = rc;
Ce.writeU24 = ra;
Ce.writeU16 = ic;
Ce.writeU8 = Jn;
Ce.writeUBE = Jv;
Ce.writeU64BE = ia;
Ce.writeU56BE = sa;
Ce.writeU48BE = na;
Ce.writeU40BE = fa;
Ce.writeU32BE = ca;
Ce.writeU24BE = oa;
Ce.writeU16BE = aa;
Ce.writeI = Xv;
Ce.writeI64 = Zv;
Ce.writeI56 = Wv;
Ce.writeI48 = jv;
Ce.writeI40 = Qv;
Ce.writeI32 = bo;
Ce.writeI24 = R9;
Ce.writeI16 = eE;
Ce.writeI8 = tE;
Ce.writeIBE = rE;
Ce.writeI64BE = iE;
Ce.writeI56BE = sE;
Ce.writeI48BE = nE;
Ce.writeI40BE = fE;
Ce.writeI32BE = po;
Ce.writeI24BE = k9;
Ce.writeI16BE = cE;
Ce.writeFloat = oE;
Ce.writeFloatBE = aE;
Ce.writeDouble = hE;
Ce.writeDoubleBE = dE;
Ce.readVarint = uE;
Ce.writeVarint = lE;
Ce.sizeVarint = ha;
Ce.readVarint2 = xE;
Ce.writeVarint2 = bE;
Ce.sizeVarint2 = pE;
Ce.sliceBytes = mE;
Ce.readBytes = gE;
Ce.writeBytes = wE;
Ce.readString = yE;
Ce.writeString = SE;
Ce.realloc = T9;
Ce.copy = BE;
Ce.concat = vE;
Ce.sizeVarBytes = EE;
Ce.sizeVarlen = IE;
Ce.sizeVarString = AE;
/*!
 * reader.js - buffer reader for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const K0 = Vn, Gt = Ce, pf = Qf, _E = Buffer.alloc(0);
let ME = class {
  /**
   * Create a buffer reader.
   * @constructor
   * @param {Buffer} data
   * @param {Boolean?} zeroCopy - Do not reallocate buffers when
   * slicing. Note that this can lead to memory leaks if not used
   * carefully.
   */
  constructor(e, t = !1) {
    K0(Buffer.isBuffer(e), "data", "buffer"), K0(typeof t == "boolean", "zeroCopy", "boolean"), this.data = e, this.offset = 0, this.zeroCopy = t, this.stack = [];
  }
  /**
   * Assertion.
   * @param {Number} size
   */
  check(e) {
    if (this.offset + e > this.data.length)
      throw new pf(this.offset, "Out of bounds read", this.check);
  }
  /**
   * Get total size of passed-in Buffer.
   * @returns {Buffer}
   */
  getSize() {
    return this.data.length;
  }
  /**
   * Calculate number of bytes left to read.
   * @returns {Number}
   */
  left() {
    return this.check(0), this.data.length - this.offset;
  }
  /**
   * Seek to a position to read from by offset.
   * @param {Number} off - Offset (positive or negative).
   */
  seek(e) {
    if (K0(Number.isSafeInteger(e), "off", "integer"), this.offset + e < 0)
      throw new pf(this.offset, "Out of bounds read");
    return this.check(e), this.offset += e, this;
  }
  /**
   * Mark the current starting position.
   */
  start() {
    return this.stack.push(this.offset), this.offset;
  }
  /**
   * Stop reading. Pop the start position off the stack
   * and calculate the size of the data read.
   * @returns {Number} Size.
   * @throws on empty stack.
   */
  end() {
    if (this.stack.length === 0)
      throw new Error("Cannot end without a stack item.");
    const e = this.stack.pop();
    return this.offset - e;
  }
  /**
   * Stop reading. Pop the start position off the stack
   * and return the data read.
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer} Data read.
   * @throws on empty stack.
   */
  endData(e = !1) {
    if (K0(typeof e == "boolean", "zeroCopy", "boolean"), this.stack.length === 0)
      throw new Error("Cannot end without a stack item.");
    const t = this.stack.pop(), i = this.offset, n = i - t, c = this.data;
    if (n === c.length)
      return c;
    if (this.zeroCopy || e)
      return c.slice(t, i);
    const o = Buffer.allocUnsafeSlow(n);
    return c.copy(o, 0, t, i), o;
  }
  /**
   * Destroy the reader. Remove references to the data.
   */
  destroy() {
    return this.data = _E, this.offset = 0, this.stack.length = 0, this;
  }
  /**
   * Read uint8.
   * @returns {Number}
   */
  readU8() {
    this.check(1);
    const e = this.data[this.offset];
    return this.offset += 1, e;
  }
  /**
   * Read uint16le.
   * @returns {Number}
   */
  readU16() {
    this.check(2);
    const e = Gt.readU16(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read uint16be.
   * @returns {Number}
   */
  readU16BE() {
    this.check(2);
    const e = Gt.readU16BE(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read uint24le.
   * @returns {Number}
   */
  readU24() {
    this.check(3);
    const e = Gt.readU24(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read uint24be.
   * @returns {Number}
   */
  readU24BE() {
    this.check(3);
    const e = Gt.readU24BE(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read uint32le.
   * @returns {Number}
   */
  readU32() {
    this.check(4);
    const e = Gt.readU32(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read uint32be.
   * @returns {Number}
   */
  readU32BE() {
    this.check(4);
    const e = Gt.readU32BE(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read uint40le.
   * @returns {Number}
   */
  readU40() {
    this.check(5);
    const e = Gt.readU40(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read uint40be.
   * @returns {Number}
   */
  readU40BE() {
    this.check(5);
    const e = Gt.readU40BE(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read uint48le.
   * @returns {Number}
   */
  readU48() {
    this.check(6);
    const e = Gt.readU48(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read uint48be.
   * @returns {Number}
   */
  readU48BE() {
    this.check(6);
    const e = Gt.readU48BE(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read uint56le.
   * @returns {Number}
   */
  readU56() {
    this.check(7);
    const e = Gt.readU56(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read uint56be.
   * @returns {Number}
   */
  readU56BE() {
    this.check(7);
    const e = Gt.readU56BE(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read uint64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readU64() {
    this.check(8);
    const e = Gt.readU64(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read uint64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readU64BE() {
    this.check(8);
    const e = Gt.readU64BE(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read int8.
   * @returns {Number}
   */
  readI8() {
    this.check(1);
    const e = Gt.readI8(this.data, this.offset);
    return this.offset += 1, e;
  }
  /**
   * Read int16le.
   * @returns {Number}
   */
  readI16() {
    this.check(2);
    const e = Gt.readI16(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read int16be.
   * @returns {Number}
   */
  readI16BE() {
    this.check(2);
    const e = Gt.readI16BE(this.data, this.offset);
    return this.offset += 2, e;
  }
  /**
   * Read int24le.
   * @returns {Number}
   */
  readI24() {
    this.check(3);
    const e = Gt.readI24(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read int24be.
   * @returns {Number}
   */
  readI24BE() {
    this.check(3);
    const e = Gt.readI24BE(this.data, this.offset);
    return this.offset += 3, e;
  }
  /**
   * Read int32le.
   * @returns {Number}
   */
  readI32() {
    this.check(4);
    const e = Gt.readI32(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read int32be.
   * @returns {Number}
   */
  readI32BE() {
    this.check(4);
    const e = Gt.readI32BE(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read int40le.
   * @returns {Number}
   */
  readI40() {
    this.check(5);
    const e = Gt.readI40(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read int40be.
   * @returns {Number}
   */
  readI40BE() {
    this.check(5);
    const e = Gt.readI40BE(this.data, this.offset);
    return this.offset += 5, e;
  }
  /**
   * Read int48le.
   * @returns {Number}
   */
  readI48() {
    this.check(6);
    const e = Gt.readI48(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read int48be.
   * @returns {Number}
   */
  readI48BE() {
    this.check(6);
    const e = Gt.readI48BE(this.data, this.offset);
    return this.offset += 6, e;
  }
  /**
   * Read int56le.
   * @returns {Number}
   */
  readI56() {
    this.check(7);
    const e = Gt.readI56(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read int56be.
   * @returns {Number}
   */
  readI56BE() {
    this.check(7);
    const e = Gt.readI56BE(this.data, this.offset);
    return this.offset += 7, e;
  }
  /**
   * Read int64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readI64() {
    this.check(8);
    const e = Gt.readI64(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read int64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */
  readI64BE() {
    this.check(8);
    const e = Gt.readI64BE(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read float le.
   * @returns {Number}
   */
  readFloat() {
    this.check(4);
    const e = Gt.readFloat(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read float be.
   * @returns {Number}
   */
  readFloatBE() {
    this.check(4);
    const e = Gt.readFloatBE(this.data, this.offset);
    return this.offset += 4, e;
  }
  /**
   * Read double float le.
   * @returns {Number}
   */
  readDouble() {
    this.check(8);
    const e = Gt.readDouble(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read double float be.
   * @returns {Number}
   */
  readDoubleBE() {
    this.check(8);
    const e = Gt.readDoubleBE(this.data, this.offset);
    return this.offset += 8, e;
  }
  /**
   * Read a varint.
   * @returns {Number}
   */
  readVarint() {
    const { size: e, value: t } = Gt.readVarint(this.data, this.offset);
    return this.offset += e, t;
  }
  /**
   * Read a varint (type 2).
   * @returns {Number}
   */
  readVarint2() {
    const { size: e, value: t } = Gt.readVarint2(this.data, this.offset);
    return this.offset += e, t;
  }
  /**
   * Read N bytes (will do a fast slice if zero copy).
   * @param {Number} size
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */
  readBytes(e, t = !1) {
    K0(e >>> 0 === e, "size", "integer"), K0(typeof t == "boolean", "zeroCopy", "boolean"), this.check(e);
    let i;
    return this.zeroCopy || t ? i = this.data.slice(this.offset, this.offset + e) : (i = Buffer.allocUnsafeSlow(e), this.data.copy(i, 0, this.offset, this.offset + e)), this.offset += e, i;
  }
  /**
   * Read a varint number of bytes (will do a fast slice if zero copy).
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */
  readVarBytes(e = !1) {
    return this.readBytes(this.readVarint(), e);
  }
  /**
   * Slice N bytes and create a child reader.
   * @param {Number} size
   * @returns {BufferReader}
   */
  readChild(e) {
    K0(e >>> 0 === e, "size", "integer"), this.check(e);
    const t = this.data.slice(0, this.offset + e), i = new this.constructor(t);
    return i.offset = this.offset, this.offset += e, i;
  }
  /**
   * Read a string.
   * @param {Number} size
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */
  readString(e, t) {
    t == null && (t = "binary"), K0(e >>> 0 === e, "size", "integer"), K0(typeof t == "string", "enc", "string"), this.check(e);
    const i = this.data.toString(t, this.offset, this.offset + e);
    return this.offset += e, i;
  }
  /**
   * Read a 32-byte hash.
   * @param {String} enc - `"hex"` or `null`.
   * @returns {Hash|Buffer}
   */
  readHash(e) {
    return e ? this.readString(32, e) : this.readBytes(32);
  }
  /**
   * Read string of a varint length.
   * @param {String} enc - Any buffer-supported encoding.
   * @param {Number?} limit - Size limit.
   * @returns {String}
   */
  readVarString(e, t = 0) {
    e == null && (e = "binary"), K0(typeof e == "string", "enc", "string"), K0(t >>> 0 === t, "limit", "integer");
    const i = this.readVarint();
    if (t !== 0 && i > t)
      throw new pf(this.offset, "String exceeds limit");
    return this.readString(i, e);
  }
  /**
   * Read a null-terminated string.
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */
  readNullString(e) {
    e == null && (e = "binary"), K0(typeof e == "string", "enc", "string");
    let t = this.offset;
    for (; t < this.data.length && this.data[t] !== 0; t++)
      ;
    if (t === this.data.length)
      throw new pf(this.offset, "No NUL terminator");
    const i = this.readString(t - this.offset, e);
    return this.offset = t + 1, i;
  }
  /**
   * Create a checksum from the last start position.
   * @param {Function} hash
   * @returns {Number} Checksum.
   */
  createChecksum(e) {
    (!e || typeof e.digest != "function") && K0(typeof e == "function", "hash", "function");
    let t = 0;
    this.stack.length > 0 && (t = this.stack[this.stack.length - 1]);
    const i = this.data.slice(t, this.offset), n = e.digest ? e.digest(i) : e(i);
    return Gt.readU32(n, 0);
  }
  /**
   * Verify a 4-byte checksum against a calculated checksum.
   * @param {Function} hash
   * @returns {Number} checksum
   * @throws on bad checksum
   */
  verifyChecksum(e) {
    const t = this.createChecksum(e), i = this.readU32();
    if (t !== i)
      throw new pf(this.offset, "Checksum mismatch");
    return t;
  }
};
var $9 = ME;
/*!
 * writer.js - buffer writer for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Wr = Vn, Ct = Ce, h6 = Qf, d6 = 0, u6 = 1, l6 = 2, x6 = 3, b6 = 4, p6 = 5, m6 = 6, g6 = 7, w6 = 8, y6 = 9, S6 = 10, B6 = 11, v6 = 12, E6 = 13, I6 = 14, A6 = 15, _6 = 16, M6 = 17, N6 = 18, O6 = 19, P6 = 20, R6 = 21, k6 = 22, q6 = 23, z6 = 24, U6 = 25, C6 = 26, T6 = 27, D6 = 28, L6 = 29, K6 = 30, $6 = 31, H6 = 32, F6 = 33, V6 = 34, mf = 35, G6 = 36, Ad = 37, _d = 38, Y6 = 39, J6 = 40;
let NE = class {
  /**
   * Create a buffer writer.
   * @constructor
   */
  constructor() {
    this.ops = [], this.offset = 0;
  }
  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */
  render() {
    const e = Buffer.allocUnsafeSlow(this.offset);
    let t = 0;
    for (const i of this.ops)
      switch (i.type) {
        case d6:
          t += i.value;
          break;
        case u6:
          t = Ct.writeU8(e, i.value, t);
          break;
        case l6:
          t = Ct.writeU16(e, i.value, t);
          break;
        case x6:
          t = Ct.writeU16BE(e, i.value, t);
          break;
        case b6:
          t = Ct.writeU24(e, i.value, t);
          break;
        case p6:
          t = Ct.writeU24BE(e, i.value, t);
          break;
        case m6:
          t = Ct.writeU32(e, i.value, t);
          break;
        case g6:
          t = Ct.writeU32BE(e, i.value, t);
          break;
        case w6:
          t = Ct.writeU40(e, i.value, t);
          break;
        case y6:
          t = Ct.writeU40BE(e, i.value, t);
          break;
        case S6:
          t = Ct.writeU48(e, i.value, t);
          break;
        case B6:
          t = Ct.writeU48BE(e, i.value, t);
          break;
        case v6:
          t = Ct.writeU56(e, i.value, t);
          break;
        case E6:
          t = Ct.writeU56BE(e, i.value, t);
          break;
        case I6:
          t = Ct.writeU64(e, i.value, t);
          break;
        case A6:
          t = Ct.writeU64BE(e, i.value, t);
          break;
        case _6:
          t = Ct.writeI8(e, i.value, t);
          break;
        case M6:
          t = Ct.writeI16(e, i.value, t);
          break;
        case N6:
          t = Ct.writeI16BE(e, i.value, t);
          break;
        case O6:
          t = Ct.writeI24(e, i.value, t);
          break;
        case P6:
          t = Ct.writeI24BE(e, i.value, t);
          break;
        case R6:
          t = Ct.writeI32(e, i.value, t);
          break;
        case k6:
          t = Ct.writeI32BE(e, i.value, t);
          break;
        case q6:
          t = Ct.writeI40(e, i.value, t);
          break;
        case z6:
          t = Ct.writeI40BE(e, i.value, t);
          break;
        case U6:
          t = Ct.writeI48(e, i.value, t);
          break;
        case C6:
          t = Ct.writeI48BE(e, i.value, t);
          break;
        case T6:
          t = Ct.writeI56(e, i.value, t);
          break;
        case D6:
          t = Ct.writeI56BE(e, i.value, t);
          break;
        case L6:
          t = Ct.writeI64(e, i.value, t);
          break;
        case K6:
          t = Ct.writeI64BE(e, i.value, t);
          break;
        case $6:
          t = Ct.writeFloat(e, i.value, t);
          break;
        case H6:
          t = Ct.writeFloatBE(e, i.value, t);
          break;
        case F6:
          t = Ct.writeDouble(e, i.value, t);
          break;
        case V6:
          t = Ct.writeDoubleBE(e, i.value, t);
          break;
        case mf:
          t = Ct.writeVarint(e, i.value, t);
          break;
        case G6:
          t = Ct.writeVarint2(e, i.value, t);
          break;
        case Ad:
          t += i.data.copy(e, t);
          break;
        case _d:
          t += e.write(i.value, t, i.enc);
          break;
        case Y6:
          t += i.func(e.slice(0, t)).copy(e, t, 0, 4);
          break;
        case J6:
          e.fill(i.value, t, t + i.size), t += i.size;
          break;
        default:
          throw new Error("Invalid type.");
      }
    if (t !== e.length)
      throw new h6(t, "Out of bounds write");
    return this.destroy(), e;
  }
  /**
   * Get size of data written so far.
   * @returns {Number}
   */
  getSize() {
    return this.offset;
  }
  /**
   * Seek to relative offset.
   * @param {Number} offset
   */
  seek(e) {
    if (Wr(Number.isSafeInteger(e), "off", "integer"), this.offset + e < 0)
      throw new h6(this.offset, "Out of bounds write");
    return this.offset += e, this.ops.push(new Tt(d6, e)), this;
  }
  /**
   * Destroy the buffer writer. Remove references to `ops`.
   */
  destroy() {
    return this.ops.length = 0, this.offset = 0, this;
  }
  /**
   * Write uint8.
   * @param {Number} value
   */
  writeU8(e) {
    return this.offset += 1, this.ops.push(new Tt(u6, e)), this;
  }
  /**
   * Write uint16le.
   * @param {Number} value
   */
  writeU16(e) {
    return this.offset += 2, this.ops.push(new Tt(l6, e)), this;
  }
  /**
   * Write uint16be.
   * @param {Number} value
   */
  writeU16BE(e) {
    return this.offset += 2, this.ops.push(new Tt(x6, e)), this;
  }
  /**
   * Write uint24le.
   * @param {Number} value
   */
  writeU24(e) {
    return this.offset += 3, this.ops.push(new Tt(b6, e)), this;
  }
  /**
   * Write uint24be.
   * @param {Number} value
   */
  writeU24BE(e) {
    return this.offset += 3, this.ops.push(new Tt(p6, e)), this;
  }
  /**
   * Write uint32le.
   * @param {Number} value
   */
  writeU32(e) {
    return this.offset += 4, this.ops.push(new Tt(m6, e)), this;
  }
  /**
   * Write uint32be.
   * @param {Number} value
   */
  writeU32BE(e) {
    return this.offset += 4, this.ops.push(new Tt(g6, e)), this;
  }
  /**
   * Write uint40le.
   * @param {Number} value
   */
  writeU40(e) {
    return this.offset += 5, this.ops.push(new Tt(w6, e)), this;
  }
  /**
   * Write uint40be.
   * @param {Number} value
   */
  writeU40BE(e) {
    return this.offset += 5, this.ops.push(new Tt(y6, e)), this;
  }
  /**
   * Write uint48le.
   * @param {Number} value
   */
  writeU48(e) {
    return this.offset += 6, this.ops.push(new Tt(S6, e)), this;
  }
  /**
   * Write uint48be.
   * @param {Number} value
   */
  writeU48BE(e) {
    return this.offset += 6, this.ops.push(new Tt(B6, e)), this;
  }
  /**
   * Write uint56le.
   * @param {Number} value
   */
  writeU56(e) {
    return this.offset += 7, this.ops.push(new Tt(v6, e)), this;
  }
  /**
   * Write uint56be.
   * @param {Number} value
   */
  writeU56BE(e) {
    return this.offset += 7, this.ops.push(new Tt(E6, e)), this;
  }
  /**
   * Write uint64le.
   * @param {Number} value
   */
  writeU64(e) {
    return this.offset += 8, this.ops.push(new Tt(I6, e)), this;
  }
  /**
   * Write uint64be.
   * @param {Number} value
   */
  writeU64BE(e) {
    return this.offset += 8, this.ops.push(new Tt(A6, e)), this;
  }
  /**
   * Write int8.
   * @param {Number} value
   */
  writeI8(e) {
    return this.offset += 1, this.ops.push(new Tt(_6, e)), this;
  }
  /**
   * Write int16le.
   * @param {Number} value
   */
  writeI16(e) {
    return this.offset += 2, this.ops.push(new Tt(M6, e)), this;
  }
  /**
   * Write int16be.
   * @param {Number} value
   */
  writeI16BE(e) {
    return this.offset += 2, this.ops.push(new Tt(N6, e)), this;
  }
  /**
   * Write int24le.
   * @param {Number} value
   */
  writeI24(e) {
    return this.offset += 3, this.ops.push(new Tt(O6, e)), this;
  }
  /**
   * Write int24be.
   * @param {Number} value
   */
  writeI24BE(e) {
    return this.offset += 3, this.ops.push(new Tt(P6, e)), this;
  }
  /**
   * Write int32le.
   * @param {Number} value
   */
  writeI32(e) {
    return this.offset += 4, this.ops.push(new Tt(R6, e)), this;
  }
  /**
   * Write int32be.
   * @param {Number} value
   */
  writeI32BE(e) {
    return this.offset += 4, this.ops.push(new Tt(k6, e)), this;
  }
  /**
   * Write int40le.
   * @param {Number} value
   */
  writeI40(e) {
    return this.offset += 5, this.ops.push(new Tt(q6, e)), this;
  }
  /**
   * Write int40be.
   * @param {Number} value
   */
  writeI40BE(e) {
    return this.offset += 5, this.ops.push(new Tt(z6, e)), this;
  }
  /**
   * Write int48le.
   * @param {Number} value
   */
  writeI48(e) {
    return this.offset += 6, this.ops.push(new Tt(U6, e)), this;
  }
  /**
   * Write int48be.
   * @param {Number} value
   */
  writeI48BE(e) {
    return this.offset += 6, this.ops.push(new Tt(C6, e)), this;
  }
  /**
   * Write int56le.
   * @param {Number} value
   */
  writeI56(e) {
    return this.offset += 7, this.ops.push(new Tt(T6, e)), this;
  }
  /**
   * Write int56be.
   * @param {Number} value
   */
  writeI56BE(e) {
    return this.offset += 7, this.ops.push(new Tt(D6, e)), this;
  }
  /**
   * Write int64le.
   * @param {Number} value
   */
  writeI64(e) {
    return this.offset += 8, this.ops.push(new Tt(L6, e)), this;
  }
  /**
   * Write int64be.
   * @param {Number} value
   */
  writeI64BE(e) {
    return this.offset += 8, this.ops.push(new Tt(K6, e)), this;
  }
  /**
   * Write float le.
   * @param {Number} value
   */
  writeFloat(e) {
    return this.offset += 4, this.ops.push(new Tt($6, e)), this;
  }
  /**
   * Write float be.
   * @param {Number} value
   */
  writeFloatBE(e) {
    return this.offset += 4, this.ops.push(new Tt(H6, e)), this;
  }
  /**
   * Write double le.
   * @param {Number} value
   */
  writeDouble(e) {
    return this.offset += 8, this.ops.push(new Tt(F6, e)), this;
  }
  /**
   * Write double be.
   * @param {Number} value
   */
  writeDoubleBE(e) {
    return this.offset += 8, this.ops.push(new Tt(V6, e)), this;
  }
  /**
   * Write a varint.
   * @param {Number} value
   */
  writeVarint(e) {
    return this.offset += Ct.sizeVarint(e), this.ops.push(new Tt(mf, e)), this;
  }
  /**
   * Write a varint (type 2).
   * @param {Number} value
   */
  writeVarint2(e) {
    return this.offset += Ct.sizeVarint2(e), this.ops.push(new Tt(G6, e)), this;
  }
  /**
   * Write bytes.
   * @param {Buffer} value
   */
  writeBytes(e) {
    return Wr(Buffer.isBuffer(e), "value", "buffer"), e.length === 0 ? this : (this.offset += e.length, this.ops.push(new X6(Ad, e)), this);
  }
  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */
  writeVarBytes(e) {
    return Wr(Buffer.isBuffer(e), "value", "buffer"), this.offset += Ct.sizeVarint(e.length), this.ops.push(new Tt(mf, e.length)), e.length === 0 ? this : (this.offset += e.length, this.ops.push(new X6(Ad, e)), this);
  }
  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */
  copy(e, t, i) {
    Wr(Buffer.isBuffer(e), "value", "buffer"), Wr(t >>> 0 === t, "start", "integer"), Wr(i >>> 0 === i, "end", "integer"), Wr(i >= t, "start", "integer");
    const n = e.slice(t, i);
    return this.writeBytes(n), this;
  }
  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeString(e, t) {
    return t == null && (t = "binary"), Wr(typeof e == "string", "value", "string"), Wr(typeof t == "string", "enc", "string"), e.length === 0 ? this : (this.offset += Buffer.byteLength(e, t), this.ops.push(new Z6(_d, e, t)), this);
  }
  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */
  writeHash(e) {
    return typeof e != "string" ? (Wr(Buffer.isBuffer(e), "value", "buffer"), Wr(e.length === 32, "value", "32-byte hash"), this.writeBytes(e), this) : (Wr(e.length === 64, "value", "32-byte hash"), this.writeString(e, "hex"), this);
  }
  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeVarString(e, t) {
    if (t == null && (t = "binary"), Wr(typeof e == "string", "value", "string"), Wr(typeof t == "string", "enc", "string"), e.length === 0)
      return this.ops.push(new Tt(mf, 0)), this;
    const i = Buffer.byteLength(e, t);
    return this.offset += Ct.sizeVarint(i), this.offset += i, this.ops.push(new Tt(mf, i)), this.ops.push(new Z6(_d, e, t)), this;
  }
  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeNullString(e, t) {
    return this.writeString(e, t), this.writeU8(0), this;
  }
  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */
  writeChecksum(e) {
    return e && typeof e.digest == "function" && (e = e.digest.bind(e)), Wr(typeof e == "function", "hash", "function"), this.offset += 4, this.ops.push(new OE(Y6, e)), this;
  }
  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */
  fill(e, t) {
    return Wr((e & 255) === e, "value", "byte"), Wr(t >>> 0 === t, "size", "integer"), t === 0 ? this : (this.offset += t, this.ops.push(new PE(J6, e, t)), this);
  }
};
class sc {
  constructor(e) {
    this.type = e;
  }
}
class Tt extends sc {
  constructor(e, t) {
    super(e), this.value = t;
  }
}
class X6 extends sc {
  constructor(e, t) {
    super(e), this.data = t;
  }
}
class Z6 extends sc {
  constructor(e, t, i) {
    super(e), this.value = t, this.enc = i;
  }
}
class OE extends sc {
  constructor(e, t) {
    super(e), this.func = t;
  }
}
class PE extends sc {
  constructor(e, t, i) {
    super(e), this.value = t, this.size = i;
  }
}
var H9 = NE;
/*!
 * staticwriter.js - buffer writer for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Kr = Vn, Yt = Ce, wc = Qf, W6 = Buffer.alloc(0), j6 = 102400;
let Md = null, RE = class k1 {
  /**
   * Statically allocated buffer writer.
   * @constructor
   * @param {Number|Buffer} options
   */
  constructor(e) {
    this.data = W6, this.offset = 0, e != null && this.init(e);
  }
  /**
   * Assertion.
   * @param {Number} size
   */
  check(e) {
    if (this.offset + e > this.data.length)
      throw new wc(this.offset, "Out of bounds write", this.check);
  }
  /**
   * Initialize options.
   * @param {Object} options
   */
  init(e) {
    return Buffer.isBuffer(e) ? (this.data = e, this.offset = 0, this) : (Kr(e >>> 0 === e, "size", "integer"), this.data = Buffer.allocUnsafeSlow(e), this.offset = 0, this);
  }
  /**
   * Allocate writer from preallocated 100kb pool.
   * @param {Number} size
   * @returns {StaticWriter}
   */
  static pool(e) {
    if (Kr(e >>> 0 === e, "size", "integer"), e <= j6) {
      Md || (Md = Buffer.allocUnsafeSlow(j6));
      const t = new k1();
      return t.data = Md.slice(0, e), t;
    }
    return new k1(e);
  }
  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */
  render() {
    const { data: e, offset: t } = this;
    if (t !== e.length)
      throw new wc(t, "Out of bounds write");
    return this.destroy(), e;
  }
  /**
   * Slice the final buffer at written offset.
   * @returns {Buffer} Rendered buffer.
   */
  slice() {
    const { data: e, offset: t } = this;
    if (t > e.length)
      throw new wc(t, "Out of bounds write");
    return this.destroy(), e.slice(0, t);
  }
  /**
   * Get size of data written so far.
   * @returns {Number}
   */
  getSize() {
    return this.offset;
  }
  /**
   * Seek to relative offset.
   * @param {Number} off
   */
  seek(e) {
    if (Kr(Number.isSafeInteger(e), "off", "integer"), this.offset + e < 0)
      throw new wc(this.offset, "Out of bounds write");
    return this.check(e), this.offset += e, this;
  }
  /**
   * Destroy the buffer writer.
   */
  destroy() {
    return this.data = W6, this.offset = 0, this;
  }
  /**
   * Write uint8.
   * @param {Number} value
   */
  writeU8(e) {
    return this.check(1), this.offset = Yt.writeU8(this.data, e, this.offset), this;
  }
  /**
   * Write uint16le.
   * @param {Number} value
   */
  writeU16(e) {
    return this.check(2), this.offset = Yt.writeU16(this.data, e, this.offset), this;
  }
  /**
   * Write uint16be.
   * @param {Number} value
   */
  writeU16BE(e) {
    return this.check(2), this.offset = Yt.writeU16BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint24le.
   * @param {Number} value
   */
  writeU24(e) {
    return this.check(3), this.offset = Yt.writeU24(this.data, e, this.offset), this;
  }
  /**
   * Write uint24be.
   * @param {Number} value
   */
  writeU24BE(e) {
    return this.check(3), this.offset = Yt.writeU24BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint32le.
   * @param {Number} value
   */
  writeU32(e) {
    return this.check(4), this.offset = Yt.writeU32(this.data, e, this.offset), this;
  }
  /**
   * Write uint32be.
   * @param {Number} value
   */
  writeU32BE(e) {
    return this.check(4), this.offset = Yt.writeU32BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint40le.
   * @param {Number} value
   */
  writeU40(e) {
    return this.check(5), this.offset = Yt.writeU40(this.data, e, this.offset), this;
  }
  /**
   * Write uint40be.
   * @param {Number} value
   */
  writeU40BE(e) {
    return this.check(5), this.offset = Yt.writeU40BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint48le.
   * @param {Number} value
   */
  writeU48(e) {
    return this.check(6), this.offset = Yt.writeU48(this.data, e, this.offset), this;
  }
  /**
   * Write uint48be.
   * @param {Number} value
   */
  writeU48BE(e) {
    return this.check(6), this.offset = Yt.writeU48BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint56le.
   * @param {Number} value
   */
  writeU56(e) {
    return this.check(7), this.offset = Yt.writeU56(this.data, e, this.offset), this;
  }
  /**
   * Write uint56be.
   * @param {Number} value
   */
  writeU56BE(e) {
    return this.check(7), this.offset = Yt.writeU56BE(this.data, e, this.offset), this;
  }
  /**
   * Write uint64le.
   * @param {Number} value
   */
  writeU64(e) {
    return this.check(8), this.offset = Yt.writeU64(this.data, e, this.offset), this;
  }
  /**
   * Write uint64be.
   * @param {Number} value
   */
  writeU64BE(e) {
    return this.check(8), this.offset = Yt.writeU64BE(this.data, e, this.offset), this;
  }
  /**
   * Write int8.
   * @param {Number} value
   */
  writeI8(e) {
    return this.check(1), this.offset = Yt.writeI8(this.data, e, this.offset), this;
  }
  /**
   * Write int16le.
   * @param {Number} value
   */
  writeI16(e) {
    return this.check(2), this.offset = Yt.writeI16(this.data, e, this.offset), this;
  }
  /**
   * Write int16be.
   * @param {Number} value
   */
  writeI16BE(e) {
    return this.check(2), this.offset = Yt.writeI16BE(this.data, e, this.offset), this;
  }
  /**
   * Write int24le.
   * @param {Number} value
   */
  writeI24(e) {
    return this.check(3), this.offset = Yt.writeI24(this.data, e, this.offset), this;
  }
  /**
   * Write int24be.
   * @param {Number} value
   */
  writeI24BE(e) {
    return this.check(3), this.offset = Yt.writeI24BE(this.data, e, this.offset), this;
  }
  /**
   * Write int32le.
   * @param {Number} value
   */
  writeI32(e) {
    return this.check(4), this.offset = Yt.writeI32(this.data, e, this.offset), this;
  }
  /**
   * Write int32be.
   * @param {Number} value
   */
  writeI32BE(e) {
    return this.check(4), this.offset = Yt.writeI32BE(this.data, e, this.offset), this;
  }
  /**
   * Write int40le.
   * @param {Number} value
   */
  writeI40(e) {
    return this.check(5), this.offset = Yt.writeI40(this.data, e, this.offset), this;
  }
  /**
   * Write int40be.
   * @param {Number} value
   */
  writeI40BE(e) {
    return this.check(5), this.offset = Yt.writeI40BE(this.data, e, this.offset), this;
  }
  /**
   * Write int48le.
   * @param {Number} value
   */
  writeI48(e) {
    return this.check(6), this.offset = Yt.writeI48(this.data, e, this.offset), this;
  }
  /**
   * Write int48be.
   * @param {Number} value
   */
  writeI48BE(e) {
    return this.check(6), this.offset = Yt.writeI48BE(this.data, e, this.offset), this;
  }
  /**
   * Write int56le.
   * @param {Number} value
   */
  writeI56(e) {
    return this.check(7), this.offset = Yt.writeI56(this.data, e, this.offset), this;
  }
  /**
   * Write int56be.
   * @param {Number} value
   */
  writeI56BE(e) {
    return this.check(7), this.offset = Yt.writeI56BE(this.data, e, this.offset), this;
  }
  /**
   * Write int64le.
   * @param {Number} value
   */
  writeI64(e) {
    return this.check(8), this.offset = Yt.writeI64(this.data, e, this.offset), this;
  }
  /**
   * Write int64be.
   * @param {Number} value
   */
  writeI64BE(e) {
    return this.check(8), this.offset = Yt.writeI64BE(this.data, e, this.offset), this;
  }
  /**
   * Write float le.
   * @param {Number} value
   */
  writeFloat(e) {
    return this.check(4), this.offset = Yt.writeFloat(this.data, e, this.offset), this;
  }
  /**
   * Write float be.
   * @param {Number} value
   */
  writeFloatBE(e) {
    return this.check(4), this.offset = Yt.writeFloatBE(this.data, e, this.offset), this;
  }
  /**
   * Write double le.
   * @param {Number} value
   */
  writeDouble(e) {
    return this.check(8), this.offset = Yt.writeDouble(this.data, e, this.offset), this;
  }
  /**
   * Write double be.
   * @param {Number} value
   */
  writeDoubleBE(e) {
    return this.check(8), this.offset = Yt.writeDoubleBE(this.data, e, this.offset), this;
  }
  /**
   * Write a varint.
   * @param {Number} value
   */
  writeVarint(e) {
    return this.offset = Yt.writeVarint(this.data, e, this.offset), this;
  }
  /**
   * Write a varint (type 2).
   * @param {Number} value
   */
  writeVarint2(e) {
    return this.offset = Yt.writeVarint2(this.data, e, this.offset), this;
  }
  /**
   * Write bytes.
   * @param {Buffer} value
   */
  writeBytes(e) {
    return Kr(Buffer.isBuffer(e), "value", "buffer"), this.check(e.length), this.offset += e.copy(this.data, this.offset), this;
  }
  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */
  writeVarBytes(e) {
    return Kr(Buffer.isBuffer(e), "value", "buffer"), this.writeVarint(e.length), this.writeBytes(e), this;
  }
  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */
  copy(e, t, i) {
    return Kr(Buffer.isBuffer(e), "value", "buffer"), Kr(t >>> 0 === t, "start", "integer"), Kr(i >>> 0 === i, "end", "integer"), Kr(i >= t, "start", "integer"), this.check(i - t), this.offset += e.copy(this.data, this.offset, t, i), this;
  }
  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeString(e, t) {
    if (t == null && (t = "binary"), Kr(typeof e == "string", "value", "string"), Kr(typeof t == "string", "enc", "string"), e.length === 0)
      return this;
    const i = Buffer.byteLength(e, t);
    return this.check(i), this.offset += this.data.write(e, this.offset, t), this;
  }
  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */
  writeHash(e) {
    return typeof e != "string" ? (Kr(Buffer.isBuffer(e), "value", "buffer"), Kr(e.length === 32, "value", "32-byte hash"), this.writeBytes(e), this) : (Kr(e.length === 64, "value", "32-byte hash"), this.check(32), this.offset += this.data.write(e, this.offset, "hex"), this);
  }
  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeVarString(e, t) {
    if (t == null && (t = "binary"), Kr(typeof e == "string", "value", "string"), Kr(typeof t == "string", "enc", "string"), e.length === 0)
      return this.writeVarint(0), this;
    const i = Buffer.byteLength(e, t);
    return this.writeVarint(i), this.check(i), this.offset += this.data.write(e, this.offset, t), this;
  }
  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */
  writeNullString(e, t) {
    return this.writeString(e, t), this.writeU8(0), this;
  }
  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */
  writeChecksum(e) {
    (!e || typeof e.digest != "function") && Kr(typeof e == "function", "hash", "function"), this.check(4);
    const t = this.data.slice(0, this.offset);
    return (e.digest ? e.digest(t) : e(t)).copy(this.data, this.offset, 0, 4), this.offset += 4, this;
  }
  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */
  fill(e, t) {
    return Kr((e & 255) === e, "value", "byte"), Kr(t >>> 0 === t, "size", "integer"), this.check(t), this.data.fill(e, this.offset, this.offset + t), this.offset += t, this;
  }
};
var F9 = RE;
/*!
 * struct.js - struct object for bcoin
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Nd = Vn, kE = $9, qE = H9, zE = F9, { custom: UE } = zl;
let CE = class {
  constructor() {
  }
  inject(e) {
    return Nd(e instanceof this.constructor, "obj", "struct"), this.decode(e.encode());
  }
  clone() {
    return new this.constructor().inject(this);
  }
  /*
   * Bindable
   */
  getSize(e) {
    return -1;
  }
  write(e, t) {
    return e;
  }
  read(e, t) {
    return this;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  fromString(e, t) {
    return this;
  }
  getJSON() {
    return this;
  }
  fromJSON(e, t) {
    return this;
  }
  fromOptions(e, t) {
    return this;
  }
  from(e, t) {
    return this.fromOptions(e, t);
  }
  format() {
    return this.getJSON();
  }
  /*
   * API
   */
  encode(e) {
    const t = this.getSize(e), i = t === -1 ? new qE() : new zE(t);
    return this.write(i, e), i.render();
  }
  decode(e, t) {
    const i = new kE(e);
    return this.read(i, t), this;
  }
  toHex(e) {
    return this.encode(e).toString("hex");
  }
  fromHex(e, t) {
    Nd(typeof e == "string", "str", "string");
    const i = e.length >>> 1, n = Buffer.from(e, "hex");
    if (n.length !== i)
      throw new Error("Invalid hex string.");
    return this.decode(n, t);
  }
  toBase64(e) {
    return this.encode(e).toString("base64");
  }
  fromBase64(e, t) {
    Nd(typeof e == "string", "str", "string");
    const i = Buffer.from(e, "base64");
    if (e.length > TE(i.length))
      throw new Error("Invalid base64 string.");
    return this.decode(i, t);
  }
  toJSON() {
    return this.getJSON();
  }
  [UE]() {
    return this.format();
  }
  /*
   * Static API
   */
  static read(e, t) {
    return new this().read(e, t);
  }
  static decode(e, t) {
    return new this().decode(e, t);
  }
  static fromHex(e, t) {
    return new this().fromHex(e, t);
  }
  static fromBase64(e, t) {
    return new this().fromBase64(e, t);
  }
  static fromString(e, t) {
    return new this().fromString(e, t);
  }
  static fromJSON(e, t) {
    return new this().fromJSON(e, t);
  }
  static fromOptions(e, t) {
    return new this().fromOptions(e, t);
  }
  static from(e, t) {
    return new this().from(e, t);
  }
  /*
   * Aliases
   */
  toWriter(e, t) {
    return this.write(e, t);
  }
  fromReader(e, t) {
    return this.read(e, t);
  }
  toRaw(e) {
    return this.encode(e);
  }
  fromRaw(e, t) {
    return this.decode(e, t);
  }
  /*
   * Static Aliases
   */
  static fromReader(e, t) {
    return this.read(e, t);
  }
  static fromRaw(e, t) {
    return this.decode(e, t);
  }
};
function TE(r) {
  return (4 * r / 3 + 3 & -4) >>> 0;
}
var DE = CE;
/*!
 * bufio.js - buffer utilities for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const LE = zl, De = Ce, R0 = Vn, Xn = Qf, V9 = $9, G9 = H9, Gl = F9, KE = DE;
Me.custom = LE;
Me.encoding = De;
Me.EncodingError = Xn;
Me.BufferReader = V9;
Me.BufferWriter = G9;
Me.StaticWriter = Gl;
Me.Struct = KE;
Me.read = function(e, t) {
  return new V9(e, t);
};
Me.write = function(e) {
  return e != null ? new Gl(e) : new G9();
};
Me.pool = function(e) {
  return Gl.pool(e);
};
function tr(r, e) {
  return function(t, i) {
    if (R0(Buffer.isBuffer(t), "data", "buffer"), R0(i >>> 0 === i, "off", "integer"), i + e > t.length)
      throw new Xn(i, "Out of bounds read");
    return r(t, i);
  };
}
function la(r) {
  return function(e, t, i) {
    if (R0(Buffer.isBuffer(e), "data", "buffer"), R0(t >>> 0 === t, "off", "integer"), R0(i >>> 0 === i, "len", "integer"), t + i > e.length)
      throw new Xn(t, "Out of bounds read");
    return r(e, t, i);
  };
}
function Y9(r) {
  return function(e, t) {
    return R0(Buffer.isBuffer(e), "data", "buffer"), R0(t >>> 0 === t, "off", "integer"), r(e, t);
  };
}
function rr(r, e) {
  return function(t, i, n) {
    if (R0(Buffer.isBuffer(t), "data", "buffer"), R0(n >>> 0 === n, "off", "integer"), n + e > t.length)
      throw new Xn(n, "Out of bounds write");
    return r(t, i, n);
  };
}
function xa(r) {
  return function(e, t, i, n) {
    if (R0(Buffer.isBuffer(e), "data", "buffer"), R0(i >>> 0 === i, "off", "integer"), R0(n >>> 0 === n, "len", "integer"), i + n > e.length)
      throw new Xn(i, "Out of bounds write");
    return r(e, t, i, n);
  };
}
function J9(r, e) {
  return function(t, i, n) {
    if (R0(Buffer.isBuffer(t), "data", "buffer"), R0(n >>> 0 === n, "off", "integer"), n + e(i) > t.length)
      throw new Xn(n, "Out of bounds write");
    return r(t, i, n);
  };
}
Me.readU = la(De.readU);
Me.readU64 = tr(De.readU64, 8);
Me.readU56 = tr(De.readU56, 7);
Me.readU48 = tr(De.readU48, 6);
Me.readU40 = tr(De.readU40, 5);
Me.readU32 = tr(De.readU32, 4);
Me.readU24 = tr(De.readU24, 3);
Me.readU16 = tr(De.readU16, 2);
Me.readU8 = tr(De.readU8, 1);
Me.readUBE = la(De.readUBE);
Me.readU64BE = tr(De.readU64BE, 8);
Me.readU56BE = tr(De.readU56BE, 7);
Me.readU48BE = tr(De.readU48BE, 6);
Me.readU40BE = tr(De.readU40BE, 5);
Me.readU32BE = tr(De.readU32BE, 4);
Me.readU24BE = tr(De.readU24BE, 3);
Me.readU16BE = tr(De.readU16BE, 2);
Me.readI = la(De.readI);
Me.readI64 = tr(De.readI64, 8);
Me.readI56 = tr(De.readI56, 7);
Me.readI48 = tr(De.readI48, 6);
Me.readI40 = tr(De.readI40, 5);
Me.readI32 = tr(De.readI32, 4);
Me.readI24 = tr(De.readI24, 3);
Me.readI16 = tr(De.readI16, 2);
Me.readI8 = tr(De.readI8, 1);
Me.readIBE = la(De.readIBE);
Me.readI64BE = tr(De.readI64BE, 8);
Me.readI56BE = tr(De.readI56BE, 7);
Me.readI48BE = tr(De.readI48BE, 6);
Me.readI40BE = tr(De.readI40BE, 5);
Me.readI32BE = tr(De.readI32BE, 4);
Me.readI24BE = tr(De.readI24BE, 3);
Me.readI16BE = tr(De.readI16BE, 2);
Me.readFloat = tr(De.readFloat, 4);
Me.readFloatBE = tr(De.readFloatBE, 4);
Me.readDouble = tr(De.readDouble, 8);
Me.readDoubleBE = tr(De.readDoubleBE, 8);
Me.writeU = xa(De.writeU);
Me.writeU64 = rr(De.writeU64, 8);
Me.writeU56 = rr(De.writeU56, 7);
Me.writeU48 = rr(De.writeU48, 6);
Me.writeU40 = rr(De.writeU40, 5);
Me.writeU32 = rr(De.writeU32, 4);
Me.writeU24 = rr(De.writeU24, 3);
Me.writeU16 = rr(De.writeU16, 2);
Me.writeU8 = rr(De.writeU8, 1);
Me.writeUBE = xa(De.writeUBE);
Me.writeU64BE = rr(De.writeU64BE, 8);
Me.writeU56BE = rr(De.writeU56BE, 7);
Me.writeU48BE = rr(De.writeU48BE, 6);
Me.writeU40BE = rr(De.writeU40BE, 5);
Me.writeU32BE = rr(De.writeU32BE, 4);
Me.writeU24BE = rr(De.writeU24BE, 3);
Me.writeU16BE = rr(De.writeU16BE, 2);
Me.writeI = xa(De.writeI);
Me.writeI64 = rr(De.writeI64, 8);
Me.writeI56 = rr(De.writeI56, 7);
Me.writeI48 = rr(De.writeI48, 6);
Me.writeI40 = rr(De.writeI40, 5);
Me.writeI32 = rr(De.writeI32, 4);
Me.writeI24 = rr(De.writeI24, 3);
Me.writeI16 = rr(De.writeI16, 2);
Me.writeI8 = rr(De.writeI8, 1);
Me.writeIBE = xa(De.writeIBE);
Me.writeI64BE = rr(De.writeI64BE, 8);
Me.writeI56BE = rr(De.writeI56BE, 7);
Me.writeI48BE = rr(De.writeI48BE, 6);
Me.writeI40BE = rr(De.writeI40BE, 5);
Me.writeI32BE = rr(De.writeI32BE, 4);
Me.writeI24BE = rr(De.writeI24BE, 3);
Me.writeI16BE = rr(De.writeI16BE, 2);
Me.writeFloat = rr(De.writeFloat, 4);
Me.writeFloatBE = rr(De.writeFloatBE, 4);
Me.writeDouble = rr(De.writeDouble, 8);
Me.writeDoubleBE = rr(De.writeDoubleBE, 8);
Me.readVarint = Y9(De.readVarint);
Me.writeVarint = J9(De.writeVarint, De.sizeVarint);
Me.sizeVarint = De.sizeVarint;
Me.readVarint2 = Y9(De.readVarint2);
Me.writeVarint2 = J9(De.writeVarint2, De.sizeVarint2);
Me.sizeVarint2 = De.sizeVarint2;
Me.sliceBytes = De.sliceBytes;
Me.readBytes = De.readBytes;
Me.writeBytes = De.writeBytes;
Me.readString = De.readString;
Me.writeString = De.writeString;
Me.realloc = De.realloc;
Me.copy = De.copy;
Me.concat = De.concat;
Me.sizeVarBytes = De.sizeVarBytes;
Me.sizeVarlen = De.sizeVarlen;
Me.sizeVarString = De.sizeVarString;
var Os = {};
/*!
 * util.js - utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  const e = Ar, t = r;
  t.bench = function(n) {
    if (!process.hrtime) {
      const c = Date.now();
      if (n) {
        const [h, x] = n, b = h * 1e3 + x / 1e6;
        return c - b;
      }
      const o = c % 1e3, d = (c - o) / 1e3, l = o * 1e6;
      return [d, l];
    }
    if (n) {
      const [c, o] = process.hrtime(n);
      return c * 1e3 + o / 1e6;
    }
    return process.hrtime();
  }, t.now = function() {
    return Math.floor(Date.now() / 1e3);
  }, t.ms = function() {
    return Date.now();
  }, t.date = function(n) {
    return n == null && (n = t.now()), new Date(n * 1e3).toISOString().slice(0, -5) + "Z";
  }, t.time = function(n) {
    return n == null ? t.now() : new Date(n) / 1e3 | 0;
  }, t.revHex = function(n) {
    return e(Buffer.isBuffer(n)), Buffer.from(n).reverse().toString("hex");
  }, t.fromRev = function(n) {
    return e(typeof n == "string"), e((n.length & 1) === 0), Buffer.from(n, "hex").reverse();
  };
})(Os);
/*!
 * invitem.js - inv item object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Q6 = Me, $E = Os;
let ba = class rs {
  /**
   * Create an inv item.
   * @constructor
   * @param {Number} type
   * @param {Hash} hash
   */
  constructor(e, t) {
    this.type = e, this.hash = t;
  }
  /**
   * get size of inv item
   * @return {Number}
   */
  getSize() {
    return 36;
  }
  /**
   * Write inv item to buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    return e.writeU32(this.type), e.writeHash(this.hash), e;
  }
  /**
   * Serialize inv item.
   * @returns {Buffer}
   */
  toRaw() {
    return this.toWriter(Q6.write(36)).render();
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    return this.type = e.readU32(), this.hash = e.readHash(), this;
  }
  /**
   * Inject properties from serialized data.
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(Q6.read(e));
  }
  /**
   * Instantiate inv item from buffer reader.
   * @param {BufferReader} br
   * @returns {InvItem}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Instantiate inv item from serialized data.
   * @param {Buffer} data
   * @param {String?} enc
   * @returns {InvItem}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Test whether the inv item is a block.
   * @returns {Boolean}
   */
  isBlock() {
    switch (this.type) {
      case rs.types.BLOCK:
      case rs.types.WITNESS_BLOCK:
      case rs.types.FILTERED_BLOCK:
      case rs.types.WITNESS_FILTERED_BLOCK:
      case rs.types.CMPCT_BLOCK:
        return !0;
      default:
        return !1;
    }
  }
  /**
   * Test whether the inv item is a tx.
   * @returns {Boolean}
   */
  isTX() {
    switch (this.type) {
      case rs.types.TX:
      case rs.types.WITNESS_TX:
        return !0;
      default:
        return !1;
    }
  }
  /**
   * Test whether the inv item has the witness bit set.
   * @returns {Boolean}
   */
  hasWitness() {
    return (this.type & rs.WITNESS_FLAG) !== 0;
  }
  /**
   * Get little-endian hash.
   * @returns {Hash}
   */
  rhash() {
    return $E.revHex(this.hash);
  }
};
ba.types = {
  TX: 1,
  BLOCK: 2,
  FILTERED_BLOCK: 3,
  CMPCT_BLOCK: 4,
  WITNESS_TX: 1 | 1 << 30,
  WITNESS_BLOCK: 2 | 1 << 30,
  WITNESS_FILTERED_BLOCK: 3 | 1 << 30
};
ba.typesByVal = {
  1: "TX",
  2: "BLOCK",
  3: "FILTERED_BLOCK",
  4: "CMPCT_BLOCK",
  [1 | 1 << 30]: "WITNESS_TX",
  [2 | 1 << 30]: "WITNESS_BLOCK",
  [3 | 1 << 30]: "WITNESS_FILTERED_BLOCK"
};
ba.WITNESS_FLAG = 1 << 30;
var HE = ba, ri = {}, X9 = { exports: {} }, Od = {};
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var e4;
function Yl() {
  return e4 || (e4 = 1, Od.custom = "inspect"), Od;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
var Pd, t4;
function FE() {
  if (t4)
    return Pd;
  t4 = 1;
  const { custom: r } = Yl(), e = (1n << 8n) - 1n, t = (1n << 16n) - 1n, i = (1n << 32n) - 1n, n = (1n << 64n) - 1n, c = (1n << 128n) - 1n, o = (1n << 256n) - 1n, d = 9007199254740991n, l = new Int8Array(new Int16Array([1]).buffer)[0] === 0 ? "be" : "le", h = 4, x = 1 << h - 1, b = BigInt((1 << h) - 1), g = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  };
  class w {
    constructor(f, m, D) {
      this.n = 0n, this.red = null, this.from(f, m, D);
    }
    /*
     * Compat
     */
    get negative() {
      return this.n < 0n ? 1 : 0;
    }
    set negative(f) {
      (f & 1) !== this.negative && (this.n = -this.n);
    }
    get length() {
      return lt(this.n, 26);
    }
    /*
     * Addition
     */
    iadd(f) {
      return N(w.isBN(f), "num", "bignum"), this.n += f.n, this;
    }
    iaddn(f) {
      return N(he(f), "num", "smi"), this.n += BigInt(f), this;
    }
    add(f) {
      return this.clone().iadd(f);
    }
    addn(f) {
      return this.clone().iaddn(f);
    }
    /*
     * Subtraction
     */
    isub(f) {
      return N(w.isBN(f), "num", "bignum"), this.n -= f.n, this;
    }
    isubn(f) {
      return N(he(f), "num", "smi"), this.n -= BigInt(f), this;
    }
    sub(f) {
      return this.clone().isub(f);
    }
    subn(f) {
      return this.clone().isubn(f);
    }
    /*
     * Multiplication
     */
    imul(f) {
      return N(w.isBN(f), "num", "bignum"), this.n *= f.n, this;
    }
    imuln(f) {
      return N(he(f), "num", "smi"), this.n *= BigInt(f), this;
    }
    mul(f) {
      return this.clone().imul(f);
    }
    muln(f) {
      return this.clone().imuln(f);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(f, m) {
      return N(w.isBN(f), "num", "bignum"), N(m - 1 >>> 0 === m - 1, "bits", "uint32"), new w(ht(this.n, f.n, m));
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(f) {
      N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n);
      const [m, D] = dt(this.n, f.n);
      return [new w(m), new w(D)];
    }
    /*
     * Truncation Division
     */
    iquo(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n /= f.n, this;
    }
    iquon(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n /= BigInt(f), this;
    }
    quo(f) {
      return this.clone().iquo(f);
    }
    quon(f) {
      return this.clone().iquon(f);
    }
    /*
     * Truncation Modulo
     */
    irem(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n %= f.n, this;
    }
    iremn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n %= BigInt(f), this;
    }
    rem(f) {
      return this.clone().irem(f);
    }
    remn(f) {
      return this.clone().iremn(f);
    }
    remrn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), Se(this.n, f);
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(f) {
      N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n);
      const [m, D] = we(this.n, f.n);
      return [new w(m), new w(D)];
    }
    /*
     * Euclidean Division
     */
    idiv(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n = Z(this.n, f.n), this;
    }
    idivn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n = Z(this.n, BigInt(f)), this;
    }
    div(f) {
      return this.clone().idiv(f);
    }
    divn(f) {
      return this.clone().idivn(f);
    }
    /*
     * Euclidean Modulo
     */
    imod(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), this.n = L(this.n, f.n), this;
    }
    imodn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), this.n = L(this.n, BigInt(f)), this;
    }
    mod(f) {
      return this.clone().imod(f);
    }
    modn(f) {
      return this.clone().imodn(f);
    }
    modrn(f) {
      return N(he(f), "num", "smi"), ce(f !== 0), oe(this.n, f);
    }
    /*
     * Round Division
     */
    divRound(f) {
      return N(w.isBN(f), "num", "bignum"), ce(f.n !== 0n), new w(s(this.n, f.n));
    }
    /*
     * Exponentiation
     */
    ipow(f) {
      return N(w.isBN(f), "num", "bignum"), this.n **= Le(f.n), this;
    }
    ipown(f) {
      return N(he(f), "num", "smi"), this.n **= Le(BigInt(f)), this;
    }
    pow(f) {
      return this.clone().ipow(f);
    }
    pown(f) {
      return this.clone().ipown(f);
    }
    isqr() {
      return this.n *= this.n, this;
    }
    sqr() {
      return this.clone().isqr();
    }
    /*
     * Roots
     */
    rootrem(f) {
      const [m, D] = p(this.n, f);
      return [new w(m), new w(D)];
    }
    iroot(f) {
      return this.n = v(this.n, f), this;
    }
    root(f) {
      return this.clone().iroot(f);
    }
    isPower(f) {
      return C(this.n, f);
    }
    sqrtrem() {
      const [f, m] = K(this.n);
      return [new w(f), new w(m)];
    }
    isqrt() {
      return this.n = O(this.n), this;
    }
    sqrt() {
      return this.clone().isqrt();
    }
    isSquare() {
      return $(this.n);
    }
    /*
     * AND
     */
    iand(f) {
      return N(w.isBN(f), "num", "bignum"), this.n &= f.n, this;
    }
    iandn(f) {
      return N(he(f), "num", "smi"), this.n &= BigInt(f), this;
    }
    and(f) {
      return this.clone().iand(f);
    }
    andn(f) {
      return this.clone().iandn(f);
    }
    andrn(f) {
      N(he(f), "num", "smi");
      const m = this.n & BigInt(f);
      if (m < -0x3ffffffn || m > 0x3ffffffn)
        throw new RangeError("Number exceeds 26 bits.");
      return Number(m);
    }
    /*
     * Unsigned AND
     */
    iuand(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = S(this.n, f.n), this;
    }
    iuandn(f) {
      return N(he(f), "num", "smi"), this.n = M(this.n, f), this;
    }
    uand(f) {
      return this.clone().iuand(f);
    }
    uandn(f) {
      return this.clone().iuandn(f);
    }
    uandrn(f) {
      return N(he(f), "num", "smi"), Number(M(this.n, f));
    }
    /*
     * OR
     */
    ior(f) {
      return N(w.isBN(f), "num", "bignum"), this.n |= f.n, this;
    }
    iorn(f) {
      return N(he(f), "num", "smi"), this.n |= BigInt(f), this;
    }
    or(f) {
      return this.clone().ior(f);
    }
    orn(f) {
      return this.clone().iorn(f);
    }
    /*
     * Unsigned OR
     */
    iuor(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = Y(this.n, f.n), this;
    }
    iuorn(f) {
      return N(he(f), "num", "smi"), this.n = J(this.n, f), this;
    }
    uor(f) {
      return this.clone().iuor(f);
    }
    uorn(f) {
      return this.clone().iuorn(f);
    }
    /*
     * XOR
     */
    ixor(f) {
      return N(w.isBN(f), "num", "bignum"), this.n ^= f.n, this;
    }
    ixorn(f) {
      return N(he(f), "num", "smi"), this.n ^= BigInt(f), this;
    }
    xor(f) {
      return this.clone().ixor(f);
    }
    xorn(f) {
      return this.clone().ixorn(f);
    }
    /*
     * Unsigned XOR
     */
    iuxor(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = X(this.n, f.n), this;
    }
    iuxorn(f) {
      return N(he(f), "num", "smi"), this.n = re(this.n, f), this;
    }
    uxor(f) {
      return this.clone().ixor(f);
    }
    uxorn(f) {
      return this.clone().iuxorn(f);
    }
    /*
     * NOT
     */
    inot() {
      return this.n = ~this.n, this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(f) {
      return N(f >>> 0 === f, "width", "uint32"), this.n = ge(this.n, f), this;
    }
    notn(f) {
      return this.clone().inotn(f);
    }
    /*
     * Left Shift
     */
    ishl(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n <<= f.n, this;
    }
    ishln(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n <<= BigInt(f), this;
    }
    shl(f) {
      return this.clone().ishl(f);
    }
    shln(f) {
      return this.clone().ishln(f);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n <<= f.n, this;
    }
    iushln(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n <<= BigInt(f), this;
    }
    ushl(f) {
      return this.clone().iushl(f);
    }
    ushln(f) {
      return this.clone().iushln(f);
    }
    /*
     * Right Shift
     */
    ishr(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n >>= f.n, this;
    }
    ishrn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n >>= BigInt(f), this;
    }
    shr(f) {
      return this.clone().ishr(f);
    }
    shrn(f) {
      return this.clone().ishrn(f);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(f) {
      return N(w.isBN(f), "bits", "bignum"), N(f.n >= 0n && f.n <= i, "bits", "uint32"), this.n = ae(this.n, f.n), this;
    }
    iushrn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n = de(this.n, f), this;
    }
    ushr(f) {
      return this.clone().iushr(f);
    }
    ushrn(f) {
      return this.clone().iushrn(f);
    }
    /*
     * Bit Manipulation
     */
    setn(f, m) {
      return N(f >>> 0 === f, "bit", "uint32"), this.n = Be(this.n, f, m), this;
    }
    usetn(f, m) {
      return N(f >>> 0 === f, "bit", "uint32"), this.n = ve(this.n, f, m), this;
    }
    testn(f) {
      return N(f >>> 0 === f, "bit", "uint32"), Oe(this.n, f);
    }
    utestn(f) {
      return N(f >>> 0 === f, "bit", "uint32"), Ie(this.n, f);
    }
    imaskn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n = Re(this.n, f), this;
    }
    maskn(f) {
      return this.clone().imaskn(f);
    }
    iumaskn(f) {
      return N(f >>> 0 === f, "bits", "uint32"), this.n = ft(this.n, f), this;
    }
    umaskn(f) {
      return this.clone().iumaskn(f);
    }
    andln(f) {
      return Ye(this.n, f);
    }
    bit(f) {
      return this.utestn(f);
    }
    bits(f, m) {
      return N(f >>> 0 === f, "pos", "uint32"), N(m >>> 0 === m, "width", "uint32"), N(m <= 26, "width", "width"), Fe(this.n, f, m);
    }
    /*
     * Negation
     */
    ineg() {
      return this.n = -this.n, this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.n = Le(this.n), this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(f) {
      return N(w.isBN(f), "num", "bignum"), He(this.n, f.n);
    }
    cmpn(f) {
      return N(he(f), "num", "smi"), et(this.n, f);
    }
    eq(f) {
      return N(w.isBN(f), "num", "bignum"), this.n === f.n;
    }
    eqn(f) {
      return N(he(f), "num", "smi"), this.n == f;
    }
    gt(f) {
      return N(w.isBN(f), "num", "bignum"), this.n > f.n;
    }
    gtn(f) {
      return N(he(f), "num", "smi"), this.n > f;
    }
    gte(f) {
      return N(w.isBN(f), "num", "bignum"), this.n >= f.n;
    }
    gten(f) {
      return N(he(f), "num", "smi"), this.n >= f;
    }
    lt(f) {
      return N(w.isBN(f), "num", "bignum"), this.n < f.n;
    }
    ltn(f) {
      return N(he(f), "num", "smi"), this.n < f;
    }
    lte(f) {
      return N(w.isBN(f), "num", "bignum"), this.n <= f.n;
    }
    lten(f) {
      return N(he(f), "num", "smi"), this.n <= f;
    }
    sign() {
      return (this.n > 0n) - (this.n < 0n);
    }
    isZero() {
      return this.n === 0n;
    }
    isNeg() {
      return this.n < 0n;
    }
    isPos() {
      return this.n >= 0n;
    }
    isOdd() {
      return (this.n & 1n) === 1n;
    }
    isEven() {
      return (this.n & 1n) === 0n;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(f) {
      return N(w.isBN(f), "num", "bignum"), xr(this.n, f.n);
    }
    ucmpn(f) {
      return N(he(f), "num", "smi"), tt(this.n, f);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(f) {
      return N(w.isBN(f), "num", "bignum"), W(!f.red, "legendre"), it(this.n, f.n);
    }
    jacobi(f) {
      return N(w.isBN(f), "num", "bignum"), Ht(this.n, f.n);
    }
    kronecker(f) {
      return N(w.isBN(f), "num", "bignum"), Qe(this.n, f.n);
    }
    igcd(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = st(this.n, f.n), this;
    }
    gcd(f) {
      return this.clone().igcd(f);
    }
    ilcm(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = s0(this.n, f.n), this;
    }
    lcm(f) {
      return this.clone().ilcm(f);
    }
    egcd(f) {
      N(w.isBN(f), "p", "bignum");
      const [m, D, ee] = ct(this.n, f.n);
      return [new w(m), new w(D), new w(ee)];
    }
    iinvert(f) {
      return N(w.isBN(f), "num", "bignum"), G(f.n >= 1n, "iinvert"), this.n = Xe(this.n, f.n), this;
    }
    invert(f) {
      return this.clone().iinvert(f);
    }
    ifermat(f) {
      return N(w.isBN(f), "num", "bignum"), G(f.n >= 1n, "ifermat"), W(!f.red, "ifermat"), this.n = qr(this.n, f.n), this;
    }
    fermat(f) {
      return this.clone().ifermat(f);
    }
    ipowm(f, m, D) {
      return N(w.isBN(f), "y", "bignum"), N(w.isBN(m), "m", "bignum"), G(m.n >= 1n, "ipowm"), W(!this.red && !f.red && !m.red, "ipowm"), this.n = Ge(this.n, f.n, m.n), this;
    }
    powm(f, m, D) {
      return this.clone().ipowm(f, m, D);
    }
    ipowmn(f, m, D) {
      return N(he(f), "y", "smi"), N(w.isBN(m), "m", "bignum"), G(m.n >= 1n, "ipowmn"), W(!this.red && !m.red, "ipowmn"), this.n = Ge(this.n, BigInt(f), m.n), this;
    }
    powmn(f, m, D) {
      return this.clone().ipowmn(f, m, D);
    }
    isqrtm(f) {
      return N(w.isBN(f), "p", "bignum"), G(f.n >= 1n, "isqrtm"), W(!this.red && !f.red, "isqrtm"), this.n = ot(this.n, f.n), this;
    }
    sqrtm(f) {
      return this.clone().isqrtm(f);
    }
    isqrtpq(f, m) {
      return N(w.isBN(f), "p", "bignum"), N(w.isBN(m), "q", "bignum"), G(f.n >= 1n, "isqrtpq"), G(m.n >= 1n, "isqrtpq"), W(!this.red && !f.red && !m.red, "isqrtpq"), this.n = Ki(this.n, f.n, m.n), this;
    }
    sqrtpq(f, m) {
      return this.clone().isqrtpq(f, m);
    }
    /*
     * Primality Testing
     */
    isPrime(f, m, D) {
      return N(m >>> 0 === m, "reps", "uint32"), !(!this.isPrimeMR(f, m + 1, !0) || !this.isPrimeLucas(D));
    }
    isPrimeMR(f, m, D) {
      return At(this.n, f, m, D);
    }
    isPrimeLucas(f) {
      return _t(this.n, f);
    }
    /*
     * Twos Complement
     */
    toTwos(f) {
      return N(f >>> 0 === f, "width", "uint32"), new w($i(this.n, f));
    }
    fromTwos(f) {
      return N(f >>> 0 === f, "width", "uint32"), G(f > 0, "width"), new w(Mt(this.n, f));
    }
    /*
     * Reduction Context
     */
    toRed(f) {
      if (N(f instanceof V, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return f.convertTo(this);
    }
    fromRed() {
      return F(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(f) {
      if (N(f instanceof V, "ctx", "reduction context"), this.red) {
        if (f.n !== this.red.n || f.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        G(this.n >= 0n, "red"), G(this.n < f.n, "red");
      return this.clone()._forceRed(f);
    }
    redIAdd(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIAdd"), this.red.iadd(this, f);
    }
    redAdd(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redAdd"), this.red.add(this, f);
    }
    redIAddn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIAddn"), this.red.iaddn(this, f);
    }
    redAddn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redAddn"), this.red.addn(this, f);
    }
    redISub(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redISub"), this.red.isub(this, f);
    }
    redSub(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redSub"), this.red.sub(this, f);
    }
    redISubn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redISubn"), this.red.isubn(this, f);
    }
    redSubn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redSubn"), this.red.subn(this, f);
    }
    redIMul(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIMul"), this.red.imul(this, f);
    }
    redMul(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redMul"), this.red.mul(this, f);
    }
    redIMuln(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIMuln"), this.red.imuln(this, f);
    }
    redMuln(f) {
      return N(he(f), "num", "smi"), F(this.red, "redMuln"), this.red.muln(this, f);
    }
    redIDiv(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIDiv"), this.red.idiv(this, f);
    }
    redDiv(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redDiv"), this.red.div(this, f);
    }
    redIDivn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIDivn"), this.red.idivn(this, f);
    }
    redDivn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redDivn"), this.red.divn(this, f);
    }
    redIPow(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIPow"), W(!f.red, "redIPow"), this.red.ipow(this, f);
    }
    redPow(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redPow"), W(!f.red, "redPow"), this.red.pow(this, f);
    }
    redIPown(f) {
      return N(he(f), "num", "smi"), F(this.red, "redIPown"), this.red.ipown(this, f);
    }
    redPown(f) {
      return N(he(f), "num", "smi"), F(this.red, "redPown"), this.red.pown(this, f);
    }
    redISqr() {
      return F(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return F(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return F(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return F(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(f) {
      return F(this.red, "redIDivSqrt"), this.red.idivsqrt(this, f);
    }
    redDivSqrt(f) {
      return F(this.red, "redDivSqrt"), this.red.divsqrt(this, f);
    }
    redIsSquare() {
      return F(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redIShl"), W(!f.red, "redIShl"), this.red.ishl(this, f);
    }
    redShl(f) {
      return N(w.isBN(f), "num", "bignum"), N(f.n >= 0n && f.n <= i, "num", "uint32"), F(this.red, "redShl"), W(!f.red, "redShl"), this.red.shl(this, f);
    }
    redIShln(f) {
      return N(f >>> 0 === f, "num", "uint32"), F(this.red, "redIShln"), this.red.ishln(this, f);
    }
    redShln(f) {
      return N(f >>> 0 === f, "num", "uint32"), F(this.red, "redShln"), this.red.shln(this, f);
    }
    redINeg() {
      return F(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return F(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(f) {
      return N(w.isBN(f), "num", "bignum"), F(this.red, "redEq"), this.red.eq(this, f);
    }
    redEqn(f) {
      return N(he(f), "num", "smi"), F(this.red, "redEqn"), this.red.eqn(this, f);
    }
    redIsHigh() {
      return F(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return F(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return F(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return F(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return F(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return F(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return F(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return F(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return F(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return F(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return F(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _forceRed(f) {
      return this.red = f, this;
    }
    /*
     * Helpers
     */
    clone() {
      return new w().inject(this);
    }
    inject(f) {
      return N(w.isBN(f), "num", "bignum"), this.n = f.n, this.red = f.red, this;
    }
    set(f, m) {
      return this.fromNumber(f, m);
    }
    swap(f) {
      return N(w.isBN(f), "num", "bignum"), [this.n, f.n] = [f.n, this.n], [this.red, f.red] = [f.red, this.red], this;
    }
    reverse() {
      const f = this.n < 0n, m = l === "be" ? "le" : "be";
      return this.fromBuffer(this.toBuffer(m), l), f && (this.n = -this.n), this;
    }
    byteLength() {
      return ii(this.n);
    }
    bitLength() {
      return at(this.n);
    }
    zeroBits() {
      return nt(this.n);
    }
    isSafe() {
      return this.n <= d && this.n >= -d;
    }
    word(f) {
      return N(f >>> 0 === f, "pos", "uint32"), Hi(this.n, f);
    }
    [r]() {
      let f = "BN";
      return this.red && (f = "BN-R"), `<${f}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      if (!this.isSafe())
        throw new RangeError("Number can only safely store up to 53 bits.");
      return Number(this.n);
    }
    toDouble() {
      return Number(this.n);
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      return this.n;
    }
    toBool() {
      return this.n !== 0n;
    }
    toString(f, m) {
      return Nt(this.n, f, m);
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(f, m) {
      const D = this.toBuffer(f, m);
      return Array.from ? Array.from(D) : Array.prototype.slice.call(D);
    }
    toBuffer(f, m) {
      return j(this.n, f, m);
    }
    toArrayLike(f, m, D) {
      if (f === Buffer)
        return this.toBuffer(m, D);
      if (f === Array)
        return this.toArray(m, D);
      if (f === Int8Array || f === Uint8Array || f === Uint8ClampedArray) {
        const ee = this.toBuffer(m, D);
        return new f(ee.buffer, ee.byteOffset, ee.byteLength);
      }
      return Q(this.n, f, m, D);
    }
    encode(f, m) {
      return this.toBuffer(f, m);
    }
    /*
     * Instantiation
     */
    of(f, m) {
      return this.fromNumber(f, m);
    }
    fromNumber(f, m) {
      return m == null && (m = "be"), N(xe(f), "num", "integer"), N(m === "be" || m === "le", "endian", "endianness"), this.n = BigInt(f), m === "le" && this.reverse(), this;
    }
    fromDouble(f, m) {
      return m == null && (m = "be"), N(typeof f == "number", "num", "double"), N(m === "be" || m === "le", "endian", "endianness"), isFinite(f) || (f = 0), this.n = BigInt(Math.trunc(f)), m === "le" && this.reverse(), this;
    }
    fromBigInt(f, m) {
      return m == null && (m = "be"), N(typeof f == "bigint", "num", "bigint"), N(m === "be" || m === "le", "endian", "endianness"), this.n = f, m === "le" && this.reverse(), this;
    }
    fromBool(f) {
      return N(typeof f == "boolean", "value", "boolean"), this.set(f ? 1 : 0);
    }
    fromString(f, m, D) {
      return (m === "le" || m === "be") && ([m, D] = [D, m]), D == null && (D = "be"), N(D === "be" || D === "le", "endian", "endianness"), this.n = Ot(f, m), D === "le" && this.reverse(), this;
    }
    fromJSON(f) {
      if (w.isBN(f))
        return f.red ? f.fromRed() : f.clone();
      if (Array.isArray(f)) {
        for (const m of f)
          N(typeof m == "string", "chunk", "string");
        f = f.join("");
      }
      return this.fromString(f, 16);
    }
    fromBN(f) {
      return this.inject(f);
    }
    fromArray(f, m) {
      return N(Array.isArray(f), "data", "array"), this.n = C0(f, m), this;
    }
    fromBuffer(f, m) {
      return this.n = R(f, m), this;
    }
    fromArrayLike(f, m) {
      if (Buffer.isBuffer(f))
        return this.fromBuffer(f, m);
      if (Array.isArray(f))
        return this.fromArray(f, m);
      if (f instanceof Int8Array || f instanceof Uint8Array || f instanceof Uint8ClampedArray) {
        const D = Buffer.from(
          f.buffer,
          f.byteOffset,
          f.byteLength
        );
        return this.fromBuffer(D, m);
      }
      return this.n = C0(f, m), this;
    }
    decode(f, m) {
      return this.fromBuffer(f, m);
    }
    from(f, m, D) {
      if (f == null)
        return this;
      if ((m === "le" || m === "be") && ([m, D] = [D, m]), typeof f == "number")
        return this.fromNumber(f, D);
      if (typeof f == "bigint")
        return this.fromBigInt(f, D);
      if (typeof f == "string")
        return this.fromString(f, m, D);
      if (typeof f == "object") {
        if (w.isBN(f))
          return this.fromBN(f, D);
        if (Buffer.isBuffer(f))
          return this.fromBuffer(f, D);
        if (f.length >>> 0 === f.length)
          return this.fromArrayLike(f, D);
      }
      if (typeof f == "boolean")
        return this.fromBool(f);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...f) {
      let m = null;
      for (const D of f)
        N(w.isBN(D), "num", "bignum"), (!m || D.cmp(m) < 0) && (m = D);
      return m || new w(0);
    }
    static max(...f) {
      let m = null;
      for (const D of f)
        N(w.isBN(D), "num", "bignum"), (!m || D.cmp(m) > 0) && (m = D);
      return m || new w(0);
    }
    static cmp(f, m) {
      return N(w.isBN(f), "a", "bignum"), f.cmp(m);
    }
    static ucmp(f, m) {
      return N(w.isBN(f), "a", "bignum"), f.ucmp(m);
    }
    static red(f) {
      return new V(f, !1);
    }
    static barret(f) {
      return new V(f, !1);
    }
    static mont(f) {
      return new V(f, !0);
    }
    static _prime(f) {
      if (g[f])
        return g[f];
      let m;
      if (f === "p192")
        m = new _();
      else if (f === "p224")
        m = new q();
      else if (f === "p521")
        m = new U();
      else if (f === "k256")
        m = new z();
      else if (f === "p251")
        m = new E();
      else if (f === "p25519")
        m = new H();
      else if (f === "p448")
        m = new k();
      else
        throw new Error(`Unknown prime: "${f}".`);
      return g[f] = m, m;
    }
    static prime(f) {
      return w._prime(f).p.clone();
    }
    static pow(f, m) {
      return f === 2 ? w.shift(1, m) : new w().fromNumber(f).ipown(m);
    }
    static shift(f, m) {
      return new w().fromNumber(f).ishln(m);
    }
    static mask(f) {
      return w.shift(1, f).isubn(1);
    }
    static randomBits(f, m) {
      const D = T0(f, m);
      return new w(D);
    }
    static random(f, m, D) {
      const ee = w.cast(m, 16), te = w.cast(D, 16), se = D0(f, ee.n, te.n);
      return new w(se);
    }
    static of(f, m) {
      return new w().of(f, m);
    }
    static fromNumber(f, m) {
      return new w().fromNumber(f, m);
    }
    static fromDouble(f, m) {
      return new w().fromDouble(f, m);
    }
    static fromBigInt(f, m) {
      return new w().fromBigInt(f, m);
    }
    static fromBool(f) {
      return new w().fromBool(f);
    }
    static fromString(f, m, D) {
      return new w().fromString(f, m, D);
    }
    static fromJSON(f) {
      return new w().fromJSON(f);
    }
    static fromBN(f) {
      return new w().fromBN(f);
    }
    static fromArray(f, m) {
      return new w().fromArray(f, m);
    }
    static fromBuffer(f, m) {
      return new w().fromBuffer(f, m);
    }
    static fromArrayLike(f, m) {
      return new w().fromArrayLike(f, m);
    }
    static decode(f, m) {
      return new w().decode(f, m);
    }
    static from(f, m, D) {
      return new w().from(f, m, D);
    }
    static cast(f, m, D) {
      return w.isBN(f) ? f : new w(f, m, D);
    }
    static isBN(f) {
      return f instanceof w;
    }
  }
  w.BN = w, w.wordSize = 26, w.native = 1;
  class I {
    constructor(f, m) {
      this.name = f, this.p = new w(m, 16);
    }
    pm2(f) {
      throw new Error("Not implemented.");
    }
    fermat(f) {
      if (f === 0n)
        throw new RangeError("Not invertible.");
      return this.pm2(f);
    }
  }
  class B extends I {
    constructor(f, m) {
      super(f, m);
    }
    pm3d4(f) {
      throw new Error("Not implemented.");
    }
    pp1d4(f) {
      throw new Error("Not implemented.");
    }
    sqrt(f) {
      const m = this.p.n, D = this.pp1d4(f);
      if (D * D % m !== f)
        throw new ne(D);
      return D;
    }
    divsqrt(f, m) {
      if (f === 0n && m === 0n)
        throw new ne(m);
      const D = this.p.n, ee = f * f % D, te = ee * f % D, se = te * ee % D, ue = m * m * m % D, be = this.pm3d4(se * ue % D), Ae = te * m * be % D;
      if (m * Ae * Ae % D === f)
        return Ae;
      throw new ne(Ae);
    }
  }
  class y extends I {
    constructor(f, m, D) {
      super(f, m), this.sm1 = new w(D, 16);
    }
    pm5d8(f) {
      throw new Error("Not implemented.");
    }
    pp3d8(f) {
      throw new Error("Not implemented.");
    }
    sqrt(f) {
      const m = this.p.n, D = this.sm1.n, ee = this.pp3d8(f);
      if (ee * ee % m === f)
        return ee;
      const te = ee * D % m;
      if (te * te % m === f)
        return te;
      throw new ne(ee);
    }
    divsqrt(f, m) {
      if (f === 0n && m === 0n)
        throw new ne(m);
      const D = this.p.n, ee = this.sm1.n, te = m * m * m % D, se = te * te * m % D, ue = this.pm5d8(f * se % D), be = f * te * ue % D, Ae = m * be * be % D;
      if (Ae === f)
        return be;
      if (Ae === L(-f, D))
        return be * ee % D;
      throw Ae === L(-f * ee, D) ? new ne(be * ee % D) : new ne(be);
    }
  }
  class A extends I {
    constructor(f, m, D) {
      super(f, m), this.g = new w(D, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(f) {
      throw new Error("Not implemented.");
    }
    powE(f) {
      throw new Error("Not implemented.");
    }
    sqrt(f) {
      const m = this.p.n;
      switch (Ht(f, m)) {
        case -1:
          throw new ne(f);
        case 0:
          return 0n;
      }
      let D = this.g.n, ee = this.powE(f), te = this.powS(f), se = this.z;
      for (; ; ) {
        let ue = te, be = 0;
        for (; ue !== 1n && be < se; )
          ue = ue * ue % m, be += 1;
        if (be === 0)
          break;
        ie(be < se), ue = ke(D, se - be - 1, m), D = ue * ue % m, ee = ee * ue % m, te = te * D % m, se = be;
      }
      return ee;
    }
    divsqrt(f, m) {
      const D = this.p.n;
      if (m === 0n)
        throw new ne(m);
      return this.sqrt(f * Xe(m, D));
    }
  }
  class _ extends B {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    core(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 6, te, m), ue = le(se, 12, se, m), be = le(ue, 6, te, m), Ae = le(be, 1, f, m), $e = le(Ae, 31, Ae, m), Rt = le($e, 62, $e, m), Jt = le(Rt, 3, ee, m), mr = ke(Jt, 1, m);
      return le(mr, 62, $e, m);
    }
    pm3d4(f) {
      return this.core(f);
    }
    pm2(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 2, D, m), te = le(ee, 4, ee, m), se = le(te, 8, te, m), ue = le(se, 16, se, m), be = le(ue, 32, ue, m), Ae = le(be, 64, be, m);
      return ke(Ae, 62, m);
    }
  }
  class q extends A {
    constructor() {
      super(
        "p224",
        "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001",
        "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74"
      );
    }
    powS(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 2, D, m), te = le(ee, 4, ee, m), se = le(te, 8, te, m), ue = le(se, 16, se, m), be = le(ue, 32, ue, m);
      return le(be, 64, be, m);
    }
    powE(f) {
      const m = this.p.n;
      return ke(f, 127, m);
    }
    pm2(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 6, te, m), ue = le(se, 12, se, m), be = le(ue, 24, ue, m), Ae = le(be, 48, be, m), $e = le(Ae, 24, ue, m), Rt = le($e, 6, te, m), Jt = le(Rt, 1, f, m), mr = ke(Jt, 1, m);
      return le(mr, 96, Ae, m);
    }
  }
  class U extends B {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    core(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 1, f, m), ue = le(se, 1, f, m), be = le(ue, 8, ue, m), Ae = le(be, 16, be, m), $e = le(Ae, 32, Ae, m), Rt = le($e, 64, $e, m), Jt = le(Rt, 128, Rt, m), mr = le(Jt, 256, Jt, m);
      return le(mr, 7, se, m);
    }
    pm3d4(f) {
      return this.core(f);
    }
    pm2(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n;
      return ke(f, 519, m);
    }
  }
  class z extends B {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    core(f, m) {
      const D = this.p.n, ee = le(m, 1, f, D), te = le(ee, 3, ee, D), se = le(te, 3, ee, D), ue = le(se, 2, m, D), be = le(ue, 11, ue, D), Ae = le(be, 22, be, D), $e = le(Ae, 44, Ae, D), Rt = le($e, 88, $e, D), Jt = le(Rt, 44, Ae, D), mr = le(Jt, 3, ee, D), Xr = ke(mr, 1, D), si = le(Xr, 22, be, D);
      return ke(si, 4, D);
    }
    pm3d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m), se = ke(te, 1, m);
      return le(se, 2, D, m);
    }
    pm2(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m), se = ke(te, 1, m), ue = le(se, 2, D, m), be = ke(ue, 1, m);
      return le(be, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 2, D, m);
      return ke(te, 2, m);
    }
  }
  class E extends B {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    core(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = le(D, 1, f, m), te = le(ee, 3, ee, m), se = le(te, 6, te, m), ue = le(se, 12, se, m), be = le(ue, 24, ue, m), Ae = le(be, 48, be, m), $e = le(Ae, 96, Ae, m), Rt = le($e, 48, be, m), Jt = le(Rt, 6, te, m);
      return le(Jt, 1, f, m);
    }
    pm3d4(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pm2(f) {
      const m = this.p.n, D = this.core(f), ee = ke(D, 1, m), te = le(ee, 1, f, m), se = ke(te, 1, m);
      return le(se, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = this.core(f), ee = le(D, 1, f, m);
      return ke(ee, 1, m);
    }
  }
  class H extends y {
    constructor() {
      super(
        "p25519",
        "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed",
        "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0"
      );
    }
    core(f, m) {
      const D = this.p.n, ee = le(m, 2, m, D), te = le(ee, 1, f, D), se = le(te, 5, te, D), ue = le(se, 10, se, D), be = le(ue, 20, ue, D), Ae = le(be, 10, se, D), $e = le(Ae, 50, Ae, D), Rt = le($e, 100, $e, D);
      return le(Rt, 50, Ae, D);
    }
    pm5d8(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = ke(ee, 1, m);
      return le(te, 1, f, m);
    }
    pm2(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = ke(ee, 1, m), se = le(te, 1, f, m), ue = ke(se, 1, m);
      return le(ue, 2, D, m);
    }
    pp3d8(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m);
      return ke(te, 1, m);
    }
  }
  class k extends B {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    core(f, m) {
      const D = this.p.n, ee = le(m, 1, f, D), te = le(ee, 3, ee, D), se = le(te, 3, ee, D), ue = le(se, 2, m, D), be = le(ue, 11, ue, D), Ae = le(be, 22, be, D), $e = le(Ae, 44, Ae, D), Rt = le($e, 88, $e, D), Jt = le(Rt, 44, Ae, D);
      return le(Jt, 2, m, D);
    }
    pm3d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 1, f, m), se = ke(te, 1, m);
      return le(se, 222, ee, m);
    }
    pm2(f) {
      const m = this.p.n, D = this.pm3d4(f), ee = ke(D, 1, m);
      return le(ee, 1, f, m);
    }
    pp1d4(f) {
      const m = this.p.n, D = le(f, 1, f, m), ee = this.core(f, D), te = le(ee, 2, D, m);
      return ke(te, 222, m);
    }
  }
  class V {
    constructor(f) {
      let m = null;
      typeof f == "string" && (m = w._prime(f), f = m.p), N(w.isBN(f), "m", "bignum"), W(!f.red, "reduction"), G(f.n >= 1n, "reduction"), this.m = f, this.n = f.n, this.prime = m, this.sm1 = null;
    }
    _verify1(f) {
      G(f.negative === 0, "red"), F(f.red != null, "red");
    }
    _verify2(f, m) {
      G((f.negative | m.negative) === 0, "red"), F(f.red != null && f.red === m.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      return this.sm1 === null && (this.n & 7n) === 5n && (this.prime ? this.sm1 = this.prime.sm1.n : this.sm1 = Ge(2n, this.n - 1n >> 2n, this.n)), this;
    }
    convertTo(f) {
      const m = new w();
      return m.n = L(f.n, this.n), m.red = this, m;
    }
    convertFrom(f) {
      const m = f.clone();
      return m.red = null, m;
    }
    iadd(f, m) {
      return this._verify2(f, m), f.n += m.n, f.n >= this.n && (f.n -= this.n), f;
    }
    add(f, m) {
      return this.iadd(f.clone(), m);
    }
    iaddn(f, m) {
      if (this._verify1(f), m < 0)
        return this.isubn(f, -m);
      let D = BigInt(m);
      return this.n < 0x4000000n && (D %= this.n), f.n += D, f.n >= this.n && (f.n -= this.n), f;
    }
    addn(f, m) {
      return this.iaddn(f.clone(), m);
    }
    isub(f, m) {
      return this._verify2(f, m), f.n -= m.n, f.n < 0n && (f.n += this.n), f;
    }
    sub(f, m) {
      return this.isub(f.clone(), m);
    }
    isubn(f, m) {
      if (this._verify1(f), m < 0)
        return this.iaddn(f, -m);
      let D = BigInt(m);
      return this.n < 0x4000000n && (D %= this.n), f.n -= D, f.n < 0n && (f.n += this.n), f;
    }
    subn(f, m) {
      return this.isubn(f.clone(), m);
    }
    imul(f, m) {
      return this._verify2(f, m), f.n *= m.n, f.n %= this.n, f;
    }
    mul(f, m) {
      return this._verify2(f, m), this.imul(f.clone(), m);
    }
    imuln(f, m) {
      return this._verify1(f), f.n *= BigInt(m), f.n = L(f.n, this.n), f;
    }
    muln(f, m) {
      return this.imuln(f.clone(), m);
    }
    idiv(f, m) {
      return f.n *= Xe(m.n, this.n), f.n %= this.n, f;
    }
    div(f, m) {
      return this.idiv(f.clone(), m);
    }
    idivn(f, m) {
      return f.n *= Xe(BigInt(m), this.n), f.n %= this.n, f;
    }
    divn(f, m) {
      return this.idivn(f.clone(), m);
    }
    ipow(f, m) {
      return this._verify1(f), f.n = Ge(f.n, m.n, this.n), f;
    }
    pow(f, m) {
      return this.ipow(f.clone(), m);
    }
    ipown(f, m) {
      return this._verify1(f), f.n = Ge(f.n, BigInt(m), this.n), f;
    }
    pown(f, m) {
      return this.ipown(f.clone(), m);
    }
    isqr(f) {
      return this._verify1(f), f.n *= f.n, f.n %= this.n, f;
    }
    sqr(f) {
      return this.isqr(f.clone());
    }
    isqrt(f) {
      return this._verify1(f), this.prime ? f.n = this.prime.sqrt(f.n) : this.sm1 != null ? f.n = Bt(f.n, this.n, this.sm1) : f.n = ot(f.n, this.n), f;
    }
    sqrt(f) {
      return this.isqrt(f.clone());
    }
    idivsqrt(f, m) {
      return this._verify2(f, m), this.prime ? f.n = this.prime.divsqrt(f.n, m.n) : f.n = Li(f.n, m.n, this.n, this.sm1), f;
    }
    divsqrt(f, m) {
      return this.idivsqrt(f.clone(), m);
    }
    isSquare(f) {
      return this._verify1(f), this.n & 1n ? Ht(f.n, this.n) >= 0 : Qe(f.n, this.n) >= 0;
    }
    ishl(f, m) {
      return this._verify1(f), f.n <<= m.n, f.n %= this.n, f;
    }
    shl(f, m) {
      return this.ishl(f.clone(), m);
    }
    ishln(f, m) {
      return this._verify1(f), f.n <<= BigInt(m), f.n %= this.n, f;
    }
    shln(f, m) {
      return this.ishln(f.clone(), m);
    }
    ineg(f) {
      return this._verify1(f), f.n !== 0n && (f.n = this.n - f.n), f;
    }
    neg(f) {
      return this.ineg(f.clone());
    }
    eq(f, m) {
      return this._verify2(f, m), f.n === m.n;
    }
    eqn(f, m) {
      if (this._verify1(f), this.n < 0x4000000n) {
        const D = Number(this.n);
        return m %= D, m < 0 && (m += D), f.n == m;
      }
      return m < 0 ? f.n === BigInt(m) + this.n : f.n == m;
    }
    isHigh(f) {
      return !this.isLow(f);
    }
    isLow(f) {
      return this._verify1(f), f.n <= this.n >> 1n;
    }
    isOdd(f) {
      return this._verify1(f), f.isOdd();
    }
    isEven(f) {
      return this._verify1(f), f.isEven();
    }
    legendre(f) {
      return this._verify1(f), it(f.n, this.n);
    }
    jacobi(f) {
      return this._verify1(f), Ht(f.n, this.n);
    }
    kronecker(f) {
      return this._verify1(f), Qe(f.n, this.n);
    }
    iinvert(f) {
      return this._verify1(f), f.n = Xe(f.n, this.n), f;
    }
    invert(f) {
      return this.iinvert(f.clone());
    }
    ifermat(f) {
      return this._verify1(f), this.prime ? f.n = this.prime.fermat(f.n) : f.n = qr(f.n, this.n), f;
    }
    fermat(f) {
      return this.ifermat(f.clone());
    }
    invertAll(f) {
      N(Array.isArray(f), "elems", "array");
      for (const se of f)
        N(w.isBN(se), "elem", "bignum"), this._verify1(se);
      const m = f.length, D = new Array(m);
      for (let se = 0; se < m; se++)
        D[se] = f[se].n;
      const ee = bt(D, this.n), te = new Array(m);
      for (let se = 0; se < m; se++)
        te[se] = new w(ee[se])._forceRed(this);
      return te;
    }
    [r]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.n.toString(10)}>`;
    }
  }
  function T(P, f, m) {
    const D = new P(f);
    return P.captureStackTrace && P.captureStackTrace(D, m), D;
  }
  function ie(P, f) {
    if (!P)
      throw T(Error, f || "Assertion failed.", ie);
  }
  function N(P, f, m) {
    if (!P) {
      const D = `"${f}" must be a(n) ${m}.`;
      throw T(TypeError, D, N);
    }
  }
  function G(P, f) {
    if (!P) {
      const m = `"${f}" only works with positive numbers.`;
      throw T(RangeError, m, G);
    }
  }
  function F(P, f) {
    if (!P) {
      const m = `"${f}" only works with red numbers.`;
      throw T(TypeError, m, F);
    }
  }
  function W(P, f) {
    if (!P) {
      const m = `"${f}" only works with normal numbers.`;
      throw T(TypeError, m, W);
    }
  }
  function ce(P) {
    if (!P)
      throw T(RangeError, "Cannot divide by zero.", ce);
  }
  class ne extends Error {
    constructor(f) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = new w(f), Error.captureStackTrace && Error.captureStackTrace(this, ne);
    }
  }
  function xe(P) {
    return Number.isSafeInteger(P);
  }
  function he(P) {
    return xe(P) && P >= -67108863 && P <= 67108863;
  }
  function me(P, f) {
    return P.allocUnsafeSlow ? P.allocUnsafeSlow(f) : new P(f);
  }
  function Ne(P) {
    if (P == null)
      return 10;
    if (typeof P == "number")
      return P;
    switch (P) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function Je(P) {
    switch (P) {
      case 2:
      case 8:
      case 10:
      case 16:
        return !0;
    }
    return !1;
  }
  function Ze(P) {
    let f = 0, m = P.length - 1, D = P.length >>> 1;
    for (; D--; ) {
      const ee = P[f];
      P[f++] = P[m], P[m--] = ee;
    }
    return P;
  }
  function ht(P, f, m) {
    const D = BigInt(m), ee = P < 0n ^ f < 0n;
    let te = P * f;
    ee && (te = -te);
    const se = te >> D - 1n & 1n;
    return te >>= D, te += se, ee && (te = -te), te;
  }
  function dt(P, f) {
    ie(f !== 0n);
    const m = P / f, D = P - m * f;
    return [m, D];
  }
  function Se(P, f) {
    return ie(f !== 0), Number(P % BigInt(f));
  }
  function we(P, f) {
    ie(f !== 0n);
    let m = P / f, D = P - m * f;
    return D < 0n && (f < 0n ? (m += 1n, D -= f) : (m -= 1n, D += f)), [m, D];
  }
  function Z(P, f) {
    ie(f !== 0n);
    let m = P / f;
    return P >= 0n || P - m * f < 0n && (f < 0n ? m += 1n : m -= 1n), m;
  }
  function L(P, f) {
    ie(f !== 0n);
    let m = P % f;
    return m < 0n && (f < 0n ? m -= f : m += f), m;
  }
  function oe(P, f) {
    let m = Se(P, f);
    return m < 0 && (f < 0 ? m -= f : m += f), m;
  }
  function s(P, f) {
    ie(f !== 0n);
    const m = f < 0n ? -(-f >> 1n) : f >> 1n;
    return P < 0n ^ f < 0n ? (P - m) / f : (P + m) / f;
  }
  function a(P, f, m) {
    if (f === 0)
      throw new RangeError("Zeroth root.");
    if (~f & P < 0n)
      throw new RangeError("Negative with even root.");
    if (P === -1n || P === 0n || P === 1n)
      return [P, 0n];
    const D = BigInt(f);
    let ee = 0n, te = 1n << BigInt(at(P) / f + 1 | 0), se, ue;
    if (P < 0n && (te = -te), f === 2)
      do
        ee = te, te = P / ee, te += ee, te >>= 1n;
      while (xr(te, ee) < 0);
    else
      do
        ee = te, te = ee ** (D - 1n), te = P / te, se = ee * (D - 1n), te += se, te /= D;
      while (xr(te, ee) < 0);
    return m && (te = ee ** D, ue = P - te), [ee, ue];
  }
  function p(P, f) {
    return a(P, f, 1);
  }
  function v(P, f) {
    return a(P, f, 0)[0];
  }
  function C(P, f) {
    if (f === 0 || ~f & P < 0n)
      return !1;
    const [, m] = p(P, f);
    return m === 0n;
  }
  function K(P) {
    return p(P, 2);
  }
  function O(P) {
    return v(P, 2);
  }
  function $(P) {
    return C(P, 2);
  }
  function u(P) {
    return (1n << BigInt(P)) - 1n;
  }
  function S(P, f) {
    const m = P < 0n, D = Le(P) & Le(f);
    return m ? -D : D;
  }
  function M(P, f) {
    return S(P, BigInt(f));
  }
  function Y(P, f) {
    const m = P < 0n, D = Le(P) | Le(f);
    return m ? -D : D;
  }
  function J(P, f) {
    return Y(P, BigInt(f));
  }
  function X(P, f) {
    const m = P < 0n, D = Le(P) ^ Le(f);
    return m ? -D : D;
  }
  function re(P, f) {
    return X(P, BigInt(f));
  }
  function ae(P, f) {
    return P < 0n ? -(-P >> f) : P >> f;
  }
  function de(P, f) {
    return ae(P, BigInt(f));
  }
  function ge(P, f) {
    const m = P < 0n;
    return m && (P = -P), P ^= u(f), m && (P = -P), P;
  }
  function Be(P, f, m) {
    return m ? P |= 1n << BigInt(f) : P &= ~(1n << BigInt(f)), P;
  }
  function ve(P, f, m) {
    const D = P < 0n;
    return D && (P = -P), P = Be(P, f, m), D && (P = -P), P;
  }
  function Oe(P, f) {
    return Number(P >> BigInt(f) & 1n);
  }
  function Ie(P, f) {
    return Oe(Le(P), f);
  }
  function Re(P, f) {
    return P & u(f);
  }
  function ft(P, f) {
    const m = P < 0n;
    return m && (P = -P), P &= u(f), m && (P = -P), P;
  }
  function Ye(P, f) {
    return P < 0n && (P = -P), Number(P & BigInt(f & 67108863));
  }
  function Fe(P, f, m) {
    P < 0n && (P = -P);
    const D = BigInt((1 << m) - 1), ee = P >> BigInt(f) & D;
    return Number(ee);
  }
  function Le(P) {
    return P < 0n ? -P : P;
  }
  function He(P, f) {
    return P < f ? -1 : P > f ? 1 : 0;
  }
  function et(P, f) {
    return P < f ? -1 : P > f ? 1 : 0;
  }
  function xr(P, f) {
    return He(Le(P), Le(f));
  }
  function tt(P, f) {
    return et(Le(P), Math.abs(f));
  }
  function it(P, f) {
    if (G(f > 0n, "legendre"), (f & 1n) === 0n)
      throw new Error("legendre: `num` must be odd.");
    const m = Ge(P, f - 1n >> 1n, f);
    if (m === 0n)
      return 0;
    if (m === 1n)
      return 1;
    if (m === f - 1n)
      return -1;
    throw new Error("Invalid prime.");
  }
  function Ht(P, f) {
    if (f === 0n || (f & 1n) === 0n)
      throw new Error("jacobi: `num` must be odd.");
    let m = P, D = f, ee = 1;
    for (D < 0n && (m < 0n && (ee = -1), D = -D), m < 0n && (m = L(m, D)); ; ) {
      if (D === 1n)
        return ee;
      if (m === 0n || (m %= D, m === 0n))
        return 0;
      const te = nt(m);
      if (te & 1) {
        const se = D & 7n;
        (se === 3n || se === 5n) && (ee = -ee);
      }
      m >>= BigInt(te), (m & 3n) === 3n && (D & 3n) === 3n && (ee = -ee), [m, D] = [D, m];
    }
  }
  function Qe(P, f) {
    const m = [
      0,
      1,
      0,
      -1,
      0,
      -1,
      0,
      1
    ];
    let D = P, ee = f, te = 1;
    if (ee === 0n)
      return Le(D) === 1n ? te : 0;
    if ((D & 1n) === 0n && (ee & 1n) === 0n)
      return 0;
    const se = nt(ee);
    for (ee >>= BigInt(se), se & 1 && (te = m[Number(Le(D) & 7n)]), ee < 0n && (D < 0n && (te = -te), ee = -ee); ; ) {
      if (D === 0n)
        return ee === 1n ? te : 0;
      const ue = nt(D);
      D >>= BigInt(ue), ue & 1 && (te *= m[Number(ee & 7n)]), ((D < 0n ? -D ^ 3n : D) & ee & 2n) !== 0n && (te = -te), ee = L(ee, D), [D, ee] = [ee, D], ee < 0n && (ee = -ee);
    }
  }
  function st(P, f) {
    for (P = Le(P), f = Le(f); f !== 0n; )
      [P, f] = [f, P % f];
    return P;
  }
  function s0(P, f) {
    return P === 0n || f === 0n ? 0n : Le(P / st(P, f) * f);
  }
  function ct(P, f) {
    let m = 0n, D = 1n, ee = 1n, te = 0n, se = Le(f), ue = Le(P);
    for (; se !== 0n; ) {
      const be = ue / se;
      [ue, se] = [se, ue - be * se], [D, m] = [m, D - be * m], [te, ee] = [ee, te - be * ee];
    }
    return ue < 0n && (ue = -ue, D = -D, te = -te), P < 0n && (D = -D), f < 0n && (te = -te), [D, te, ue];
  }
  function Xe(P, f) {
    if (ie(f > 0n), f === 1n)
      throw new RangeError("Not invertible.");
    (P < 0n || P >= f) && (P = L(P, f));
    let m = 0n, D = 1n, ee = f, te = P;
    for (; te !== 0n; ) {
      const se = ee / te;
      [m, D] = [D, m - se * D], [ee, te] = [te, ee - se * te];
    }
    if (ee < 0n && (ee = -ee, m = -m), ee !== 1n)
      throw new RangeError("Not invertible.");
    return m < 0n && (m += f), m;
  }
  function qr(P, f) {
    if (ie(f > 0n), f === 1n)
      throw new RangeError("Not invertible.");
    const m = Ge(P, f - 2n, f);
    if (m === 0n)
      throw new RangeError("Not invertible.");
    return m;
  }
  function bt(P, f) {
    if (ie(f > 0n), f === 1n || !(f & 1n))
      throw new RangeError("Not invertible.");
    const m = P.length, D = new Array(m);
    if (m === 0)
      return D;
    const ee = new Array(m);
    for (let se = 0; se < m; se++) {
      let ue = P[se];
      (ue < 0n || ue >= f) && (ue = L(ue, f)), ee[se] = ue;
    }
    let te = 1n;
    for (let se = 0; se < m; se++) {
      if (ee[se] === 0n) {
        D[se] = 0n;
        continue;
      }
      D[se] = te, te = te * ee[se] % f;
    }
    te = Xe(te, f);
    for (let se = m - 1; se >= 0; se--)
      ee[se] !== 0n && (D[se] = te * D[se] % f, te = te * ee[se] % f);
    return D;
  }
  function Ge(P, f, m) {
    return ie(m > 0n), f < 0n ? (P = Xe(P, m), f = -f) : P = L(P, m), f <= i ? I0(P, f, m) : pt(P, f, m);
  }
  function I0(P, f, m) {
    let D = 1n;
    for (; f > 0n; )
      (f & 1n) === 1n && (D = D * P % m), P = P * P % m, f >>= 1n;
    return D;
  }
  function pt(P, f, m) {
    const D = new Array(x), ee = P * P % m;
    D[0] = P;
    for (let ue = 1; ue < x; ue++)
      D[ue] = D[ue - 1] * ee % m;
    let te = at(f), se = 1n;
    for (; te >= h; ) {
      let ue = h, be = Number(f >> BigInt(te - ue) & b);
      if (be < x) {
        se = se * se % m, te -= 1;
        continue;
      }
      for (; !(be & 1); )
        ue -= 1, be >>= 1;
      se === 1n ? se = D[be >> 1] : (se = ke(se, ue, m), se = se * D[be >> 1] % m), te -= ue;
    }
    for (; te--; )
      se = se * se % m, f >> BigInt(te) & 1n && (se = se * P % m);
    return se;
  }
  function ke(P, f, m) {
    for (; f--; )
      P = P * P % m;
    return P;
  }
  function le(P, f, m, D) {
    return ke(P, f, D) * m % D;
  }
  function ot(P, f) {
    return ie(f > 0n), (P < 0n || P >= f) && (P = L(P, f)), (f & 3n) === 3n ? St(P, f) : (f & 7n) === 5n ? Di(P, f) : vt(P, f);
  }
  function St(P, f) {
    const m = f + 1n >> 2n, D = Ge(P, m, f);
    if (D * D % f !== P)
      throw new ne(D);
    return D;
  }
  function Di(P, f) {
    const m = f >> 3n, D = (P << 1n) % f, ee = Ge(D, m, f), te = D * ee * ee % f, se = ee * P * (te - 1n) % f;
    if (se * se % f !== P)
      throw new ne(se);
    return se;
  }
  function Bt(P, f, m) {
    const D = f + 3n >> 3n, ee = Ge(P, D, f);
    if (ee * ee % f === P)
      return ee;
    const te = ee * m % f;
    if (te * te % f === P)
      return te;
    throw new ne(ee);
  }
  function vt(P, f) {
    if (f === 1n || (f & 1n) === 0n)
      throw new Error("Invalid prime.");
    switch (Ht(P, f)) {
      case -1:
        throw new ne(P);
      case 0:
        return 0n;
    }
    let m = f - 1n;
    const D = nt(m);
    m >>= BigInt(D);
    let ee = 2n;
    for (; Ht(ee, f) !== -1; )
      ee += 1n;
    let te = Ge(ee, m, f), se = Ge(P, m + 1n >> 1n, f), ue = Ge(P, m, f), be = D;
    for (; ; ) {
      let Ae = ue, $e = 0;
      for (; Ae !== 1n && $e < be; )
        Ae = Ae * Ae % f, $e += 1;
      if ($e === 0)
        break;
      ie($e < be), Ae = ke(te, be - $e - 1, f), te = Ae * Ae % f, se = se * Ae % f, ue = ue * te % f, be = $e;
    }
    return se;
  }
  function Li(P, f, m, D) {
    if (ie(m > 0n), (P < 0n || P >= m) && (P = L(P, m)), (f < 0n || f >= m) && (f = L(f, m)), P === 0n && f === 0n)
      throw new ne(f);
    if ((m & 3n) === 3n)
      return Et(P, f, m);
    if (D != null && (m & 7n) === 5n)
      return It(P, f, m, D);
    if (f === 0n)
      throw new ne(f);
    return ot(P * Xe(f, m), m);
  }
  function Et(P, f, m) {
    const D = m - 3n >> 2n, ee = P * P % m, te = ee * P % m, se = te * ee % m, ue = f * f * f % m, be = Ge(se * ue, D, m), Ae = te * f * be % m;
    if (f * Ae * Ae % m === P)
      return Ae;
    throw new ne(Ae);
  }
  function It(P, f, m, D) {
    const ee = m - 5n >> 3n, te = f * f * f % m, se = te * te * f % m, ue = Ge(P * se, ee, m), be = P * te * ue % m, Ae = f * be * be % m;
    if (Ae === P)
      return be;
    if (Ae === L(-P, m))
      return be * D % m;
    throw Ae === L(-P * D, m) ? new ne(be * D % m) : new ne(be);
  }
  function Ki(P, f, m) {
    ie(f > 0n), ie(m > 0n);
    const D = ot(P, f), ee = ot(P, m), [te, se] = ct(f, m);
    return L(ee * te * f + D * se * m, f * m);
  }
  function At(P, f, m, D = !1) {
    if (N(m >>> 0 === m, "reps", "uint32"), N(m > 0, "reps", "integer"), N(typeof D == "boolean", "force2", "boolean"), P < 7n)
      return P === 2n || P === 3n || P === 5n;
    if ((P & 1n) === 0n)
      return !1;
    const ee = P - 1n, te = ee - 2n, se = nt(ee), ue = ee >> BigInt(se);
    e:
      for (let be = 0; be < m; be++) {
        let Ae, $e;
        if (be === m - 1 && D ? Ae = 2n : (Ae = D0(f, 0n, te), Ae += 2n), $e = Ge(Ae, ue, P), !($e === 1n || $e === ee)) {
          for (let Rt = 1; Rt < se; Rt++) {
            if ($e = $e * $e % P, $e === ee)
              continue e;
            if ($e === 1n)
              return !1;
          }
          return !1;
        }
      }
    return !0;
  }
  function _t(P, f = 0) {
    if (N(f >>> 0 === f, "limit", "uint32"), P <= 1n)
      return !1;
    if ((P & 1n) === 0n)
      return P === 2n;
    let m = 3n;
    for (; ; ) {
      if (m > 10000n)
        throw new Error(`Cannot find (D/n) = -1 for ${P.toString(10)}.`);
      if (f !== 0 && m > f)
        return !1;
      const ue = m * m - 4n, be = Ht(ue, P);
      if (be === -1)
        break;
      if (be === 0)
        return P === m + 2n;
      if (m === 40n && $(P))
        return !1;
      m += 1n;
    }
    let D = P + 1n;
    const ee = nt(D);
    D >>= BigInt(ee);
    let te = 2n, se = m;
    for (let ue = BigInt(at(D)); ue >= 0n; ue--)
      D & 1n << ue ? (te = L(te * se - m, P), se = L(se * se - 2n, P)) : (se = L(se * te - m, P), te = L(te * te - 2n, P));
    if (te === 2n || te === P - 2n) {
      const ue = te * m % P, be = (se << 1n) % P;
      if (ue === be)
        return !0;
    }
    for (let ue = 0; ue < ee - 1; ue++) {
      if (te === 0n)
        return !0;
      if (te === 2n)
        return !1;
      te = L(te * te - 2n, P);
    }
    return !1;
  }
  function $i(P, f) {
    return P < 0n ? ge(-P, f) + 1n : P;
  }
  function Mt(P, f) {
    return Oe(P, f - 1) ? -(ge(P, f) + 1n) : P;
  }
  function lt(P, f) {
    if (P === 0n)
      return 0;
    P < 0n && (P = -P);
    let m = 0;
    for (; P >= o; )
      m += 256, P >>= 256n;
    for (; P >= c; )
      m += 128, P >>= 128n;
    for (; P >= n; )
      m += 64, P >>= 64n;
    for (; P >= i; )
      m += 32, P >>= 32n;
    for (; P >= t; )
      m += 16, P >>= 16n;
    for (; P >= e; )
      m += 8, P >>= 8n;
    for (; P > 0n; )
      m += 1, P >>= 1n;
    return (m + (f - 1)) / f >>> 0;
  }
  function ii(P) {
    return lt(P, 8);
  }
  function at(P) {
    return lt(P, 1);
  }
  function nt(P) {
    if (P === 0n)
      return 0;
    P < 0n && (P = -P);
    let f = 0;
    for (; (P & i) === 0n; )
      f += 32, P >>= 32n;
    for (; (P & t) === 0n; )
      f += 16, P >>= 16n;
    for (; (P & e) === 0n; )
      f += 8, P >>= 8n;
    for (; (P & 1n) === 0n; )
      f += 1, P >>= 1n;
    return f;
  }
  function Hi(P, f) {
    return Number(Le(P) >> BigInt(f * 26) & 0x3ffffffn);
  }
  function Nt(P, f, m) {
    if (f = Ne(f), m == null && (m = 0), m === 0 && (m = 1), N(f >>> 0 === f, "base", "uint32"), N(m >>> 0 === m, "padding", "uint32"), f < 2 || f > 36)
      throw new RangeError("Base ranges between 2 and 36.");
    let D = !1;
    P < 0n && (D = !0, P = -P);
    let ee = P.toString(f);
    for (; ee.length % m; )
      ee = "0" + ee;
    return D && (ee = "-" + ee), ee;
  }
  function Ot(P, f) {
    if (f = Ne(f), N(typeof P == "string", "str", "string"), N(f >>> 0 === f, "base", "uint32"), f < 2 || f > 36)
      throw new RangeError("Base ranges between 2 and 36.");
    if (Je(f))
      return Ke(P, f);
    let m = !1, D = 0;
    for (; D < P.length; D++) {
      switch (P.charCodeAt(D)) {
        case 9:
        case 10:
        case 13:
        case 32:
          continue;
      }
      break;
    }
    D < P.length && P.charCodeAt(D) === 45 && (m = !0, D += 1);
    const ee = BigInt(f);
    let te = 0n;
    for (; D < P.length; D++) {
      let se = P.charCodeAt(D);
      switch (se) {
        case 9:
        case 10:
        case 13:
        case 32:
          continue;
      }
      if (se >= 48 && se <= 57 ? se -= 48 : se >= 65 && se <= 90 ? se -= 65 - 10 : se >= 97 && se <= 122 ? se -= 97 - 10 : se = f, se >= f)
        throw new Error("Invalid string.");
      te *= ee, te += BigInt(se);
    }
    return m && (te = -te), te;
  }
  function Ke(P, f) {
    let m = !1, D;
    switch (P = P.replace(/\s+/g, ""), P.length > 0 && P.charCodeAt(0) === 45 && (P = P.substring(1), m = !0), f) {
      case 2:
        P = "0b" + P;
        break;
      case 8:
        P = "0o" + P;
        break;
      case 10:
        if (P.length > 1) {
          const ee = P.charCodeAt(1);
          if (ee < 48 || ee > 57)
            throw new Error("Invalid string.");
        }
        break;
      case 16:
        P = "0x" + P;
        break;
      default:
        throw new Error("Invalid base.");
    }
    try {
      D = BigInt(P);
    } catch {
      throw new Error("Invalid string.");
    }
    return m && (D = -D), D;
  }
  function j(P, f, m) {
    f == null && (f = "be"), m == null && (m = 0), N(f === "be" || f === "le", "endian", "endianness"), N(m >>> 0 === m, "length", "uint32");
    let D = Le(P).toString(16);
    D.length & 1 && (D = "0" + D);
    const ee = D.length >>> 1, te = m || Math.max(1, ee);
    if (ee > te)
      throw new RangeError("Byte array longer than desired length.");
    const se = D.padStart(te * 2, "00"), ue = Buffer.allocUnsafeSlow(te);
    return ue.write(se, "hex"), f === "le" && Ze(ue), ue;
  }
  function R(P, f) {
    f == null && (f = "be"), N(Buffer.isBuffer(P), "data", "buffer"), N(f === "be" || f === "le", "endian", "endianness"), f !== l && (P = Ze(Buffer.from(P)));
    const m = P.byteOffset & 7;
    m && (P = Buffer.from(
      P.buffer,
      P.byteOffset - m,
      m + P.byteLength
    ));
    const D = new BigUint64Array(
      P.buffer,
      P.byteOffset,
      P.length >>> 3
    ), ee = P.length & 7, te = P.length - ee;
    let se = 0n;
    if (l === "be") {
      for (let ue = 0; ue < D.length; ue++)
        se <<= 64n, se |= D[ue];
      for (let ue = te; ue < P.length; ue++)
        se <<= 8n, se |= BigInt(P[ue]);
      m && (se &= u((P.length - m) * 8));
    } else {
      for (let ue = P.length - 1; ue >= te; ue--)
        se <<= 8n, se |= BigInt(P[ue]);
      for (let ue = D.length - 1; ue >= 0; ue--)
        se <<= 64n, se |= D[ue];
      m && (se >>= BigInt(m * 8));
    }
    return se;
  }
  function Q(P, f, m, D) {
    m == null && (m = "be"), D == null && (D = 0), N(typeof f == "function", "ArrayType", "function"), N(m === "be" || m === "le", "endian", "endianness"), N(D >>> 0 === D, "length", "uint32");
    const ee = ii(P), te = D || Math.max(1, ee);
    if (ee > te)
      throw new RangeError("Byte array longer than desired length.");
    const se = me(f, te);
    let ue = Le(P);
    if (m === "be") {
      let be = te - 1;
      for (; ue > 0n; )
        se[be--] = Number(ue & 0xffn), ue >>= 8n;
      for (; be >= 0; be--)
        se[be] = 0;
    } else {
      let be = 0;
      for (; ue > 0n; )
        se[be++] = Number(ue & 0xffn), ue >>= 8n;
      for (; be < te; be++)
        se[be] = 0;
    }
    return se;
  }
  function C0(P, f) {
    f == null && (f = "be"), N(P && P.length >>> 0 === P.length, "data", "array-like"), N(f === "be" || f === "le", "endian", "endianness");
    let m = 0n;
    if (f === "be")
      for (let D = 0; D < P.length; D++)
        m <<= 8n, m |= BigInt(P[D] & 255);
    else
      for (let D = P.length - 1; D >= 0; D--)
        m <<= 8n, m |= BigInt(P[D] & 255);
    return m;
  }
  function T0(P, f) {
    if (N(P != null, "rng", "rng"), N(f >>> 0 === f, "bits", "uint32"), typeof P == "object") {
      N(typeof P.randomBytes == "function", "rng", "rng");
      const D = f + 7 >>> 3, ee = D * 8, te = P.randomBytes(D);
      if (N(Buffer.isBuffer(te), "bytes", "buffer"), te.length !== D)
        throw new RangeError("Invalid number of bytes returned from RNG.");
      let se = R(te);
      return ee > f && (se >>= BigInt(ee - f)), se;
    }
    N(typeof P == "function", "rng", "rng");
    const m = P(f);
    if (N(w.isBN(m), "num", "bignum"), G(m.negative === 0, "RNG"), W(!m.red, "RNG"), m.bitLength() > f)
      throw new RangeError("Invalid number of bits returned from RNG.");
    return m.n;
  }
  function D0(P, f, m) {
    if (f > m)
      throw new RangeError("Minimum cannot be greater than maximum.");
    const D = Le(m - f), ee = at(D);
    if (ee === 0)
      return f;
    for (; ; ) {
      let te = T0(P, ee);
      if (!(te >= D))
        return te += f, te;
    }
  }
  return w.Red = V, Pd = w, Pd;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
var Rd, r4;
function q1() {
  if (r4)
    return Rd;
  r4 = 1;
  const { custom: r } = Yl(), e = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ], t = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ], i = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ], n = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  }, c = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  }, o = 4, d = 1 << o - 1, l = typeof BigInt == "function";
  class h {
    constructor(s, a, p) {
      this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(s, a, p);
    }
    /*
     * Addition Engine
     */
    _iadd(s, a) {
      let p = 0, v = 0;
      for (s.length < a.length && ([s, a] = [a, s]), s !== this && this._alloc(s.length); v < a.length; v++) {
        const C = (s.words[v] | 0) + (a.words[v] | 0) + p;
        this.words[v] = C & 67108863, p = C >>> 26;
      }
      for (; p !== 0 && v < s.length; v++) {
        const C = (s.words[v] | 0) + p;
        this.words[v] = C & 67108863, p = C >>> 26;
      }
      if (this.length = s.length, p !== 0)
        this._alloc(this.length + 1), this.words[this.length++] = p;
      else if (s !== this)
        for (; v < s.length; v++)
          this.words[v] = s.words[v];
      return this;
    }
    _iaddn(s) {
      if (this.words[0] += s, this.words[0] < 67108864)
        return this;
      let a = 0;
      for (this._alloc(this.length + 1), this.words[this.length] = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, this.words[a + 1] += 1;
      return this.length = Math.max(this.length, a + 1), this;
    }
    /*
     * Addition
     */
    iadd(s) {
      if (T(h.isBN(s), "num", "bignum"), this.negative === s.negative)
        this._iadd(this, s);
      else {
        const a = this.ucmp(s);
        if (a === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        a < 0 ? (this._isub(s, this), this.negative ^= 1) : this._isub(this, s);
      }
      return this;
    }
    iaddn(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      return a && (s = -s), this.negative === a ? this._iaddn(s) : this.length === 1 && this.words[0] < s ? (this.words[0] = s - this.words[0], this.negative ^= 1) : this._isubn(s), this;
    }
    add(s) {
      return T(h.isBN(s), "num", "bignum"), s.length > this.length ? s.clone().iadd(this) : this.clone().iadd(s);
    }
    addn(s) {
      return this.clone().iaddn(s);
    }
    /*
     * Subtraction Engine
     */
    _isub(s, a) {
      let p = 0, v = 0;
      for (V(s.length >= a.length), s !== this && this._alloc(s.length); v < a.length; v++) {
        const C = (s.words[v] | 0) - (a.words[v] | 0) + p;
        p = C >> 26, this.words[v] = C & 67108863;
      }
      for (; p !== 0 && v < s.length; v++) {
        const C = (s.words[v] | 0) + p;
        p = C >> 26, this.words[v] = C & 67108863;
      }
      if (V(p === 0), s !== this)
        for (; v < s.length; v++)
          this.words[v] = s.words[v];
      return this.length = Math.max(this.length, v), this._strip();
    }
    _isubn(s) {
      if (this.words[0] -= s, this.words[0] >= 0)
        return this._normalize();
      V(this.length !== 1), this._alloc(this.length + 1);
      for (let a = 0; a < this.length && this.words[a] < 0; a++)
        this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this.words[this.length] = 0, this._strip();
    }
    /*
     * Subtraction
     */
    isub(s) {
      if (T(h.isBN(s), "num", "bignum"), this.negative !== s.negative)
        this._iadd(this, s);
      else {
        const a = this.ucmp(s);
        if (a === 0)
          return this.words[0] = 0, this.length = 1, this.negative = 0, this;
        a < 0 ? (this._isub(s, this), this.negative ^= 1) : this._isub(this, s);
      }
      return this;
    }
    isubn(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      return a && (s = -s), this.negative !== a ? this._iaddn(s) : this.length === 1 && this.words[0] < s ? (this.words[0] = s - this.words[0], this.negative ^= 1) : this._isubn(s), this;
    }
    sub(s) {
      return this.clone().isub(s);
    }
    subn(s) {
      return this.clone().isubn(s);
    }
    /*
     * Multiplication Engine
     */
    _mul(s, a) {
      if (T(h.isBN(s), "num", "bignum"), T(h.isBN(a), "out", "bignum"), this.length === 10 && s.length === 10)
        return L(this, s, a);
      const p = this.length + s.length;
      return p < 63 ? Se(this, s, a) : p < 1024 ? we(this, s, a) : Z(this, s, a);
    }
    /*
     * Multiplication
     */
    imul(s) {
      return this.mul(s)._move(this);
    }
    imuln(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      a && (s = -s);
      let p = 0;
      for (let v = 0; v < this.length; v++) {
        const C = this.words[v] * s, K = (C & 67108863) + (p & 67108863);
        p >>= 26, p += C / 67108864 | 0, p += K >>> 26, this.words[v] = K & 67108863;
      }
      return this.negative ^= a, p !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = p) : this._strip(), this;
    }
    mul(s) {
      T(h.isBN(s), "num", "bignum");
      const a = this.length + s.length, p = new h();
      p.words = new Array(a);
      for (let v = 0; v < a; v++)
        p.words[v] = 0;
      return this._mul(s, p);
    }
    muln(s) {
      return this.clone().imuln(s);
    }
    /*
     * Multiplication + Shift
     */
    mulShift(s, a) {
      T(h.isBN(s), "num", "bignum"), T(a >>> 0 === a, "bits", "uint32");
      const p = this.mul(s), v = p.utestn(a - 1);
      return p.iushrn(a), this.negative ^ s.negative ? p.isubn(v) : p.iaddn(v);
    }
    /*
     * Division Engine
     */
    _div(s, a) {
      T(h.isBN(s), "num", "bignum"), V((a & c.ALL) === a), V(a !== c.NONE);
      const p = this, v = s;
      if (F(!v.isZero()), p.isZero())
        return [new h(0), new h(0)];
      const C = p.negative, K = v.negative;
      p.negative = 0, v.negative = 0;
      let O = null, $ = null;
      return p.ucmp(v) < 0 ? (a & c.QUO && (O = new h(0)), a & c.REM && ($ = p.clone())) : v.length === 1 ? (a & c.QUO && (O = p.quon(v.words[0])), a & c.REM && ($ = p.remn(v.words[0]))) : [O, $] = p._wordDiv(v, a), p.negative = C, v.negative = K, a & c.QUO && (O.negative = p.negative ^ v.negative, O._normalize()), a & c.REM && ($.negative = p.negative, $._normalize()), a & c.EUCLID && (a & c.QUO && (V((a & c.REM) !== 0), $.negative !== 0 && (v.negative !== 0 ? O.iaddn(1) : O.isubn(1))), a & c.REM && $.negative !== 0 && (v.negative !== 0 ? $.isub(v) : $.iadd(v))), [O, $];
    }
    _wordDiv(s, a) {
      let p = this.clone(), v = s, C = null, K;
      const O = v.words[v.length - 1] | 0, $ = 26 - me(O);
      $ !== 0 ? (v = v.clone(), p.iushln($), v.iushln($), K = v.words[v.length - 1] | 0) : K = O;
      const u = p.length - v.length;
      if (V(u >= 0), a & c.QUO) {
        C = new h(0), C.length = u + 1, C.words = new Array(C.length);
        for (let M = 0; M < C.length; M++)
          C.words[M] = 0;
      }
      const S = p.clone();
      S._ishlnsubmul(v, 1, u), S.negative === 0 && (C && (C.words[u] = 1), p = S);
      for (let M = u - 1; M >= 0; M--) {
        const Y = p.words[v.length + M], J = p.words[v.length + M - 1], X = (Y * 67108864 + J) / K | 0;
        let re = Math.min(X, 67108863);
        for (p._ishlnsubmul(v, re, M); p.negative !== 0; )
          re -= 1, p.negative = 0, p._ishlnsubmul(v, 1, M), p.ineg();
        C && (C.words[M] = re);
      }
      return C && C._strip(), a & c.REM && $ !== 0 && p.iushrn($), [C, p];
    }
    _ishlnsubmul(s, a, p) {
      let v = 0, C = 0;
      for (this._expand(s.length + p); C < s.length; C++) {
        const K = (this.words[C + p] | 0) + v, O = s.words[C] * a, $ = K - (O & 67108863);
        v = ($ >> 26) - (O / 67108864 | 0), this.words[C + p] = $ & 67108863;
      }
      for (; C < this.length - p; C++) {
        const K = (this.words[C + p] | 0) + v;
        v = K >> 26, this.words[C + p] = K & 67108863;
      }
      if (v === 0)
        return this._strip();
      V(v === -1), v = 0;
      for (let K = 0; K < this.length; K++) {
        const O = -(this.words[K] | 0) + v;
        v = O >> 26, this.words[K] = O & 67108863;
      }
      return this.negative = 1, this._strip();
    }
    /*
     * Truncation Division + Modulo
     */
    quorem(s) {
      return this._div(s, c.BOTH);
    }
    /*
     * Truncation Division
     */
    iquo(s) {
      return this.quo(s)._move(this);
    }
    iquon(s) {
      T(ne(s), "num", "smi"), F(s !== 0);
      const a = s < 0 | 0;
      a && (s = -s);
      let p = 0;
      for (let v = this.length - 1; v >= 0; v--) {
        const C = (this.words[v] | 0) + p * 67108864;
        this.words[v] = C / s | 0, p = C % s;
      }
      return this.negative ^= a, this._strip();
    }
    quo(s) {
      return this._div(s, c.QUO)[0];
    }
    quon(s) {
      return this.clone().iquon(s);
    }
    /*
     * Truncation Modulo
     */
    irem(s) {
      return this.rem(s)._move(this);
    }
    iremn(s) {
      let a = this.remrn(s);
      return a < 0 && (a = -a), this.words[0] = a, this.length = 1, this._normalize();
    }
    rem(s) {
      return this._div(s, c.REM)[1];
    }
    remn(s) {
      return this.clone().iremn(s);
    }
    remrn(s) {
      T(ne(s), "num", "smi"), F(s !== 0), s < 0 && (s = -s);
      const a = (1 << 26) % s;
      let p = 0;
      for (let v = this.length - 1; v >= 0; v--)
        p = (a * p + (this.words[v] | 0)) % s;
      return this.negative !== 0 ? -p | 0 : p;
    }
    /*
     * Euclidean Division + Modulo
     */
    divmod(s) {
      return this._div(s, c.BOTH | c.EUCLID);
    }
    /*
     * Euclidean Division
     */
    idiv(s) {
      return this.div(s)._move(this);
    }
    idivn(s) {
      if (this.negative === 0)
        return this.iquon(s);
      const a = this.remrn(s);
      return this.iquon(s), a < 0 && (s < 0 ? this.iaddn(1) : this.isubn(1)), this;
    }
    div(s) {
      return this._div(s, c.BOTH | c.EUCLID)[0];
    }
    divn(s) {
      return this.clone().idivn(s);
    }
    /*
     * Euclidean Modulo
     */
    imod(s) {
      return this.ucmp(s) < 0 ? (this.negative !== 0 && (this._isub(s, this), this.negative = 0), this) : this.mod(s)._move(this);
    }
    imodn(s) {
      return this.words[0] = this.modrn(s), this.length = 1, this.negative = 0, this;
    }
    mod(s) {
      return this._div(s, c.REM | c.EUCLID)[1];
    }
    modn(s) {
      return this.clone().imodn(s);
    }
    modrn(s) {
      T(ne(s), "num", "smi");
      let a = this.remrn(s);
      return a < 0 && (s < 0 ? a -= s : a += s), a;
    }
    /*
     * Round Division
     */
    divRound(s) {
      const [a, p] = this.quorem(s);
      if (p.isZero())
        return a;
      const v = s.words[0] & 1;
      s.iushrn(1);
      const C = p.ucmp(s);
      return s.iushln(1), s.words[0] |= v, C < 0 || s.isOdd() && C === 0 ? a : this.negative ^ s.negative ? a.isubn(1) : a.iaddn(1);
    }
    /*
     * Exponentiation
     */
    ipow(s) {
      return this.pow(s)._move(this);
    }
    ipown(s) {
      return this.pown(s)._move(this);
    }
    pow(s) {
      T(h.isBN(s), "num", "bignum");
      let a = me(s.words[s.length - 1]), p = new h(1);
      for (let v = s.length - 1; v >= 0; v--) {
        const C = s.words[v];
        for (let K = a - 1; K >= 0; K--)
          p = p.sqr(), C >> K & 1 && (p = p.mul(this));
        a = 26;
      }
      return p;
    }
    pown(s) {
      if (T(ne(s), "num", "smi"), s < 0 && (s = -s), s === 0)
        return new h(1);
      if (s === 1)
        return this.clone();
      const a = me(s);
      let p = this;
      for (let v = a - 2; v >= 0; v--)
        p = p.sqr(), s >> v & 1 && (p = p.mul(this));
      return p;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    /*
     * Roots Engine
     */
    _rootrem(s, a) {
      if (T(s >>> 0 === s, "num", "uint32"), s === 0)
        throw new RangeError("Zeroth root.");
      if (~s & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new h(0)];
      let p = new h(0), v = h.shift(1, this.bitLength() / s + 1 | 0), C, K;
      if (this.negative !== 0 && v.ineg(), s === 2)
        do
          p = v, v = this.quo(p), v.iadd(p), v.iushrn(1);
        while (v.ucmp(p) < 0);
      else
        do
          p = v, v = p.pown(s - 1), v = this.quo(v), C = p.muln(s - 1), v.iadd(C), v = v.quon(s);
        while (v.ucmp(p) < 0);
      return a && (v = p.pown(s), K = this.sub(v)), [p, K];
    }
    /*
     * Roots
     */
    rootrem(s) {
      return this._rootrem(s, 1);
    }
    iroot(s) {
      return this.root(s)._move(this);
    }
    root(s) {
      return this._rootrem(s, 0)[0];
    }
    isPower(s) {
      if (T(s >>> 0 === s, "num", "uint32"), s === 0 || ~s & this.negative)
        return !1;
      const [, a] = this.rootrem(s);
      return a.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    /*
     * AND
     */
    iand(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      if (a === p)
        return a;
      if (!(a.negative | p.negative))
        return a.iuand(p);
      if ((a.negative & p.negative) === 1)
        return a.iaddn(1), p.iaddn(1), a.iuor(p), a.isubn(1), p.isubn(1), a;
      a.negative !== 0 && ([a, p] = [p.clone(), a]);
      const v = a.bitLength();
      return p.iaddn(1), p.inotn(v), a.iuand(p), p.inotn(v), p.isubn(1), a._move(this);
    }
    iandn(s) {
      return T(ne(s), "num", "smi"), this.negative | s < 0 ? this.iand(new h(s)) : (this.words[0] &= s, this.length = 1, this);
    }
    and(s) {
      return this.clone().iand(s);
    }
    andn(s) {
      return this.clone().iandn(s);
    }
    andrn(s) {
      if (T(ne(s), "num", "smi"), this.negative | s < 0) {
        const a = this.iand(new h(s));
        if (a.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return a.negative !== 0 ? -a.words[0] : a.words[0];
      }
      return this.words[0] & s;
    }
    /*
     * Unsigned AND
     */
    iuand(s) {
      T(h.isBN(s), "num", "bignum"), this.length = Math.min(this.length, s.length);
      for (let a = 0; a < this.length; a++)
        this.words[a] &= s.words[a];
      return this._strip();
    }
    iuandn(s) {
      return T(ne(s), "num", "smi"), this.words[0] &= Math.abs(s), this.length = 1, this._normalize();
    }
    uand(s) {
      return this.clone().iuand(s);
    }
    uandn(s) {
      return this.clone().iuandn(s);
    }
    uandrn(s) {
      T(ne(s), "num", "smi");
      const a = this.words[0] & Math.abs(s);
      return this.negative !== 0 ? -a | 0 : a;
    }
    /*
     * OR
     */
    ior(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      return a === p ? a : a.negative | p.negative ? (a.negative & p.negative) === 1 ? (a.iaddn(1), p.iaddn(1), a.iuand(p), a.isubn(1), p.isubn(1), a) : (p = p.clone(), a.negative !== 0 && ([a, p] = [p, a]), p.iaddn(1), a.inotn(p.bitLength()), p.iuand(a), p.isubn(1), p._move(this)) : a.iuor(p);
    }
    iorn(s) {
      return T(ne(s), "num", "smi"), this.negative | s < 0 ? this.ior(new h(s)) : (this.words[0] |= s, this);
    }
    or(s) {
      return this.clone().ior(s);
    }
    orn(s) {
      return this.clone().iorn(s);
    }
    /*
     * Unsigned OR
     */
    iuor(s) {
      T(h.isBN(s), "num", "bignum"), this._expand(s.length);
      for (let a = 0; a < s.length; a++)
        this.words[a] |= s.words[a];
      return this;
    }
    iuorn(s) {
      return T(ne(s), "num", "smi"), this.words[0] |= Math.abs(s), this;
    }
    uor(s) {
      return this.clone().iuor(s);
    }
    uorn(s) {
      return this.clone().iuorn(s);
    }
    /*
     * XOR
     */
    ixor(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      return a === p ? (a.words[0] = 0, a.length = 1, a.negative = 0, a) : a.negative | p.negative ? (a.negative & p.negative) === 1 ? (a.iaddn(1), p.iaddn(1), a.iuxor(p), a.ineg(), p.isubn(1), a) : (a.negative !== 0 && ([a, p] = [p.clone(), a]), p.iaddn(1), a.iuxor(p), a.iaddn(1), a.ineg(), p.isubn(1), a._move(this)) : a.iuxor(p);
    }
    ixorn(s) {
      return T(ne(s), "num", "smi"), this.negative | s < 0 ? this.ixor(new h(s)) : (this.words[0] ^= s, this);
    }
    xor(s) {
      return this.clone().ixor(s);
    }
    xorn(s) {
      return this.clone().ixorn(s);
    }
    /*
     * Unsigned XOR
     */
    iuxor(s) {
      T(h.isBN(s), "num", "bignum");
      let a = this, p = s;
      a.length < p.length && ([a, p] = [p, a]);
      let v = 0;
      for (; v < p.length; v++)
        this.words[v] = a.words[v] ^ p.words[v];
      if (a !== this)
        for (this._alloc(a.length); v < a.length; v++)
          this.words[v] = a.words[v];
      return this.length = a.length, this._strip();
    }
    iuxorn(s) {
      return T(ne(s), "num", "smi"), this.words[0] ^= Math.abs(s), this._normalize();
    }
    uxor(s) {
      return this.clone().iuxor(s);
    }
    uxorn(s) {
      return this.clone().iuxorn(s);
    }
    /*
     * NOT
     */
    inot() {
      return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(s) {
      T(s >>> 0 === s, "width", "uint32");
      const a = s % 26;
      let p = Math.ceil(s / 26), v = 0;
      for (this._expand(p), a > 0 && (p -= 1); v < p; v++)
        this.words[v] ^= 67108863;
      return a > 0 && (this.words[v] ^= (1 << a) - 1), this._strip();
    }
    notn(s) {
      return this.clone().inotn(s);
    }
    /*
     * Left Shift
     */
    ishl(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.ishln(s.toNumber());
    }
    ishln(s) {
      return this.iushln(s);
    }
    shl(s) {
      return this.clone().ishl(s);
    }
    shln(s) {
      return this.clone().ishln(s);
    }
    /*
     * Unsigned Left Shift
     */
    iushl(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.iushln(s.toNumber());
    }
    iushln(s) {
      T(s >>> 0 === s, "bits", "uint32");
      const a = s % 26, p = (s - a) / 26, v = (1 << a) - 1 << 26 - a;
      if (a !== 0) {
        let C = 0;
        for (let K = 0; K < this.length; K++) {
          const O = this.words[K] & v, $ = (this.words[K] | 0) - O << a;
          this.words[K] = $ | C, C = O >>> 26 - a;
        }
        C !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = C);
      }
      if (p !== 0) {
        this._alloc(this.length + p);
        for (let C = this.length - 1; C >= 0; C--)
          this.words[C + p] = this.words[C];
        for (let C = 0; C < p; C++)
          this.words[C] = 0;
        this.length += p;
      }
      return this._strip();
    }
    ushl(s) {
      return this.clone().iushl(s);
    }
    ushln(s) {
      return this.clone().iushln(s);
    }
    /*
     * Right Shift Engine
     */
    _split(s, a) {
      const p = s % 26, v = Math.min((s - p) / 26, this.length), C = (1 << p) - 1;
      if (a) {
        a._alloc(v);
        for (let O = 0; O < v; O++)
          a.words[O] = this.words[O];
        a.length = v;
      }
      if (v !== 0)
        if (this.length > v) {
          this.length -= v;
          for (let O = 0; O < this.length; O++)
            this.words[O] = this.words[O + v];
        } else
          this.words[0] = 0, this.length = 1;
      let K = 0;
      if (p !== 0)
        for (let O = this.length - 1; O >= 0; O--) {
          const $ = this.words[O] | 0;
          this.words[O] = K << 26 - p | $ >>> p, K = $ & C;
        }
      return a && (K !== 0 ? (a._alloc(a.length + 1), a.words[a.length++] = K) : (a.length === 0 && (a.words[a.length++] = 0), a._strip())), this._strip();
    }
    /*
     * Right Shift
     */
    ishr(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.ishrn(s.toNumber());
    }
    ishrn(s) {
      return T(s >>> 0 === s, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(s), this.isubn(1), this) : this.iushrn(s);
    }
    shr(s) {
      return this.clone().ishr(s);
    }
    shrn(s) {
      return this.clone().ishrn(s);
    }
    /*
     * Unsigned Right Shift
     */
    iushr(s) {
      return T(h.isBN(s), "bits", "bignum"), T(s.bitLength() <= 32, "bits", "uint32"), this.iushrn(s.toNumber());
    }
    iushrn(s) {
      return T(s >>> 0 === s, "bits", "uint32"), this._split(s, null);
    }
    ushr(s) {
      return this.clone().iushr(s);
    }
    ushrn(s) {
      return this.clone().iushrn(s);
    }
    /*
     * Bit Manipulation
     */
    setn(s, a) {
      return T(s >>> 0 === s, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(s, !a), this.isubn(1), this) : this.usetn(s, a);
    }
    usetn(s, a) {
      T(s >>> 0 === s, "bit", "uint32");
      const p = s % 26, v = (s - p) / 26;
      return this._expand(v + 1), a ? this.words[v] |= 1 << p : this.words[v] &= ~(1 << p), this._strip();
    }
    testn(s) {
      T(s >>> 0 === s, "bit", "uint32");
      const a = s % 26, p = (s - a) / 26;
      if (this.length <= p)
        return this.negative;
      const v = this.words[p], C = v >> a & 1;
      if (this.negative !== 0) {
        if (a > 0 && v & (1 << a) - 1)
          return C ^ 1;
        let K = p;
        for (; K--; )
          if (this.words[K] > 0)
            return C ^ 1;
      }
      return C;
    }
    utestn(s) {
      T(s >>> 0 === s, "bit", "uint32");
      const a = s % 26, p = (s - a) / 26;
      return this.length <= p ? 0 : this.words[p] >> a & 1;
    }
    imaskn(s) {
      return T(s >>> 0 === s, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(s + 1), this.ineg()), this.iumaskn(s);
    }
    maskn(s) {
      return this.clone().imaskn(s);
    }
    iumaskn(s) {
      T(s >>> 0 === s, "bits", "uint32");
      const a = s % 26;
      let p = (s - a) / 26;
      return this.length <= p ? this : (a !== 0 && (p += 1), this.length = Math.min(p, this.length), a !== 0 && (this.words[this.length - 1] &= (1 << a) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip());
    }
    umaskn(s) {
      return this.clone().iumaskn(s);
    }
    andln(s) {
      return this.words[0] & s;
    }
    bit(s) {
      return this.utestn(s);
    }
    bits(s, a) {
      T(s >>> 0 === s, "pos", "uint32"), T(a >>> 0 === a, "width", "uint32"), T(a <= 26, "width", "width");
      const p = s % 26, v = (s - p) / 26;
      if (v >= this.length)
        return 0;
      let C = this.words[v] >> p & (1 << a) - 1;
      if (p + a > 26 && v + 1 < this.length) {
        const K = p + a - 26, O = this.words[v + 1] & (1 << K) - 1;
        C |= O << 26 - p;
      }
      return C;
    }
    /*
     * Negation
     */
    ineg() {
      return this.isZero() || (this.negative ^= 1), this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      return this.negative = 0, this;
    }
    abs() {
      return this.clone().iabs();
    }
    /*
     * Comparison
     */
    cmp(s) {
      if (T(h.isBN(s), "num", "bignum"), this.negative !== s.negative)
        return s.negative - this.negative;
      const a = this.ucmp(s);
      return this.negative !== 0 ? -a | 0 : a;
    }
    cmpn(s) {
      T(ne(s), "num", "smi");
      const a = s < 0 | 0;
      if (this.negative !== a)
        return a - this.negative;
      const p = this.ucmpn(s);
      return this.negative !== 0 ? -p | 0 : p;
    }
    eq(s) {
      return this.cmp(s) === 0;
    }
    eqn(s) {
      return this.cmpn(s) === 0;
    }
    gt(s) {
      return this.cmp(s) > 0;
    }
    gtn(s) {
      return this.cmpn(s) > 0;
    }
    gte(s) {
      return this.cmp(s) >= 0;
    }
    gten(s) {
      return this.cmpn(s) >= 0;
    }
    lt(s) {
      return this.cmp(s) < 0;
    }
    ltn(s) {
      return this.cmpn(s) < 0;
    }
    lte(s) {
      return this.cmp(s) <= 0;
    }
    lten(s) {
      return this.cmpn(s) <= 0;
    }
    sign() {
      return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    /*
     * Unsigned Comparison
     */
    ucmp(s) {
      if (T(h.isBN(s), "num", "bignum"), this.length < s.length)
        return -1;
      if (this.length > s.length)
        return 1;
      for (let a = this.length - 1; a >= 0; a--) {
        const p = this.words[a] | 0, v = s.words[a] | 0;
        if (p !== v)
          return (p > v) - (p < v);
      }
      return 0;
    }
    ucmpn(s) {
      if (T(ne(s), "num", "smi"), this.length > 1)
        return 1;
      const a = this.words[0] | 0;
      return s < 0 && (s = -s), (a > s) - (a < s);
    }
    /*
     * Number Theoretic Functions
     */
    legendre(s) {
      const a = l ? h.red(s) : h.mont(s);
      return this.toRed(a).redLegendre();
    }
    jacobi(s) {
      if (T(h.isBN(s), "num", "bignum"), s.isZero() || s.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let a = this._cloneNormal(), p = s.clone(), v = 1;
      for (p.isNeg() && (a.isNeg() && (v = -1), p.ineg()), (a.isNeg() || a.ucmp(p) >= 0) && a.imod(p); !a.isZero(); ) {
        if (a._makeOdd() & 1) {
          const O = p.andln(7);
          (O === 3 || O === 5) && (v = -v);
        }
        a.ucmp(p) < 0 && ([a, p] = [p, a], a.andln(3) === 3 && p.andln(3) === 3 && (v = -v)), a._isub(a, p).iushrn(1);
        const K = p.andln(7);
        (K === 3 || K === 5) && (v = -v);
      }
      return p.cmpn(1) !== 0 ? 0 : v;
    }
    kronecker(s) {
      T(h.isBN(s), "num", "bignum");
      const a = [
        0,
        1,
        0,
        -1,
        0,
        -1,
        0,
        1
      ];
      let p = this._cloneNormal(), v = s.clone(), C = 1;
      if (v.isZero())
        return p.ucmpn(1) === 0 ? C : 0;
      if (!p.isOdd() && !v.isOdd())
        return 0;
      for (v._makeOdd() & 1 && (C = a[p.andln(7)]), v.isNeg() && (p.isNeg() && (C = -C), v.ineg()); !p.isZero(); )
        p._makeOdd() & 1 && (C *= a[v.andln(7)]), (p.words[0] ^ p.negative * 67108863) & v.words[0] & 2 && (C = -C), v.imod(p), [p, v] = [v, p], v.negative = 0;
      return v.cmpn(1) !== 0 ? 0 : C;
    }
    igcd(s) {
      return this.gcd(s)._move(this);
    }
    gcd(s) {
      if (T(h.isBN(s), "num", "bignum"), this.isZero())
        return s.abs();
      if (s.isZero())
        return this.abs();
      let a = this.clone(), p = s.clone();
      a.negative = 0, p.negative = 0;
      const v = a._factor2(p);
      for (v !== 0 && (a.iushrn(v), p.iushrn(v)); ; ) {
        a._makeOdd(), p._makeOdd();
        const C = a.ucmp(p);
        if (C < 0)
          [a, p] = [p, a];
        else if (C === 0 || p.ucmpn(1) === 0)
          break;
        a._isub(a, p);
      }
      return p.iushln(v);
    }
    ilcm(s) {
      return this.lcm(s)._move(this);
    }
    lcm(s) {
      return T(h.isBN(s), "num", "bignum"), this.isZero() || s.isZero() ? new h(0) : this.quo(this.gcd(s)).mul(s).iabs();
    }
    egcd(s) {
      if (T(h.isBN(s), "num", "bignum"), this.isZero())
        return [
          new h(0),
          new h(s.sign()),
          s.abs()
        ];
      if (s.isZero())
        return [
          new h(this.sign()),
          new h(0),
          this.abs()
        ];
      const a = this.clone(), p = s.clone();
      a.negative = 0, p.negative = 0;
      const v = new h(1), C = new h(0), K = new h(0), O = new h(1), $ = a._factor2(p);
      $ > 0 && (a.iushrn($), p.iushrn($));
      const u = a.clone(), S = p.clone();
      for (; !a.isZero(); ) {
        let M = a._makeOdd(), Y = p._makeOdd();
        for (; M--; )
          (v.isOdd() || C.isOdd()) && (v.iadd(S), C.isub(u)), v.iushrn(1), C.iushrn(1);
        for (; Y--; )
          (K.isOdd() || O.isOdd()) && (K.iadd(S), O.isub(u)), K.iushrn(1), O.iushrn(1);
        a.cmp(p) >= 0 ? (a.isub(p), v.isub(K), C.isub(O)) : (p.isub(a), K.isub(v), O.isub(C));
      }
      return this.negative !== 0 && K.ineg(), s.negative !== 0 && O.ineg(), [K, O, p.iushln($)];
    }
    iinvert(s) {
      return this.invert(s)._move(this);
    }
    invert(s) {
      if (T(h.isBN(s), "num", "bignum"), ie(s.sign() > 0, "invert"), s.isOdd())
        return this._invertp(s);
      if (s.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [a, , p] = this.egcd(s);
      if (p.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return a.imod(s);
    }
    ifermat(s) {
      return this.fermat(s)._move(this);
    }
    fermat(s) {
      const a = l ? h.red(s) : h.mont(s);
      return this.toRed(a).redFermat().fromRed();
    }
    ipowm(s, a, p) {
      return this.powm(s, a, p)._move(this);
    }
    powm(s, a, p) {
      const v = !l && p ? h.mont(a) : h.red(a);
      return this.toRed(v).redPow(s).fromRed();
    }
    ipowmn(s, a, p) {
      return this.powmn(s, a, p)._move(this);
    }
    powmn(s, a, p) {
      const v = p ? h.mont(a) : h.red(a);
      return this.toRed(v).redPown(s).fromRed();
    }
    isqrtm(s) {
      return this.sqrtm(s)._move(this);
    }
    sqrtm(s) {
      T(h.isBN(s), "p", "bignum");
      let a;
      return s.andln(3) === 3 || s.andln(7) === 5 ? a = h.red(s) : a = h.mont(s), this.toRed(a).redSqrt().fromRed();
    }
    isqrtpq(s, a) {
      return this.sqrtpq(s, a)._move(this);
    }
    sqrtpq(s, a) {
      const p = this.sqrtm(s), v = this.sqrtm(a), [C, K] = s.egcd(a), O = v.mul(C).mul(s), $ = p.mul(K).mul(a), u = s.mul(a);
      return O.iadd($).imod(u);
    }
    /*
     * Primality Testing
     */
    isPrime(s, a, p) {
      return T(a >>> 0 === a, "reps", "uint32"), !(!this.isPrimeMR(s, a + 1, !0) || !this.isPrimeLucas(p));
    }
    isPrimeMR(s, a, p = !1) {
      T(a >>> 0 === a, "reps", "uint32"), T(a > 0, "reps", "integer"), T(typeof p == "boolean", "force2", "boolean");
      const v = this;
      if (v.cmpn(7) < 0)
        return v.cmpn(2) === 0 || v.cmpn(3) === 0 || v.cmpn(5) === 0;
      if (v.isEven())
        return !1;
      const C = v.subn(1), K = C.subn(2), O = C.zeroBits(), $ = C.ushrn(O), u = h.red(v), S = C.toRed(u), M = new h(1).toRed(u);
      e:
        for (let Y = 0; Y < a; Y++) {
          let J;
          Y === a - 1 && p ? J = new h(2) : (J = h.random(s, 0, K), J.iaddn(2));
          let X = J.toRed(u).redPow($);
          if (!(X.cmp(M) === 0 || X.cmp(S) === 0)) {
            for (let re = 1; re < O; re++) {
              if (X = X.redSqr(), X.cmp(S) === 0)
                continue e;
              if (X.cmp(M) === 0)
                return !1;
            }
            return !1;
          }
        }
      return !0;
    }
    isPrimeLucas(s = 0) {
      T(s >>> 0 === s, "limit", "uint32");
      const a = this;
      if (a.cmpn(1) <= 0)
        return !1;
      if (a.isEven())
        return a.cmpn(2) === 0;
      let p = 3;
      for (; ; ) {
        if (p > 1e4)
          throw new Error(`Cannot find (D/n) = -1 for ${a.toString(10)}.`);
        if (s !== 0 && p > s)
          return !1;
        const u = new h(p * p - 4).jacobi(a);
        if (u === -1)
          break;
        if (u === 0)
          return a.cmpn(p + 2) === 0;
        if (p === 40 && a.isSquare())
          return !1;
        p += 1;
      }
      const v = a.addn(1), C = v._makeOdd();
      let K = new h(2), O = new h(p);
      for (let $ = v.bitLength(); $ >= 0; $--)
        v.utestn($) ? (K = K.mul(O).isubn(p).imod(a), O = O.sqr().isubn(2).imod(a)) : (O = O.mul(K).isubn(p).imod(a), K = K.sqr().isubn(2).imod(a));
      if (K.cmpn(2) === 0 || K.cmp(a.subn(2)) === 0) {
        const $ = K.muln(p).imod(a), u = O.ushln(1).imod(a);
        if ($.cmp(u) === 0)
          return !0;
      }
      for (let $ = 0; $ < C - 1; $++) {
        if (K.isZero())
          return !0;
        if (K.cmpn(2) === 0)
          return !1;
        K = K.sqr().isubn(2).imod(a);
      }
      return !1;
    }
    /*
     * Twos Complement
     */
    toTwos(s) {
      return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
    }
    fromTwos(s) {
      return T(s >>> 0 === s, "width", "uint32"), ie(s > 0, "width"), this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
    }
    /*
     * Reduction Context
     */
    toRed(s) {
      if (T(s instanceof z, "ctx", "reduction context"), this.red)
        throw new Error("Already in reduction context.");
      return s.convertTo(this);
    }
    fromRed() {
      return N(this.red, "fromRed"), this.red.convertFrom(this);
    }
    forceRed(s) {
      if (T(s instanceof z, "ctx", "reduction context"), this.red) {
        if (!s.m.eq(this.red.m) || s.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else
        ie(this.negative === 0, "red"), ie(this.ucmp(s.m) < 0, "red");
      return this.clone()._forceRed(s);
    }
    redIAdd(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIAdd"), this.red.iadd(this, s);
    }
    redAdd(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redAdd"), this.red.add(this, s);
    }
    redIAddn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIAddn"), this.red.iaddn(this, s);
    }
    redAddn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redAddn"), this.red.addn(this, s);
    }
    redISub(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redISub"), this.red.isub(this, s);
    }
    redSub(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redSub"), this.red.sub(this, s);
    }
    redISubn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redISubn"), this.red.isubn(this, s);
    }
    redSubn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redSubn"), this.red.subn(this, s);
    }
    redIMul(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIMul"), this.red.imul(this, s);
    }
    redMul(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redMul"), this.red.mul(this, s);
    }
    redIMuln(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIMuln"), this.red.imuln(this, s);
    }
    redMuln(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redMuln"), this.red.muln(this, s);
    }
    redIDiv(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIDiv"), this.red.idiv(this, s);
    }
    redDiv(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redDiv"), this.red.div(this, s);
    }
    redIDivn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIDivn"), this.red.idivn(this, s);
    }
    redDivn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redDivn"), this.red.divn(this, s);
    }
    redIPow(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIPow"), G(!s.red, "redIPow"), this.red.ipow(this, s);
    }
    redPow(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redPow"), G(!s.red, "redPow"), this.red.pow(this, s);
    }
    redIPown(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redIPown"), this.red.ipown(this, s);
    }
    redPown(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redPown"), this.red.pown(this, s);
    }
    redISqr() {
      return N(this.red, "redISqr"), this.red.isqr(this);
    }
    redSqr() {
      return N(this.red, "redSqr"), this.red.sqr(this);
    }
    redISqrt() {
      return N(this.red, "redISqrt"), this.red.isqrt(this);
    }
    redSqrt() {
      return N(this.red, "redSqrt"), this.red.sqrt(this);
    }
    redIDivSqrt(s) {
      return N(this.red, "redIDivSqrt"), this.red.idivsqrt(this, s);
    }
    redDivSqrt(s) {
      return N(this.red, "redDivSqrt"), this.red.divsqrt(this, s);
    }
    redIsSquare() {
      return N(this.red, "redIsSquare"), this.red.isSquare(this);
    }
    redIShl(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redIShl"), G(!s.red, "redIShl"), this.red.ishl(this, s);
    }
    redShl(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redShl"), G(!s.red, "redShl"), this.red.shl(this, s);
    }
    redIShln(s) {
      return T(s >>> 0 === s, "num", "uint32"), N(this.red, "redIShln"), this.red.ishln(this, s);
    }
    redShln(s) {
      return T(s >>> 0 === s, "num", "uint32"), N(this.red, "redShln"), this.red.shln(this, s);
    }
    redINeg() {
      return N(this.red, "redINeg"), this.red.ineg(this);
    }
    redNeg() {
      return N(this.red, "redNeg"), this.red.neg(this);
    }
    redEq(s) {
      return T(h.isBN(s), "num", "bignum"), N(this.red, "redEq"), this.red.eq(this, s);
    }
    redEqn(s) {
      return T(ne(s), "num", "smi"), N(this.red, "redEqn"), this.red.eqn(this, s);
    }
    redIsHigh() {
      return N(this.red, "redIsHigh"), this.red.isHigh(this);
    }
    redIsLow() {
      return N(this.red, "redIsLow"), this.red.isLow(this);
    }
    redIsOdd() {
      return N(this.red, "redIsOdd"), this.red.isOdd(this);
    }
    redIsEven() {
      return N(this.red, "redIsEven"), this.red.isEven(this);
    }
    redLegendre() {
      return N(this.red, "redLegendre"), this.red.legendre(this);
    }
    redJacobi() {
      return N(this.red, "redJacobi"), this.red.jacobi(this);
    }
    redKronecker() {
      return N(this.red, "redKronecker"), this.red.kronecker(this);
    }
    redIInvert() {
      return N(this.red, "redIInvert"), this.red.iinvert(this);
    }
    redInvert() {
      return N(this.red, "redInvert"), this.red.invert(this);
    }
    redIFermat() {
      return N(this.red, "redIFermat"), this.red.ifermat(this);
    }
    redFermat() {
      return N(this.red, "redFermat"), this.red.fermat(this);
    }
    /*
     * Internal
     */
    _move(s) {
      return s.words = this.words, s.length = this.length, s.negative = this.negative, s.red = this.red, s;
    }
    _alloc(s) {
      for (; this.words.length < s; )
        this.words.push(0);
      return this;
    }
    _expand(s) {
      for (this._alloc(s); this.length < s; )
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      return V(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }
    _check() {
      return V(this.length > 0), V(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && V(this.negative === 0), this) : (V(this.words[this.length - 1] !== 0), this);
    }
    _invertp(s) {
      if (T(h.isBN(s), "p", "bignum"), ie(s.sign() > 0, "invert"), V(s.isOdd()), s.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const a = this.clone(), p = s.clone(), v = new h(1), C = new h(0);
      for ((a.isNeg() || a.ucmp(p) >= 0) && a.imod(p); !a.isZero(); ) {
        let K = a._makeOdd(), O = p._makeOdd();
        for (; K--; )
          v.isOdd() && v._iadd(v, s), v.iushrn(1);
        for (; O--; )
          C.isOdd() && C._iadd(C, s), C.iushrn(1);
        a.ucmp(p) >= 0 ? (a._isub(a, p), v.ucmp(C) < 0 ? (v._isub(C, v), v._isub(s, v)) : v._isub(v, C)) : (p._isub(p, a), C.ucmp(v) < 0 ? (C._isub(v, C), C._isub(s, C)) : C._isub(C, v));
      }
      if (p.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return V(C.negative === 0), V(C.ucmp(s) < 0), C;
    }
    _makeOdd() {
      const s = this.zeroBits();
      return s > 0 && this.iushrn(s), s;
    }
    _factor2(s) {
      if ((this.words[0] | s.words[0]) & 1)
        return 0;
      const a = Math.min(this.length, s.length);
      let p = 0;
      for (let v = 0; v < a; v++) {
        const C = Ne(this.words[v] | s.words[v]);
        if (p += C, C !== 26)
          break;
      }
      return p;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(s) {
      return this.red = s, this;
    }
    /*
     * Helpers
     */
    clone() {
      const s = new h();
      s.words = new Array(this.length);
      for (let a = 0; a < this.length; a++)
        s.words[a] = this.words[a];
      return s.length = this.length, s.negative = this.negative, s.red = this.red, s;
    }
    inject(s) {
      T(h.isBN(s), "num", "bignum"), this._alloc(s.length);
      for (let a = 0; a < s.length; a++)
        this.words[a] = s.words[a];
      return this.length = s.length, this.negative = s.negative, this.red = s.red, this;
    }
    set(s, a) {
      return this.fromNumber(s, a);
    }
    swap(s) {
      T(h.isBN(s), "num", "bignum");
      const a = this, p = s;
      return [a.words, p.words] = [p.words, a.words], [a.length, p.length] = [p.length, a.length], [a.negative, p.negative] = [p.negative, a.negative], [a.red, p.red] = [p.red, a.red], a;
    }
    reverse() {
      const s = this.negative;
      return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = s, this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const s = this.words[this.length - 1], a = me(s);
      return (this.length - 1) * 26 + a;
    }
    zeroBits() {
      if (this.isZero() || this.isOdd())
        return 0;
      let s = 0;
      for (let a = 0; a < this.length; a++) {
        const p = Ne(this.words[a]);
        if (s += p, p !== 26)
          break;
      }
      return s;
    }
    isSafe() {
      return this.length <= 2 || this.length === 3 && this.words[2] === 1;
    }
    word(s) {
      return T(s >>> 0 === s, "pos", "uint32"), s >= this.length ? 0 : this.words[s];
    }
    [r]() {
      let s = "BN";
      return this.red && (s = "BN-R"), `<${s}: ${this.toString(10)}>`;
    }
    /*
     * Conversion
     */
    toNumber() {
      let s = this.words[0];
      if (this.length === 2)
        s += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        s += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        throw new RangeError("Number can only safely store up to 53 bits.");
      return this.negative !== 0 ? -s : s;
    }
    toDouble() {
      let s = 0;
      for (let a = this.length - 1; a >= 0; a--)
        s = s * 67108864 + this.words[a];
      return this.negative !== 0 ? -s : s;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!l)
        throw new Error("BigInt is not supported!");
      const s = BigInt(52), a = BigInt(26);
      let p = this.length - 1, v = BigInt(0);
      for (; p >= 1; p -= 2) {
        const C = this.words[p] * 67108864, K = this.words[p - 1];
        v = v << s | BigInt(C + K);
      }
      return p >= 0 && (v = v << a | BigInt(this.words[0])), this.negative !== 0 ? -v : v;
    }
    toBool() {
      return !this.isZero();
    }
    toString(s, a) {
      if (s = he(s), a == null && (a = 0), a === 0 && (a = 1), T(s >>> 0 === s, "base", "uint32"), T(a >>> 0 === a, "padding", "uint32"), s < 2 || s > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      if (this._check(), s === 16) {
        let O = "", $ = 0, u = 0;
        for (let S = 0; S < this.length; S++) {
          const M = this.words[S], Y = ((M << $ | u) & 16777215).toString(16);
          u = M >>> 24 - $ & 16777215, u !== 0 || S !== this.length - 1 ? O = e[6 - Y.length] + Y + O : O = Y + O, $ += 2, $ >= 26 && ($ -= 26, S -= 1);
        }
        for (u !== 0 && (O = u.toString(16) + O); O.length % a !== 0; )
          O = "0" + O;
        return this.negative !== 0 && (O = "-" + O), O;
      }
      const p = t[s - 1], v = i[s - 1], C = this.clone();
      let K = "";
      for (C.negative = 0; !C.isZero(); ) {
        const O = C.remrn(v).toString(s);
        C.iquon(v), C.isZero() ? K = O + K : K = e[p - O.length] + O + K;
      }
      for (this.isZero() && (K = "0"); K.length % a !== 0; )
        K = "0" + K;
      return this.negative !== 0 && (K = "-" + K), K;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(s, a) {
      return this.toArrayLike(Array, s, a);
    }
    toBuffer(s, a) {
      return this.toArrayLike(Buffer, s, a);
    }
    toArrayLike(s, a, p) {
      a == null && (a = "be"), p == null && (p = 0), T(typeof s == "function", "ArrayType", "function"), T(a === "be" || a === "le", "endian", "endianness"), T(p >>> 0 === p, "length", "uint32"), this._check();
      const v = this.byteLength(), C = p || Math.max(1, v);
      if (v > C)
        throw new RangeError("Byte array longer than desired length.");
      const K = xe(s, C);
      if (a === "be") {
        let O = K.length - 1, $ = 0;
        for (let u = 0; u < this.length; u++) {
          const S = (u & 3) << 1, M = this.words[u] << S | $;
          K[O--] = M & 255, O >= 0 && (K[O--] = M >>> 8 & 255), O >= 0 && (K[O--] = M >>> 16 & 255), S === 6 ? (O >= 0 && (K[O--] = M >>> 24 & 255), $ = 0) : $ = M >>> 24;
        }
        if (O >= 0) {
          for (K[O--] = $; O >= 0; )
            K[O--] = 0;
          $ = 0;
        }
        V($ === 0);
      } else {
        let O = 0, $ = 0;
        for (let u = 0; u < this.length; u++) {
          const S = (u & 3) << 1, M = this.words[u] << S | $;
          K[O++] = M & 255, O < K.length && (K[O++] = M >>> 8 & 255), O < K.length && (K[O++] = M >>> 16 & 255), S === 6 ? (O < K.length && (K[O++] = M >>> 24 & 255), $ = 0) : $ = M >>> 24;
        }
        if (O < K.length) {
          for (K[O++] = $; O < K.length; )
            K[O++] = 0;
          $ = 0;
        }
        V($ === 0);
      }
      return K;
    }
    encode(s, a) {
      return this.toBuffer(s, a);
    }
    /*
     * Instantiation
     */
    of(s, a) {
      return this.fromNumber(s, a);
    }
    fromNumber(s, a) {
      a == null && (a = "be"), T(ce(s), "num", "integer"), T(a === "be" || a === "le", "endian", "endianness");
      const p = s < 0 | 0;
      return p && (s = -s), s < 67108864 ? (this.words[0] = s & 67108863, this.length = 1) : s < 4503599627370496 ? (this.words = [
        s & 67108863,
        s / 67108864 & 67108863
      ], this.length = 2) : (this.words = [
        s & 67108863,
        s / 67108864 & 67108863,
        1
      ], this.length = 3), this.negative = p, a === "le" && this.reverse(), this;
    }
    fromDouble(s, a) {
      a == null && (a = "be"), T(typeof s == "number", "num", "double"), T(a === "be" || a === "le", "endian", "endianness"), isFinite(s) || (s = 0);
      const p = s <= -1 | 0;
      for (s < 0 && (s = -s), s = Math.floor(s), this.words = []; s > 0; ) {
        const v = s % 67108864, C = (s - v) / 67108864;
        this.words.push(v), s = C;
      }
      return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = p, a === "le" && this.reverse(), this;
    }
    fromBigInt(s, a) {
      if (a == null && (a = "be"), T(typeof s == "bigint", "num", "bigint"), T(a === "be" || a === "le", "endian", "endianness"), !l)
        throw new Error("BigInt is not supported!");
      const p = s < BigInt(0) | 0;
      return this._fromHex(s.toString(16), p), this.negative = p, a === "le" && this.reverse(), this;
    }
    fromBool(s) {
      return T(typeof s == "boolean", "value", "boolean"), this.words[0] = s | 0, this.length = 1, this.negative = 0, this;
    }
    fromString(s, a, p) {
      if ((a === "le" || a === "be") && ([a, p] = [p, a]), a = he(a), p == null && (p = "be"), T(typeof s == "string", "string", "string"), T(a >>> 0 === a, "base", "uint32"), T(p === "be" || p === "le", "endian", "endianness"), a < 2 || a > 36)
        throw new Error("Base ranges between 2 and 36.");
      s = s.replace(/\s+/g, "");
      let v = 0;
      return s.length > 0 && s.charCodeAt(0) === 45 && (v = 1), a === 16 ? this._fromHex(s, v) : this._fromBase(s, a, v), this.negative = v, this._normalize(), p === "le" && this.reverse(), this;
    }
    _fromHex(s, a) {
      this.length = Math.max(2, Math.ceil((s.length - a) / 6)), this.words = new Array(this.length);
      for (let K = 0; K < this.length; K++)
        this.words[K] = 0;
      let p = 0, v = s.length - 6, C = 0;
      for (; v >= a; v -= 6) {
        const K = Je(s, v, v + 6);
        this.words[C] |= K << p & 67108863, this.words[C + 1] |= K >>> 26 - p & 4194303, p += 24, p >= 26 && (p -= 26, C += 1);
      }
      if (v + 6 !== a) {
        const K = Je(s, a, v + 6);
        this.words[C] |= K << p & 67108863, this.words[C + 1] |= K >>> 26 - p & 4194303;
      }
      return this._strip();
    }
    _fromBase(s, a, p) {
      this.words[0] = 0, this.length = 1, this.negative = 0;
      let v = 0, C = 1;
      for (; C <= 67108863; C *= a)
        v += 1;
      v -= 1, C = C / a | 0;
      const K = s.length - p, O = K % v, $ = Math.min(K, K - O) + p;
      let u = p;
      for (; u < $; u += v) {
        const S = Ze(s, u, u + v, a);
        this.imuln(C), this._iaddn(S);
      }
      if (O !== 0) {
        const S = Math.pow(a, O), M = Ze(s, u, s.length, a);
        this.imuln(S), this._iaddn(M);
      }
      return this;
    }
    fromJSON(s) {
      if (h.isBN(s))
        return s.red ? s.fromRed() : s.clone();
      if (Array.isArray(s)) {
        for (const a of s)
          T(typeof a == "string", "chunk", "string");
        s = s.join("");
      }
      return this.fromString(s, 16);
    }
    fromBN(s) {
      return this.inject(s);
    }
    fromArray(s, a) {
      return T(Array.isArray(s), "data", "array"), this.fromArrayLike(s, a);
    }
    fromBuffer(s, a) {
      return T(Buffer.isBuffer(s), "data", "buffer"), this.fromArrayLike(s, a);
    }
    fromArrayLike(s, a) {
      if (a == null && (a = "be"), T(s && s.length >>> 0 === s.length, "data", "array-like"), T(a === "be" || a === "le", "endian", "endianness"), s.length === 0)
        return this.words[0] = 0, this.length = 1, this.negative = 0, this;
      this.length = Math.max(2, Math.ceil(s.length / 3)), this.words = new Array(this.length), this.negative = 0;
      for (let O = 0; O < this.length; O++)
        this.words[O] = 0;
      const p = s.length % 3;
      let v = 0, C = 0, K = 0;
      if (a === "be") {
        for (let O = s.length - 1; O >= 2; O -= 3) {
          const $ = s[O] | s[O - 1] << 8 | s[O - 2] << 16;
          this.words[C] |= $ << v & 67108863, this.words[C + 1] = $ >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, C += 1);
        }
        switch (p) {
          case 2:
            K = s[1] | s[0] << 8;
            break;
          case 1:
            K = s[0];
            break;
        }
      } else {
        const O = s.length - p;
        for (let $ = 0; $ < O; $ += 3) {
          const u = s[$] | s[$ + 1] << 8 | s[$ + 2] << 16;
          this.words[C] |= u << v & 67108863, this.words[C + 1] = u >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, C += 1);
        }
        switch (p) {
          case 2:
            K = s[O] | s[O + 1] << 8;
            break;
          case 1:
            K = s[O];
            break;
        }
      }
      return p > 0 && (this.words[C] |= K << v & 67108863, this.words[C + 1] = K >>> 26 - v & 67108863), this._strip();
    }
    decode(s, a) {
      return this.fromBuffer(s, a);
    }
    from(s, a, p) {
      if (s == null)
        return this;
      if ((a === "le" || a === "be") && ([a, p] = [p, a]), typeof s == "number")
        return this.fromNumber(s, p);
      if (typeof s == "bigint")
        return this.fromBigInt(s, p);
      if (typeof s == "string")
        return this.fromString(s, a, p);
      if (typeof s == "object") {
        if (h.isBN(s))
          return this.fromBN(s, p);
        if (s.length >>> 0 === s.length)
          return this.fromArrayLike(s, p);
      }
      if (typeof s == "boolean")
        return this.fromBool(s);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    /*
     * Static Methods
     */
    static min(...s) {
      let a = null;
      for (const p of s)
        T(h.isBN(p), "num", "bignum"), (!a || p.cmp(a) < 0) && (a = p);
      return a || new h(0);
    }
    static max(...s) {
      let a = null;
      for (const p of s)
        T(h.isBN(p), "num", "bignum"), (!a || p.cmp(a) > 0) && (a = p);
      return a || new h(0);
    }
    static cmp(s, a) {
      return T(h.isBN(s), "a", "bignum"), s.cmp(a);
    }
    static ucmp(s, a) {
      return T(h.isBN(s), "a", "bignum"), s.ucmp(a);
    }
    static red(s) {
      return new z(s);
    }
    static barrett(s) {
      return new E(s);
    }
    static mont(s) {
      return new H(s);
    }
    static _prime(s) {
      if (n[s])
        return n[s];
      let a;
      if (s === "p192")
        a = new I();
      else if (s === "p224")
        a = new B();
      else if (s === "p521")
        a = new y();
      else if (s === "k256")
        a = new A();
      else if (s === "p251")
        a = new _();
      else if (s === "p25519")
        a = new q();
      else if (s === "p448")
        a = new U();
      else
        throw new Error(`Unknown prime: "${s}".`);
      return n[s] = a, a;
    }
    static prime(s) {
      return h._prime(s).p.clone();
    }
    static pow(s, a) {
      return s === 2 ? h.shift(1, a) : new h().fromNumber(s).pown(a);
    }
    static shift(s, a) {
      return s === 1 ? new h(0).usetn(a, 1) : new h().fromNumber(s).ishln(a);
    }
    static mask(s) {
      return h.shift(1, s).isubn(1);
    }
    static randomBits(s, a) {
      if (T(s != null, "rng", "rng"), T(a >>> 0 === a, "bits", "uint32"), typeof s == "object") {
        T(typeof s.randomBytes == "function", "rng", "rng");
        const v = a + 7 >>> 3, C = v * 8, K = s.randomBytes(v);
        if (T(Buffer.isBuffer(K), "bytes", "buffer"), K.length !== v)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const O = h.fromBuffer(K);
        return C > a && O.iushrn(C - a), O;
      }
      T(typeof s == "function", "rng", "rng");
      const p = s(a);
      if (T(h.isBN(p), "num", "bignum"), ie(p.negative === 0, "RNG"), G(!p.red, "RNG"), p.bitLength() > a)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return p;
    }
    static random(s, a, p) {
      if (a = h.cast(a, 16), p = h.cast(p, 16), a.cmp(p) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const v = p.sub(a).iabs(), C = v.bitLength();
      if (C === 0)
        return a.clone();
      for (; ; ) {
        const K = h.randomBits(s, C);
        if (!(K.cmp(v) >= 0))
          return K.iadd(a), K;
      }
    }
    static of(s, a) {
      return new h().of(s, a);
    }
    static fromNumber(s, a) {
      return new h().fromNumber(s, a);
    }
    static fromDouble(s, a) {
      return new h().fromDouble(s, a);
    }
    static fromBigInt(s, a) {
      return new h().fromBigInt(s, a);
    }
    static fromBool(s) {
      return new h().fromBool(s);
    }
    static fromString(s, a, p) {
      return new h().fromString(s, a, p);
    }
    static fromJSON(s) {
      return new h().fromJSON(s);
    }
    static fromBN(s) {
      return new h().fromBN(s);
    }
    static fromArray(s, a) {
      return new h().fromArray(s, a);
    }
    static fromBuffer(s, a) {
      return new h().fromBuffer(s, a);
    }
    static fromArrayLike(s, a) {
      return new h().fromArrayLike(s, a);
    }
    static decode(s, a) {
      return new h().decode(s, a);
    }
    static from(s, a, p) {
      return new h().from(s, a, p);
    }
    static cast(s, a, p) {
      return h.isBN(s) ? s : new h(s, a, p);
    }
    static isBN(s) {
      return s instanceof h;
    }
  }
  h.BN = h, h.wordSize = 26, h.native = 0;
  class x {
    constructor(s, a) {
      this.name = s, this.p = new h(a, 16), this.n = this.p.bitLength(), this.k = h.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone();
    }
    ireduce(s) {
      const a = s.negative !== 0;
      let p = s.bitLength();
      for (V(p <= this.n * 2), s.negative = 0; p > this.n; )
        this.split(s, this.lo), this.imulK(s), s._iadd(s, this.lo), p = s.bitLength();
      const v = p < this.n ? -1 : s.ucmp(this.p);
      return v === 0 ? (s.words[0] = 0, s.length = 1) : v > 0 && s._isub(s, this.p), a && !s.isZero() && s._isub(this.p, s), s;
    }
    split(s, a) {
      s._split(this.n, a);
    }
    imulK(s) {
      return s.imul(this.k);
    }
    pm2(s) {
      throw new Error("Not implemented.");
    }
    fermat(s) {
      return this.pm2(s);
    }
  }
  class b extends x {
    constructor(s, a) {
      super(s, a);
    }
    pm3d4(s) {
      throw new Error("Not implemented.");
    }
    pp1d4(s) {
      throw new Error("Not implemented.");
    }
    sqrt(s) {
      const { red: a } = s, p = this.pp1d4(s);
      if (!a.sqr(p).eq(s))
        throw new W(p);
      return p;
    }
    divsqrt(s, a) {
      const { red: p } = s, v = p.sqr(s), C = p.mul(v, s), K = p.mul(C, v), O = p.mul(p.sqr(a), a), $ = this.pm3d4(p.mul(K, O)), u = p.mul(p.mul(C, a), $);
      if (p.mul(a, p.sqr(u)).eq(s))
        return u;
      throw new W(u);
    }
  }
  class g extends x {
    constructor(s, a, p) {
      super(s, a), this.sm1 = new h(p, 16);
    }
    pm5d8(s) {
      throw new Error("Not implemented.");
    }
    pp3d8(s) {
      throw new Error("Not implemented.");
    }
    sqrt(s) {
      const { red: a } = s, p = this.sm1._forceRed(a), v = this.pp3d8(s);
      if (a.sqr(v).eq(s))
        return v;
      const C = a.mul(v, p);
      if (a.sqr(C).eq(s))
        return C;
      throw new W(v);
    }
    divsqrt(s, a) {
      const { red: p } = s, v = this.sm1._forceRed(p), C = p.mul(p.sqr(a), a), K = p.mul(p.sqr(C), a), O = this.pm5d8(p.mul(s, K)), $ = p.mul(p.mul(s, C), O), u = p.mul(a, p.sqr($));
      if (u.eq(s))
        return $;
      const S = p.ineg(u);
      if (S.eq(s))
        return p.mul($, v);
      throw S.eq(p.mul(s, v)) ? new W(p.mul($, v)) : new W($);
    }
  }
  class w extends x {
    constructor(s, a, p) {
      super(s, a), this.g = new h(p, 16), this.z = this.p.subn(1).zeroBits();
    }
    powS(s) {
      throw new Error("Not implemented.");
    }
    powE(s) {
      throw new Error("Not implemented.");
    }
    sqrt(s) {
      const { red: a } = s;
      switch (a.jacobi(s)) {
        case -1:
          throw new W(s);
        case 0:
          return s.clone();
      }
      let p = this.g._forceRed(a), v = this.powE(s), C = this.powS(s), K = this.z;
      for (; ; ) {
        let O = C, $ = 0;
        for (; O.cmpn(1) !== 0 && $ < K; )
          O = a.sqr(O), $ += 1;
        if ($ === 0)
          break;
        V($ < K), O = a.sqrn(p, K - $ - 1), p = a.sqr(O), v = a.mul(v, O), C = a.mul(C, p), K = $;
      }
      return v;
    }
    divsqrt(s, a) {
      const { red: p } = s;
      if (a.isZero())
        throw new W(a);
      return this.sqrt(p.div(s, a));
    }
  }
  class I extends b {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(s) {
      const a = this.one.inject(s);
      return s.iushln(64)._iadd(s, a);
    }
    core(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 6, C), O = a.sqrnmul(K, 12, K), $ = a.sqrnmul(O, 6, C), u = a.sqrnmul($, 1, s), S = a.sqrnmul(u, 31, u), M = a.sqrnmul(S, 62, S), Y = a.sqrnmul(M, 3, v), J = a.sqrn(Y, 1);
      return a.sqrnmul(J, 62, S);
    }
    pm3d4(s) {
      return this.core(s);
    }
    pm2(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 2, p), C = a.sqrnmul(v, 4, v), K = a.sqrnmul(C, 8, C), O = a.sqrnmul(K, 16, K), $ = a.sqrnmul(O, 32, O), u = a.sqrnmul($, 64, $);
      return a.sqrn(u, 62);
    }
  }
  class B extends w {
    constructor() {
      super(
        "p224",
        "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001",
        "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74"
      );
    }
    imulK(s) {
      const a = this.one.inject(s);
      return s.iushln(96)._isub(s, a);
    }
    powS(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 2, p), C = a.sqrnmul(v, 4, v), K = a.sqrnmul(C, 8, C), O = a.sqrnmul(K, 16, K), $ = a.sqrnmul(O, 32, O);
      return a.sqrnmul($, 64, $);
    }
    powE(s) {
      const { red: a } = s;
      return a.sqrn(s, 127);
    }
    pm2(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 6, C), O = a.sqrnmul(K, 12, K), $ = a.sqrnmul(O, 24, O), u = a.sqrnmul($, 48, $), S = a.sqrnmul(u, 24, O), M = a.sqrnmul(S, 6, C), Y = a.sqrnmul(M, 1, s), J = a.sqrn(Y, 1);
      return a.sqrnmul(J, 96, u);
    }
  }
  class y extends b {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(s) {
      return s;
    }
    core(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 1, s), O = a.sqrnmul(K, 1, s), $ = a.sqrnmul(O, 8, O), u = a.sqrnmul($, 16, $), S = a.sqrnmul(u, 32, u), M = a.sqrnmul(S, 64, S), Y = a.sqrnmul(M, 128, M), J = a.sqrnmul(Y, 256, Y);
      return a.sqrnmul(J, 7, K);
    }
    pm3d4(s) {
      return this.core(s);
    }
    pm2(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s;
      return a.sqrn(s, 519);
    }
  }
  class A extends b {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(s, a) {
      const v = Math.min(s.length, 9);
      a._alloc(v + 1);
      for (let O = 0; O < v; O++)
        a.words[O] = s.words[O];
      if (a.length = v, s.length <= 9) {
        a._strip(), s.words[0] = 0, s.length = 1;
        return;
      }
      let C = s.words[9], K = 10;
      for (a.words[a.length++] = C & 4194303, a._strip(); K < s.length; K++) {
        const O = s.words[K] | 0;
        s.words[K - 10] = (O & 4194303) << 4 | C >>> 22, C = O;
      }
      C >>>= 22, s.words[K - 10] = C, C === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9, s._strip();
    }
    imulK(s) {
      s._expand(s.length + 2);
      let a = 0;
      for (let p = 0; p < s.length; p++) {
        const v = s.words[p];
        a += v * 977, s.words[p] = a & 67108863, a = v * 64 + Math.floor(a / 67108864);
      }
      return s.words[s.length - 1] === 0 && (s.length -= 1, s.words[s.length - 1] === 0 && (s.length -= 1)), s;
    }
    core(s, a) {
      const { red: p } = s, v = p.sqrnmul(a, 1, s), C = p.sqrnmul(v, 3, v), K = p.sqrnmul(C, 3, v), O = p.sqrnmul(K, 2, a), $ = p.sqrnmul(O, 11, O), u = p.sqrnmul($, 22, $), S = p.sqrnmul(u, 44, u), M = p.sqrnmul(S, 88, S), Y = p.sqrnmul(M, 44, u), J = p.sqrnmul(Y, 3, v), X = p.sqrn(J, 1), re = p.sqrnmul(X, 22, $);
      return p.sqrn(re, 4);
    }
    pm3d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1);
      return a.sqrnmul(K, 2, p);
    }
    pm2(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1), O = a.sqrnmul(K, 2, p), $ = a.sqrn(O, 1);
      return a.sqrnmul($, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 2, p);
      return a.sqrn(C, 2);
    }
  }
  class _ extends b {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(s) {
      if (s.isZero())
        return s;
      let a = 0;
      for (let p = 0; p < s.length; p++) {
        const v = s.words[p] * 9 + a;
        a = v >>> 26, s.words[p] = v & 67108863;
      }
      return a !== 0 && (s._alloc(s.length + 1), s.words[s.length++] = a), s;
    }
    core(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = a.sqrnmul(p, 1, s), C = a.sqrnmul(v, 3, v), K = a.sqrnmul(C, 6, C), O = a.sqrnmul(K, 12, K), $ = a.sqrnmul(O, 24, O), u = a.sqrnmul($, 48, $), S = a.sqrnmul(u, 96, u), M = a.sqrnmul(S, 48, $), Y = a.sqrnmul(M, 6, C);
      return a.sqrnmul(Y, 1, s);
    }
    pm3d4(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pm2(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrn(p, 1), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1);
      return a.sqrnmul(K, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = this.core(s), v = a.sqrnmul(p, 1, s);
      return a.sqrn(v, 1);
    }
  }
  class q extends g {
    constructor() {
      super(
        "p25519",
        "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed",
        "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0"
      );
    }
    imulK(s) {
      let a = 0;
      for (let p = 0; p < s.length; p++) {
        const v = s.words[p] * 19 + a;
        a = v >>> 26, s.words[p] = v & 67108863;
      }
      return a !== 0 && (s._alloc(s.length + 1), s.words[s.length++] = a), s;
    }
    core(s, a) {
      const { red: p } = s, v = p.sqrnmul(a, 2, a), C = p.sqrnmul(v, 1, s), K = p.sqrnmul(C, 5, C), O = p.sqrnmul(K, 10, K), $ = p.sqrnmul(O, 20, O), u = p.sqrnmul($, 10, K), S = p.sqrnmul(u, 50, u), M = p.sqrnmul(S, 100, S);
      return p.sqrnmul(M, 50, u);
    }
    pm5d8(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrn(v, 1);
      return a.sqrnmul(C, 1, s);
    }
    pm2(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrn(v, 1), K = a.sqrnmul(C, 1, s), O = a.sqrn(K, 1);
      return a.sqrnmul(O, 2, p);
    }
    pp3d8(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s);
      return a.sqrn(C, 1);
    }
  }
  class U extends b {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(s) {
      const a = this.one.inject(s);
      return s.iushln(224)._iadd(s, a);
    }
    core(s, a) {
      const { red: p } = s, v = p.sqrnmul(a, 1, s), C = p.sqrnmul(v, 3, v), K = p.sqrnmul(C, 3, v), O = p.sqrnmul(K, 2, a), $ = p.sqrnmul(O, 11, O), u = p.sqrnmul($, 22, $), S = p.sqrnmul(u, 44, u), M = p.sqrnmul(S, 88, S), Y = p.sqrnmul(M, 44, u);
      return p.sqrnmul(Y, 2, a);
    }
    pm3d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 1, s), K = a.sqrn(C, 1);
      return a.sqrnmul(K, 222, v);
    }
    pm2(s) {
      const { red: a } = s, p = this.pm3d4(s), v = a.sqrn(p, 1);
      return a.sqrnmul(v, 1, s);
    }
    pp1d4(s) {
      const { red: a } = s, p = a.sqrnmul(s, 1, s), v = this.core(s, p), C = a.sqrnmul(v, 2, p);
      return a.sqrn(C, 222);
    }
  }
  class z {
    constructor(s) {
      let a = null;
      typeof s == "string" && (a = h._prime(s), s = a.p), T(h.isBN(s), "m", "bignum"), G(!s.red, "reduction"), ie(s.sign() > 0, "reduction"), this.m = s, this.prime = a, this.mb = null, this.sm1 = null;
    }
    _verify1(s) {
      ie(s.negative === 0, "red"), N(s.red != null, "red");
    }
    _verify2(s, a) {
      ie((s.negative | a.negative) === 0, "red"), N(s.red != null && s.red === a.red, "red");
    }
    get mont() {
      return !1;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5)
        if (this.prime)
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        else {
          const s = new h(2).toRed(this), a = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(s, a);
        }
      return this;
    }
    convertTo(s) {
      const a = s.mod(this.m);
      return a.red = this, a;
    }
    convertFrom(s) {
      const a = s.clone();
      return a.red = null, a;
    }
    intTo(s) {
      return s;
    }
    intFrom(s) {
      return s;
    }
    imod(s) {
      return this.prime ? this.prime.ireduce(s)._forceRed(this) : s.imod(this.m)._forceRed(this);
    }
    iadd(s, a) {
      return this._verify2(s, a), s._iadd(s, a), s.ucmp(this.m) >= 0 && s._isub(s, this.m), s;
    }
    add(s, a) {
      return s.length < a.length ? this.iadd(a.clone(), s) : this.iadd(s.clone(), a);
    }
    iaddn(s, a) {
      return this._verify1(s), a < 0 ? this.isubn(s, -a) : (this.m.length === 1 && (a %= this.m.words[0]), s._iaddn(a), s.ucmp(this.m) >= 0 && s._isub(s, this.m), s);
    }
    addn(s, a) {
      return this.iaddn(s.clone(), a);
    }
    isub(s, a) {
      this._verify2(s, a);
      const p = s.ucmp(a);
      return p === 0 ? (s.words[0] = 0, s.length = 1, s) : (p < 0 ? (s._isub(a, s), s._isub(this.m, s)) : s._isub(s, a), s);
    }
    sub(s, a) {
      return this.isub(s.clone(), a);
    }
    isubn(s, a) {
      return this._verify1(s), a < 0 ? this.iaddn(s, -a) : (this.m.length === 1 && (a %= this.m.words[0]), s.length === 1 && s.words[0] < a ? (s.words[0] = a - s.words[0], s._isub(this.m, s)) : s._isubn(a), s);
    }
    subn(s, a) {
      return this.isubn(s.clone(), a);
    }
    imul(s, a) {
      return this._verify2(s, a), this.imod(s.imul(a));
    }
    mul(s, a) {
      return this._verify2(s, a), this.imod(s.mul(a));
    }
    imuln(s, a) {
      if (this._verify1(s), s.isZero())
        return s;
      if (a === 0)
        return s.words[0] = 0, s.length = 1, s;
      const p = a < 0;
      if (p && (a = -a), this.m.length === 1 && (a %= this.m.words[0]), s.imuln(a), a <= 16)
        for (; s.ucmp(this.m) >= 0; )
          s._isub(s, this.m);
      else
        this.imod(s);
      return p && this.ineg(s), s;
    }
    muln(s, a) {
      return this.imuln(s.clone(), a);
    }
    idiv(s, a) {
      return this.div(s, a)._move(s);
    }
    div(s, a) {
      return this.mul(s, this.invert(a));
    }
    idivn(s, a) {
      return this.divn(s, a)._move(s);
    }
    divn(s, a) {
      return this.div(s, this.convertTo(new h(a)));
    }
    ipow(s, a) {
      return this.pow(s, a)._move(s);
    }
    pow(s, a) {
      return this._verify1(s), a.isNeg() && (s = this.invert(s)), a.length === 1 ? this.pown(s, a.words[0]) : l && !this.prime ? this.powInt(s, a) : this.powNum(s, a);
    }
    powNum(s, a) {
      const p = new h(1).toRed(this), v = new Array(d), C = this.sqr(s);
      v[0] = s;
      for (let $ = 1; $ < d; $++)
        v[$] = this.mul(v[$ - 1], C);
      let K = a.bitLength(), O = p;
      for (; K >= o; ) {
        let $ = o, u = a.bits(K - $, $);
        if (u < d) {
          O = this.sqr(O), K -= 1;
          continue;
        }
        for (; !(u & 1); )
          $ -= 1, u >>= 1;
        O === p ? O = v[u >> 1].clone() : (O = this.sqrn(O, $), O = this.mul(O, v[u >> 1])), K -= $;
      }
      if (K > 0) {
        const $ = a.bits(0, K);
        for (; K--; )
          O = this.sqr(O), $ >> K & 1 && (O = this.mul(O, s));
      }
      return O;
    }
    powInt(s, a) {
      this.mb === null && (this.mb = this.m.toBigInt());
      const p = this.intFrom(s.toBigInt()), v = ht(p, a, this.mb), C = this.intTo(v);
      return h.fromBigInt(C)._forceRed(this);
    }
    sqrn(s, a) {
      for (; a--; )
        s = this.sqr(s);
      return s;
    }
    sqrnmul(s, a, p) {
      return this.mul(this.sqrn(s, a), p);
    }
    ipown(s, a) {
      return this.pown(s, a)._move(s);
    }
    pown(s, a) {
      if (this._verify1(s), a < 0 && (s = this.invert(s), a = -a), a === 0)
        return new h(1).toRed(this);
      if (a === 1)
        return s.clone();
      const p = me(a);
      let v = s;
      for (let C = p - 2; C >= 0; C--)
        v = this.sqr(v), a >> C & 1 && (v = this.mul(v, s));
      return v;
    }
    isqr(s) {
      return this.imul(s, s);
    }
    sqr(s) {
      return this.mul(s, s);
    }
    isqrt(s) {
      return this.sqrt(s)._move(s);
    }
    sqrt(s) {
      return this._verify1(s), this.prime ? this.prime.sqrt(s) : this.m.andln(3) === 3 ? this.sqrt3mod4(s) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(s) : this.sqrt5mod8(s) : this.sqrt0(s);
    }
    sqrt3mod4(s) {
      const a = this.m.addn(1).iushrn(2), p = this.pow(s, a);
      if (!this.sqr(p).eq(s))
        throw new W(p);
      return p;
    }
    sqrt5mod8(s) {
      const a = new h(1).toRed(this), p = this.m.ushrn(3), v = this.add(s, s), C = this.pow(v, p), K = this.mul(v, this.sqr(C)), O = this.mul(this.mul(C, s), this.isub(K, a));
      if (!this.sqr(O).eq(s))
        throw new W(O);
      return O;
    }
    sqrt5mod8sm1(s) {
      const a = this.m.addn(3).iushrn(3), p = this.pow(s, a);
      if (this.sqr(p).eq(s))
        return p;
      const v = this.mul(p, this.sm1);
      if (this.sqr(v).eq(s))
        return v;
      throw new W(p);
    }
    sqrt0(s) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(s)) {
        case -1:
          throw new W(s);
        case 0:
          return s.clone();
      }
      const a = new h(1).toRed(this), p = this.m.subn(1), v = p._makeOdd(), C = new h(2).toRed(this);
      for (; this.jacobi(C) !== -1; )
        this.iadd(C, a);
      let K = this.pow(C, p), O = this.pow(s, p), $ = this.pow(s, p.iaddn(1).iushrn(1)), u = v;
      for (; ; ) {
        let S = O, M = 0;
        for (; !S.eq(a) && M < u; )
          S = this.sqr(S), M += 1;
        if (M === 0)
          break;
        V(M < u), S = this.sqrn(K, u - M - 1), K = this.sqr(S), $ = this.mul($, S), O = this.mul(O, K), u = M;
      }
      return $;
    }
    idivsqrt(s, a) {
      return this.divsqrt(s, a)._move(s);
    }
    divsqrt(s, a) {
      if (this._verify2(s, a), s.isZero() && a.isZero())
        throw new W(a);
      if (this.prime)
        return this.prime.divsqrt(s, a);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(s, a);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(s, a);
      if (a.isZero())
        throw new W(a);
      return this.sqrt(this.div(s, a));
    }
    divsqrt3mod4(s, a) {
      const p = this.m.subn(3).iushrn(2), v = this.sqr(s), C = this.mul(v, s), K = this.mul(C, v), O = this.mul(this.sqr(a), a), $ = this.pow(this.mul(K, O), p), u = this.mul(this.mul(C, a), $);
      if (this.mul(a, this.sqr(u)).eq(s))
        return u;
      throw new W(u);
    }
    divsqrt5mod8(s, a) {
      const p = this.m.subn(5).iushrn(3), v = this.mul(this.sqr(a), a), C = this.mul(this.sqr(v), a), K = this.pow(this.mul(s, C), p), O = this.mul(this.mul(s, v), K), $ = this.mul(a, this.sqr(O));
      if ($.eq(s))
        return O;
      const u = this.ineg($);
      if (u.eq(s))
        return this.mul(O, this.sm1);
      throw u.eq(this.mul(s, this.sm1)) ? new W(this.mul(O, this.sm1)) : new W(O);
    }
    isSquare(s) {
      return this.m.isOdd() ? this.jacobi(s) >= 0 : this.kronecker(s) >= 0;
    }
    ishl(s, a) {
      return this._verify1(s), this.imod(s.iushl(a));
    }
    shl(s, a) {
      return this.ishl(s.clone(), a);
    }
    ishln(s, a) {
      if (this._verify1(s), s.iushln(a), a <= 4)
        for (; s.ucmp(this.m) >= 0; )
          s._isub(s, this.m);
      else
        this.imod(s);
      return s;
    }
    shln(s, a) {
      return this.ishln(s.clone(), a);
    }
    ineg(s) {
      return this._verify1(s), s.isZero() || s._isub(this.m, s), s;
    }
    neg(s) {
      return this.ineg(s.clone());
    }
    eq(s, a) {
      return this._verify2(s, a), s.ucmp(a) === 0;
    }
    eqn(s, a) {
      if (this._verify1(s), this.m.length === 1)
        return a %= this.m.words[0], a < 0 && (a += this.m.words[0]), s.ucmpn(a) === 0;
      if (a < 0) {
        this.m._isubn(-a);
        const p = s.ucmp(this.m);
        return this.m._iaddn(-a), p === 0;
      }
      return s.ucmpn(a) === 0;
    }
    isHigh(s) {
      return !this.isLow(s);
    }
    isLow(s) {
      return this._verify1(s), s.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(s) {
      return this._verify1(s), s.isOdd();
    }
    isEven(s) {
      return this._verify1(s), s.isEven();
    }
    legendre(s) {
      if (this._verify1(s), this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const a = this.m.subn(1).iushrn(1), p = this.pow(s, a);
      if (p.isZero())
        return 0;
      const v = new h(1).toRed(this);
      if (p.eq(v))
        return 1;
      if (p.eq(this.ineg(v)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(s) {
      return this._verify1(s), s.jacobi(this.m);
    }
    kronecker(s) {
      return this._verify1(s), s.kronecker(this.m);
    }
    iinvert(s) {
      return this.invert(s)._move(s);
    }
    invert(s) {
      return this._verify1(s), s.invert(this.m)._forceRed(this);
    }
    ifermat(s) {
      return this.fermat(s)._move(s);
    }
    fermat(s) {
      if (this._verify1(s), s.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      return this.prime ? this.prime.fermat(s) : this.pow(s, this.m.subn(2));
    }
    invertAll(s) {
      T(Array.isArray(s), "elems", "array");
      for (const C of s)
        T(h.isBN(C), "elem", "bignum"), this._verify1(C);
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const a = s.length, p = new Array(a);
      if (a === 0)
        return p;
      let v = new h(1).toRed(this);
      for (let C = 0; C < a; C++) {
        if (s[C].isZero()) {
          p[C] = s[C].clone();
          continue;
        }
        p[C] = v, v = this.mul(v, s[C]);
      }
      v = this.invert(v);
      for (let C = a - 1; C >= 0; C--)
        s[C].isZero() || (p[C] = this.mul(v, p[C]), v = this.mul(v, s[C]));
      return p;
    }
    [r]() {
      return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`;
    }
  }
  class E extends z {
    constructor(s) {
      super(s), this.prime = null, this.n = this.m.bitLength(), this.n % 26 !== 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = h.shift(1, this.k).div(this.m);
    }
    convertTo(s) {
      return s.length > this.w ? super.convertTo(s) : this.imod(s.clone());
    }
    _shift(s) {
      let a = 0, p = this.w;
      for (; p < s.length; )
        s.words[a++] = s.words[p++];
      a === 0 && (s.words[a++] = 0), s.length = a;
    }
    imod(s) {
      const a = s.negative;
      V(s.length <= this.w), s.negative = 0;
      const p = s.mul(this.b);
      return this._shift(p), s._isub(s, p.mul(this.m)), s.ucmp(this.m) >= 0 && s._isub(s, this.m), a && !s.isZero() && s._isub(this.m, s), s.red = this, s;
    }
  }
  class H extends z {
    constructor(s) {
      super(s), this.prime = null, this.n = this.m.length * 26, this.r = h.shift(1, this.n), this.r2 = h.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null;
    }
    get mont() {
      return !0;
    }
    convertTo(s) {
      return s.isNeg() || s.ucmp(this.m) >= 0 ? this.imod(s.ushln(this.n)) : this.mul(s, this.r2);
    }
    convertFrom(s) {
      const a = this.mul(s, new h(1));
      return a.red = null, a;
    }
    intTo(s) {
      return (s << BigInt(this.n)) % this.mb;
    }
    intFrom(s) {
      return this.rib === null && (this.rib = this.ri.toBigInt()), s * this.rib % this.mb;
    }
    iaddn(s, a) {
      return this.iadd(s, this.convertTo(new h(a)));
    }
    isubn(s, a) {
      return this.isub(s, this.convertTo(new h(a)));
    }
    imul(s, a) {
      return this.mul(s, a)._move(s);
    }
    mul(s, a) {
      if (s.isZero() || a.isZero())
        return new h(0)._forceRed(this);
      const p = s.mul(a), v = p.umaskn(this.n).mul(this.mi).iumaskn(this.n), C = p.iadd(v.mul(this.m)).iushrn(this.n);
      return C.ucmp(this.m) >= 0 && C._isub(C, this.m), C._forceRed(this);
    }
    imuln(s, a) {
      if (this._verify1(s), s.isZero())
        return s;
      if (a === 0)
        return s.words[0] = 0, s.length = 1, s;
      const p = a < 0;
      p && (a = -a), this.m.length === 1 && (a %= this.m.words[0]);
      const v = me(a);
      if (v > 5)
        this.imul(s, this.convertTo(new h(a)));
      else if (a & a - 1) {
        const C = s.clone();
        for (let K = v - 2; K >= 0; K--)
          this.iadd(s, s), a >> K & 1 && this.iadd(s, C);
      } else
        for (let C = 0; C < v - 1; C++)
          this.iadd(s, s);
      return p && this.ineg(s), s;
    }
    eqn(s, a) {
      return this._verify1(s), a === 0 ? s.isZero() : s.ucmp(this.convertTo(new h(a))) === 0;
    }
    isLow(s) {
      return this._verify1(s), this.convertFrom(s).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(s) {
      return this._verify1(s), this.convertFrom(s).isOdd();
    }
    isEven(s) {
      return this._verify1(s), this.convertFrom(s).isEven();
    }
    invert(s) {
      return this._verify1(s), this.imod(s.invert(this.m).mul(this.r2));
    }
  }
  function k(oe, s, a) {
    const p = new oe(s);
    return oe.captureStackTrace && oe.captureStackTrace(p, a), p;
  }
  function V(oe, s) {
    if (!oe)
      throw k(Error, s || "Assertion failed.", V);
  }
  function T(oe, s, a) {
    if (!oe) {
      const p = `"${s}" must be a(n) ${a}.`;
      throw k(TypeError, p, T);
    }
  }
  function ie(oe, s) {
    if (!oe) {
      const a = `"${s}" only works with positive numbers.`;
      throw k(RangeError, a, ie);
    }
  }
  function N(oe, s) {
    if (!oe) {
      const a = `"${s}" only works with red numbers.`;
      throw k(TypeError, a, N);
    }
  }
  function G(oe, s) {
    if (!oe) {
      const a = `"${s}" only works with normal numbers.`;
      throw k(TypeError, a, G);
    }
  }
  function F(oe) {
    if (!oe)
      throw k(RangeError, "Cannot divide by zero.", F);
  }
  class W extends Error {
    constructor(s) {
      super(), this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = s.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, W);
    }
  }
  function ce(oe) {
    return Number.isSafeInteger(oe);
  }
  function ne(oe) {
    return ce(oe) && oe >= -67108863 && oe <= 67108863;
  }
  function xe(oe, s) {
    return oe.allocUnsafeSlow ? oe.allocUnsafeSlow(s) : new oe(s);
  }
  function he(oe) {
    if (oe == null)
      return 10;
    if (typeof oe == "number")
      return oe;
    switch (oe) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function me(oe) {
    if (Math.clz32)
      return 32 - Math.clz32(oe);
    let s = oe, a = 0;
    return s >= 4096 && (a += 13, s >>>= 13), s >= 64 && (a += 7, s >>>= 7), s >= 8 && (a += 4, s >>>= 4), s >= 2 && (a += 2, s >>>= 2), a + s;
  }
  function Ne(oe) {
    if (oe === 0)
      return 26;
    let s = oe, a = 0;
    return s & 8191 || (a += 13, s >>>= 13), s & 127 || (a += 7, s >>>= 7), s & 15 || (a += 4, s >>>= 4), s & 3 || (a += 2, s >>>= 2), s & 1 || (a += 1), a;
  }
  function Je(oe, s, a) {
    const p = Math.min(oe.length, a);
    let v = 0, C = 0;
    for (let K = s; K < p; K++) {
      const O = oe.charCodeAt(K) - 48;
      v <<= 4;
      let $;
      O >= 49 && O <= 54 ? $ = O - 49 + 10 : O >= 17 && O <= 22 ? $ = O - 17 + 10 : $ = O, v |= $, C |= $;
    }
    if (C & -16)
      throw new Error("Invalid string.");
    return v;
  }
  function Ze(oe, s, a, p) {
    const v = Math.min(oe.length, a);
    let C = 0;
    for (let K = s; K < v; K++) {
      const O = oe.charCodeAt(K) - 48;
      C *= p;
      let $;
      if (O >= 49 ? $ = O - 49 + 10 : O >= 17 ? $ = O - 17 + 10 : $ = O, O < 0 || O > 207 || $ >= p)
        throw new Error("Invalid string.");
      C += $;
    }
    return C;
  }
  function ht(oe, s, a) {
    const p = BigInt(1), v = new Array(d), C = oe * oe % a;
    v[0] = oe;
    for (let $ = 1; $ < d; $++)
      v[$] = v[$ - 1] * C % a;
    let K = s.bitLength(), O = p;
    for (; K >= o; ) {
      let $ = o, u = s.bits(K - $, $);
      if (u < d) {
        O = O * O % a, K -= 1;
        continue;
      }
      for (; !(u & 1); )
        $ -= 1, u >>= 1;
      O === p ? O = v[u >> 1] : (O = dt(O, $, a), O = O * v[u >> 1] % a), K -= $;
    }
    if (K > 0) {
      const $ = s.bits(0, K);
      for (; K--; )
        O = O * O % a, $ >> K & 1 && (O = O * oe % a);
    }
    return O;
  }
  function dt(oe, s, a) {
    for (let p = 0; p < s; p++)
      oe = oe * oe % a;
    return oe;
  }
  function Se(oe, s, a) {
    const p = oe.length + s.length;
    a.negative = oe.negative ^ s.negative, a._alloc(p), a.length = p;
    const v = oe.words[0], C = s.words[0], K = v * C, O = K & 67108863;
    let $ = K / 67108864 | 0, u = 1;
    for (a.words[0] = O; u < a.length - 1; u++) {
      let S = $ >>> 26, M = $ & 67108863;
      const Y = Math.max(0, u - oe.length + 1), J = Math.min(u, s.length - 1);
      for (let X = Y; X <= J; X++) {
        const re = u - X, ae = oe.words[re], de = s.words[X], ge = ae * de + M;
        S += ge / 67108864 | 0, M = ge & 67108863;
      }
      a.words[u] = M | 0, $ = S | 0;
    }
    return $ !== 0 ? a.words[u] = $ | 0 : a.length -= 1, a._strip();
  }
  function we(oe, s, a) {
    const p = oe.length + s.length;
    a.negative = oe.negative ^ s.negative, a._alloc(p), a.length = p;
    let v = 0, C = 0, K = 0;
    for (; K < a.length - 1; K++) {
      let O = C;
      C = 0;
      let $ = v & 67108863;
      const u = Math.max(0, K - oe.length + 1), S = Math.min(K, s.length - 1);
      for (let M = u; M <= S; M++) {
        const Y = K - M, J = oe.words[Y], X = s.words[M], re = J * X;
        let ae = re & 67108863;
        O = O + (re / 67108864 | 0) | 0, ae = ae + $ | 0, $ = ae & 67108863, O = O + (ae >>> 26) | 0, C += O >>> 26, O &= 67108863;
      }
      a.words[K] = $, v = O, O = C;
    }
    return v !== 0 ? a.words[K] = v : a.length -= 1, a._strip();
  }
  function Z(oe, s, a) {
    if (!l || oe.length + s.length > 82595519)
      return we(oe, s, a);
    const p = BigInt(0), v = BigInt(67108863), C = BigInt(26);
    let K = oe.toBigInt() * s.toBigInt();
    const O = K < p | 0;
    O && (K = -K);
    let $ = 0;
    for (; K > p; )
      a.words[$++] = Number(K & v), K >>= C;
    return $ === 0 && (a.words[$++] = 0), a.length = $, a.negative = O, a;
  }
  function L(oe, s, a) {
    const p = oe.words, v = s.words, C = a.words, K = p[0] | 0, O = K & 8191, $ = K >>> 13, u = p[1] | 0, S = u & 8191, M = u >>> 13, Y = p[2] | 0, J = Y & 8191, X = Y >>> 13, re = p[3] | 0, ae = re & 8191, de = re >>> 13, ge = p[4] | 0, Be = ge & 8191, ve = ge >>> 13, Oe = p[5] | 0, Ie = Oe & 8191, Re = Oe >>> 13, ft = p[6] | 0, Ye = ft & 8191, Fe = ft >>> 13, Le = p[7] | 0, He = Le & 8191, et = Le >>> 13, xr = p[8] | 0, tt = xr & 8191, it = xr >>> 13, Ht = p[9] | 0, Qe = Ht & 8191, st = Ht >>> 13, s0 = v[0] | 0, ct = s0 & 8191, Xe = s0 >>> 13, qr = v[1] | 0, bt = qr & 8191, Ge = qr >>> 13, I0 = v[2] | 0, pt = I0 & 8191, ke = I0 >>> 13, le = v[3] | 0, ot = le & 8191, St = le >>> 13, Di = v[4] | 0, Bt = Di & 8191, vt = Di >>> 13, Li = v[5] | 0, Et = Li & 8191, It = Li >>> 13, Ki = v[6] | 0, At = Ki & 8191, _t = Ki >>> 13, $i = v[7] | 0, Mt = $i & 8191, lt = $i >>> 13, ii = v[8] | 0, at = ii & 8191, nt = ii >>> 13, Hi = v[9] | 0, Nt = Hi & 8191, Ot = Hi >>> 13;
    let Ke = 0, j, R, Q;
    a.negative = oe.negative ^ s.negative, a._alloc(20), a.length = 19, j = Math.imul(O, ct), R = Math.imul(O, Xe), R = R + Math.imul($, ct) | 0, Q = Math.imul($, Xe);
    let C0 = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (C0 >>> 26) | 0, C0 &= 67108863, j = Math.imul(S, ct), R = Math.imul(S, Xe), R = R + Math.imul(M, ct) | 0, Q = Math.imul(M, Xe), j = j + Math.imul(O, bt) | 0, R = R + Math.imul(O, Ge) | 0, R = R + Math.imul($, bt) | 0, Q = Q + Math.imul($, Ge) | 0;
    let T0 = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (T0 >>> 26) | 0, T0 &= 67108863, j = Math.imul(J, ct), R = Math.imul(J, Xe), R = R + Math.imul(X, ct) | 0, Q = Math.imul(X, Xe), j = j + Math.imul(S, bt) | 0, R = R + Math.imul(S, Ge) | 0, R = R + Math.imul(M, bt) | 0, Q = Q + Math.imul(M, Ge) | 0, j = j + Math.imul(O, pt) | 0, R = R + Math.imul(O, ke) | 0, R = R + Math.imul($, pt) | 0, Q = Q + Math.imul($, ke) | 0;
    let D0 = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (D0 >>> 26) | 0, D0 &= 67108863, j = Math.imul(ae, ct), R = Math.imul(ae, Xe), R = R + Math.imul(de, ct) | 0, Q = Math.imul(de, Xe), j = j + Math.imul(J, bt) | 0, R = R + Math.imul(J, Ge) | 0, R = R + Math.imul(X, bt) | 0, Q = Q + Math.imul(X, Ge) | 0, j = j + Math.imul(S, pt) | 0, R = R + Math.imul(S, ke) | 0, R = R + Math.imul(M, pt) | 0, Q = Q + Math.imul(M, ke) | 0, j = j + Math.imul(O, ot) | 0, R = R + Math.imul(O, St) | 0, R = R + Math.imul($, ot) | 0, Q = Q + Math.imul($, St) | 0;
    let P = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (P >>> 26) | 0, P &= 67108863, j = Math.imul(Be, ct), R = Math.imul(Be, Xe), R = R + Math.imul(ve, ct) | 0, Q = Math.imul(ve, Xe), j = j + Math.imul(ae, bt) | 0, R = R + Math.imul(ae, Ge) | 0, R = R + Math.imul(de, bt) | 0, Q = Q + Math.imul(de, Ge) | 0, j = j + Math.imul(J, pt) | 0, R = R + Math.imul(J, ke) | 0, R = R + Math.imul(X, pt) | 0, Q = Q + Math.imul(X, ke) | 0, j = j + Math.imul(S, ot) | 0, R = R + Math.imul(S, St) | 0, R = R + Math.imul(M, ot) | 0, Q = Q + Math.imul(M, St) | 0, j = j + Math.imul(O, Bt) | 0, R = R + Math.imul(O, vt) | 0, R = R + Math.imul($, Bt) | 0, Q = Q + Math.imul($, vt) | 0;
    let f = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (f >>> 26) | 0, f &= 67108863, j = Math.imul(Ie, ct), R = Math.imul(Ie, Xe), R = R + Math.imul(Re, ct) | 0, Q = Math.imul(Re, Xe), j = j + Math.imul(Be, bt) | 0, R = R + Math.imul(Be, Ge) | 0, R = R + Math.imul(ve, bt) | 0, Q = Q + Math.imul(ve, Ge) | 0, j = j + Math.imul(ae, pt) | 0, R = R + Math.imul(ae, ke) | 0, R = R + Math.imul(de, pt) | 0, Q = Q + Math.imul(de, ke) | 0, j = j + Math.imul(J, ot) | 0, R = R + Math.imul(J, St) | 0, R = R + Math.imul(X, ot) | 0, Q = Q + Math.imul(X, St) | 0, j = j + Math.imul(S, Bt) | 0, R = R + Math.imul(S, vt) | 0, R = R + Math.imul(M, Bt) | 0, Q = Q + Math.imul(M, vt) | 0, j = j + Math.imul(O, Et) | 0, R = R + Math.imul(O, It) | 0, R = R + Math.imul($, Et) | 0, Q = Q + Math.imul($, It) | 0;
    let m = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (m >>> 26) | 0, m &= 67108863, j = Math.imul(Ye, ct), R = Math.imul(Ye, Xe), R = R + Math.imul(Fe, ct) | 0, Q = Math.imul(Fe, Xe), j = j + Math.imul(Ie, bt) | 0, R = R + Math.imul(Ie, Ge) | 0, R = R + Math.imul(Re, bt) | 0, Q = Q + Math.imul(Re, Ge) | 0, j = j + Math.imul(Be, pt) | 0, R = R + Math.imul(Be, ke) | 0, R = R + Math.imul(ve, pt) | 0, Q = Q + Math.imul(ve, ke) | 0, j = j + Math.imul(ae, ot) | 0, R = R + Math.imul(ae, St) | 0, R = R + Math.imul(de, ot) | 0, Q = Q + Math.imul(de, St) | 0, j = j + Math.imul(J, Bt) | 0, R = R + Math.imul(J, vt) | 0, R = R + Math.imul(X, Bt) | 0, Q = Q + Math.imul(X, vt) | 0, j = j + Math.imul(S, Et) | 0, R = R + Math.imul(S, It) | 0, R = R + Math.imul(M, Et) | 0, Q = Q + Math.imul(M, It) | 0, j = j + Math.imul(O, At) | 0, R = R + Math.imul(O, _t) | 0, R = R + Math.imul($, At) | 0, Q = Q + Math.imul($, _t) | 0;
    let D = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (D >>> 26) | 0, D &= 67108863, j = Math.imul(He, ct), R = Math.imul(He, Xe), R = R + Math.imul(et, ct) | 0, Q = Math.imul(et, Xe), j = j + Math.imul(Ye, bt) | 0, R = R + Math.imul(Ye, Ge) | 0, R = R + Math.imul(Fe, bt) | 0, Q = Q + Math.imul(Fe, Ge) | 0, j = j + Math.imul(Ie, pt) | 0, R = R + Math.imul(Ie, ke) | 0, R = R + Math.imul(Re, pt) | 0, Q = Q + Math.imul(Re, ke) | 0, j = j + Math.imul(Be, ot) | 0, R = R + Math.imul(Be, St) | 0, R = R + Math.imul(ve, ot) | 0, Q = Q + Math.imul(ve, St) | 0, j = j + Math.imul(ae, Bt) | 0, R = R + Math.imul(ae, vt) | 0, R = R + Math.imul(de, Bt) | 0, Q = Q + Math.imul(de, vt) | 0, j = j + Math.imul(J, Et) | 0, R = R + Math.imul(J, It) | 0, R = R + Math.imul(X, Et) | 0, Q = Q + Math.imul(X, It) | 0, j = j + Math.imul(S, At) | 0, R = R + Math.imul(S, _t) | 0, R = R + Math.imul(M, At) | 0, Q = Q + Math.imul(M, _t) | 0, j = j + Math.imul(O, Mt) | 0, R = R + Math.imul(O, lt) | 0, R = R + Math.imul($, Mt) | 0, Q = Q + Math.imul($, lt) | 0;
    let ee = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (ee >>> 26) | 0, ee &= 67108863, j = Math.imul(tt, ct), R = Math.imul(tt, Xe), R = R + Math.imul(it, ct) | 0, Q = Math.imul(it, Xe), j = j + Math.imul(He, bt) | 0, R = R + Math.imul(He, Ge) | 0, R = R + Math.imul(et, bt) | 0, Q = Q + Math.imul(et, Ge) | 0, j = j + Math.imul(Ye, pt) | 0, R = R + Math.imul(Ye, ke) | 0, R = R + Math.imul(Fe, pt) | 0, Q = Q + Math.imul(Fe, ke) | 0, j = j + Math.imul(Ie, ot) | 0, R = R + Math.imul(Ie, St) | 0, R = R + Math.imul(Re, ot) | 0, Q = Q + Math.imul(Re, St) | 0, j = j + Math.imul(Be, Bt) | 0, R = R + Math.imul(Be, vt) | 0, R = R + Math.imul(ve, Bt) | 0, Q = Q + Math.imul(ve, vt) | 0, j = j + Math.imul(ae, Et) | 0, R = R + Math.imul(ae, It) | 0, R = R + Math.imul(de, Et) | 0, Q = Q + Math.imul(de, It) | 0, j = j + Math.imul(J, At) | 0, R = R + Math.imul(J, _t) | 0, R = R + Math.imul(X, At) | 0, Q = Q + Math.imul(X, _t) | 0, j = j + Math.imul(S, Mt) | 0, R = R + Math.imul(S, lt) | 0, R = R + Math.imul(M, Mt) | 0, Q = Q + Math.imul(M, lt) | 0, j = j + Math.imul(O, at) | 0, R = R + Math.imul(O, nt) | 0, R = R + Math.imul($, at) | 0, Q = Q + Math.imul($, nt) | 0;
    let te = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (te >>> 26) | 0, te &= 67108863, j = Math.imul(Qe, ct), R = Math.imul(Qe, Xe), R = R + Math.imul(st, ct) | 0, Q = Math.imul(st, Xe), j = j + Math.imul(tt, bt) | 0, R = R + Math.imul(tt, Ge) | 0, R = R + Math.imul(it, bt) | 0, Q = Q + Math.imul(it, Ge) | 0, j = j + Math.imul(He, pt) | 0, R = R + Math.imul(He, ke) | 0, R = R + Math.imul(et, pt) | 0, Q = Q + Math.imul(et, ke) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Ye, St) | 0, R = R + Math.imul(Fe, ot) | 0, Q = Q + Math.imul(Fe, St) | 0, j = j + Math.imul(Ie, Bt) | 0, R = R + Math.imul(Ie, vt) | 0, R = R + Math.imul(Re, Bt) | 0, Q = Q + Math.imul(Re, vt) | 0, j = j + Math.imul(Be, Et) | 0, R = R + Math.imul(Be, It) | 0, R = R + Math.imul(ve, Et) | 0, Q = Q + Math.imul(ve, It) | 0, j = j + Math.imul(ae, At) | 0, R = R + Math.imul(ae, _t) | 0, R = R + Math.imul(de, At) | 0, Q = Q + Math.imul(de, _t) | 0, j = j + Math.imul(J, Mt) | 0, R = R + Math.imul(J, lt) | 0, R = R + Math.imul(X, Mt) | 0, Q = Q + Math.imul(X, lt) | 0, j = j + Math.imul(S, at) | 0, R = R + Math.imul(S, nt) | 0, R = R + Math.imul(M, at) | 0, Q = Q + Math.imul(M, nt) | 0, j = j + Math.imul(O, Nt) | 0, R = R + Math.imul(O, Ot) | 0, R = R + Math.imul($, Nt) | 0, Q = Q + Math.imul($, Ot) | 0;
    let se = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, j = Math.imul(Qe, bt), R = Math.imul(Qe, Ge), R = R + Math.imul(st, bt) | 0, Q = Math.imul(st, Ge), j = j + Math.imul(tt, pt) | 0, R = R + Math.imul(tt, ke) | 0, R = R + Math.imul(it, pt) | 0, Q = Q + Math.imul(it, ke) | 0, j = j + Math.imul(He, ot) | 0, R = R + Math.imul(He, St) | 0, R = R + Math.imul(et, ot) | 0, Q = Q + Math.imul(et, St) | 0, j = j + Math.imul(Ye, Bt) | 0, R = R + Math.imul(Ye, vt) | 0, R = R + Math.imul(Fe, Bt) | 0, Q = Q + Math.imul(Fe, vt) | 0, j = j + Math.imul(Ie, Et) | 0, R = R + Math.imul(Ie, It) | 0, R = R + Math.imul(Re, Et) | 0, Q = Q + Math.imul(Re, It) | 0, j = j + Math.imul(Be, At) | 0, R = R + Math.imul(Be, _t) | 0, R = R + Math.imul(ve, At) | 0, Q = Q + Math.imul(ve, _t) | 0, j = j + Math.imul(ae, Mt) | 0, R = R + Math.imul(ae, lt) | 0, R = R + Math.imul(de, Mt) | 0, Q = Q + Math.imul(de, lt) | 0, j = j + Math.imul(J, at) | 0, R = R + Math.imul(J, nt) | 0, R = R + Math.imul(X, at) | 0, Q = Q + Math.imul(X, nt) | 0, j = j + Math.imul(S, Nt) | 0, R = R + Math.imul(S, Ot) | 0, R = R + Math.imul(M, Nt) | 0, Q = Q + Math.imul(M, Ot) | 0;
    let ue = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (ue >>> 26) | 0, ue &= 67108863, j = Math.imul(Qe, pt), R = Math.imul(Qe, ke), R = R + Math.imul(st, pt) | 0, Q = Math.imul(st, ke), j = j + Math.imul(tt, ot) | 0, R = R + Math.imul(tt, St) | 0, R = R + Math.imul(it, ot) | 0, Q = Q + Math.imul(it, St) | 0, j = j + Math.imul(He, Bt) | 0, R = R + Math.imul(He, vt) | 0, R = R + Math.imul(et, Bt) | 0, Q = Q + Math.imul(et, vt) | 0, j = j + Math.imul(Ye, Et) | 0, R = R + Math.imul(Ye, It) | 0, R = R + Math.imul(Fe, Et) | 0, Q = Q + Math.imul(Fe, It) | 0, j = j + Math.imul(Ie, At) | 0, R = R + Math.imul(Ie, _t) | 0, R = R + Math.imul(Re, At) | 0, Q = Q + Math.imul(Re, _t) | 0, j = j + Math.imul(Be, Mt) | 0, R = R + Math.imul(Be, lt) | 0, R = R + Math.imul(ve, Mt) | 0, Q = Q + Math.imul(ve, lt) | 0, j = j + Math.imul(ae, at) | 0, R = R + Math.imul(ae, nt) | 0, R = R + Math.imul(de, at) | 0, Q = Q + Math.imul(de, nt) | 0, j = j + Math.imul(J, Nt) | 0, R = R + Math.imul(J, Ot) | 0, R = R + Math.imul(X, Nt) | 0, Q = Q + Math.imul(X, Ot) | 0;
    let be = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, j = Math.imul(Qe, ot), R = Math.imul(Qe, St), R = R + Math.imul(st, ot) | 0, Q = Math.imul(st, St), j = j + Math.imul(tt, Bt) | 0, R = R + Math.imul(tt, vt) | 0, R = R + Math.imul(it, Bt) | 0, Q = Q + Math.imul(it, vt) | 0, j = j + Math.imul(He, Et) | 0, R = R + Math.imul(He, It) | 0, R = R + Math.imul(et, Et) | 0, Q = Q + Math.imul(et, It) | 0, j = j + Math.imul(Ye, At) | 0, R = R + Math.imul(Ye, _t) | 0, R = R + Math.imul(Fe, At) | 0, Q = Q + Math.imul(Fe, _t) | 0, j = j + Math.imul(Ie, Mt) | 0, R = R + Math.imul(Ie, lt) | 0, R = R + Math.imul(Re, Mt) | 0, Q = Q + Math.imul(Re, lt) | 0, j = j + Math.imul(Be, at) | 0, R = R + Math.imul(Be, nt) | 0, R = R + Math.imul(ve, at) | 0, Q = Q + Math.imul(ve, nt) | 0, j = j + Math.imul(ae, Nt) | 0, R = R + Math.imul(ae, Ot) | 0, R = R + Math.imul(de, Nt) | 0, Q = Q + Math.imul(de, Ot) | 0;
    let Ae = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, j = Math.imul(Qe, Bt), R = Math.imul(Qe, vt), R = R + Math.imul(st, Bt) | 0, Q = Math.imul(st, vt), j = j + Math.imul(tt, Et) | 0, R = R + Math.imul(tt, It) | 0, R = R + Math.imul(it, Et) | 0, Q = Q + Math.imul(it, It) | 0, j = j + Math.imul(He, At) | 0, R = R + Math.imul(He, _t) | 0, R = R + Math.imul(et, At) | 0, Q = Q + Math.imul(et, _t) | 0, j = j + Math.imul(Ye, Mt) | 0, R = R + Math.imul(Ye, lt) | 0, R = R + Math.imul(Fe, Mt) | 0, Q = Q + Math.imul(Fe, lt) | 0, j = j + Math.imul(Ie, at) | 0, R = R + Math.imul(Ie, nt) | 0, R = R + Math.imul(Re, at) | 0, Q = Q + Math.imul(Re, nt) | 0, j = j + Math.imul(Be, Nt) | 0, R = R + Math.imul(Be, Ot) | 0, R = R + Math.imul(ve, Nt) | 0, Q = Q + Math.imul(ve, Ot) | 0;
    let $e = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, j = Math.imul(Qe, Et), R = Math.imul(Qe, It), R = R + Math.imul(st, Et) | 0, Q = Math.imul(st, It), j = j + Math.imul(tt, At) | 0, R = R + Math.imul(tt, _t) | 0, R = R + Math.imul(it, At) | 0, Q = Q + Math.imul(it, _t) | 0, j = j + Math.imul(He, Mt) | 0, R = R + Math.imul(He, lt) | 0, R = R + Math.imul(et, Mt) | 0, Q = Q + Math.imul(et, lt) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Ye, nt) | 0, R = R + Math.imul(Fe, at) | 0, Q = Q + Math.imul(Fe, nt) | 0, j = j + Math.imul(Ie, Nt) | 0, R = R + Math.imul(Ie, Ot) | 0, R = R + Math.imul(Re, Nt) | 0, Q = Q + Math.imul(Re, Ot) | 0;
    let Rt = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, j = Math.imul(Qe, At), R = Math.imul(Qe, _t), R = R + Math.imul(st, At) | 0, Q = Math.imul(st, _t), j = j + Math.imul(tt, Mt) | 0, R = R + Math.imul(tt, lt) | 0, R = R + Math.imul(it, Mt) | 0, Q = Q + Math.imul(it, lt) | 0, j = j + Math.imul(He, at) | 0, R = R + Math.imul(He, nt) | 0, R = R + Math.imul(et, at) | 0, Q = Q + Math.imul(et, nt) | 0, j = j + Math.imul(Ye, Nt) | 0, R = R + Math.imul(Ye, Ot) | 0, R = R + Math.imul(Fe, Nt) | 0, Q = Q + Math.imul(Fe, Ot) | 0;
    let Jt = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, j = Math.imul(Qe, Mt), R = Math.imul(Qe, lt), R = R + Math.imul(st, Mt) | 0, Q = Math.imul(st, lt), j = j + Math.imul(tt, at) | 0, R = R + Math.imul(tt, nt) | 0, R = R + Math.imul(it, at) | 0, Q = Q + Math.imul(it, nt) | 0, j = j + Math.imul(He, Nt) | 0, R = R + Math.imul(He, Ot) | 0, R = R + Math.imul(et, Nt) | 0, Q = Q + Math.imul(et, Ot) | 0;
    let mr = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (mr >>> 26) | 0, mr &= 67108863, j = Math.imul(Qe, at), R = Math.imul(Qe, nt), R = R + Math.imul(st, at) | 0, Q = Math.imul(st, nt), j = j + Math.imul(tt, Nt) | 0, R = R + Math.imul(tt, Ot) | 0, R = R + Math.imul(it, Nt) | 0, Q = Q + Math.imul(it, Ot) | 0;
    let Xr = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    Ke = (Q + (R >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, j = Math.imul(Qe, Nt), R = Math.imul(Qe, Ot), R = R + Math.imul(st, Nt) | 0, Q = Math.imul(st, Ot);
    let si = (Ke + j | 0) + ((R & 8191) << 13) | 0;
    return Ke = (Q + (R >>> 13) | 0) + (si >>> 26) | 0, si &= 67108863, C[0] = C0, C[1] = T0, C[2] = D0, C[3] = P, C[4] = f, C[5] = m, C[6] = D, C[7] = ee, C[8] = te, C[9] = se, C[10] = ue, C[11] = be, C[12] = Ae, C[13] = $e, C[14] = Rt, C[15] = Jt, C[16] = mr, C[17] = Xr, C[18] = si, Ke !== 0 && (C[19] = Ke, a.length += 1), a;
  }
  return Math.imul || (L = Se), h.Red = z, Rd = h, Rd;
}
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
(function(r) {
  if (process.env.BCRYPTO_FORCE_BIGINT || process.env.NODE_BACKEND !== "js")
    try {
      if (r.exports = FE(), !r.exports.native)
        throw new Error();
    } catch {
      r.exports = q1();
    }
  else
    r.exports = q1();
})(X9);
var Z9 = X9.exports;
/*!
 * consensus.js - consensus constants and helpers for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  const e = Ar, t = Z9;
  r.COIN = 1e8, r.MAX_MONEY = 21e6 * r.COIN, r.BASE_REWARD = 50 * r.COIN, r.HALF_REWARD = Math.floor(r.BASE_REWARD / 2), r.MAX_BLOCK_SIZE = 1e6, r.MAX_RAW_BLOCK_SIZE = 4e6, r.MAX_BLOCK_WEIGHT = 4e6, r.MAX_BLOCK_SIGOPS = 1e6 / 50, r.MAX_BLOCK_SIGOPS_COST = 8e4, r.MEDIAN_TIMESPAN = 11, r.VERSION_TOP_BITS = 536870912, r.VERSION_TOP_MASK = 3758096384, r.COINBASE_MATURITY = 100, r.WITNESS_SCALE_FACTOR = 4, r.LOCKTIME_THRESHOLD = 5e8, r.SEQUENCE_DISABLE_FLAG = 1 << 31 >>> 0, r.SEQUENCE_TYPE_FLAG = 1 << 22, r.SEQUENCE_GRANULARITY = 9, r.SEQUENCE_MASK = 65535, r.MAX_SCRIPT_SIZE = 1e4, r.MAX_SCRIPT_STACK = 1e3, r.MAX_SCRIPT_PUSH = 520, r.MAX_SCRIPT_OPS = 201, r.MAX_MULTISIG_PUBKEYS = 20, r.BIP16_TIME = 1333238400, r.ZERO_HASH = Buffer.alloc(32, 0), r.fromCompact = function(n) {
    if (n === 0)
      return new t(0);
    const c = n >>> 24, o = n >>> 23 & 1;
    let d = n & 8388607, l;
    return c <= 3 ? (d >>>= 8 * (3 - c), l = new t(d)) : (l = new t(d), l.iushln(8 * (c - 3))), o && l.ineg(), l;
  }, r.toCompact = function(n) {
    if (n.isZero())
      return 0;
    let c = n.byteLength(), o;
    c <= 3 ? (o = n.toNumber(), o <<= 8 * (3 - c)) : o = n.ushrn(8 * (c - 3)).toNumber(), o & 8388608 && (o >>= 8, c++);
    let d = c << 24 | o;
    return n.isNeg() && (d |= 8388608), d >>>= 0, d;
  }, r.verifyPOW = function(n, c) {
    const o = r.fromCompact(c);
    return !(o.isNeg() || o.isZero() || o.bitLength() > 256 || new t(n, "le").gt(o));
  }, r.getReward = function(n, c) {
    e(n >= 0, "Bad height for reward.");
    const o = Math.floor(n / c);
    return o >= 33 ? 0 : o === 0 ? r.BASE_REWARD : r.HALF_REWARD >>> o - 1;
  }, r.hasBit = function(n, c) {
    const o = r.VERSION_TOP_MASK, d = r.VERSION_TOP_BITS, l = (n & o) >>> 0, h = 1 << c;
    return l === d && (n & h) !== 0;
  };
})(ri);
var nc = {};
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
 */
const Uf = Jr, VE = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", W9 = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  -1,
  17,
  18,
  19,
  20,
  21,
  -1,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  -1,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  -1,
  -1,
  -1,
  -1,
  -1
], j9 = Buffer.alloc(128);
function GE(r) {
  Uf(Buffer.isBuffer(r));
  let e = 0, t = 0;
  for (; t < r.length && r[t] === 0; t++)
    e += 1;
  const i = ((r.length - e) * 138 / 100 | 0) + 1, n = i <= 128 ? j9.fill(0) : Buffer.alloc(i);
  let c = 0;
  for (; t < r.length; t++) {
    let d = r[t], l = 0;
    for (let h = i - 1; h >= 0 && !(d === 0 && l >= c); h--, l++)
      d += n[h] * 256, n[h] = d % 58, d = d / 58 | 0;
    Uf(d === 0), c = l;
  }
  for (t = i - c; t < i && n[t] === 0; )
    t += 1;
  let o = "";
  for (let d = 0; d < e; d++)
    o += "1";
  for (; t < i; )
    o += VE[n[t++]];
  return o;
}
function YE(r) {
  Uf(typeof r == "string");
  let e = 0, t = 0;
  for (; t < r.length && r[t] === "1"; t++)
    e += 1;
  const i = (r.length * 733 / 1e3 | 0) + 1, n = i <= 128 ? j9.fill(0) : Buffer.alloc(i);
  let c = 0;
  for (; t < r.length; t++) {
    const l = r.charCodeAt(t);
    if (l & 65408)
      throw new Error("Invalid base58 string.");
    const h = W9[l];
    if (h === -1)
      throw new Error("Invalid base58 string.");
    let x = h, b = 0;
    for (let g = i - 1; g >= 0 && !(x === 0 && b >= c); g--, b++)
      x += n[g] * 58, n[g] = x, x >>>= 8;
    Uf(x === 0), c = b;
  }
  t = i - c;
  const o = Buffer.alloc(e + (i - t));
  let d;
  for (d = 0; d < e; d++)
    o[d] = 0;
  for (; t < i; )
    o[d++] = n[t++];
  return o;
}
function JE(r) {
  Uf(typeof r == "string");
  for (let e = 0; e < r.length; e++) {
    const t = r.charCodeAt(e);
    if (t & 65408 || W9[t] === -1)
      return !1;
  }
  return !0;
}
nc.native = 0;
nc.encode = GE;
nc.decode = YE;
nc.test = JE;
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var XE = nc;
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bech32:
 *   Copyright (c) 2017, Pieter Wuille (MIT License).
 *   https://github.com/sipa/bech32
 *
 * Resources:
 *   https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 *   https://github.com/sipa/bech32/blob/master/ref/c/segwit_addr.c
 *   https://github.com/bitcoin/bitcoin/blob/master/src/bech32.cpp
 */
const gr = Jr, ZE = Buffer.alloc(65), i4 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", WE = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  15,
  -1,
  10,
  17,
  21,
  20,
  26,
  30,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  29,
  -1,
  24,
  13,
  25,
  9,
  8,
  23,
  -1,
  18,
  22,
  31,
  27,
  19,
  -1,
  1,
  0,
  3,
  16,
  11,
  28,
  12,
  14,
  6,
  4,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  29,
  -1,
  24,
  13,
  25,
  9,
  8,
  23,
  -1,
  18,
  22,
  31,
  27,
  19,
  -1,
  1,
  0,
  3,
  16,
  11,
  28,
  12,
  14,
  6,
  4,
  2,
  -1,
  -1,
  -1,
  -1,
  -1
];
let jE = class {
  constructor(e) {
    gr(e >>> 0 === e), this.checksum = e, this.native = 0;
  }
  /**
   * Update checksum.
   * @ignore
   * @param {Number} c
   * @returns {Number}
   */
  polymod(e) {
    const t = e >>> 25;
    return (e & 33554431) << 5 ^ 996825010 & -(t >> 0 & 1) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1);
  }
  /**
   * Encode hrp and data as a bech32 string.
   * @param {String} hrp
   * @param {Buffer} data
   * @returns {String}
   */
  serialize(e, t) {
    if (gr(typeof e == "string"), gr(Buffer.isBuffer(t)), e.length === 0 || e.length > 83)
      throw new Error("Invalid bech32 human-readable part.");
    if (e.length + 1 + t.length + 6 > 90)
      throw new Error("Invalid bech32 data length.");
    let i = "", n = 1, c;
    for (c = 0; c < e.length; c++) {
      const o = e.charCodeAt(c);
      if (o < 33 || o > 126)
        throw new Error("Invalid bech32 character.");
      if (o >= 65 && o <= 90)
        throw new Error("Invalid bech32 character.");
      n = this.polymod(n) ^ o >> 5;
    }
    n = this.polymod(n);
    for (let o = 0; o < e.length; o++) {
      const d = e.charCodeAt(o);
      n = this.polymod(n) ^ d & 31, i += e[o];
    }
    i += "1";
    for (let o = 0; o < t.length; o++) {
      const d = t[o];
      if (d >> 5)
        throw new Error("Invalid bech32 value.");
      n = this.polymod(n) ^ d, i += i4[d];
    }
    for (let o = 0; o < 6; o++)
      n = this.polymod(n);
    n ^= this.checksum;
    for (let o = 0; o < 6; o++)
      i += i4[n >>> (5 - o) * 5 & 31];
    return i;
  }
  /**
   * Decode a bech32 string.
   * @param {String} str
   * @returns {Array} [hrp, data]
   */
  deserialize(e) {
    if (gr(typeof e == "string"), e.length < 8 || e.length > 90)
      throw new Error("Invalid bech32 string length.");
    let t = !1, i = !1, n = 0;
    for (let x = 0; x < e.length; x++) {
      const b = e.charCodeAt(x);
      if (b < 33 || b > 126)
        throw new Error("Invalid bech32 character.");
      b >= 97 && b <= 122 ? t = !0 : b >= 65 && b <= 90 ? i = !0 : b === 49 && (n = x);
    }
    if (n === 0)
      throw new Error("Invalid bech32 human-readable part.");
    const c = e.length - (n + 1);
    if (c < 6)
      throw new Error("Invalid bech32 data length.");
    if (t && i)
      throw new Error("Invalid bech32 casing.");
    let o = 1, d = "";
    for (let x = 0; x < n; x++) {
      let b = e.charCodeAt(x);
      b >= 65 && b <= 90 && (b += 32), o = this.polymod(o) ^ b >> 5, d += String.fromCharCode(b);
    }
    o = this.polymod(o);
    for (let x = 0; x < n; x++)
      o = this.polymod(o) ^ e.charCodeAt(x) & 31;
    const l = Buffer.alloc(c - 6);
    let h = 0;
    for (let x = n + 1; x < e.length; x++) {
      const b = WE[e.charCodeAt(x)];
      if (b === -1)
        throw new Error("Invalid bech32 character.");
      o = this.polymod(o) ^ b, x < e.length - 6 && (l[h++] = b);
    }
    if (o !== this.checksum)
      throw new Error("Invalid bech32 checksum.");
    return gr(h === l.length), [d, l];
  }
  /**
   * Test whether a string is a bech32 string.
   * @param {String} str
   * @returns {Boolean}
   */
  is(e) {
    gr(typeof e == "string");
    try {
      return this.deserialize(e), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Convert serialized data to another base.
   * @param {Buffer} dst
   * @param {Number} dstoff
   * @param {Number} dstbits
   * @param {Buffer} src
   * @param {Number} srcoff
   * @param {Number} srcbits
   * @param {Boolean} pad
   * @returns {Buffer}
   */
  convert(e, t, i, n, c, o, d) {
    gr(Buffer.isBuffer(e)), gr(t >>> 0 === t), gr(i >>> 0 === i), gr(Buffer.isBuffer(n)), gr(c >>> 0 === c), gr(o >>> 0 === o), gr(typeof d == "boolean"), gr(i >= 1 && i <= 8), gr(o >= 1 && o <= 8);
    const l = (1 << i) - 1;
    let h = 0, x = 0, b = c, g = t;
    for (; b < n.length; b++)
      for (h = h << o | n[b], x += o; x >= i; )
        x -= i, e[g++] = h >>> x & l;
    const w = i - x;
    if (d)
      x && (e[g++] = h << w & l);
    else if (h << w & l || x >= o)
      throw new Error("Invalid bits.");
    return gr(g <= e.length), e.slice(0, g);
  }
  /**
   * Calculate size required for bit conversion.
   * @param {Number} len
   * @param {Number} srcbits
   * @param {Number} dstbits
   * @param {Boolean} pad
   * @returns {Number}
   */
  convertSize(e, t, i, n) {
    return gr(e >>> 0 === e), gr(t >>> 0 === t), gr(i >>> 0 === i), gr(typeof n == "boolean"), gr(t >= 1 && t <= 8), gr(i >= 1 && i <= 8), (e * t + (i - 1) * (n | 0)) / i >>> 0;
  }
  /**
   * Convert serialized data to another base.
   * @param {Buffer} data
   * @param {Number} srcbits
   * @param {Number} dstbits
   * @param {Boolean} pad
   * @returns {Buffer}
   */
  convertBits(e, t, i, n) {
    gr(Buffer.isBuffer(e));
    const c = this.convertSize(e.length, t, i, n), o = Buffer.alloc(c);
    return this.convert(o, 0, i, e, 0, t, n);
  }
  /**
   * Serialize data to bech32 address.
   * @param {String} hrp
   * @param {Number} version
   * @param {Buffer} hash
   * @returns {String}
   */
  encode(e, t, i) {
    if (gr(typeof e == "string"), gr(t >>> 0 === t), gr(Buffer.isBuffer(i)), t > 31)
      throw new Error("Invalid bech32 version.");
    if (i.length < 2 || i.length > 40)
      throw new Error("Invalid bech32 data length.");
    const n = ZE;
    n[0] = t;
    const c = this.convert(n, 1, 5, i, 0, 8, !0);
    return this.serialize(e, c);
  }
  /**
   * Deserialize data from bech32 address.
   * @param {String} addr
   * @returns {Array}
   */
  decode(e) {
    const [t, i] = this.deserialize(e);
    if (i.length === 0 || i.length > 65)
      throw new Error("Invalid bech32 data length.");
    const n = i[0];
    if (n > 31)
      throw new Error("Invalid bech32 version.");
    const c = i, o = this.convert(c, 0, 8, i, 1, 5, !1);
    if (o.length < 2 || o.length > 40)
      throw new Error("Invalid bech32 data length.");
    return [t, n, o];
  }
  /**
   * Test whether a string is a bech32 string.
   * @param {String} addr
   * @returns {Boolean}
   */
  test(e) {
    gr(typeof e == "string");
    try {
      return this.decode(e), !0;
    } catch {
      return !1;
    }
  }
};
var Q9 = jE;
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const QE = Q9;
var eI = new QE(1), yc = { exports: {} }, Cs = {};
/*!
 * random-openssl.js - random number generator for bcrypto
 * Copyright (c) 2014-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 */
var s4;
function tI() {
  if (s4)
    return Cs;
  s4 = 1;
  const r = Jr, e = M0, t = e.randomFillSync.bind(e), i = new Uint32Array(16);
  let n = 0;
  function c(b) {
    r(b >>> 0 === b);
    const g = Buffer.alloc(b);
    return t(g, 0, b), g;
  }
  function o(b, g, w) {
    return r(Buffer.isBuffer(b)), g == null && (g = 0), r(g >>> 0 === g), w == null && (w = b.length - g), r(w >>> 0 === w), r(g + w <= b.length), t(b, g, w), b;
  }
  function d() {
    return n & 15 || (x(i), n = 0), i[n++];
  }
  function l(b, g) {
    r(b >>> 0 === b), r(g >>> 0 === g), r(g >= b);
    const w = g - b;
    if (w === 0)
      return b;
    const I = -w >>> 0;
    let B, y;
    do
      B = d(), y = B % w;
    while (B - y > I);
    return y + b;
  }
  let h = null;
  function x(b) {
    if (r(b != null && typeof b == "object"), r(b.buffer instanceof ArrayBuffer), h === null)
      try {
        t(new Uint32Array(1)), h = !0;
      } catch {
        h = !1;
      }
    h || (b = Buffer.from(
      b.buffer,
      b.byteOffset,
      b.byteLength
    )), t(b);
  }
  return Cs.native = 1, Cs.randomBytes = c, Cs.randomFill = o, Cs.randomInt = d, Cs.randomRange = l, Cs;
}
var bs = {};
/*!
 * loady.js - dynamic loader for node.js
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/loady
 */
var kd, n4;
function ep() {
  if (n4)
    return kd;
  n4 = 1;
  const r = M0, e = M0, t = [
    "Debug",
    "Release",
    "MinSizeRel",
    "RelWithDebInfo"
  ];
  function i(h, x) {
    if (typeof h != "string")
      throw new TypeError('"name" must be a string.');
    if (typeof x != "string")
      throw new TypeError('"root" must be a string.');
    if (!r.existsSync)
      throw l(h);
    e.extname(h) !== ".node" && (h += ".node"), x = o(x);
    const b = `${h}\0${x}`;
    if (i.cache[b])
      return i.cache[b];
    if (process.pkg && !c(h) && (h = e.resolve(process.execPath, "..", h)), c(h)) {
      const g = e.resolve(x, h);
      if (!r.existsSync(g))
        throw l(g);
      const w = d(g);
      return i.cache[b] = w, w;
    }
    for (; ; ) {
      const g = e.join(x, "build");
      if (r.existsSync(g)) {
        const I = [e.join(g, h)];
        for (const B of t)
          I.push(e.join(g, B, h));
        for (const B of I)
          if (r.existsSync(B)) {
            const y = d(B);
            return i.cache[b] = y, y;
          }
      }
      const w = e.dirname(x);
      if (w === x)
        break;
      x = w;
    }
    throw l(h);
  }
  i.cache = /* @__PURE__ */ Object.create(null);
  function n(h, x) {
    const b = i(h, x);
    if (n.cache[b])
      return n.cache[b];
    if (!process.dlopen)
      throw new Error(`${h}: cannot open shared object file`);
    const g = { exports: {} };
    return process.dlopen(g, b), n.cache[b] = g.exports, g.exports;
  }
  n.cache = /* @__PURE__ */ Object.create(null);
  function c(h) {
    return process.platform === "win32" && (h = h.replace("\\", "/")), h[0] === "/" || h.startsWith("./") || h.startsWith("../");
  }
  function o(h) {
    if (h.indexOf("file:") === 0) {
      const x = M0;
      if (!x.fileURLToPath)
        throw new Error("File URLs are unsupported on this platform.");
      return e.resolve(x.fileURLToPath(h), "..");
    }
    return e.resolve(h);
  }
  function d(h) {
    try {
      return r.realpathSync(h);
    } catch {
      return e.resolve(h);
    }
  }
  function l(h) {
    const x = new Error(`Cannot find module '${h}'`);
    throw x.code = "MODULE_NOT_FOUND", x;
  }
  return n.load = n, n.resolve = i, kd = n, kd;
}
/*!
 * random-torsion.js - random number generator for bcrypto
 * Copyright (c) 2014-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var f4;
function rI() {
  if (f4)
    return bs;
  f4 = 1;
  const r = Jr, e = ep()("bcrypto", __dirname);
  function t(d) {
    r(d >>> 0 === d);
    const l = Buffer.alloc(d);
    return e.getrandom(l, 0, d);
  }
  function i(d, l, h) {
    return r(Buffer.isBuffer(d)), l == null && (l = 0), r(l >>> 0 === l), h == null && (h = d.length - l), r(h >>> 0 === h), e.getrandom(d, l, h);
  }
  function n() {
    return e.random();
  }
  function c(d, l) {
    return r(d >>> 0 === d), r(l >>> 0 === l), r(l >= d), d + e.uniform(l - d);
  }
  function o(d) {
    r(d >>> 0 === d);
    const l = Buffer.alloc(d);
    return e.getentropy(l, 0, d);
  }
  return bs.native = 2, bs.randomBytes = t, bs.randomFill = i, bs.randomInt = n, bs.randomRange = c, bs._getEntropy = o, bs;
}
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var c4;
function iI() {
  return c4 || (c4 = 1, process.env.BCRYPTO_FORCE_TORSION !== "1" ? yc.exports = tI() : yc.exports = rI()), yc.exports;
}
/*!
 * binding.js - bindings for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var qd, o4;
function sI() {
  if (o4)
    return qd;
  o4 = 1;
  const r = Jr, e = iI(), t = ep()("bcrypto", __dirname);
  t.hashes = {
    __proto__: null,
    NONE: 0,
    BLAKE2B160: 1,
    BLAKE2B256: 2,
    BLAKE2B384: 3,
    BLAKE2B512: 4,
    BLAKE2S128: 5,
    BLAKE2S160: 6,
    BLAKE2S224: 7,
    BLAKE2S256: 8,
    GOST94: 9,
    HASH160: 10,
    HASH256: 11,
    KECCAK224: 12,
    KECCAK256: 13,
    KECCAK384: 14,
    KECCAK512: 15,
    MD2: 16,
    MD4: 17,
    MD5: 18,
    MD5SHA1: 19,
    RIPEMD160: 20,
    SHA1: 21,
    SHA224: 22,
    SHA256: 23,
    SHA384: 24,
    SHA512: 25,
    SHA3_224: 26,
    SHA3_256: 27,
    SHA3_384: 28,
    SHA3_512: 29,
    SHAKE128: 30,
    SHAKE256: 31,
    WHIRLPOOL: 32
  }, t.curves = {
    wei: {
      __proto__: null,
      P192: 0,
      P224: 1,
      P256: 2,
      P384: 3,
      P521: 4,
      SECP256K1: 5
    },
    mont: {
      __proto__: null,
      X25519: 0,
      X448: 1
    },
    edwards: {
      __proto__: null,
      ED25519: 0,
      ED448: 1,
      ED1174: 2
    }
  }, t.ciphers = {
    __proto__: null,
    AES128: 0,
    AES192: 1,
    AES256: 2,
    ARC2: 3,
    ARC2_GUTMANN: 4,
    ARC2_40: 5,
    ARC2_64: 6,
    ARC2_128: 7,
    ARC2_128_GUTMANN: 8,
    BLOWFISH: 9,
    CAMELLIA128: 10,
    CAMELLIA192: 11,
    CAMELLIA256: 12,
    CAST5: 13,
    DES: 14,
    DES_EDE: 15,
    DES_EDE3: 16,
    IDEA: 17,
    SERPENT128: 18,
    SERPENT192: 19,
    SERPENT256: 20,
    TWOFISH128: 21,
    TWOFISH192: 22,
    TWOFISH256: 23
  }, t.modes = {
    __proto__: null,
    RAW: 0,
    ECB: 1,
    CBC: 2,
    CTS: 3,
    XTS: 4,
    CTR: 5,
    CFB: 6,
    OFB: 7,
    GCM: 8,
    CCM: 9,
    EAX: 10
  }, t.algorithms = {
    __proto__: null,
    "AES-128": 0,
    "AES-192": 1,
    "AES-256": 2,
    ARC2: 3,
    "ARC2-GUTMANN": 4,
    "ARC2-40": 5,
    "ARC2-64": 6,
    "ARC2-128": 7,
    "ARC2-128-GUTMANN": 8,
    BF: 9,
    BLOWFISH: 9,
    "CAMELLIA-128": 10,
    "CAMELLIA-192": 11,
    "CAMELLIA-256": 12,
    CAST5: 13,
    DES: 14,
    "DES-EDE": 15,
    "DES-EDE3": 16,
    IDEA: 17,
    "SERPENT-128": 18,
    "SERPENT-192": 19,
    "SERPENT-256": 20,
    "TWOFISH-128": 21,
    "TWOFISH-192": 22,
    "TWOFISH-256": 23
  }, t.NULL = Buffer.alloc(0), t.ternary = function(o) {
    return o == null ? -1 : (r(typeof o == "boolean"), o | 0);
  }, t.hash = function(o) {
    r(o && typeof o.id == "string");
    const d = t.hashes[o.id];
    return r(d >>> 0 === d), d;
  };
  const i = {
    wei: {
      __proto__: null
    },
    mont: {
      __proto__: null
    },
    edwards: {
      __proto__: null
    }
  };
  t.curve = function(o, d) {
    r(typeof o == "string"), r(typeof d == "string");
    const l = i[o];
    if (r(l), l[d])
      return l[d];
    const h = t.curves[o];
    r(h);
    const x = h[d];
    r(x >>> 0 === x);
    let b;
    switch (o) {
      case "wei":
        b = t.wei_curve_create(x), t.wei_curve_randomize(b, t.entropy());
        break;
      case "mont":
        b = t.mont_curve_create(x);
        break;
      case "edwards":
        b = t.edwards_curve_create(x), t.edwards_curve_randomize(b, t.entropy());
        break;
    }
    return l[d] = b, b;
  };
  let n = null;
  return t.secp256k1 = function() {
    return n || (n = t.secp256k1_context_create(), t.secp256k1_context_randomize(n, t.entropy(32))), n;
  }, t.entropy = function(o = t.ENTROPY_SIZE) {
    return e.randomBytes(o);
  }, t.hint = function() {
    return e.randomInt() & 65535;
  }, t.copy = function(o) {
    r(Buffer.isBuffer(o));
    const d = Buffer.allocUnsafeSlow(o.length);
    return r(o.copy(d, 0) === o.length), d;
  }, t.encode = function(o) {
    r(Array.isArray(o));
    let d = 0;
    for (const x of o)
      r(x == null || Buffer.isBuffer(x)), d += 2, x && (r(x.length <= 65535), d += x.length);
    const l = Buffer.allocUnsafeSlow(d);
    let h = 0;
    for (const x of o) {
      if (!x) {
        l[h++] = 0, l[h++] = 0;
        continue;
      }
      l[h++] = x.length >> 8, l[h++] = x.length, h += x.copy(l, h);
    }
    return r(h === d), l;
  }, t.decode = function(o, d) {
    r(Buffer.isBuffer(o)), r(d >>> 0 === d);
    const l = new Array(d);
    let h = 0;
    for (let x = 0; x < d; x++) {
      r(h + 2 <= o.length);
      const b = o[h++] * 256 + o[h++];
      r(h + b <= o.length);
      const g = Buffer.allocUnsafeSlow(b);
      r(o.copy(g, 0, h, h + b) === b), l[x] = g, h += b;
    }
    return r(h === o.length), t.cleanse(o), l;
  }, qd = t, qd;
}
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var zd, a4;
function nI() {
  if (a4)
    return zd;
  a4 = 1;
  const r = Jr, e = sI();
  class t {
    constructor(n) {
      r(n >>> 0 === n), this.checksum = n, this.native = 2;
    }
    serialize(n, c) {
      return r(typeof n == "string"), r(Buffer.isBuffer(c)), e.bech32_serialize(n, c, this.checksum);
    }
    deserialize(n) {
      return r(typeof n == "string"), e.bech32_deserialize(n, this.checksum);
    }
    is(n) {
      return r(typeof n == "string"), e.bech32_is(n, this.checksum);
    }
    convertBits(n, c, o, d) {
      return r(Buffer.isBuffer(n)), r(c >>> 0 === c), r(o >>> 0 === o), r(typeof d == "boolean"), e.bech32_convert_bits(n, c, o, d);
    }
    encode(n, c, o) {
      return r(typeof n == "string"), r(c >>> 0 === c), r(Buffer.isBuffer(o)), e.bech32_encode(n, c, o, this.checksum);
    }
    decode(n) {
      return r(typeof n == "string"), e.bech32_decode(n, this.checksum);
    }
    test(n) {
      return r(typeof n == "string"), e.bech32_test(n, this.checksum);
    }
  }
  return zd = t, zd;
}
/*!
 * bech32m.js - bech32m for bcrypto
 * Copyright (c) 2021, the bcoin developers (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
let z1;
process.env.NODE_BACKEND === "js" ? z1 = Q9 : z1 = nI();
var fI = new z1(734539939);
/*!
 * sha256.js - sha256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var pa = ql;
/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */
const gf = Jr, cI = jf, Sc = -1, Ud = Buffer.alloc(8, 0), tp = Buffer.alloc(64, 0);
tp[0] = 128;
const oI = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
]), aI = new Uint8Array([
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
]), hI = new Uint8Array([
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
]), dI = new Uint8Array([
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
]);
let us = class Vs {
  constructor() {
    this.state = new Uint32Array(5), this.msg = new Uint32Array(16), this.block = Buffer.alloc(64), this.size = Sc;
  }
  init() {
    return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
  }
  update(e) {
    return gf(Buffer.isBuffer(e)), this._update(e, e.length), this;
  }
  final() {
    return this._final(Buffer.alloc(20));
  }
  _update(e, t) {
    gf(this.size !== Sc, "Context is not initialized.");
    let i = this.size & 63, n = 0;
    if (this.size += t, i > 0) {
      let c = 64 - i;
      if (c > t && (c = t), e.copy(this.block, i, n, n + c), i += c, t -= c, n += c, i < 64)
        return;
      this._transform(this.block, 0);
    }
    for (; t >= 64; )
      this._transform(e, n), n += 64, t -= 64;
    t > 0 && e.copy(this.block, 0, n, n + t);
  }
  _final(e) {
    gf(this.size !== Sc, "Context is not initialized.");
    const t = this.size & 63, i = this.size * 8;
    Cd(Ud, i >>> 0, 0), Cd(Ud, i * (1 / 4294967296) >>> 0, 4), this._update(tp, 1 + (119 - t & 63)), this._update(Ud, 8);
    for (let n = 0; n < 5; n++)
      Cd(e, this.state[n], n * 4), this.state[n] = 0;
    for (let n = 0; n < 16; n++)
      this.msg[n] = 0;
    for (let n = 0; n < 64; n++)
      this.block[n] = 0;
    return this.size = Sc, e;
  }
  _transform(e, t) {
    const i = this.msg;
    let n = this.state[0], c = this.state[1], o = this.state[2], d = this.state[3], l = this.state[4], h = n, x = c, b = o, g = d, w = l;
    for (let B = 0; B < 16; B++)
      i[B] = xI(e, t + B * 4);
    for (let B = 0; B < 80; B++) {
      let y = n + h4(B, c, o, d) + i[oI[B]] + uI(B), A = Bc(y, hI[B]), _ = A + l;
      n = l, l = d, d = Bc(o, 10), o = c, c = _, y = h + h4(79 - B, x, b, g) + i[aI[B]] + lI(B), A = Bc(y, dI[B]), _ = A + w, h = w, w = g, g = Bc(b, 10), b = x, x = _;
    }
    const I = this.state[1] + o + g;
    this.state[1] = this.state[2] + d + w, this.state[2] = this.state[3] + l + h, this.state[3] = this.state[4] + n + x, this.state[4] = this.state[0] + c + b, this.state[0] = I;
  }
  static hash() {
    return new Vs();
  }
  static hmac() {
    return new cI(Vs, 64);
  }
  static digest(e) {
    return Vs.ctx.init().update(e).final();
  }
  static root(e, t) {
    return gf(Buffer.isBuffer(e) && e.length === 20), gf(Buffer.isBuffer(t) && t.length === 20), Vs.ctx.init().update(e).update(t).final();
  }
  static multi(e, t, i) {
    const { ctx: n } = Vs;
    return n.init(), n.update(e), n.update(t), i && n.update(i), n.final();
  }
  static mac(e, t) {
    return Vs.hmac().init(t).update(e).final();
  }
};
us.native = 0;
us.id = "RIPEMD160";
us.size = 20;
us.bits = 160;
us.blockSize = 64;
us.zero = Buffer.alloc(20, 0);
us.ctx = new us();
function Bc(r, e) {
  return r << e | r >>> 32 - e;
}
function h4(r, e, t, i) {
  return r <= 15 ? e ^ t ^ i : r <= 31 ? e & t | ~e & i : r <= 47 ? (e | ~t) ^ i : r <= 63 ? e & i | t & ~i : e ^ (t | ~i);
}
function uI(r) {
  return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838;
}
function lI(r) {
  return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0;
}
function xI(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216;
}
function Cd(r, e, t) {
  return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t;
}
var rp = us;
/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */
const d4 = Jr, bI = ql, pI = rp, mI = jf, Td = new pI();
class h0 {
  constructor() {
    this.ctx = new bI();
  }
  init() {
    return this.ctx.init(), this;
  }
  update(e) {
    return this.ctx.update(e), this;
  }
  final() {
    const e = Buffer.alloc(32);
    return this.ctx._final(e), Td.init(), Td.update(e), Td._final(e), e.slice(0, 20);
  }
  static hash() {
    return new h0();
  }
  static hmac() {
    return new mI(h0, 64);
  }
  static digest(e) {
    return h0.ctx.init().update(e).final();
  }
  static root(e, t) {
    return d4(Buffer.isBuffer(e) && e.length === 20), d4(Buffer.isBuffer(t) && t.length === 20), h0.ctx.init().update(e).update(t).final();
  }
  static multi(e, t, i) {
    const { ctx: n } = h0;
    return n.init(), n.update(e), n.update(t), i && n.update(i), n.final();
  }
  static mac(e, t) {
    return h0.hmac().init(t).update(e).final();
  }
}
h0.native = 0;
h0.id = "HASH160";
h0.size = 20;
h0.bits = 160;
h0.blockSize = 64;
h0.zero = Buffer.alloc(20, 0);
h0.ctx = new h0();
var gI = h0;
/*!
 * hash160.js - hash160 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var ip = gI, ma = {};
/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  r.search = function(i, n, c, o) {
    let d = 0, l = i.length - 1;
    for (; d <= l; ) {
      const h = d + l >>> 1, x = c(i[h], n);
      if (x === 0)
        return h;
      x < 0 ? d = h + 1 : l = h - 1;
    }
    return o ? d : -1;
  }, r.insert = function(i, n, c, o) {
    const d = r.search(i, n, c, !0);
    return o && d < i.length && c(i[d], n) === 0 ? -1 : (d === 0 ? i.unshift(n) : d === i.length ? i.push(n) : i.splice(d, 0, n), d);
  }, r.remove = function(i, n, c) {
    const o = r.search(i, n, c, !1);
    return o === -1 ? !1 : (e(i, o), !0);
  };
  function e(t, i) {
    if (i === 0) {
      t.shift();
      return;
    }
    let n = i + 1;
    for (; n < t.length; )
      t[i++] = t[n++];
    t.pop();
  }
})(ma);
var sp = {};
/*!
 * network.js - bitcoin networks for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  const e = Z9, t = r;
  function i(l) {
    return Buffer.from(l, "hex");
  }
  t.types = ["main", "testnet", "regtest", "simnet"];
  const n = {};
  n.type = "main", n.seeds = [
    "seed.bitcoin.sipa.be",
    "dnsseed.bluematt.me",
    "dnsseed.bitcoin.dashjr.org",
    "seed.bitcoinstats.com",
    "seed.bitcoin.jonasschnelli.ch",
    "seed.btc.petertodd.org",
    "seed.bitcoin.sprovoost.nl",
    "dnsseed.emzy.de"
    // Stephan Oeste
  ], n.magic = 3652501241, n.port = 8333, n.checkpointMap = {
    11111: i("1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000"),
    33333: i("a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000"),
    74e3: i("201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000"),
    105e3: i("97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000"),
    134444: i("feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000"),
    168e3: i("63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000"),
    193e3: i("17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000"),
    21e4: i("2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000"),
    216116: i("4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000"),
    225430: i("32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000"),
    25e4: i("14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000"),
    279e3: i("407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000"),
    295e3: i("83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000"),
    300255: i("b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000"),
    319400: i("3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000"),
    343185: i("548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000"),
    352940: i("ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000"),
    382320: i("b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000"),
    401465: i("eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000"),
    42e4: i("a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000"),
    44e4: i("9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000"),
    45e4: i("0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000"),
    46e4: i("8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000"),
    47e4: i("89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000"),
    48e4: i("b1a896fd31e639e0c74d1abeb1dbc93f176b767a5d4c02010000000000000000"),
    49e4: i("90dec4d0153f20fbdcb245b1d5fb3d5a8d7bb1379106de000000000000000000"),
    5e5: i("045d94a1c33354c3759cc0512dcc49fd81bf4c3637fb24000000000000000000"),
    51e4: i("297301b8ca28584cb0c31c7e3fed51696bc33ef8782615000000000000000000"),
    525e3: i("1dde8e3fb49bbd5ab66a1b847544d67fff10b108a1fa2f000000000000000000")
  }, n.lastCheckpoint = 525e3, n.txnData = {
    rate: 2.925802860942233,
    time: 1661697692,
    count: 760120522
  }, n.halvingInterval = 21e4, n.genesis = {
    version: 1,
    hash: i("6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000"),
    prevBlock: i("0000000000000000000000000000000000000000000000000000000000000000"),
    merkleRoot: i("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
    time: 1231006505,
    bits: 486604799,
    nonce: 2083236893,
    height: 0
  }, n.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", n.pow = {
    /**
     * Default target.
     * @const {BN}
     */
    limit: new e("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff", "hex"),
    /**
     * Compact pow limit.
     * @const {Number}
     * @default
     */
    bits: 486604799,
    /**
     * Minimum chainwork for best chain.
     * @const {BN}
     */
    chainwork: new e("00000000000000000000000000000000000000000259c9b7d8c7779d29a1188f", "hex"),
    /**
     * Desired retarget period in seconds.
     * @const {Number}
     * @default
     */
    targetTimespan: 14 * 24 * 60 * 60,
    /**
     * Average block time.
     * @const {Number}
     * @default
     */
    targetSpacing: 10 * 60,
    /**
     * Retarget interval in blocks.
     * @const {Number}
     * @default
     */
    retargetInterval: 2016,
    /**
     * Whether to reset target if a block
     * has not been mined recently.
     * @const {Boolean}
     * @default
     */
    targetReset: !1,
    /**
     * Do not allow retargetting.
     * @const {Boolean}
     * @default
     */
    noRetargeting: !1
  }, n.block = {
    /**
     * Height at which bip34 was activated.
     * Used for avoiding bip30 checks.
     */
    bip34height: 227931,
    /**
     * Hash of the block that activated bip34.
     */
    bip34hash: i("b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000"),
    /**
     * Height at which bip65 was activated.
     */
    bip65height: 388381,
    /**
     * Hash of the block that activated bip65.
     */
    bip65hash: i("f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000"),
    /**
     * Height at which bip66 was activated.
     */
    bip66height: 363725,
    /**
     * Hash of the block that activated bip66.
     */
    bip66hash: i("3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000"),
    /**
     * Safe height to start pruning.
     */
    pruneAfterHeight: 1e3,
    /**
     * Safe number of blocks to keep.
     */
    keepBlocks: 288,
    /**
     * Age used for the time delta to
     * determine whether the chain is synced.
     */
    maxTipAge: 24 * 60 * 60,
    /**
     * Height at which block processing is
     * slow enough that we can output
     * logs without spamming.
     */
    slowHeight: 325e3
  }, n.bip30 = {
    91842: i("eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000"),
    91880: i("21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000")
  }, n.activationThreshold = 1916, n.minerWindow = 2016, n.deployments = {
    csv: {
      name: "csv",
      bit: 0,
      startTime: 1462060800,
      timeout: 1493596800,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    },
    segwit: {
      name: "segwit",
      bit: 1,
      startTime: 1479168e3,
      timeout: 1510704e3,
      threshold: -1,
      window: -1,
      required: !0,
      force: !1
    },
    segsignal: {
      name: "segsignal",
      bit: 4,
      startTime: 1496275200,
      timeout: 1510704e3,
      threshold: 269,
      window: 336,
      required: !1,
      force: !1
    },
    testdummy: {
      name: "testdummy",
      bit: 28,
      startTime: 1199145601,
      timeout: 1230767999,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    }
  }, n.deploys = [
    n.deployments.csv,
    n.deployments.segwit,
    n.deployments.segsignal,
    n.deployments.testdummy
  ], n.keyPrefix = {
    privkey: 128,
    xpubkey: 76067358,
    xprivkey: 76066276,
    xpubkey58: "xpub",
    xprivkey58: "xprv",
    coinType: 0
  }, n.addressPrefix = {
    pubkeyhash: 0,
    scripthash: 5,
    bech32: "bc"
  }, n.requireStandard = !0, n.rpcPort = 8332, n.walletPort = 8334, n.minRelay = 1e3, n.feeRate = 5e3, n.maxFeeRate = 4e5, n.selfConnect = !1, n.requestMempool = !1;
  const c = {};
  c.type = "testnet", c.seeds = [
    "testnet-seed.bitcoin.jonasschnelli.ch",
    "seed.tbtc.petertodd.org",
    "testnet-seed.bluematt.me",
    "testnet-seed.bitcoin.schildbach.de",
    "seed.testnet.bitcoin.sprovoost.nl"
    // Sjors Provoost
  ], c.magic = 118034699, c.port = 18333, c.checkpointMap = {
    546: i("70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000"),
    1e4: i("02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000"),
    5e4: i("0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000"),
    9e4: i("cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000"),
    1e5: i("1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000"),
    14e4: i("92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000"),
    17e4: i("508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000"),
    21e4: i("32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000"),
    23e4: i("b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000"),
    27e4: i("1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000"),
    3e5: i("a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000"),
    34e4: i("67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000"),
    35e4: i("592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000"),
    39e4: i("f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000"),
    42e4: i("de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000"),
    46e4: i("2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000"),
    5e5: i("06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000"),
    54e4: i("8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000"),
    57e4: i("87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000"),
    6e5: i("169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000"),
    63e4: i("bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000"),
    67e4: i("080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000"),
    7e5: i("c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000"),
    74e4: i("b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000"),
    78e4: i("0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000"),
    8e5: i("03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000"),
    84e4: i("dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000"),
    88e4: i("ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000"),
    9e5: i("9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000"),
    94e4: i("c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000"),
    98e4: i("cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000"),
    101e4: i("9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000"),
    105e4: i("d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000")
  }, c.lastCheckpoint = 105e4, c.txnData = {
    rate: 0.1079119341520164,
    time: 1661705221,
    count: 63531852
  }, c.halvingInterval = 21e4, c.genesis = {
    version: 1,
    hash: i("43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000"),
    prevBlock: i("0000000000000000000000000000000000000000000000000000000000000000"),
    merkleRoot: i("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
    time: 1296688602,
    bits: 486604799,
    nonce: 414098458,
    height: 0
  }, c.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae180101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", c.pow = {
    limit: new e("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff", "hex"),
    bits: 486604799,
    chainwork: new e("000000000000000000000000000000000000000000000062b7123cfd7d09f7b6", "hex"),
    targetTimespan: 14 * 24 * 60 * 60,
    targetSpacing: 10 * 60,
    retargetInterval: 2016,
    targetReset: !0,
    noRetargeting: !1
  }, c.block = {
    bip34height: 21111,
    bip34hash: i("f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000"),
    bip65height: 581885,
    bip65hash: i("b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000"),
    bip66height: 330776,
    bip66hash: i("82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000"),
    pruneAfterHeight: 1e3,
    keepBlocks: 1e4,
    maxTipAge: 24 * 60 * 60,
    slowHeight: 95e4
  }, c.bip30 = {}, c.activationThreshold = 1512, c.minerWindow = 2016, c.deployments = {
    csv: {
      name: "csv",
      bit: 0,
      startTime: 1456790400,
      timeout: 1493596800,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    },
    segwit: {
      name: "segwit",
      bit: 1,
      startTime: 1462060800,
      timeout: 1493596800,
      threshold: -1,
      window: -1,
      required: !0,
      force: !1
    },
    segsignal: {
      name: "segsignal",
      bit: 4,
      startTime: 4294967295,
      timeout: 4294967295,
      threshold: 269,
      window: 336,
      required: !1,
      force: !1
    },
    testdummy: {
      name: "testdummy",
      bit: 28,
      startTime: 1199145601,
      timeout: 1230767999,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    }
  }, c.deploys = [
    c.deployments.csv,
    c.deployments.segwit,
    c.deployments.segsignal,
    c.deployments.testdummy
  ], c.keyPrefix = {
    privkey: 239,
    xpubkey: 70617039,
    xprivkey: 70615956,
    xpubkey58: "tpub",
    xprivkey58: "tprv",
    coinType: 1
  }, c.addressPrefix = {
    pubkeyhash: 111,
    scripthash: 196,
    bech32: "tb"
  }, c.requireStandard = !1, c.rpcPort = 18332, c.walletPort = 18334, c.minRelay = 1e3, c.feeRate = 2e4, c.maxFeeRate = 6e4, c.selfConnect = !1, c.requestMempool = !1;
  const o = {};
  o.type = "regtest", o.seeds = [], o.magic = 3669344250, o.port = 48444, o.checkpointMap = {}, o.lastCheckpoint = 0, o.txnData = {
    rate: 0,
    time: 0,
    count: 0
  }, o.halvingInterval = 150, o.genesis = {
    version: 1,
    hash: i("06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f"),
    prevBlock: i("0000000000000000000000000000000000000000000000000000000000000000"),
    merkleRoot: i("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
    time: 1296688602,
    bits: 545259519,
    nonce: 2,
    height: 0
  }, o.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", o.pow = {
    limit: new e("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", "hex"),
    bits: 545259519,
    chainwork: new e("0000000000000000000000000000000000000000000000000000000000000002", "hex"),
    targetTimespan: 14 * 24 * 60 * 60,
    targetSpacing: 10 * 60,
    retargetInterval: 2016,
    targetReset: !0,
    noRetargeting: !0
  }, o.block = {
    bip34height: 1e8,
    bip34hash: null,
    bip65height: 1351,
    bip65hash: null,
    bip66height: 1251,
    bip66hash: null,
    pruneAfterHeight: 1e3,
    keepBlocks: 1e4,
    maxTipAge: 4294967295,
    slowHeight: 0
  }, o.bip30 = {}, o.activationThreshold = 108, o.minerWindow = 144, o.deployments = {
    csv: {
      name: "csv",
      bit: 0,
      startTime: 0,
      timeout: 4294967295,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    },
    segwit: {
      name: "segwit",
      bit: 1,
      startTime: -1,
      timeout: 4294967295,
      threshold: -1,
      window: -1,
      required: !0,
      force: !1
    },
    segsignal: {
      name: "segsignal",
      bit: 4,
      startTime: 4294967295,
      timeout: 4294967295,
      threshold: 269,
      window: 336,
      required: !1,
      force: !1
    },
    testdummy: {
      name: "testdummy",
      bit: 28,
      startTime: 0,
      timeout: 4294967295,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    }
  }, o.deploys = [
    o.deployments.csv,
    o.deployments.segwit,
    o.deployments.segsignal,
    o.deployments.testdummy
  ], o.keyPrefix = {
    privkey: 239,
    xpubkey: 70617039,
    xprivkey: 70615956,
    xpubkey58: "tpub",
    xprivkey58: "tprv",
    coinType: 1
  }, o.addressPrefix = {
    pubkeyhash: 111,
    scripthash: 196,
    bech32: "bcrt"
  }, o.requireStandard = !1, o.rpcPort = 48332, o.walletPort = 48334, o.minRelay = 1e3, o.feeRate = 2e4, o.maxFeeRate = 6e4, o.selfConnect = !0, o.requestMempool = !0;
  const d = {};
  d.type = "simnet", d.seeds = [
    "127.0.0.1"
  ], d.magic = 303307798, d.port = 18555, d.checkpointMap = {}, d.lastCheckpoint = 0, d.txnData = {
    time: 0,
    count: 0,
    rate: 0
  }, d.halvingInterval = 21e4, d.genesis = {
    version: 1,
    hash: i("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
    prevBlock: i("0000000000000000000000000000000000000000000000000000000000000000"),
    merkleRoot: i("3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a"),
    time: 1401292357,
    bits: 545259519,
    nonce: 2,
    height: 0
  }, d.genesisBlock = "0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a45068653ffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000", d.pow = {
    limit: new e(
      // High target of 0x207fffff (545259519)
      "7fffff0000000000000000000000000000000000000000000000000000000000",
      "hex"
    ),
    bits: 545259519,
    chainwork: new e("0000000000000000000000000000000000000000000000000000000000000002", "hex"),
    targetTimespan: 14 * 24 * 60 * 60,
    targetSpacing: 10 * 60,
    retargetInterval: 2016,
    targetReset: !0,
    noRetargeting: !1
  }, d.block = {
    bip34height: 0,
    bip34hash: i("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
    bip65height: 0,
    bip65hash: i("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
    bip66height: 0,
    bip66hash: i("f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68"),
    pruneAfterHeight: 1e3,
    keepBlocks: 1e4,
    maxTipAge: 4294967295,
    slowHeight: 0
  }, d.bip30 = {}, d.activationThreshold = 75, d.minerWindow = 100, d.deployments = {
    csv: {
      name: "csv",
      bit: 0,
      startTime: 0,
      timeout: 4294967295,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    },
    segwit: {
      name: "segwit",
      bit: 1,
      startTime: 0,
      timeout: 4294967295,
      threshold: -1,
      window: -1,
      required: !0,
      force: !1
    },
    segsignal: {
      name: "segsignal",
      bit: 4,
      startTime: 4294967295,
      timeout: 4294967295,
      threshold: 269,
      window: 336,
      required: !1,
      force: !1
    },
    testdummy: {
      name: "testdummy",
      bit: 28,
      startTime: 1199145601,
      timeout: 1230767999,
      threshold: -1,
      window: -1,
      required: !1,
      force: !0
    }
  }, d.deploys = [
    d.deployments.csv,
    d.deployments.segwit,
    d.deployments.segsignal,
    d.deployments.testdummy
  ], d.keyPrefix = {
    privkey: 100,
    xpubkey: 69254458,
    xprivkey: 69253376,
    xpubkey58: "spub",
    xprivkey58: "sprv",
    coinType: 115
  }, d.addressPrefix = {
    pubkeyhash: 63,
    scripthash: 123,
    bech32: "sb"
  }, d.requireStandard = !1, d.rpcPort = 18556, d.walletPort = 18558, d.minRelay = 1e3, d.feeRate = 2e4, d.maxFeeRate = 6e4, d.selfConnect = !1, d.requestMempool = !1, t.main = n, t.testnet = c, t.regtest = o, t.simnet = d;
})(sp);
/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const wI = M0, u4 = Os, yI = ma;
let SI = class extends wI {
  /**
   * Create time data.
   * @constructor
   * @param {Number} [limit=200]
   */
  constructor(e) {
    super(), e == null && (e = 200), this.samples = [], this.known = /* @__PURE__ */ new Map(), this.limit = e, this.offset = 0, this.checked = !1;
  }
  /**
   * Add time data.
   * @param {String} id
   * @param {Number} time
   */
  add(e, t) {
    if (this.samples.length >= this.limit || this.known.has(e))
      return;
    const i = t - u4.now();
    if (this.known.set(e, i), yI.insert(this.samples, i, BI), this.emit("sample", i, this.samples.length), this.samples.length >= 5 && this.samples.length % 2 === 1) {
      let n = this.samples[this.samples.length >>> 1];
      if (Math.abs(n) >= 70 * 60) {
        if (!this.checked) {
          let c = !1;
          for (const o of this.samples)
            if (o !== 0 && Math.abs(o) < 5 * 60) {
              c = !0;
              break;
            }
          c || (this.checked = !0, this.emit("mismatch"));
        }
        n = 0;
      }
      this.offset = n, this.emit("offset", this.offset);
    }
  }
  /**
   * Get the current adjusted time.
   * @returns {Number} Adjusted Time.
   */
  now() {
    return u4.now() + this.offset;
  }
  /**
   * Adjust a timestamp.
   * @param {Number} time
   * @returns {Number} Adjusted Time.
   */
  adjust(e) {
    return e + this.offset;
  }
  /**
   * Unadjust a timestamp.
   * @param {Number} time
   * @returns {Number} Local Time.
   */
  local(e) {
    return e - this.offset;
  }
  /**
   * Get the current adjusted time in milliseconds.
   * @returns {Number} Adjusted Time.
   */
  ms() {
    return Date.now() + this.offset * 1e3;
  }
};
function BI(r, e) {
  return r - e;
}
var vI = SI, Gr = {}, Jl = {};
/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  const e = Ar;
  r.encode = function(o, d) {
    e(Number.isSafeInteger(o), "Invalid integer value.");
    let l = "";
    o < 0 && (o = -o, l = "-");
    const h = t(d);
    let x = o % h, b = (o - x) / h;
    for (x = x.toString(10), b = b.toString(10); x.length < d; )
      x = "0" + x;
    return x = x.replace(/0+$/, ""), e(x.length <= d, "Invalid integer value."), x.length === 0 && (x = "0"), d === 0 ? `${l}${b}` : `${l}${b}.${x}`;
  }, r.decode = function(o, d) {
    e(typeof o == "string"), e(o.length <= 32, "Fixed number string too large.");
    let l = 1;
    o.length > 0 && o[0] === "-" && (o = o.substring(1), l = -1);
    let h = o, x = "0";
    const b = o.indexOf(".");
    for (b !== -1 && (h = o.substring(0, b), x = o.substring(b + 1)), h = h.replace(/^0+/, ""), x = x.replace(/0+$/, ""), e(h.length <= 16 - d, "Fixed number string exceeds 2^53-1."), e(x.length <= d, "Too many decimal places in fixed number string."), h.length === 0 && (h = "0"); x.length < d; )
      x += "0";
    x.length === 0 && (x = "0"), e(/^\d+$/.test(h) && /^\d+$/.test(x), "Non-numeric characters in fixed number string."), h = parseInt(h, 10), x = parseInt(x, 10);
    const g = t(d), w = i(g), I = n(g);
    return e(h < I || h === I && x <= w, "Fixed number string exceeds 2^53-1."), l * (h * g + x);
  }, r.toFloat = function(o, d) {
    return parseFloat(r.encode(o, d));
  }, r.fromFloat = function(o, d) {
    return e(typeof o == "number" && isFinite(o)), e(Number.isSafeInteger(d)), r.decode(o.toFixed(d), d);
  };
  function t(c) {
    switch (c) {
      case 0:
        return 1;
      case 1:
        return 10;
      case 2:
        return 100;
      case 3:
        return 1e3;
      case 4:
        return 1e4;
      case 5:
        return 1e5;
      case 6:
        return 1e6;
      case 7:
        return 1e7;
      case 8:
        return 1e8;
    }
    throw new Error("Exponent is too large.");
  }
  function i(c) {
    switch (c) {
      case 1:
        return 0;
      case 10:
        return 1;
      case 100:
        return 91;
      case 1e3:
        return 991;
      case 1e4:
        return 991;
      case 1e5:
        return 40991;
      case 1e6:
        return 740991;
      case 1e7:
        return 4740991;
      case 1e8:
        return 54740991;
    }
    throw new Error("Exponent is too large.");
  }
  function n(c) {
    switch (c) {
      case 1:
        return 9007199254740991;
      case 10:
        return 900719925474099;
      case 100:
        return 90071992547409;
      case 1e3:
        return 9007199254740;
      case 1e4:
        return 900719925474;
      case 1e5:
        return 90071992547;
      case 1e6:
        return 9007199254;
      case 1e7:
        return 900719925;
      case 1e8:
        return 90071992;
    }
    throw new Error("Exponent is too large.");
  }
})(Jl);
var np = {};
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var fc = q1(), Zn = {};
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */
const g0 = Jr, mo = Pn.crypto || Pn.msCrypto, fp = mo && typeof mo.getRandomValues == "function", EI = fp ? mo.getRandomValues.bind(mo) : null, l4 = new Uint32Array(16), Dd = 65536;
let Ld = 0;
function II(r) {
  g0(r >>> 0 === r);
  const e = Buffer.alloc(r);
  return op(e, 0, r), e;
}
function AI(r, e, t) {
  return g0(Buffer.isBuffer(r)), e == null && (e = 0), g0(e >>> 0 === e), t == null && (t = r.length - e), g0(t >>> 0 === t), g0(e + t <= r.length), op(r, e, t), r;
}
function cp() {
  return Ld & 15 || (U1(l4), Ld = 0), l4[Ld++];
}
function _I(r, e) {
  g0(r >>> 0 === r), g0(e >>> 0 === e), g0(e >= r);
  const t = e - r;
  if (t === 0)
    return r;
  const i = -t >>> 0;
  let n, c;
  do
    n = cp(), c = n % t;
  while (n - c > i);
  return c + r;
}
function U1(r) {
  if (!fp)
    throw new Error("Entropy source not available.");
  return EI(r);
}
function op(r, e, t) {
  if (g0(Buffer.isBuffer(r)), g0(r.buffer instanceof ArrayBuffer), g0(r.byteOffset >>> 0 === r.byteOffset), g0(r.byteLength >>> 0 === r.byteLength), g0(e >>> 0 === e), g0(t >>> 0 === t), g0(e + t <= r.byteLength), t > 2 ** 31 - 1)
    throw new RangeError('The value "size" is out of range.');
  const i = r.byteOffset + e, n = new Uint8Array(r.buffer, i, t);
  if (n.length > Dd)
    for (let c = 0; c < n.length; c += Dd) {
      let o = c + Dd;
      o > n.length && (o = n.length), U1(n.subarray(c, o));
    }
  else
    n.length > 0 && U1(n);
}
Zn.native = 0;
Zn.randomBytes = II;
Zn.randomFill = AI;
Zn.randomInt = cp;
Zn.randomRange = _I;
/*!
 * random.js - random for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var MI = Zn, Z0 = {};
/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const ir = M0, Xl = fc;
function Zl(r, e, t) {
  if (ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir(typeof t == "boolean"), e >= r.length)
    throw new Error("Invalid size.");
  const i = r[e], n = i & 127;
  if (e += 1, !(i & 128))
    return [n, e];
  if (t && n === 0)
    throw new Error("Indefinite length.");
  let c = 0;
  for (let o = 0; o < n; o++) {
    ir(e < r.length);
    const d = r[e];
    if (e += 1, c >= 1 << 24)
      throw new Error("Length too large.");
    if (c *= 256, c += d, t && c === 0)
      throw new Error("Unexpected leading zeroes.");
  }
  if (t && c < 128)
    throw new Error("Non-minimal length.");
  return [c, e];
}
function NI(r, e, t = !0) {
  if (ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir(typeof t == "boolean"), e >= r.length || r[e] !== 48)
    throw new Error("Invalid sequence tag.");
  e += 1;
  let i;
  if ([i, e] = Zl(r, e, t), t && e + i !== r.length)
    throw new Error("Trailing bytes.");
  return e;
}
function ap(r, e, t = !0) {
  if (ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir(typeof t == "boolean"), e >= r.length || r[e] !== 2)
    throw new Error("Invalid integer tag.");
  e += 1;
  let i;
  if ([i, e] = Zl(r, e, t), e + i > r.length)
    throw new Error("Integer body out of bounds.");
  if (t) {
    if (i === 0)
      throw new Error("Zero length integer.");
    if (r[e] & 128)
      throw new Error("Integers must be positive.");
    if (i > 1 && r[e] === 0 && !(r[e + 1] & 128))
      throw new Error("Unexpected leading zeroes.");
  }
  for (; i > 0 && r[e] === 0; )
    e += 1, i -= 1;
  if (i > 2048)
    throw new Error("Invalid integer size.");
  const n = Xl.decode(r.slice(e, e + i));
  return e += i, [n, e];
}
function OI(r, e, t, i = !0) {
  ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir((t & 255) === t), ir(typeof i == "boolean");
  let n;
  if ([n, e] = ap(r, e, i), n.cmpn(t) !== 0)
    throw new Error("Invalid version.");
  return e;
}
function Wl(r) {
  return ir(r >>> 0 === r), r <= 127 ? 1 : r <= 255 ? 2 : (ir(r <= 65535), 3);
}
function PI(r) {
  return 1 + Wl(r) + r;
}
function RI(r) {
  ir(r instanceof Xl);
  const e = r.bitLength();
  let t = e + 7 >>> 3;
  return e > 0 && !(e & 7) && (t += r.testn(e - 1)), e === 0 && (t = 1), 1 + Wl(t) + t;
}
function kI(r) {
  return ir((r & 255) === r), 3;
}
function jl(r, e, t) {
  return ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir(t >>> 0 === t), t <= 127 ? r[e++] = t : t <= 255 ? (r[e++] = 129, r[e++] = t) : (ir(t <= 65535), r[e++] = 130, r[e++] = t >> 8, r[e++] = t & 255), ir(e <= r.length), e;
}
function qI(r, e, t) {
  return ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), r[e++] = 48, jl(r, e, t);
}
function zI(r, e, t) {
  ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir(t instanceof Xl);
  const i = t.bitLength();
  let n = i + 7 >>> 3, c = 0;
  return i > 0 && !(i & 7) && (c = t.testn(i - 1)), i === 0 && (n = 1), r[e++] = 2, e = jl(r, e, c + n), c && (r[e++] = 0), i !== 0 ? t.encode().copy(r, e) : r[e] = 0, e += n, ir(e <= r.length), e;
}
function UI(r, e, t) {
  return ir(Buffer.isBuffer(r)), ir(e >>> 0 === e), ir((t & 255) === t), ir(e + 3 <= r.length), r[e++] = 2, r[e++] = 1, r[e++] = t, e;
}
Z0.readSize = Zl;
Z0.readSeq = NI;
Z0.readInt = ap;
Z0.readVersion = OI;
Z0.sizeSize = Wl;
Z0.sizeSeq = PI;
Z0.sizeInt = RI;
Z0.sizeVersion = kI;
Z0.writeSize = jl;
Z0.writeSeq = qI;
Z0.writeInt = zI;
Z0.writeVersion = UI;
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */
const wn = Jr, Kd = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
let hp = class dp {
  /**
   * Create a ChaCha20 context.
   * @constructor
   */
  constructor() {
    this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, Kd && (this.bytes = Buffer.alloc(64));
  }
  /**
   * Initialize chacha20 with a key, nonce, and counter.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @param {Number} counter
   */
  init(e, t, i) {
    if (i == null && (i = 0), wn(Buffer.isBuffer(e)), wn(Buffer.isBuffer(t)), wn(Number.isSafeInteger(i)), e.length !== 16 && e.length !== 32)
      throw new RangeError("Invalid key size.");
    if (t.length >= 24 && (e = dp.derive(e, t.slice(0, 16)), t = t.slice(16)), this.state[0] = 1634760805, this.state[1] = e.length < 32 ? 824206446 : 857760878, this.state[2] = e.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = dr(e, 0), this.state[5] = dr(e, 4), this.state[6] = dr(e, 8), this.state[7] = dr(e, 12), this.state[8] = dr(e, 16 % e.length), this.state[9] = dr(e, 20 % e.length), this.state[10] = dr(e, 24 % e.length), this.state[11] = dr(e, 28 % e.length), this.state[12] = i >>> 0, t.length === 8)
      this.state[13] = i / 4294967296 >>> 0, this.state[14] = dr(t, 0), this.state[15] = dr(t, 4);
    else if (t.length === 12)
      this.state[13] = dr(t, 0), this.state[14] = dr(t, 4), this.state[15] = dr(t, 8);
    else if (t.length === 16)
      this.state[12] = dr(t, 0), this.state[13] = dr(t, 4), this.state[14] = dr(t, 8), this.state[15] = dr(t, 12);
    else
      throw new RangeError("Invalid nonce size.");
    return this.pos = 0, this;
  }
  /**
   * Encrypt/decrypt data.
   * @param {Buffer} data - Will be mutated.
   * @returns {Buffer}
   */
  encrypt(e) {
    if (wn(Buffer.isBuffer(e)), this.pos === -1)
      throw new Error("Context is not initialized.");
    for (let t = 0; t < e.length; t++)
      this.pos & 63 || (this._block(), this.pos = 0), e[t] ^= this.bytes[this.pos++];
    return e;
  }
  /**
   * Stir the stream.
   */
  _block() {
    for (let e = 0; e < 16; e++)
      this.stream[e] = this.state[e];
    for (let e = 0; e < 10; e++)
      n0(this.stream, 0, 4, 8, 12), n0(this.stream, 1, 5, 9, 13), n0(this.stream, 2, 6, 10, 14), n0(this.stream, 3, 7, 11, 15), n0(this.stream, 0, 5, 10, 15), n0(this.stream, 1, 6, 11, 12), n0(this.stream, 2, 7, 8, 13), n0(this.stream, 3, 4, 9, 14);
    for (let e = 0; e < 16; e++)
      this.stream[e] += this.state[e];
    if (Kd)
      for (let e = 0; e < 16; e++)
        ji(this.bytes, this.stream[e], e * 4);
    this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1);
  }
  /**
   * Destroy context.
   */
  destroy() {
    for (let e = 0; e < 16; e++)
      this.state[e] = 0, this.stream[e] = 0;
    if (Kd)
      for (let e = 0; e < 64; e++)
        this.bytes[e] = 0;
    return this.pos = -1, this;
  }
  /**
   * Derive key with XChaCha20.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @returns {Buffer}
   */
  static derive(e, t) {
    if (wn(Buffer.isBuffer(e)), wn(Buffer.isBuffer(t)), e.length !== 16 && e.length !== 32)
      throw new RangeError("Invalid key size.");
    if (t.length !== 16)
      throw new RangeError("Invalid nonce size.");
    const i = new Uint32Array(16);
    i[0] = 1634760805, i[1] = e.length < 32 ? 824206446 : 857760878, i[2] = e.length < 32 ? 2036477238 : 2036477234, i[3] = 1797285236, i[4] = dr(e, 0), i[5] = dr(e, 4), i[6] = dr(e, 8), i[7] = dr(e, 12), i[8] = dr(e, 16 % e.length), i[9] = dr(e, 20 % e.length), i[10] = dr(e, 24 % e.length), i[11] = dr(e, 28 % e.length), i[12] = dr(t, 0), i[13] = dr(t, 4), i[14] = dr(t, 8), i[15] = dr(t, 12);
    for (let c = 0; c < 10; c++)
      n0(i, 0, 4, 8, 12), n0(i, 1, 5, 9, 13), n0(i, 2, 6, 10, 14), n0(i, 3, 7, 11, 15), n0(i, 0, 5, 10, 15), n0(i, 1, 6, 11, 12), n0(i, 2, 7, 8, 13), n0(i, 3, 4, 9, 14);
    const n = Buffer.alloc(32);
    return ji(n, i[0], 0), ji(n, i[1], 4), ji(n, i[2], 8), ji(n, i[3], 12), ji(n, i[12], 16), ji(n, i[13], 20), ji(n, i[14], 24), ji(n, i[15], 28), n;
  }
};
hp.native = 0;
function n0(r, e, t, i, n) {
  r[e] += r[t], r[n] = vc(r[n] ^ r[e], 16), r[i] += r[n], r[t] = vc(r[t] ^ r[i], 12), r[e] += r[t], r[n] = vc(r[n] ^ r[e], 8), r[i] += r[n], r[t] = vc(r[t] ^ r[i], 7);
}
function vc(r, e) {
  return r << e | r >>> 32 - e;
}
function dr(r, e) {
  return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216;
}
function ji(r, e, t) {
  return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t;
}
var CI = hp;
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var TI = CI;
/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */
const x4 = Jr, Ec = fc, DI = TI, b4 = pa;
let LI = class {
  constructor(e, t = (i) => i) {
    this.curve = e, this.encode = t, this.hash = new b4(), this.chacha = new DI(), this.key = Buffer.alloc(32, 0), this.iv = Buffer.alloc(8, 0), this.cache = [new Ec(1), new Ec(1)];
  }
  init(e) {
    x4(Array.isArray(e)), this.hash.init();
    for (const [t, i, n] of e)
      this.hash.update(b4.digest(t)), this.hash.update(i), this.hash.update(this.encode(n));
    return this.key = this.hash.final(), this.cache[0] = new Ec(1), this.cache[1] = new Ec(1), this;
  }
  encrypt(e) {
    const t = this.curve.scalarSize * 2, i = Buffer.alloc(t, 0), n = i.slice(0, this.curve.scalarSize), c = i.slice(this.curve.scalarSize);
    return this.chacha.init(this.key, this.iv, e), this.chacha.encrypt(i), [
      this.curve.decodeScalar(n),
      this.curve.decodeScalar(c)
    ];
  }
  refresh(e) {
    let t = 0;
    for (; ; ) {
      this.iv[4] = t, this.iv[5] = t >>> 8, this.iv[6] = t >>> 16, this.iv[7] = t >>> 24, t += 1;
      const [i, n] = this.encrypt(e);
      if (!(i.isZero() || i.cmp(this.curve.n) >= 0) && !(n.isZero() || n.cmp(this.curve.n) >= 0)) {
        this.cache[0] = i, this.cache[1] = n;
        break;
      }
    }
  }
  generate(e) {
    return x4(e >>> 0 === e), e & 1 && this.refresh(e >>> 1), this.cache[e & 1];
  }
};
var KI = LI;
/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */
const Pi = Jr, $I = KI, p4 = fc;
let HI = class {
  constructor(e, t) {
    this.curve = e, this.hash = t, this.rng = new $I(this.curve, this.encode.bind(this));
  }
  check() {
    if (this.curve.p.andln(3) !== 3)
      throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
  }
  encode(e) {
    Pi(Buffer.isBuffer(e));
    const { fieldSize: t } = this.curve;
    if (e.length === 1 + t)
      return e;
    if (e.length !== 1 + t * 2)
      throw new Error("Invalid point.");
    const i = Buffer.alloc(1 + t);
    return i[0] = 2 | e[e.length - 1] & 1, e.copy(i, 1, 1, 1 + t), i;
  }
  hashInt(...e) {
    const t = new this.hash();
    t.init();
    for (const c of e)
      t.update(c);
    let i = t.final(this.curve.scalarSize);
    i.length > this.curve.scalarSize && (i = i.slice(0, this.curve.scalarSize));
    const n = p4.decode(i, this.curve.endian);
    return n.iumaskn(this.curve.scalarBits), n.imod(this.curve.n);
  }
  hashNonce(e, t) {
    return this.hashInt(e, t);
  }
  hashChallenge(e, t, i) {
    return this.hashInt(e, this.encode(t), i);
  }
  sign(e, t) {
    return Pi(Buffer.isBuffer(e)), this.check(), this._sign(e, t);
  }
  _sign(e, t) {
    const { n: i } = this.curve, n = this.curve.g, c = this.curve.decodeScalar(t);
    if (c.isZero() || c.cmp(i) >= 0)
      throw new Error("Invalid private key.");
    const o = n.mulBlind(c), d = this.hashNonce(t, e);
    if (d.isZero())
      throw new Error("Signing failed (k' = 0).");
    const l = n.mulBlind(d);
    l.isSquare() || d.ineg().imod(i);
    const h = l.encodeX(), x = o.encode(), b = this.hashChallenge(h, x, e), g = d.add(b.mul(c)).imod(i);
    return Buffer.concat([h, this.curve.encodeScalar(g)]);
  }
  verify(e, t, i) {
    if (Pi(Buffer.isBuffer(e)), Pi(Buffer.isBuffer(t)), Pi(Buffer.isBuffer(i)), this.check(), t.length !== this.curve.fieldSize + this.curve.scalarSize)
      return !1;
    try {
      return this._verify(e, t, i);
    } catch {
      return !1;
    }
  }
  _verify(e, t, i) {
    const { p: n, n: c } = this.curve, o = this.curve.g, d = t.slice(0, this.curve.fieldSize), l = t.slice(this.curve.fieldSize), h = this.curve.decodeField(d), x = this.curve.decodeScalar(l), b = this.curve.decodePoint(i);
    if (h.cmp(n) >= 0 || x.cmp(c) >= 0)
      return !1;
    const g = this.hashChallenge(d, i, e), w = o.jmulAdd(x, b, g.ineg().imod(c));
    return !(!w.isSquare() || !w.eqX(h));
  }
  verifyBatch(e) {
    Pi(Array.isArray(e)), this.check();
    for (const t of e) {
      Pi(Array.isArray(t) && t.length === 3);
      const [i, n, c] = t;
      if (Pi(Buffer.isBuffer(i)), Pi(Buffer.isBuffer(n)), Pi(Buffer.isBuffer(c)), n.length !== this.curve.fieldSize + this.curve.scalarSize)
        return !1;
    }
    try {
      return this._verifyBatch(e);
    } catch {
      return !1;
    }
  }
  _verifyBatch(e) {
    const { n: t } = this.curve, i = this.curve.g, n = new Array(1 + e.length * 2), c = new Array(1 + e.length * 2), o = new p4(0);
    this.rng.init(e), n[0] = i, c[0] = o;
    for (let d = 0; d < e.length; d++) {
      const [l, h, x] = e[d], b = h.slice(0, this.curve.fieldSize), g = h.slice(this.curve.fieldSize), w = this.curve.decodeSquare(b), I = this.curve.decodeScalar(g), B = this.curve.decodePoint(x);
      if (I.cmp(t) >= 0)
        return !1;
      const y = this.hashChallenge(b, x, l), A = this.rng.generate(d), _ = y.mul(A).imod(t);
      o.iadd(I.mul(A)).imod(t), n[1 + d * 2 + 0] = w, c[1 + d * 2 + 0] = A, n[1 + d * 2 + 1] = B, c[1 + d * 2 + 1] = _;
    }
    return o.ineg().imod(t), this.curve.jmulAll(n, c).isInfinity();
  }
};
var FI = HI;
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */
const Qi = Jr, VI = 281474976710656, GI = Buffer.from([0]), YI = Buffer.from([1]);
let up = class {
  constructor(e, t, i, n) {
    Qi(e && typeof e.id == "string"), this.hash = e, this.minEntropy = e.id === "SHA1" ? 10 : 24, this.K = Buffer.alloc(e.size), this.V = Buffer.alloc(e.size), this.rounds = 0, t && this.init(t, i, n);
  }
  init(e, t, i) {
    t == null && (t = Buffer.alloc(0)), i == null && (i = Buffer.alloc(0)), Qi(Buffer.isBuffer(e)), Qi(Buffer.isBuffer(t)), Qi(Buffer.isBuffer(i));
    for (let c = 0; c < this.V.length; c++)
      this.K[c] = 0, this.V[c] = 1;
    const n = Buffer.concat([e, t, i]);
    if (n.length < this.minEntropy)
      throw new Error("Not enough entropy.");
    return this.update(n), this.rounds = 1, this;
  }
  reseed(e, t) {
    if (t == null && (t = Buffer.alloc(0)), Qi(Buffer.isBuffer(e)), Qi(Buffer.isBuffer(t)), this.rounds === 0)
      throw new Error("DRBG not initialized.");
    const i = Buffer.concat([e, t]);
    if (i.length < this.minEntropy)
      throw new Error("Not enough entropy.");
    return this.update(i), this.rounds = 1, this;
  }
  generate(e, t) {
    if (Qi(e >>> 0 === e), Qi(t == null || Buffer.isBuffer(t)), this.rounds === 0)
      throw new Error("DRBG not initialized.");
    if (this.rounds > VI)
      throw new Error("Reseed is required.");
    t && t.length > 0 && this.update(t);
    const i = Math.ceil(e / this.hash.size), n = Buffer.alloc(i * this.hash.size);
    for (let c = 0; c < i; c++)
      this.V = this.mac(this.V), this.V.copy(n, c * this.hash.size);
    return this.update(t), this.rounds += 1, n.slice(0, e);
  }
  randomBytes(e) {
    return this.generate(e);
  }
  /*
   * Helpers
   */
  mac(e) {
    return this.hash.mac(e, this.K);
  }
  hmac() {
    return this.hash.hmac().init(this.K);
  }
  update(e) {
    Qi(e == null || Buffer.isBuffer(e));
    const t = this.hmac();
    if (t.update(this.V), t.update(GI), e && t.update(e), this.K = t.final(), this.V = this.mac(this.V), e && e.length > 0) {
      const i = this.hmac();
      i.update(this.V), i.update(YI), i.update(e), this.K = i.final(), this.V = this.mac(this.V);
    }
    return this;
  }
};
up.native = 0;
var JI = up;
/*!
 * hmac-drbg.js - hmac-drbg for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var XI = JI, U0 = {};
/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */
const { custom: Wn } = Yl(), Ee = fc, Ci = {
  AFFINE: 0,
  JACOBIAN: 1,
  PROJECTIVE: 2,
  EXTENDED: 3
}, ZI = [
  -3,
  // -1 -1
  -1,
  // -1 0
  -5,
  // -1 1
  -7,
  // 0 -1
  0,
  // 0 0
  7,
  // 0 1
  5,
  // 1 -1
  1,
  // 1 0
  3
  // 1 1
];
let WI = 0;
class k0 {
  constructor(e, t, i) {
    this.Point = null, this.id = null, this.uid = WI++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(e, t, i);
  }
  _init(e, t, i) {
    fe(typeof e == "function"), fe(typeof t == "string"), fe(i && typeof i == "object"), fe(i.red == null || i.red instanceof Ee.Red), fe(i.p != null, "Must pass a prime."), fe(i.id == null || typeof i.id == "string"), fe(i.ossl == null || typeof i.ossl == "string"), fe(i.endian == null || typeof i.endian == "string"), fe(i.hash == null || typeof i.hash == "string"), fe(i.prefix == null || typeof i.prefix == "string"), fe(i.context == null || typeof i.context == "boolean"), fe(i.prime == null || typeof i.prime == "string"), fe(i.torsion == null || Array.isArray(i.torsion)), this.Point = e, this.id = i.id || null, this.ossl = i.ossl || null, this.type = t, this.endian = i.endian || (t === "short" ? "be" : "le"), this.hash = i.hash || null, this.prefix = i.prefix ? Buffer.from(i.prefix, "binary") : null, this.context = i.context || !1, this.prime = i.prime || null, this.p = Ee.fromJSON(i.p), i.red ? this.red = i.red : (this.red = i.prime ? Ee.red(i.prime) : Ee.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, this.fieldBits & 7 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = Ee.fromJSON(i.n || "0"), this.h = Ee.fromJSON(i.h || "1"), this.q = this.n.mul(this.h), this.z = Ee.fromJSON(i.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new Ee(0).toRed(this.red), this.one = new Ee(1).toRed(this.red), this.two = new Ee(2).toRed(this.red), this.three = new Ee(3).toRed(this.red), this.four = new Ee(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
    for (let n = 0; n < this.torsion.length; n++)
      this.torsion[n] = this.point();
    return this.endo = null, this.hi = null, this._scale = $d(this._scale, this), this.isIsomorphic = $d(this.isIsomorphic, this), this.isIsogenous = $d(this.isIsogenous, this), fe(this.p.sign() > 0 && this.p.isOdd()), fe(this.n.sign() >= 0), fe(this.h.sign() > 0 && this.h.cmpn(255) <= 0), fe(this.endian === "be" || this.endian === "le"), this;
  }
  _finalize(e) {
    if (fe(e && typeof e == "object"), this.g = e.g ? this.pointFromJSON(e.g) : this.point(), e.torsion) {
      fe(e.torsion.length === this.torsion.length);
      for (let t = 0; t < this.torsion.length; t++)
        this.torsion[t] = this.pointFromJSON(e.torsion[t]);
    }
    return this;
  }
  _findTorsion() {
    fe(!this.n.isZero());
    const e = this.h.word(0), t = this.one.redNeg(), i = [this.point()], n = /* @__PURE__ */ new Set();
    let c = e;
    for (; i.length < c; ) {
      let o;
      t.redIAdd(this.one);
      try {
        o = this.pointFromX(t.clone());
      } catch {
        continue;
      }
      try {
        o = o.mul(this.n);
      } catch {
        c = 2;
        continue;
      }
      if (!o.isInfinity()) {
        o.normalize();
        for (const d of [o, o.neg()]) {
          const l = d.key();
          n.has(l) || (i.push(d), n.add(l));
        }
      }
    }
    for (i.sort((o, d) => o.cmp(d)); i.length < e; )
      i.push(this.point());
    return i;
  }
  _fixedMul(e, t) {
    fe(e instanceof Mr), fe(t instanceof Ee), fe(e.pre && e.pre.windows);
    const { width: i, points: n } = e._getWindows(0, 0), c = 1 << i, d = (t.bitLength() + i - 1) / i >>> 0;
    let l = this.jpoint();
    for (let h = 0; h < d; h++) {
      const x = t.bits(h * i, i);
      l = l.add(n[h * c + x]);
    }
    return t.isNeg() && (l = l.neg()), l;
  }
  _fixedNafMul(e, t) {
    fe(e instanceof Mr), fe(t instanceof Ee), fe(e.pre && e.pre.doubles);
    const { step: i, points: n } = e._getDoubles(0, 0), c = bA(t, 2, t.bitLength() + 1, i), o = ((1 << i + 1) - (i % 2 === 0 ? 2 : 1)) / 3;
    let d = this.jpoint(), l = this.jpoint();
    for (let h = o; h > 0; h--) {
      for (let x = 0; x < c.length; x++) {
        const b = c[x];
        b === h ? l = l.add(n[x]) : b === -h && (l = l.sub(n[x]));
      }
      d = d.add(l);
    }
    return d;
  }
  _wnafMul(e, t, i) {
    fe(t instanceof Mr), fe(i instanceof Ee);
    const { width: n, points: c } = t._safeNAF(e), o = Gc(i, n, i.bitLength() + 1);
    let d = this.jpoint();
    for (let l = o.length - 1; l >= 0; l--) {
      const h = o[l];
      l !== o.length - 1 && (d = d.dbl()), h > 0 ? d = d.add(c[h - 1 >> 1]) : h < 0 && (d = d.sub(c[-h - 1 >> 1]));
    }
    return d;
  }
  _wnafMulAdd(e, t, i) {
    fe(e >>> 0 === e), fe(Array.isArray(t)), fe(Array.isArray(i)), fe(t.length === i.length);
    const n = t.length, c = new Array(n), o = new Array(n);
    let d = 0;
    for (let g = 0; g < n; g++) {
      const w = t[g], I = i[g];
      if (fe(w instanceof Mr), fe(I instanceof Ee), g > 0 && w.type !== t[g - 1].type)
        throw new Error("Cannot mix points.");
      c[g] = null, o[g] = null, d = Math.max(d, I.bitLength() + 1);
    }
    let l = null, h = null, x = 0;
    for (let g = 0; g < n; g++) {
      const w = t[g], I = i[g], B = w._getNAF(0);
      if (B) {
        c[x] = B.points, o[x] = Gc(I, B.width, d), x += 1;
        continue;
      }
      if (!l) {
        l = w, h = I;
        continue;
      }
      c[x] = l._getJNAF(w), o[x] = mA(h, I, d), l = null, h = null, x += 1;
    }
    if (l) {
      const g = l._safeNAF(e);
      c[x] = g.points, o[x] = Gc(h, g.width, d), x += 1;
    }
    let b = this.jpoint();
    for (let g = d - 1; g >= 0; g--) {
      g !== d - 1 && (b = b.dbl());
      for (let w = 0; w < x; w++) {
        const I = o[w][g];
        I > 0 ? b = b.add(c[w][I - 1 >> 1]) : I < 0 && (b = b.sub(c[w][-I - 1 >> 1]));
      }
    }
    return b;
  }
  _endoWnafMulAdd(e, t) {
    throw new Error("Not implemented.");
  }
  _scale(e, t) {
    switch (fe(e instanceof k0), fe(e.p.eq(this.p)), e.type) {
      case "short":
        return this._scaleShort(e, t);
      case "mont":
        return this._scaleMont(e, t);
      case "edwards":
        return this._scaleEdwards(e, t);
      default:
        throw new Error("Not implemented.");
    }
  }
  _scaleShort(e, t) {
    throw new Error("Not implemented.");
  }
  _scaleMont(e, t) {
    throw new Error("Not implemented.");
  }
  _scaleEdwards(e, t) {
    throw new Error("Not implemented.");
  }
  isElliptic() {
    throw new Error("Not implemented.");
  }
  jinv() {
    throw new Error("Not implemented.");
  }
  isComplete() {
    return !1;
  }
  precompute(e) {
    return fe(!this.g.isInfinity(), "Must have base point."), fe(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), e), this;
  }
  scalar(e, t, i) {
    const n = new Ee(e, t, i);
    return fe(!n.red), this.n.isZero() ? n : n.imod(this.n);
  }
  field(e, t, i) {
    const n = Ee.cast(e, t, i);
    return n.red ? n.forceRed(this.red) : n.toRed(this.red);
  }
  point(e, t) {
    throw new Error("Not implemented.");
  }
  jpoint(e, t, i) {
    throw new Error("Not implemented.");
  }
  xpoint(e, t) {
    throw new Error("Not implemented.");
  }
  cpoint(e, t, i, n) {
    if (fe(e instanceof Ee), fe(t instanceof Ee), fe(i instanceof Ee), fe(n instanceof Ee), t.isZero() || n.isZero())
      return this.point();
    const c = t.redMul(n).redInvert(), o = e.redMul(n).redMul(c), d = i.redMul(t).redMul(c);
    return this.point(o, d);
  }
  solveX2(e) {
    throw new Error("Not implemented.");
  }
  solveX(e) {
    return this.solveX2(e).redSqrt();
  }
  solveY2(e) {
    throw new Error("Not implemented.");
  }
  solveY(e) {
    return this.solveY2(e).redSqrt();
  }
  validate(e) {
    throw new Error("Not implemented.");
  }
  pointFromX(e, t) {
    throw new Error("Not implemented.");
  }
  pointFromY(e, t) {
    throw new Error("Not implemented.");
  }
  isIsomorphic(e) {
    throw new Error("Not implemented.");
  }
  isIsogenous(e) {
    throw new Error("Not implemented.");
  }
  pointFromShort(e) {
    throw new Error("Not implemented.");
  }
  pointFromMont(e, t) {
    throw new Error("Not implemented.");
  }
  pointFromEdwards(e) {
    throw new Error("Not implemented.");
  }
  pointFromUniform(e) {
    throw new Error("Not implemented.");
  }
  pointToUniform(e) {
    throw new Error("Not implemented.");
  }
  pointFromHash(e, t = !1) {
    if (fe(Buffer.isBuffer(e)), fe(typeof t == "boolean"), e.length !== this.fieldSize * 2)
      throw new Error("Invalid hash size.");
    const i = e.slice(0, this.fieldSize), n = e.slice(this.fieldSize), c = this.decodeUniform(i), o = this.decodeUniform(n), d = this.pointFromUniform(c), l = this.pointFromUniform(o), h = d.add(l);
    return t ? h.mulH() : h;
  }
  pointToHash(e, t, i) {
    fe(e instanceof this.Point), fe(t >>> 0 === t);
    const n = t % this.torsion.length, c = e.add(this.torsion[n]);
    for (; ; ) {
      const o = this.randomField(i), d = this.pointFromUniform(o);
      if (d.neg().eq(d))
        continue;
      const l = c.sub(d), h = w4(i);
      let x;
      try {
        x = this.pointToUniform(l, h & 15);
      } catch (w) {
        if (w.message === "Invalid point.")
          continue;
        throw w;
      }
      const b = this.encodeUniform(o, h >>> 8), g = this.encodeUniform(x, h >>> 16);
      return Buffer.concat([b, g]);
    }
  }
  randomScalar(e) {
    const t = this.n.isZero() ? this.p : this.n;
    return Ee.random(e, 1, t);
  }
  randomField(e) {
    return Ee.random(e, 1, this.p).toRed(this.red);
  }
  randomPoint(e) {
    let t;
    for (; ; ) {
      const i = this.randomField(e), n = (w4(e) & 1) !== 0;
      try {
        t = this.pointFromX(i, n);
      } catch {
        continue;
      }
      return fe(t.validate()), t.mulH();
    }
  }
  mulAll(e, t) {
    return this.jmulAll(e, t);
  }
  jmulAll(e, t) {
    return fe(Array.isArray(e)), fe(e.length === 0 || e[0] instanceof Mr), this.endo && e.length > 0 && e[0].type === Ci.AFFINE ? this._endoWnafMulAdd(e, t) : this._wnafMulAdd(5, e, t);
  }
  mulH(e) {
    return fe(e instanceof Ee), this.imulH(e.clone());
  }
  imulH(e) {
    fe(e instanceof Ee), fe(!e.red);
    const t = this.h.word(0);
    if (!(t & t - 1)) {
      const i = this.h.bitLength();
      return e.iushln(i - 1).imod(this.n);
    }
    return e.imuln(t).imod(this.n);
  }
  normalizeAll(e) {
    fe(Array.isArray(e));
    const t = e.length, i = new Array(t);
    for (let o = 0; o < t; o++) {
      const d = e[o];
      if (fe(d instanceof Mr), fe(d.curve === this), d.type === Ci.AFFINE) {
        i[o] = this.one;
        continue;
      }
      i[o] = d.z;
    }
    const n = this.red.invertAll(i), c = new Array(t);
    for (let o = 0; o < t; o++)
      c[o] = e[o].scale(n[o]);
    return c;
  }
  affinizeAll(e) {
    return this.normalizeAll(e);
  }
  clamp(e) {
    fe(Buffer.isBuffer(e)), fe(e.length === this.scalarSize), fe(this.scalarSize <= this.fieldSize);
    let t = this.fieldBits & 7 || 8, i = 0, n = this.scalarSize - 1;
    return this.endian === "be" && ([i, n] = [n, i]), this.scalarSize < this.fieldSize && (t = 8), e[i] &= -this.h.word(0) & 255, e[n] &= (1 << t) - 1, e[n] |= 1 << t - 1, e;
  }
  splitHash(e) {
    fe(Buffer.isBuffer(e)), fe(e.length === this.adjustedSize * 2), fe(this.scalarSize <= this.adjustedSize);
    let t = 0;
    this.endian === "be" && (t = this.adjustedSize - this.scalarSize);
    const i = e.slice(t, t + this.scalarSize), n = e.slice(this.adjustedSize);
    return this.clamp(i), [i, n];
  }
  encodeField(e) {
    return fe(e instanceof Ee), fe(!e.red), e.encode(this.endian, this.fieldSize);
  }
  decodeField(e) {
    if (fe(Buffer.isBuffer(e)), e.length !== this.fieldSize)
      throw new Error("Invalid field element size.");
    return Ee.decode(e, this.endian);
  }
  encodeAdjusted(e) {
    return fe(e instanceof Ee), fe(!e.red), e.encode(this.endian, this.adjustedSize);
  }
  decodeAdjusted(e) {
    if (fe(Buffer.isBuffer(e)), e.length !== this.adjustedSize)
      throw new Error("Invalid field element size.");
    return Ee.decode(e, this.endian);
  }
  encodeScalar(e) {
    return fe(e instanceof Ee), fe(!e.red), e.encode(this.endian, this.scalarSize);
  }
  decodeScalar(e) {
    if (fe(Buffer.isBuffer(e)), e.length !== this.scalarSize)
      throw new Error("Invalid scalar size.");
    return Ee.decode(e, this.endian);
  }
  encodeClamped(e) {
    return this.clamp(this.encodeScalar(e));
  }
  decodeClamped(e) {
    if (fe(Buffer.isBuffer(e)), e.length !== this.scalarSize)
      throw new Error("Invalid scalar size.");
    const t = this.clamp(Buffer.from(e));
    return Ee.decode(t, this.endian);
  }
  encodeUniform(e, t) {
    fe(e instanceof Ee), fe(t >>> 0 === t);
    const i = this.endian === "le" ? this.fieldSize - 1 : 0, n = e.fromRed().encode(this.endian, this.fieldSize);
    return n[i] |= t & ~this.mask & 255, n;
  }
  decodeUniform(e) {
    if (fe(Buffer.isBuffer(e)), e.length !== this.fieldSize)
      throw new Error("Invalid field size.");
    const t = Ee.decode(e, this.endian);
    return t.iumaskn(this.fieldBits), t.toRed(this.red);
  }
  encodePoint(e, t) {
    return fe(e instanceof Mr), e.encode(t);
  }
  decodePoint(e) {
    throw new Error("Not implemented.");
  }
  encodeX(e) {
    throw new Error("Not implemented.");
  }
  decodeX(e) {
    throw new Error("Not implemented.");
  }
  decodeEven(e) {
    throw new Error("Not implemented.");
  }
  decodeSquare(e) {
    throw new Error("Not implemented.");
  }
  toShort() {
    throw new Error("Not implemented.");
  }
  toMont(e) {
    throw new Error("Not implemented.");
  }
  toEdwards(e) {
    throw new Error("Not implemented.");
  }
  pointToJSON(e, t) {
    return fe(e instanceof Mr), e.toJSON(t);
  }
  pointFromJSON(e) {
    throw new Error("Not implemented.");
  }
  toJSON(e) {
    let t, i, n, c, o;
    return this.type === "edwards" && (t = this.prefix ? this.prefix.toString() : null, i = this.context), this.n.isZero() || (n = this.n.toJSON()), this.z.isZero() || (c = this.z.fromRed(), this.z.redIsHigh() && c.isub(this.p), c = c.toString(16)), this.endo && (o = this.endo.toJSON()), {
      id: this.id,
      ossl: this.ossl,
      type: this.type,
      endian: this.endian,
      hash: this.hash,
      prefix: t,
      context: i,
      prime: this.prime,
      p: this.p.toJSON(),
      a: void 0,
      b: void 0,
      d: void 0,
      n,
      h: this.h.toString(16),
      s: void 0,
      z: c,
      c: void 0,
      g: this.g.toJSON(e),
      endo: o
    };
  }
  static fromJSON(e) {
    return new this(e);
  }
}
class Mr {
  constructor(e, t) {
    fe(e instanceof k0), fe(t >>> 0 === t), this.curve = e, this.type = t, this.pre = null;
  }
  _init() {
    throw new Error("Not implemented.");
  }
  _safeNAF(e) {
    if (fe(e >>> 0 === e), this.pre && this.pre.naf)
      return this.pre.naf;
    if (e === 0)
      return null;
    const t = 1 << e - 2, i = new Array(t), n = this.toJ(), c = t === 1 ? null : n.dbl();
    i[0] = n;
    for (let o = 1; o < t; o++)
      i[o] = i[o - 1].add(c);
    return new C1(e, i);
  }
  _getNAF(e) {
    if (fe(e >>> 0 === e), this.pre && this.pre.naf)
      return this.pre.naf;
    if (e === 0)
      return null;
    const t = this._safeNAF(e).points, i = this.curve.affinizeAll(t);
    return new C1(e, i);
  }
  _getWindows(e, t) {
    if (fe(e >>> 0 === e), fe(t >>> 0 === t), this.pre && this.pre.windows)
      return this.pre.windows;
    if (e === 0)
      return null;
    const i = 1 << e, n = (t + e - 1) / e >>> 0, c = new Array(n * i);
    let o = this.toJ();
    for (let l = 0; l < n; l++) {
      c[l * i] = this.curve.jpoint();
      for (let h = 1; h < i; h++)
        c[l * i + h] = c[l * i + h - 1].add(o);
      o = o.dblp(e);
    }
    const d = this.curve.affinizeAll(c);
    return new lp(e, t, d);
  }
  _getDoubles(e, t) {
    if (fe(e >>> 0 === e), fe(t >>> 0 === t), this.pre && this.pre.doubles)
      return this.pre.doubles;
    if (e === 0)
      return null;
    const i = Math.ceil(t / e) + 1, n = new Array(i);
    let c = this.toJ(), o = 0;
    n[o++] = c;
    for (let l = 0; l < t; l += e) {
      for (let h = 0; h < e; h++)
        c = c.dbl();
      n[o++] = c;
    }
    fe(o === i);
    const d = this.curve.affinizeAll(n);
    return new xp(e, d);
  }
  _getBeta() {
    return null;
  }
  _getBlinding(e) {
    if (this.pre && this.pre.blinding)
      return this.pre.blinding;
    if (!e || this.curve.n.isZero())
      return null;
    const t = this.curve.randomScalar(e), i = this.mul(t);
    return new bp(t, i);
  }
  _hasWindows(e) {
    if (fe(e instanceof Ee), !this.pre || !this.pre.windows)
      return !1;
    const { width: t, bits: i } = this.pre.windows, n = (i + t - 1) / t >>> 0;
    return e.bitLength() <= n * t;
  }
  _hasDoubles(e) {
    if (fe(e instanceof Ee), !this.pre || !this.pre.doubles)
      return !1;
    const { step: t, points: i } = this.pre.doubles, n = e.bitLength() + 1;
    return i.length >= Math.ceil(n / t) + 1;
  }
  _getJNAF(e) {
    return fe(e instanceof Mr), fe(e.type === this.type), [
      this,
      // 1
      this.add(e),
      // 3
      this.sub(e),
      // 5
      e
      // 7
    ];
  }
  _blind(e, t) {
    if (fe(e instanceof Ee), fe(!e.red), this.pre && this.pre.blinding) {
      const { blind: n, unblind: c } = this.pre.blinding, o = e.sub(n);
      return [this, o, c];
    }
    if (!t)
      return [this, e, null];
    if (this.pre) {
      if (this.curve.n.isZero())
        return [this, e, null];
      const o = this.curve.randomScalar(t).mul(this.curve.n).iadd(e);
      return [this, o, null];
    }
    return [this.randomize(t), e, null];
  }
  clone() {
    throw new Error("Not implemented.");
  }
  precompute(e, t) {
    return fe(e >>> 0 === e), this.pre || (this.pre = new Ql()), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, e + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(t)), this;
  }
  validate() {
    return this.curve.validate(this);
  }
  normalize() {
    return this;
  }
  scale(e) {
    throw new Error("Not implemented.");
  }
  randomize(e) {
    const t = this.curve.randomField(e);
    return this.scale(t);
  }
  neg() {
    throw new Error("Not implemented.");
  }
  add(e) {
    throw new Error("Not implemented.");
  }
  sub(e) {
    return fe(e instanceof Mr), this.add(e.neg());
  }
  dbl() {
    throw new Error("Not implemented.");
  }
  dblp(e) {
    fe(e >>> 0 === e);
    let t = this;
    for (let i = 0; i < e; i++)
      t = t.dbl();
    return t;
  }
  diffAddDbl(e, t) {
    throw new Error("Not implemented.");
  }
  getX() {
    throw new Error("Not implemented.");
  }
  getY() {
    throw new Error("Not implemented.");
  }
  eq(e) {
    throw new Error("Not implemented.");
  }
  cmp(e) {
    throw new Error("Not implemented.");
  }
  isInfinity() {
    throw new Error("Not implemented.");
  }
  isOrder2() {
    throw new Error("Not implemented.");
  }
  isOdd() {
    throw new Error("Not implemented.");
  }
  isEven() {
    throw new Error("Not implemented.");
  }
  isSquare() {
    throw new Error("Not implemented.");
  }
  eqX(e) {
    throw new Error("Not implemented.");
  }
  eqR(e) {
    throw new Error("Not implemented.");
  }
  isSmall() {
    return this.isInfinity() ? !1 : this.jmulH().isInfinity();
  }
  hasTorsion() {
    return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity();
  }
  order() {
    const { h: e, n: t } = this.curve;
    let i = this.toJ(), n = new Ee(1);
    for (; !i.isInfinity(); ) {
      if (n.iaddn(1), n.cmp(e) > 0) {
        n = t.clone();
        break;
      }
      i = i.add(this);
    }
    return n;
  }
  mul(e) {
    return this.jmul(e);
  }
  muln(e) {
    return this.jmuln(e);
  }
  mulBlind(e, t) {
    return this.jmulBlind(e, t);
  }
  mulAdd(e, t, i) {
    return this.jmulAdd(e, t, i);
  }
  mulH() {
    return this.jmulH();
  }
  div(e) {
    return this.jdiv(e);
  }
  divn(e) {
    return this.jdivn(e);
  }
  divH() {
    return this.jdivH();
  }
  jmul(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo && this.type === Ci.AFFINE ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(5, this, e);
  }
  jmuln(e) {
    return fe((e | 0) === e), this.jmul(new Ee(e));
  }
  jmulBlind(e, t = null) {
    const [i, n, c] = this._blind(e, t), o = i.jmul(n);
    return c ? o.add(c) : o;
  }
  jmulAdd(e, t, i) {
    return this.curve.endo && this.type === Ci.AFFINE ? this.curve._endoWnafMulAdd([this, t], [e, i]) : this.curve._wnafMulAdd(5, [this, t], [e, i]);
  }
  jmulH() {
    const e = this.curve.h.word(0);
    if (!(e & e - 1)) {
      const t = this.curve.h.bitLength();
      return this.toJ().dblp(t - 1);
    }
    return this.jmul(this.curve.h);
  }
  jdiv(e) {
    return fe(e instanceof Ee), fe(!e.red), this.jmul(e.invert(this.curve.n));
  }
  jdivn(e) {
    return fe(!this.curve.n.isZero()), this.curve.h.cmpn(e) === 0 ? this.jdivH() : this.jdiv(new Ee(e));
  }
  jdivH() {
    return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi));
  }
  toP() {
    return this.normalize();
  }
  toJ() {
    return this;
  }
  toX() {
    return this;
  }
  key() {
    if (this.isInfinity())
      return `${this.curve.uid}:oo`;
    this.normalize();
    const e = this.getX().toString(16), t = this.getY().toString(16);
    return `${this.curve.uid}:${e},${t}`;
  }
  encode(e) {
    throw new Error("Not implemented.");
  }
  static decode(e, t) {
    throw new Error("Not implemented.");
  }
  encodeX() {
    throw new Error("Not implemented.");
  }
  static decodeX(e, t) {
    throw new Error("Not implemented.");
  }
  static decodeEven(e, t) {
    throw new Error("Not implemented.");
  }
  static decodeSquare(e, t) {
    throw new Error("Not implemented.");
  }
  toJSON(e) {
    throw new Error("Not implemented.");
  }
  static fromJSON(e, t) {
    throw new Error("Not implemented.");
  }
  [Wn]() {
    return "<Point>";
  }
}
class Ir extends k0 {
  constructor(e) {
    super(Nr, "short", e), this.a = Ee.fromJSON(e.a).toRed(this.red), this.b = Ee.fromJSON(e.b).toRed(this.red), this.c = Ee.fromJSON(e.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(e);
  }
  _finalize(e) {
    return super._finalize(e), e.endo != null ? this.endo = m4.fromJSON(this, e.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this;
  }
  static _isomorphism(e, t, i, n) {
    if (fe(e instanceof Ee), fe(t instanceof Ee), fe(i instanceof Ee), fe(n == null || typeof n == "boolean"), fe(!e.isZero() || !t.isZero()), i.isZero())
      throw new Error("Invalid coefficient.");
    if (e.isZero()) {
      const b = i, g = b.redDiv(t), w = g4(g);
      return fe(w.redJacobi() === 1), [e.clone(), b.clone()];
    }
    if (t.isZero()) {
      const b = i, w = b.redDiv(e).redSqrt();
      if (w.redJacobi() !== 1 && w.redINeg(), w.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [b.clone(), t.clone()];
    }
    const c = i, o = c.redDiv(e), d = o.redSqrt();
    if (n != null ? d.redIsOdd() !== n && d.redINeg() : d.redJacobi() !== 1 && d.redINeg(), d.redJacobi() !== 1)
      throw new Error("Invalid `a` coefficient.");
    const l = o.redMul(d), h = e.redMul(o), x = t.redMul(l);
    return fe(h.eq(c)), [h, x];
  }
  _short(e, t) {
    return Ir._isomorphism(this.a, this.b, e, t);
  }
  _mont(e, t) {
    const [i, n] = this._findRS(t), c = n.redInvert(), o = i.redMuln(3).redMul(c);
    return e != null ? Or._isomorphism(o, c, e) : [o, c];
  }
  _edwards(e, t) {
    const [i, n] = this._findRS(t), c = i.redMuln(3), o = n.redMuln(2), d = c.redAdd(o), l = c.redSub(o);
    return e != null ? t0._isomorphism(d, l, e) : [d, l];
  }
  _findRS(e) {
    fe(e == null || typeof e == "boolean"), fe(this.h.word(0) >= 4), fe(!this.n.isZero());
    const t = this.one.redNeg();
    let i;
    for (; ; ) {
      t.redIAdd(this.one);
      try {
        i = this.pointFromX(t.clone());
      } catch {
        continue;
      }
      if (i = i.mul(this.n), !i.isInfinity() && i.y.isZero())
        break;
    }
    const n = i.x, o = n.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
    return e != null && o.redIsOdd() !== e && o.redINeg(), [n, o];
  }
  _scale0(e, t) {
    if (fe(this.a.isZero() === e.isZero()), fe(this.b.isZero() === t.isZero()), this.a.isZero()) {
      const l = this.b.redDiv(this.field(t)), h = g4(l), x = h.redSqrt(), b = h.redMul(x);
      return fe(b.redSqr().eq(l)), fe(!x.isZero()), [h, b];
    }
    if (this.b.isZero()) {
      const l = this.a.redDiv(this.field(e)), h = l.redSqrt();
      h.redJacobi() !== 1 && h.redINeg();
      const x = h.redSqrt(), b = h.redMul(x);
      return fe(b.redMul(x).eq(l)), fe(!x.isZero()), [h, b];
    }
    const i = this.a.redDiv(this.field(e)), n = this.b.redDiv(this.field(t)), c = i.redSqrt();
    i.redMul(c).eq(n) || c.redINeg(), fe(i.redMul(c).eq(n));
    const o = c.redSqrt(), d = c.redMul(o);
    return fe(!o.isZero()), [c, d];
  }
  _scale1(e, t) {
    const i = this.g.x.redDiv(this.field(e)), n = this.g.y.redDiv(this.field(t)), c = i.redSqrt();
    return i.redMul(c).eq(n) || c.redINeg(), fe(i.redMul(c).eq(n)), fe(!c.isZero()), [i, n];
  }
  _scaleShort(e) {
    return fe(e instanceof Ir), this.g.isInfinity() || e.g.isInfinity() ? this._scale0(e.a, e.b) : this._scale1(e.g.x, e.g.y);
  }
  _scaleMont(e) {
    if (fe(e instanceof Or), this.g.isInfinity() || e.g.isInfinity()) {
      const [o, d] = e._short();
      return this._scale0(o, d);
    }
    const { x: t, y: i } = e.g, n = t.redAdd(e.a3).redMul(e.bi), c = i.redMul(e.bi);
    return this._scale1(n, c);
  }
  _scaleEdwards(e) {
    if (fe(e instanceof t0), this.g.isInfinity() || e.g.isInfinity()) {
      const [q, U] = e._short();
      return this._scale0(q, U);
    }
    const { x: t, y: i, z: n } = e.g, c = e.a.redMuln(5), o = e.d.redMuln(5), d = e.d.redSub(e.a), l = o.redSub(e.a), h = e.d.redSub(c), x = i.redAdd(n), b = i.redSub(n), g = l.redMul(i).redIAdd(h.redMul(n)), w = b.redMuln(12), I = d.redMul(x).redMul(n), B = b.redMul(t).redIMuln(4), y = w.redMul(B).redInvert(), A = g.redMul(B).redMul(y), _ = I.redMul(w).redMul(y);
    return this._scale1(A, _);
  }
  _getEndomorphism(e = 0) {
    if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
      return null;
    const [t, i] = this._getEndoRoots(this.p), n = [t, i][e & 1].toRed(this.red), [c, o] = this._getEndoRoots(this.n), d = this.point(this.g.x.redMul(n), this.g.y);
    let l;
    this.g.mul(c).eq(d) ? l = c : (fe(this.g.mul(o).eq(d)), l = o);
    const h = this._getEndoBasis(l), x = this._getEndoPrecomp(h);
    return new m4(n, l, h, x);
  }
  _getEndoRoots(e) {
    const t = e === this.p ? this.red : Ee.mont(e), i = new Ee(2).toRed(t), n = new Ee(3).toRed(t), c = i.redInvert(), o = n.redNeg().redSqrt().redMul(c), d = o.redNeg(), l = o.redSub(c).fromRed(), h = d.redSub(c).fromRed();
    return [l, h].sort(Ee.cmp);
  }
  _getEndoBasis(e) {
    const [t, i, n, c, o, d] = this._egcdSqrt(e), l = n, h = c.neg(), x = t.sqr().iadd(i.sqr()), b = o.sqr().iadd(d.sqr());
    let g, w;
    return x.cmp(b) <= 0 ? (g = t, w = i.neg()) : (g = o, w = d.neg()), [
      new _n(l, h),
      new _n(g, w)
    ];
  }
  _egcdSqrt(e) {
    fe(e instanceof Ee), fe(!e.red), fe(e.sign() > 0), fe(this.n.sign() > 0);
    const t = this.n.ushrn(this.n.bitLength() >>> 1);
    let i = e, n = this.n.clone(), c = new Ee(1), o = new Ee(0), d = new Ee(0), l = new Ee(1), h, x, b, g, w = 0, I = 0, B;
    for (; !i.isZero() && w < 2; ) {
      const _ = n.quo(i), q = n.sub(_.mul(i)), U = d.sub(_.mul(c)), z = l.sub(_.mul(o));
      I === 0 && q.cmp(t) < 0 && (h = B, x = c, b = q, g = U, I = 1), B = q, n = i, i = q, d = c, c = U, l = o, o = z, w += I;
    }
    return fe(I !== 0, "Could not find r < sqrt(n)."), [
      h,
      x,
      b,
      g,
      d,
      c
    ];
  }
  _getEndoPrecomp(e) {
    fe(Array.isArray(e)), fe(e.length === 2), fe(e[0] instanceof _n), fe(e[1] instanceof _n);
    const [t, i] = e, n = t.a.mul(i.b).isub(t.b.mul(i.a)), c = n.bitLength(), o = c >= 160;
    fe(n.eq(this.n));
    let d = c + Math.ceil(c / 2) + 1, l, h;
    for (o && (d -= d & 63); d > c && (l = i.b.ushln(d).divRound(n), h = t.b.ushln(d).divRound(n), !(l.ucmp(n) < 0 && h.ucmp(n) < 0)); )
      o ? d -= 64 : d -= 1;
    if (d <= c)
      throw new Error("Could not calculate g1 and g2.");
    return [d, l, h];
  }
  _endoSplit(e) {
    fe(e instanceof Ee), fe(!e.red), fe(!this.n.isZero());
    const [t, i] = this.endo.basis, n = i.b.mul(e).divRound(this.n), c = t.b.neg().mul(e).divRound(this.n), o = n.mul(t.a), d = c.mul(i.a), l = n.ineg().mul(t.b), h = c.mul(i.b), x = e.sub(o).isub(d), b = l.isub(h);
    return [x, b];
  }
  _endoBeta(e) {
    return fe(e instanceof Nr), [e, e._getBeta()];
  }
  _endoWnafMulAdd(e, t) {
    fe(Array.isArray(e)), fe(Array.isArray(t)), fe(e.length === t.length), fe(this.endo != null);
    const i = e.length, n = new Array(i * 2), c = new Array(i * 2);
    for (let o = 0; o < i; o++) {
      const [d, l] = this._endoBeta(e[o]), [h, x] = this._endoSplit(t[o]);
      n[o * 2 + 0] = d, c[o * 2 + 0] = h, n[o * 2 + 1] = l, c[o * 2 + 1] = x;
    }
    return this._wnafMulAdd(5, n, c);
  }
  _sswu(e) {
    const { b: t, z: i, ai: n, zi: c, one: o } = this, d = i.redSqr(), l = t.redNeg().redMul(n), h = t.redMul(c).redMul(n), x = e.redSqr(), b = x.redSqr(), g = d.redMul(b).redIAdd(i.redMul(x)), w = g.isZero() ? g : g.redInvert(), I = w.isZero() ? h : l.redMul(o.redAdd(w)), B = i.redMul(x).redMul(I), y = this.solveY2(I), A = this.solveY2(B), _ = y.redIsSquare() | 0, q = [I, B][_ ^ 1], U = [y, A][_ ^ 1].redSqrt();
    return U.redIsOdd() !== e.redIsOdd() && U.redINeg(), this.point(q, U);
  }
  _sswui(e, t) {
    const { a: i, b: n, z: c } = this, { x: o, y: d } = e, l = t & 3, h = i.redSqr().redMul(o.redSqr()), x = i.redMul(n).redMul(o).redIMuln(2), b = n.redSqr().redMuln(3), g = i.redMul(o).redIAdd(n), w = h.redISub(x).redISub(b).redSqrt(), I = g.redSub(w).redINeg(), B = g.redAdd(w).redINeg(), y = g.redMul(c).redIMuln(2), A = n.redMul(c).redIMuln(2), _ = [I, B][l & 1], q = [y, A][l >>> 1], U = _.redDivSqrt(q);
    return U.redIsOdd() !== d.redIsOdd() && U.redINeg(), U;
  }
  _svdwf(e) {
    const { c: t, z: i, zi: n, i2: c, i3: o } = this, d = this.solveY2(i), l = o.redMul(n.redSqr()), h = e.redSqr(), x = h.redSqr(), b = h.redAdd(d), g = h.redMul(b), w = g.isZero() ? g : g.redInvert(), I = x.redMul(w).redMul(t), B = b.redSqr().redMul(b), y = t.redSub(i).redMul(c).redISub(I), A = I.redSub(t.redAdd(i).redMul(c)), _ = i.redSub(B.redMul(w).redMul(l)), q = this.solveY2(y), U = this.solveY2(A), z = this.solveY2(_), E = q.redJacobi() | 1, H = U.redJacobi() | 1, k = gA((E - 1) * H, 3), V = [y, A, _][k], T = [q, U, z][k];
    return [V, T];
  }
  _svdw(e) {
    const [t, i] = this._svdwf(e), n = i.redSqrt();
    return n.redIsOdd() !== e.redIsOdd() && n.redINeg(), this.point(t, n);
  }
  _svdwi(e, t) {
    const { b: i, c: n, z: c, zero: o, two: d } = this, { x: l, y: h } = e, x = t & 3, b = c.redSqr(), g = b.redMul(c), w = b.redSqr(), I = g.redAdd(i), B = I.redMuln(2), y = l.redSqr(), A = l.redMuln(2).redIAdd(c), _ = l.redMul(b), q = n.redSub(A), U = n.redAdd(A), z = y.redMul(b).redIAdd(w).redIMuln(9), E = l.redMul(g).redIMuln(18), H = I.redMul(l.redSub(c)).redIMuln(12), V = (x >= 2 ? z.redISub(E).redIAdd(H).redSqrt() : o).redMul(c), T = g.redISub(_).redIMuln(3).redISub(B), ie = I.redMul(q), N = I.redMul(U), G = T.redAdd(V), F = T.redSub(V), W = d, ce = [ie, N, G, F][x], ne = [U, q, W, W][x], xe = ce.redDivSqrt(ne), [he] = this._svdwf(xe);
    if (!he.eq(l))
      throw new Error("Invalid point.");
    return xe.redIsOdd() !== h.redIsOdd() && xe.redINeg(), xe;
  }
  isElliptic() {
    const { a: e, b: t } = this, n = e.redSqr().redMul(e);
    return !t.redSqr().redMuln(27).redIAdd(n.redMuln(4)).isZero();
  }
  jinv() {
    const { a: e, b: t } = this, n = e.redSqr().redMul(e), c = t.redSqr(), o = n.redMuln(4), d = o.redMuln(1728), l = c.redMuln(27).redIAdd(o);
    if (l.isZero())
      throw new Error("Curve is not elliptic.");
    return d.redDiv(l).fromRed();
  }
  point(e, t) {
    return new Nr(this, e, t);
  }
  jpoint(e, t, i) {
    return new On(this, e, t, i);
  }
  solveX(e) {
    if (fe(e instanceof Ee), !this.a.isZero())
      throw new Error("Not implemented.");
    const i = e.redSqr().redSub(this.b);
    return mp(i);
  }
  solveY2(e) {
    fe(e instanceof Ee);
    const i = e.redSqr().redMul(e).redIAdd(this.b);
    return this.zeroA || (this.threeA ? i.redIAdd(e.redMuln(-3)) : i.redIAdd(this.a.redMul(e))), i;
  }
  validate(e) {
    if (fe(e instanceof Nr), e.inf)
      return !0;
    const { x: t, y: i } = e, n = this.solveY2(t);
    return i.redSqr().eq(n);
  }
  pointFromX(e, t = null) {
    fe(e instanceof Ee), fe(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
    const i = this.solveY(e);
    if (t != null) {
      if (this.h.cmpn(1) > 0 && i.isZero() && t)
        throw new Error("Invalid point.");
      i.redIsOdd() !== t && i.redINeg();
    }
    return this.point(e, i);
  }
  pointFromY(e, t = 0) {
    fe(e instanceof Ee), fe(t >>> 0 === t), e.red || (e = e.toRed(this.red));
    const i = this.solveX(e);
    if (t >= i.length)
      throw new Error("Invalid X coordinate index.");
    const n = i[t];
    return this.point(n, e);
  }
  isIsomorphic(e) {
    if (fe(e instanceof k0), !e.p.eq(this.p))
      return !1;
    let t, i;
    try {
      [t, i] = this._scale(e);
    } catch {
      return !1;
    }
    if (e.type === "short") {
      const n = this.field(e.a).redMul(t.redSqr()), c = this.field(e.b).redMul(i.redSqr());
      return this.a.eq(n) && this.b.eq(c);
    }
    if (e.type === "mont") {
      const { a3: n, bi: c } = e, o = this.field(n.redMul(c)).redMul(t);
      return this.solveY2(o).isZero();
    }
    if (e.type === "edwards") {
      const n = this.field(e.ad6).redMul(t);
      return this.solveY2(n).isZero();
    }
    return !1;
  }
  isIsogenous(e) {
    return fe(e instanceof k0), !1;
  }
  pointFromShort(e) {
    if (fe(e instanceof Nr), this.isIsomorphic(e.curve)) {
      if (e.isInfinity())
        return this.point();
      const [t, i] = this._scale(e.curve), n = this.field(e.x), c = this.field(e.y), o = n.redMul(t), d = c.redMul(i);
      return this.point(o, d);
    }
    throw new Error("Not implemented.");
  }
  pointFromMont(e) {
    if (fe(e instanceof w0), this.isIsomorphic(e.curve)) {
      if (e.isInfinity())
        return this.point();
      const { a3: t, bi: i } = e.curve, [n, c] = this._scale(e.curve), o = e.x.redAdd(t).redMul(i), d = e.y.redMul(i);
      return this.point(
        this.field(o).redMul(n),
        this.field(d).redMul(c)
      );
    }
    throw new Error("Not implemented.");
  }
  pointFromEdwards(e) {
    if (fe(e instanceof m0), this.isIsomorphic(e.curve)) {
      const { a: t, d: i, ad6: n } = e.curve, [c, o] = this._scale(e.curve);
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero()) {
        const z = this.field(n).redMul(c);
        return this.point(z, this.zero);
      }
      const { x: d, y: l, z: h } = e, x = t.redMuln(5), b = i.redMuln(5), g = i.redSub(t), w = b.redSub(t), I = i.redSub(x), B = l.redAdd(h), y = l.redSub(h), A = w.redMul(l).redIAdd(I.redMul(h)), _ = y.redMuln(12), q = g.redMul(B).redMul(h), U = y.redMul(d).redIMuln(4);
      return this.cpoint(
        this.field(A).redMul(c),
        this.field(_),
        this.field(q).redMul(o),
        this.field(U)
      );
    }
    throw new Error("Not implemented.");
  }
  pointFromUniform(e) {
    if (fe(e instanceof Ee), this.z.isZero() || this.b.isZero())
      throw new Error("Not implemented.");
    if (!this.a.isZero())
      return this._sswu(e);
    if (!this.c.isZero())
      return this._svdw(e);
    throw new Error("Not implemented.");
  }
  pointToUniform(e, t) {
    if (fe(e instanceof Nr), fe(t >>> 0 === t), this.z.isZero() || this.b.isZero())
      throw new Error("Not implemented.");
    if (e.isInfinity())
      throw new Error("Invalid point.");
    const i = (t >>> 4 & 15) % this.torsion.length, n = e.add(this.torsion[i]);
    return pp(() => {
      if (!this.a.isZero())
        return this._sswui(n, t);
      if (!this.c.isZero())
        return this._svdwi(n, t);
      throw new Error("Not implemented.");
    });
  }
  mulAll(e, t) {
    return super.mulAll(e, t).toP();
  }
  affinizeAll(e) {
    const t = this.normalizeAll(e);
    for (let i = 0; i < t.length; i++)
      t[i] = t[i].toP();
    return t;
  }
  decodePoint(e) {
    return Nr.decode(this, e);
  }
  encodeX(e) {
    return fe(e instanceof Mr), e.encodeX();
  }
  decodeEven(e) {
    return Nr.decodeEven(this, e);
  }
  decodeSquare(e) {
    return Nr.decodeSquare(this, e);
  }
  toShort(e, t, i = null) {
    const [n, c] = this._short(e, t), o = new Ir({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      b: c,
      n: this.n,
      h: this.h
    });
    if (i != null) {
      const [, d] = o._scale(this);
      d.redIsOdd() !== i && d.redINeg();
    }
    this.g.isInfinity() || (o.g = o.pointFromShort(this.g));
    for (let d = 0; d < this.h.word(0); d++)
      o.torsion[d] = o.pointFromShort(this.torsion[d]);
    return o;
  }
  toMont(e, t, i = null) {
    const [n, c] = this._mont(e, t), o = new Or({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      b: c,
      n: this.n,
      h: this.h
    });
    if (i != null) {
      const [, d] = this._scale(o);
      d.redIsOdd() !== i && d.redINeg();
    }
    this.g.isInfinity() || (o.g = o.pointFromShort(this.g));
    for (let d = 0; d < this.h.word(0); d++)
      o.torsion[d] = o.pointFromShort(this.torsion[d]);
    return o;
  }
  toEdwards(e, t, i = null) {
    const [n, c] = this._edwards(e, t), o = new t0({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      d: c,
      n: this.n,
      h: this.h
    });
    if (i != null) {
      const [, d] = this._scale(o);
      d.redIsOdd() !== i && d.redINeg();
    }
    if (this.g.isInfinity() || (o.g = o.pointFromShort(this.g), o.g.normalize()), o.isComplete())
      for (let d = 0; d < this.h.word(0); d++)
        o.torsion[d] = o.pointFromShort(this.torsion[d]), o.torsion[d].normalize();
    return o;
  }
  pointFromJSON(e) {
    return Nr.fromJSON(this, e);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.a = this.a.fromRed().toJSON(), t.b = this.b.fromRed().toJSON(), this.c.isZero() || (t.c = this.c.fromRed().toJSON()), t;
  }
}
class Nr extends Mr {
  constructor(e, t, i) {
    fe(e instanceof Ir), super(e, Ci.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, t != null && this._init(t, i);
  }
  _init(e, t) {
    fe(e instanceof Ee), fe(t instanceof Ee), this.x = e, this.y = t, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
  }
  _getBeta() {
    if (!this.curve.endo)
      return null;
    if (this.pre && this.pre.beta)
      return this.pre.beta;
    const e = this.x.redMul(this.curve.endo.beta), t = this.curve.point(e, this.y);
    return this.pre && (t.pre = this.pre.map((i) => {
      const n = i.x.redMul(this.curve.endo.beta);
      return this.curve.point(n, i.y);
    }), this.pre.beta = t), t;
  }
  _getJNAF(e) {
    if (fe(e instanceof Nr), this.inf || e.inf)
      return super._getJNAF(e);
    const t = [
      this,
      // 1
      null,
      // 3
      null,
      // 5
      e
      // 7
    ];
    return this.y.eq(e.y) ? (t[1] = this.add(e), t[2] = this.toJ().sub(e)) : this.y.eq(e.y.redNeg()) ? (t[1] = this.toJ().add(e), t[2] = this.sub(e)) : (t[1] = this.toJ().add(e), t[2] = this.toJ().sub(e)), t;
  }
  clone() {
    return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
  }
  scale(e) {
    return this.toJ().scale(e);
  }
  neg() {
    return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
  }
  add(e) {
    if (fe(e instanceof Nr), this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.x.eq(e.x))
      return this.y.eq(e.y) ? this.dbl() : this.curve.point();
    if (this.y.eq(e.y)) {
      const d = this.x.redNeg().redISub(e.x), l = this.y.redNeg();
      return this.curve.point(d, l);
    }
    const t = this.x.redSub(e.x), n = this.y.redSub(e.y).redDiv(t), c = n.redSqr().redISub(this.x).redISub(e.x), o = n.redMul(this.x.redSub(c)).redISub(this.y);
    return this.curve.point(c, o);
  }
  dbl() {
    if (this.inf)
      return this;
    if (this.y.isZero())
      return this.curve.point();
    const t = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), i = this.y.redMuln(2), n = t.redDiv(i), c = n.redSqr().redISub(this.x).redISub(this.x), o = n.redMul(this.x.redSub(c)).redISub(this.y);
    return this.curve.point(c, o);
  }
  dblp(e) {
    return this.toJ().dblp(e).toP();
  }
  getX() {
    if (this.inf)
      throw new Error("Invalid point.");
    return this.x.fromRed();
  }
  getY() {
    if (this.inf)
      throw new Error("Invalid point.");
    return this.y.fromRed();
  }
  eq(e) {
    return fe(e instanceof Nr), this === e ? !0 : this.inf ? e.inf : e.inf ? !1 : this.x.eq(e.x) && this.y.eq(e.y);
  }
  cmp(e) {
    return fe(e instanceof Nr), this.inf && !e.inf ? -1 : !this.inf && e.inf ? 1 : this.inf && e.inf ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX()) || this.getY().cmp(e.getY());
  }
  isInfinity() {
    return this.inf;
  }
  isOrder2() {
    return this.inf ? !1 : this.y.isZero();
  }
  isOdd() {
    return this.inf ? !1 : this.y.redIsOdd();
  }
  isEven() {
    return this.inf ? !1 : this.y.redIsEven();
  }
  isSquare() {
    return this.inf ? !1 : this.y.redJacobi() !== -1;
  }
  eqX(e) {
    return fe(e instanceof Ee), fe(!e.red), this.inf ? !1 : this.getX().eq(e);
  }
  eqR(e) {
    return fe(e instanceof Ee), fe(!e.red), fe(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(e);
  }
  mul(e) {
    return super.mul(e).toP();
  }
  muln(e) {
    return super.muln(e).toP();
  }
  mulBlind(e, t) {
    return super.mulBlind(e, t).toP();
  }
  mulAdd(e, t, i) {
    return super.mulAdd(e, t, i).toP();
  }
  mulH() {
    return super.mulH().toP();
  }
  div(e) {
    return super.div(e).toP();
  }
  divn(e) {
    return super.divn(e).toP();
  }
  divH() {
    return super.divH().toP();
  }
  toP() {
    return this;
  }
  toJ() {
    return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one);
  }
  encode(e) {
    e == null && (e = !0), fe(typeof e == "boolean");
    const { fieldSize: t } = this.curve;
    if (this.inf)
      throw new Error("Invalid point.");
    if (e) {
      const o = Buffer.alloc(1 + t), d = this.curve.encodeField(this.getX());
      return o[0] = 2 | this.y.redIsOdd(), d.copy(o, 1), o;
    }
    const i = Buffer.alloc(1 + t * 2), n = this.curve.encodeField(this.getX()), c = this.curve.encodeField(this.getY());
    return i[0] = 4, n.copy(i, 1), c.copy(i, 1 + t), i;
  }
  static decode(e, t) {
    fe(e instanceof Ir), fe(Buffer.isBuffer(t));
    const i = e.fieldSize;
    if (t.length < 1 + i)
      throw new Error("Not a point.");
    const n = t[0];
    switch (n) {
      case 2:
      case 3: {
        if (t.length !== 1 + i)
          throw new Error("Invalid point size for compressed.");
        const c = e.decodeField(t.slice(1, 1 + i));
        if (c.cmp(e.p) >= 0)
          throw new Error("Invalid point.");
        const o = e.pointFromX(c, n === 3);
        return fe(!o.isInfinity()), o;
      }
      case 4:
      case 6:
      case 7: {
        if (t.length !== 1 + i * 2)
          throw new Error("Invalid point size for uncompressed.");
        const c = e.decodeField(t.slice(1, 1 + i)), o = e.decodeField(t.slice(1 + i, 1 + 2 * i));
        if (c.cmp(e.p) >= 0 || o.cmp(e.p) >= 0)
          throw new Error("Invalid point.");
        if (n !== 4 && n !== (6 | o.isOdd()))
          throw new Error("Invalid hybrid encoding.");
        const d = e.point(c, o);
        if (!d.validate())
          throw new Error("Invalid point.");
        return fe(!d.isInfinity()), d;
      }
      default:
        throw new Error("Unknown point format.");
    }
  }
  encodeX() {
    return this.curve.encodeField(this.getX());
  }
  static decodeEven(e, t) {
    fe(e instanceof Ir);
    const i = e.decodeField(t);
    if (i.cmp(e.p) >= 0)
      throw new Error("Invalid point.");
    return e.pointFromX(i, !1);
  }
  static decodeSquare(e, t) {
    fe(e instanceof Ir);
    const i = e.decodeField(t);
    if (i.cmp(e.p) >= 0)
      throw new Error("Invalid point.");
    return e.pointFromX(i);
  }
  toJSON(e) {
    if (this.inf)
      return [];
    const t = this.getX().toJSON(), i = this.getY().toJSON();
    return e === !0 && this.pre ? [t, i, this.pre.toJSON()] : [t, i];
  }
  toPretty() {
    if (this.inf)
      return [];
    const e = this.curve.fieldSize * 2, t = Cn(this.getX(), e), i = Cn(this.getY(), e);
    return [t, i];
  }
  static fromJSON(e, t) {
    if (fe(e instanceof Ir), fe(Array.isArray(t)), fe(t.length === 0 || t.length === 2 || t.length === 3), t.length === 0)
      return e.point();
    const i = Ee.fromJSON(t[0]), n = Ee.fromJSON(t[1]), c = e.point(i, n);
    return t.length > 2 && t[2] != null && (c.pre = Ql.fromJSON(c, t[2])), c;
  }
  [Wn]() {
    return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
  }
}
class On extends Mr {
  constructor(e, t, i, n) {
    fe(e instanceof Ir), super(e, Ci.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, t != null && this._init(t, i, n);
  }
  _init(e, t, i) {
    fe(e instanceof Ee), fe(t instanceof Ee), fe(i == null || i instanceof Ee), this.x = e, this.y = t, this.z = i || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one);
  }
  clone() {
    return this.curve.jpoint(this.x, this.y, this.z);
  }
  validate() {
    const { a: e, b: t } = this.curve;
    if (this.isInfinity())
      return !0;
    if (this.zOne)
      return this.curve.validate(this.toP());
    const i = this.y.redSqr(), n = this.x.redSqr().redMul(this.x), c = this.z.redSqr(), o = c.redSqr(), d = o.redMul(c), l = n.redIAdd(t.redMul(d));
    return this.curve.zeroA || (this.curve.threeA ? l.redIAdd(o.redIMuln(-3).redMul(this.x)) : l.redIAdd(e.redMul(o).redMul(this.x))), i.eq(l);
  }
  normalize() {
    if (this.zOne)
      return this;
    if (this.isInfinity())
      return this;
    const e = this.z.redInvert(), t = e.redSqr();
    return this.x = this.x.redMul(t), this.y = this.y.redMul(t).redMul(e), this.z = this.curve.one, this.zOne = !0, this;
  }
  scale(e) {
    if (fe(e instanceof Ee), this.isInfinity())
      return this.curve.jpoint();
    const t = e.redSqr(), i = this.x.redMul(t), n = this.y.redMul(t).redMul(e), c = this.z.redMul(e);
    return this.curve.jpoint(i, n, c);
  }
  neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }
  add(e) {
    return fe(e instanceof Mr), e.type === Ci.AFFINE ? this._mixedAdd(e) : this._add(e);
  }
  _add(e) {
    return fe(e instanceof On), this.isInfinity() ? e : e.isInfinity() ? this : this.zOne ? e._addJA(this) : e.zOne ? this._addJA(e) : this._addJJ(e);
  }
  _mixedAdd(e) {
    return fe(e instanceof Nr), this.isInfinity() ? e.toJ() : e.isInfinity() ? this : this._addJA(e);
  }
  _addJJ(e) {
    const t = this.z.redSqr(), i = e.z.redSqr(), n = this.x.redMul(i), c = e.x.redMul(t), o = this.y.redMul(e.z).redMul(i), d = e.y.redMul(this.z).redMul(t), l = c.redISub(n), h = d.redISub(o);
    if (l.isZero())
      return h.isZero() ? this.dbl() : this.curve.jpoint();
    const x = l.redSqr(), b = l.redMul(x), g = n.redMul(x), w = h.redSqr().redISub(b).redISub(g).redISub(g), I = h.redMul(g.redISub(w)).redISub(o.redMul(b)), B = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(w, I, B);
  }
  _addJA(e) {
    const t = this.z.redSqr(), i = e.x.redMul(t), n = e.y.redMul(this.z).redMul(t), c = i.redISub(this.x), o = n.redISub(this.y).redIMuln(2);
    if (c.isZero())
      return o.isZero() ? this.dbl() : this.curve.jpoint();
    const d = c.redMuln(2).redSqr(), l = c.redMul(d), h = this.x.redMul(d), x = o.redSqr().redISub(l).redISub(h).redISub(h), b = o.redMul(h.redISub(x)).redISub(this.y.redMul(l).redIMuln(2)), g = this.z.redMul(c).redIMuln(2);
    return this.curve.jpoint(x, b, g);
  }
  dbl() {
    return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ();
  }
  _dblJ() {
    const e = this.x.redSqr(), t = this.y.redSqr(), i = this.z.redSqr(), n = this.x.redMul(t).redIMuln(4), c = e.redIMuln(3).redIAdd(this.curve.a.redMul(i.redSqr())), o = c.redSqr().redISub(n).redISub(n), d = o, l = c.redMul(n.redISub(o)).redISub(t.redSqr().redIMuln(8)), h = this.y.redMul(this.z).redIMuln(2);
    return this.curve.jpoint(d, l, h);
  }
  _dbl0() {
    const e = this.x.redSqr(), t = this.y.redSqr(), i = t.redSqr(), c = t.redIAdd(this.x).redSqr().redISub(e).redISub(i).redIMuln(2), o = e.redIMuln(3), l = o.redSqr().redISub(c).redISub(c), h = o.redMul(c.redISub(l)).redISub(i.redIMuln(8)), x = this.y.redMul(this.z).redIMuln(2);
    return this.curve.jpoint(l, h, x);
  }
  _dbl3() {
    const e = this.z.redSqr(), t = this.y.redSqr(), i = this.x.redMul(t), n = this.x.redSub(e), c = this.x.redAdd(e), o = n.redMul(c).redIMuln(3), d = i.redIMuln(4), l = d.redMuln(2), h = t.redSqr().redIMuln(8), x = o.redSqr().redISub(l), b = this.y.redAdd(this.z).redSqr().redISub(t).redISub(e), g = o.redMul(d.redISub(x)).redISub(h);
    return this.curve.jpoint(x, g, b);
  }
  getX() {
    if (this.isInfinity())
      throw new Error("Invalid point.");
    return this.normalize(), this.x.fromRed();
  }
  getY() {
    if (this.isInfinity())
      throw new Error("Invalid point.");
    return this.normalize(), this.y.fromRed();
  }
  eq(e) {
    if (fe(e instanceof On), this === e)
      return !0;
    if (this.isInfinity())
      return e.isInfinity();
    if (e.isInfinity())
      return !1;
    if (this.z.eq(e.z))
      return this.x.eq(e.x) && this.y.eq(e.y);
    const t = this.z.redSqr(), i = e.z.redSqr(), n = this.x.redMul(i), c = e.x.redMul(t);
    if (!n.eq(c))
      return !1;
    const o = t.redMul(this.z), d = i.redMul(e.z), l = this.y.redMul(d), h = e.y.redMul(o);
    return l.eq(h);
  }
  cmp(e) {
    fe(e instanceof On);
    const t = this.isInfinity(), i = e.isInfinity();
    return t && !i ? -1 : !t && i ? 1 : t && i ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX()) || this.getY().cmp(e.getY());
  }
  isInfinity() {
    return this.z.isZero();
  }
  isOrder2() {
    return this.isInfinity() ? !1 : this.y.isZero();
  }
  isOdd() {
    return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd());
  }
  isEven() {
    return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven());
  }
  isSquare() {
    return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1;
  }
  eqX(e) {
    if (fe(e instanceof Ee), fe(!e.red), this.isInfinity())
      return !1;
    const t = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(t);
    return this.x.eq(i);
  }
  eqR(e) {
    if (fe(e instanceof Ee), fe(!e.red), !this.curve.smallGap)
      return this.toP().eqR(e);
    if (this.isInfinity() || e.cmp(this.curve.p) >= 0)
      return !1;
    const t = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(t);
    if (this.x.eq(i))
      return !0;
    if (this.curve.highOrder || e.cmp(this.curve.pmodn) >= 0)
      return !1;
    const n = this.curve.redN.redMul(t);
    return i.redIAdd(n), this.x.eq(i);
  }
  toP() {
    return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y));
  }
  toJ() {
    return this;
  }
  encode(e) {
    return this.toP().encode(e);
  }
  static decode(e, t) {
    return Nr.decode(e, t).toJ();
  }
  encodeX() {
    return this.toP().encodeX();
  }
  static decodeEven(e, t) {
    return Nr.decodeEven(e, t).toJ();
  }
  static decodeSquare(e, t) {
    return Nr.decodeSquare(e, t).toJ();
  }
  toJSON(e) {
    return this.toP().toJSON(e);
  }
  toPretty() {
    return this.toP().toPretty();
  }
  static fromJSON(e, t) {
    return Nr.fromJSON(e, t).toJ();
  }
  [Wn]() {
    return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
  }
}
class Or extends k0 {
  constructor(e) {
    super(w0, "mont", e), this.a = Ee.fromJSON(e.a).toRed(this.red), this.b = Ee.fromJSON(e.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(e);
  }
  static _isomorphism(e, t, i) {
    fe(e instanceof Ee), fe(t instanceof Ee), fe(i instanceof Ee);
    const n = e.clone(), c = i.clone();
    if (t.redDiv(i).redJacobi() !== 1)
      throw new Error("Invalid `b` coefficient.");
    return [n, c];
  }
  _short(e, t) {
    const { a: i, b: n, three: c } = this, o = i.redSqr(), d = o.redMul(i), l = n.redSqr(), h = l.redMul(n), x = c.redSub(o), b = l.redMuln(3), g = d.redMuln(2).redISub(i.redMuln(9)), w = h.redMuln(27), I = x.redDiv(b), B = g.redDiv(w);
    return e != null ? Ir._isomorphism(I, B, e, t) : [I, B];
  }
  _mont(e) {
    return Or._isomorphism(this.a, this.b, e);
  }
  _edwards(e, t = !1) {
    fe(typeof t == "boolean");
    const { two: i, bi: n } = this, c = this.a.redAdd(i).redMul(n), o = this.a.redSub(i).redMul(n);
    return t && c.swap(o), e != null ? t0._isomorphism(c, o, e) : [c, o];
  }
  _scaleShort(e) {
    fe(e instanceof Ir);
    const [t, i] = e._scale(this);
    return [
      this.field(t.redInvert()),
      this.field(i.redInvert())
    ];
  }
  _scaleMont(e) {
    return fe(e instanceof Or), this.g.isInfinity() || e.g.isInfinity() ? this.field(e.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(e.g.y));
  }
  _scaleEdwards(e, t) {
    fe(e instanceof t0);
    const i = e._scale(this, t);
    return this.field(i);
  }
  _solveY0(e) {
    fe(e instanceof Ee);
    const t = this.a0, i = this.b0, n = e.redSqr();
    return n.redMul(e).redIAdd(t.redMul(n)).redIAdd(i.redMul(e));
  }
  _elligator2(e) {
    const t = this.a0.redNeg(), i = this.one.redAdd(this.z.redMul(e.redSqr()));
    i.isZero() && i.inject(this.one);
    const n = t.redMul(i.redInvert()), c = n.redNeg().redISub(this.a0), o = this._solveY0(n), d = this._solveY0(c), l = o.redIsSquare() | 0, h = [n, c][l ^ 1], x = [o, d][l ^ 1].redSqrt();
    x.redIsOdd() !== e.redIsOdd() && x.redINeg();
    const b = this.b.redMul(h), g = this.b.redMul(x);
    return this.point(b, g);
  }
  _invert2(e, t) {
    const { x: i, y: n } = e, c = t & 1, o = i.redMul(this.bi), d = n.redMul(this.bi), l = o.redAdd(this.a0), h = o, x = [l, h][c].redINeg(), b = [h, l][c].redMul(this.z), g = x.redDivSqrt(b);
    return g.redIsOdd() !== d.redIsOdd() && g.redINeg(), g;
  }
  isElliptic() {
    const e = this.a.redSqr();
    return !this.b.redMul(e.redSub(this.four)).isZero();
  }
  jinv() {
    const { a: e, three: t, four: i } = this, n = e.redSqr(), o = n.redSub(t).redPown(3).redIMuln(256), d = n.redSub(i);
    if (d.isZero())
      throw new Error("Curve is not elliptic.");
    return o.redDiv(d).fromRed();
  }
  point(e, t) {
    return new w0(this, e, t);
  }
  jpoint(e, t, i) {
    return fe(e == null && t == null && i == null), this.point();
  }
  xpoint(e, t) {
    return new cs(this, e, t);
  }
  solveY2(e) {
    fe(e instanceof Ee);
    const t = e.redSqr();
    return t.redMul(e).redIAdd(this.a.redMul(t)).redIAdd(e).redMul(this.bi);
  }
  validate(e) {
    if (fe(e instanceof w0), e.isInfinity())
      return !0;
    const { x: t, y: i } = e, n = this.solveY2(t);
    return i.redSqr().eq(n);
  }
  pointFromX(e, t = null) {
    fe(e instanceof Ee), fe(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
    const i = this.solveY(e);
    if (t != null) {
      if (i.isZero() && t)
        throw new Error("Invalid point.");
      i.redIsOdd() !== t && i.redINeg();
    }
    return this.point(e, i);
  }
  isIsomorphic(e, t) {
    if (fe(e instanceof k0), !e.p.eq(this.p))
      return !1;
    if (e.type === "mont") {
      const i = this.field(e.a), n = this.field(e.b);
      return !this.a.eq(i) || this.b.isZero() ? !1 : n.redDiv(this.b).redJacobi() === 1;
    }
    return e.isIsomorphic(this, t);
  }
  isIsogenous(e) {
    return fe(e instanceof k0), e.type === "mont" ? !1 : e.isIsogenous(this);
  }
  pointFromShort(e) {
    if (fe(e instanceof Nr), this.isIsomorphic(e.curve)) {
      if (e.isInfinity())
        return this.point();
      const { a3: t, b: i } = this, [n, c] = this._scale(e.curve), o = this.field(e.x).redMul(n), d = this.field(e.y).redMul(c), l = i.redMul(o).redISub(t), h = i.redMul(d);
      return this.point(l, h);
    }
    throw new Error("Not implemented.");
  }
  pointFromMont(e) {
    if (fe(e instanceof w0), this.isIsomorphic(e.curve)) {
      if (e.isInfinity())
        return this.point();
      const t = this._scale(e.curve), i = this.field(e.x), n = this.field(e.y), c = i, o = t.redMul(n);
      return this.point(c, o);
    }
    throw new Error("Not implemented.");
  }
  pointFromEdwards(e) {
    fe(e instanceof m0), fe(e.curve.p.eq(this.p));
    const t = this.field(e.x), i = this.field(e.y), n = this.field(e.z);
    if (this.isIsogenous(e.curve)) {
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero())
        return this.point(this.zero, this.zero);
      const c = n.redSqr().redIMuln(2), o = i.redSqr(), d = t.redSqr(), l = c.redISub(d).redISub(o).redMul(i), h = d.redMul(t);
      return this.cpoint(o, d, l, h);
    }
    if (this.isIsomorphic(e.curve, !0)) {
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero())
        return this.point(this.zero, this.zero);
      const c = this._scale(e.curve, !0), o = i.redAdd(n), d = i.redSub(n), l = c.redMul(n).redMul(o), h = t.redMul(d);
      return this.cpoint(o, d, l, h);
    }
    if (this.isIsomorphic(e.curve, !1)) {
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero())
        return this.point(this.zero, this.zero);
      const c = this._scale(e.curve, !1), o = n.redAdd(i), d = n.redSub(i), l = c.redMul(n).redMul(o), h = t.redMul(d);
      return this.cpoint(o, d, l, h);
    }
    throw new Error("Not implemented.");
  }
  pointFromUniform(e) {
    if (fe(e instanceof Ee), this.z.isZero() || this.a.isZero())
      throw new Error("Not implemented.");
    return this._elligator2(e);
  }
  pointToUniform(e, t) {
    if (fe(e instanceof w0), fe(t >>> 0 === t), this.z.isZero() || this.a.isZero())
      throw new Error("Not implemented.");
    if (e.isInfinity())
      throw new Error("Invalid point.");
    const i = (t >>> 4 & 15) % this.torsion.length, n = e.add(this.torsion[i]);
    return pp(() => this._invert2(n, t));
  }
  decodePoint(e, t) {
    return w0.decode(this, e, t);
  }
  encodeX(e) {
    return fe(e instanceof cs), e.encode();
  }
  decodeX(e) {
    return cs.decode(this, e);
  }
  toShort(e, t, i = null) {
    const [n, c] = this._short(e, t), o = new Ir({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      b: c,
      n: this.n,
      h: this.h
    });
    if (i != null) {
      const [, d] = o._scale(this);
      d.redIsOdd() !== i && d.redINeg();
    }
    this.g.isInfinity() || (o.g = o.pointFromMont(this.g));
    for (let d = 0; d < this.h.word(0); d++)
      o.torsion[d] = o.pointFromMont(this.torsion[d]);
    return o;
  }
  toMont(e, t = null) {
    const [i, n] = this._mont(e), c = new Or({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: i,
      b: n,
      n: this.n,
      h: this.h,
      z: this.z
    });
    if (t != null) {
      const o = c._scale(this);
      o.redIsOdd() !== t && o.redINeg();
    }
    this.g.isInfinity() || (c.g = c.pointFromMont(this.g));
    for (let o = 0; o < this.h.word(0); o++)
      c.torsion[o] = c.pointFromMont(this.torsion[o]);
    return c;
  }
  toEdwards(e, t, i = null) {
    const [n, c] = this._edwards(e, t), o = new t0({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      d: c,
      n: this.n,
      h: this.h,
      z: this.z
    });
    if (i != null) {
      const d = o._scale(this, t);
      d.redIsOdd() !== i && d.redINeg();
    }
    if (this.g.isInfinity() || (o.g = o.pointFromMont(this.g), o.g.normalize()), o.isComplete())
      for (let d = 0; d < this.h.word(0); d++)
        o.torsion[d] = o.pointFromMont(this.torsion[d]), o.torsion[d].normalize();
    return o;
  }
  pointFromJSON(e) {
    return w0.fromJSON(this, e);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.a = this.a.fromRed().toJSON(), t.b = this.b.fromRed().toJSON(), t;
  }
}
class w0 extends Mr {
  constructor(e, t, i) {
    fe(e instanceof Or), super(e, Ci.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, t != null && this._init(t, i);
  }
  _init(e, t) {
    fe(e instanceof Ee), fe(t instanceof Ee), this.x = e, this.y = t, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1;
  }
  clone() {
    return this.inf ? this.curve.point() : this.curve.point(this.x, this.y);
  }
  scale(e) {
    return this.clone();
  }
  randomize(e) {
    return this.clone();
  }
  neg() {
    return this.inf ? this : this.curve.point(this.x, this.y.redNeg());
  }
  add(e) {
    if (fe(e instanceof w0), this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.x.eq(e.x))
      return this.y.eq(e.y) ? this.dbl() : this.curve.point();
    const t = e.x.redSub(this.x), n = e.y.redSub(this.y).redDiv(t), o = this.curve.b.redMul(n.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(e.x), d = n.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, d);
  }
  dbl() {
    if (this.inf)
      return this;
    if (this.y.isZero())
      return this.curve.point();
    const e = this.x.redSqr().redIMuln(3), t = this.curve.a.redMul(this.x).redIMuln(2), i = e.redIAdd(t).redIAdd(this.curve.one), n = this.curve.b.redMul(this.y).redIMuln(2), c = i.redDiv(n), d = this.curve.b.redMul(c.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), l = c.redMul(this.x.redSub(d)).redISub(this.y);
    return this.curve.point(d, l);
  }
  getX() {
    if (this.inf)
      throw new Error("Invalid point.");
    return this.x.fromRed();
  }
  getY() {
    if (this.inf)
      throw new Error("Invalid point.");
    return this.y.fromRed();
  }
  eq(e) {
    return fe(e instanceof w0), this === e ? !0 : this.inf ? e.inf : e.inf ? !1 : this.x.eq(e.x) && this.y.eq(e.y);
  }
  cmp(e) {
    return fe(e instanceof w0), this.inf && !e.inf ? -1 : !this.inf && e.inf ? 1 : this.inf && e.inf ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX()) || this.getY().cmp(e.getY());
  }
  isInfinity() {
    return this.inf;
  }
  isOrder2() {
    return this.inf ? !1 : this.y.isZero();
  }
  isOdd() {
    return this.inf ? !1 : this.y.redIsOdd();
  }
  isEven() {
    return this.inf ? !1 : this.y.redIsEven();
  }
  toP() {
    return this;
  }
  toJ() {
    return this;
  }
  toX() {
    return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one);
  }
  encode() {
    return this.toX().encode();
  }
  static decode(e, t, i) {
    return fe(e instanceof Or), e.decodeX(t).toP(i);
  }
  toJSON(e) {
    if (this.inf)
      return [];
    const t = this.getX().toJSON(), i = this.getY().toJSON();
    return [t, i];
  }
  toPretty() {
    if (this.inf)
      return [];
    const e = this.curve.fieldSize * 2, t = Cn(this.getX(), e), i = Cn(this.getY(), e);
    return [t, i];
  }
  static fromJSON(e, t) {
    if (fe(e instanceof Or), fe(Array.isArray(t)), fe(t.length === 0 || t.length === 2 || t.length === 3), t.length === 0)
      return e.point();
    const i = Ee.fromJSON(t[0]), n = Ee.fromJSON(t[1]);
    return e.point(i, n);
  }
  [Wn]() {
    return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
  }
}
class cs extends Mr {
  constructor(e, t, i) {
    fe(e instanceof Or), super(e, Ci.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, t != null && this._init(t, i);
  }
  _init(e, t) {
    fe(e instanceof Ee), fe(t == null || t instanceof Ee), this.x = e, this.z = t || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red));
  }
  clone() {
    return this.curve.xpoint(this.x, this.z);
  }
  precompute(e, t) {
    return this;
  }
  validate() {
    if (this.isInfinity())
      return !0;
    const { x: e, z: t } = this, i = e.redSqr(), n = i.redMul(e), c = t.redSqr(), o = this.curve.a.redMul(i).redMul(t);
    return n.redIAdd(o).redIAdd(e.redMul(c)).redMul(this.curve.bi).redMul(t).redJacobi() !== -1;
  }
  normalize() {
    return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this);
  }
  scale(e) {
    if (fe(e instanceof Ee), this.isInfinity())
      return this.curve.xpoint();
    const t = this.x.redMul(e), i = this.z.redMul(e);
    return this.curve.xpoint(t, i);
  }
  neg() {
    return this;
  }
  dbl() {
    const t = this.x.redAdd(this.z).redSqr(), n = this.x.redSub(this.z).redSqr(), c = t.redSub(n), o = t.redMul(n), d = c.redMul(n.redIAdd(this.curve.a24.redMul(c)));
    return this.curve.xpoint(o, d);
  }
  diffAddDbl(e, t) {
    fe(e instanceof cs), fe(t instanceof cs);
    const i = e.x.redAdd(e.z), n = i.redSqr(), c = e.x.redSub(e.z), o = c.redSqr(), d = n.redSub(o), l = t.x.redAdd(t.z), x = t.x.redSub(t.z).redMul(i), b = l.redMul(c), g = this.z.redMul(x.redAdd(b).redSqr()), w = this.x.redMul(x.redISub(b).redSqr()), I = n.redMul(o), B = d.redMul(o.redIAdd(this.curve.a24.redMul(d)));
    return [
      this.curve.xpoint(I, B),
      this.curve.xpoint(g, w)
    ];
  }
  getX() {
    if (this.isInfinity())
      throw new Error("Invalid point.");
    return this.normalize(), this.x.fromRed();
  }
  getY(e) {
    return this.toP(e).getY();
  }
  eq(e) {
    if (fe(e instanceof cs), this === e)
      return !0;
    if (this.isInfinity())
      return e.isInfinity();
    if (e.isInfinity())
      return !1;
    if (this.z.eq(e.z))
      return this.x.eq(e.x);
    const t = this.x.redMul(e.z), i = e.x.redMul(this.z);
    return t.eq(i);
  }
  cmp(e) {
    fe(e instanceof cs);
    const t = this.isInfinity(), i = e.isInfinity();
    return t && !i ? -1 : !t && i ? 1 : t && i ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX());
  }
  isInfinity() {
    return this.z.isZero();
  }
  isOrder2() {
    return this.isInfinity() ? !1 : this.x.isZero();
  }
  isOdd() {
    return !1;
  }
  isEven() {
    return !1;
  }
  hasTorsion() {
    return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion();
  }
  order() {
    try {
      return this.toP().order();
    } catch {
      return new Ee(1);
    }
  }
  jmul(e) {
    fe(e instanceof Ee), fe(!e.red);
    const t = e.bitLength();
    let i = this.curve.xpoint(), n = this;
    for (let c = t - 1; c >= 0; c--)
      e.bit(c) === 0 ? [i, n] = this.diffAddDbl(i, n) : [n, i] = this.diffAddDbl(n, i);
    return i;
  }
  jmulBlind(e, t) {
    return t ? this.randomize(t).jmul(e) : this.jmul(e);
  }
  jmulAdd(e, t, i) {
    throw new Error("Not implemented.");
  }
  toP(e = null) {
    return fe(e == null || typeof e == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, e));
  }
  toJ() {
    return this;
  }
  toX() {
    return this;
  }
  key() {
    if (this.isInfinity())
      return `${this.curve.uid}:oo`;
    this.normalize();
    const e = this.getX().toString(16);
    return `${this.curve.uid}:${e}`;
  }
  encode() {
    return this.curve.encodeField(this.getX());
  }
  static decode(e, t) {
    fe(e instanceof Or);
    const i = e.decodeField(t);
    i.iumaskn(e.fieldBits);
    const n = e.xpoint(i, e.one);
    return fe(!n.isInfinity()), n;
  }
  toJSON(e) {
    return this.toP().toJSON(e);
  }
  toPretty() {
    return this.toP().toPretty();
  }
  static fromJSON(e, t) {
    return w0.fromJSON(e, t).toX();
  }
  [Wn]() {
    return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
  }
}
class t0 extends k0 {
  constructor(e) {
    super(m0, "edwards", e), this.a = Ee.fromJSON(e.a).toRed(this.red), this.d = Ee.fromJSON(e.d).toRed(this.red), this.s = Ee.fromJSON(e.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(e);
  }
  static _isomorphism(e, t, i) {
    fe(e instanceof Ee), fe(t instanceof Ee), fe(i instanceof Ee);
    const n = i.clone(), c = i.redMul(t).redDiv(e);
    if (e.redDiv(i).redJacobi() !== 1)
      throw new Error("Invalid `a` coefficient.");
    return [n, c];
  }
  _short(e, t) {
    const { a: i, d: n } = this, c = i.redSqr(), o = c.redMul(i), d = n.redSqr(), l = d.redMul(n), h = i.redMul(n).redIMuln(14), x = c.redMul(n), b = i.redMul(d), g = x.redIAdd(b).redIMuln(33), w = c.redAdd(h).redIAdd(d).redDivn(-48), I = g.redISub(o).redISub(l).redDivn(864);
    return e != null ? Ir._isomorphism(w, I, e, t) : [w, I];
  }
  _mont(e, t = !1) {
    fe(typeof t == "boolean");
    let i, n;
    t ? (i = this.d.redAdd(this.a), n = this.d.redSub(this.a)) : (i = this.a.redAdd(this.d), n = this.a.redSub(this.d));
    const c = n.redInvert(), o = i.redMuln(2).redMul(c), d = c.redMuln(4);
    return e != null ? Or._isomorphism(o, d, e) : [o, d];
  }
  _edwards(e) {
    return t0._isomorphism(this.a, this.d, e);
  }
  _scaleShort(e) {
    fe(e instanceof Ir);
    const [t, i] = e._scale(this);
    return [
      this.field(t.redInvert()),
      this.field(i.redInvert())
    ];
  }
  _scaleMont(e, t = !1) {
    if (fe(e instanceof Or), fe(typeof t == "boolean"), this.g.isInfinity() || e.g.isInfinity()) {
      const [n] = e._edwards(null, t);
      return this.field(n).redDivSqrt(this.a);
    }
    const i = e.g.x.redDiv(e.g.y);
    return this.g.x.redDiv(this.field(i));
  }
  _scaleEdwards(e) {
    return fe(e instanceof t0), this.g.isInfinity() || e.g.isInfinity() ? this.field(e.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(e.g.x));
  }
  _mulA(e) {
    return fe(e instanceof Ee), this.oneA ? e.clone() : this.mOneA ? e.redNeg() : this.a.redMul(e);
  }
  _mulD(e) {
    return fe(e instanceof Ee), this.smallD ? e.redMuln(this.smi) : this.d.redMul(e);
  }
  _elligator1(e) {
    const { s: t, si: i, i2: n, one: c, two: o } = this, d = i.redSqr().redIMuln(2), l = t.redSqr().redMul(n), h = l.redSqr(), x = d.redAdd(l), b = x.redSqr().redISub(o), g = d.redSub(c), w = c.redSub(e), I = c.redAdd(e), B = I.isZero() ? I : w.redDiv(I), y = B.redSqr(), A = y.redMul(B), q = A.redMul(y).redAdd(b.redMul(A)).redIAdd(B), U = this.field(q.redJacobi()), z = this.field(y.redAdd(h).redJacobi()), E = U.redMul(z), H = U.redMul(B), k = U.redMul(q).redSqrt().redMul(E), V = c.redAdd(H), T = x.redMul(H), ie = V.redSqr(), N = g.redMul(t).redMul(H).redMul(V), G = B.isZero() ? this.one : k, F = T.redSub(ie), W = T.redAdd(ie);
    return this.cpoint(N, G, F, W);
  }
  _invert1(e, t) {
    const { s: i, si: n, i2: c, one: o } = this, { x: d, y: l, z: h } = e, x = t & 1, b = n.redSqr().redIMuln(2), g = i.redSqr().redMul(c), w = g.redSqr(), I = b.redAdd(g), B = b.redSub(o), y = l.redSub(h), A = l.redAdd(h).redIMuln(2), _ = A.isZero() ? A : y.redDiv(A), q = o.redAdd(_.redMul(I)), E = q.redSqr().redISub(o).redSqrt().redSub(q), H = o.redAdd(E), V = B.redMul(i).redMul(E).redMul(H).redMul(d.redMul(h)), T = E.redSqr().redIAdd(w), N = this.field(V.redMul(T).redJacobi()).redMul(E), G = o.redSub(N), F = o.redAdd(N), W = F.isZero() ? F : G.redDiv(F);
    return W.redIsOdd() !== !!x && W.redINeg(), W;
  }
  _alt() {
    return this.alt || (this.alt = this.toMont()), this.alt;
  }
  isElliptic() {
    const e = this.a.redMul(this.d), t = this.a.redSub(this.d);
    return !e.redMul(t).isZero();
  }
  jinv() {
    const { a: e, d: t } = this, i = e.redMul(t), n = e.redSub(t).redPown(4), c = e.redSqr(), o = t.redSqr(), l = c.redAdd(i.redMuln(14)).redIAdd(o).redPown(3).redIMuln(16), h = i.redMul(n);
    if (h.isZero())
      throw new Error("Curve is not elliptic.");
    return l.redDiv(h).fromRed();
  }
  isComplete() {
    return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
  }
  point(e, t, i, n) {
    return new m0(this, e, t, i, n);
  }
  jpoint(e, t, i) {
    return fe(e == null && t == null && i == null), this.point();
  }
  cpoint(e, t, i, n) {
    fe(e instanceof Ee), fe(t instanceof Ee), fe(i instanceof Ee), fe(n instanceof Ee);
    const c = e.redMul(n), o = i.redMul(t), d = t.redMul(n), l = e.redMul(i);
    return this.point(c, o, d, l);
  }
  solveX2(e) {
    fe(e instanceof Ee);
    const t = e.redSqr(), i = this._mulD(t).redISub(this.a);
    return t.redISub(this.one).redDiv(i);
  }
  solveX(e) {
    const t = e.redSqr(), i = this._mulD(t).redISub(this.a);
    return t.redISub(this.one).redDivSqrt(i);
  }
  solveY2(e) {
    fe(e instanceof Ee);
    const t = e.redSqr(), i = this._mulA(t).redISub(this.one), n = this._mulD(t).redISub(this.one);
    return i.redDiv(n);
  }
  solveY(e) {
    const t = e.redSqr(), i = this._mulA(t).redISub(this.one), n = this._mulD(t).redISub(this.one);
    return i.redDivSqrt(n);
  }
  validate(e) {
    if (fe(e instanceof m0), e.zOne) {
      const b = e.x.redSqr(), g = e.y.redSqr(), w = this._mulD(b).redMul(g), I = this._mulA(b).redIAdd(g), B = this.one.redAdd(w), y = e.t, A = e.x.redMul(e.y);
      return I.eq(B) && y.eq(A);
    }
    const t = e.x.redSqr(), i = e.y.redSqr(), n = e.z.redSqr(), c = n.redSqr(), o = this._mulD(t).redMul(i), d = this._mulA(t).redIAdd(i).redMul(n), l = c.redIAdd(o), h = e.t.redMul(e.z), x = e.x.redMul(e.y);
    return d.eq(l) && h.eq(x);
  }
  pointFromX(e, t = null) {
    fe(e instanceof Ee), fe(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
    const i = this.solveY(e);
    if (t != null) {
      if (i.isZero() && t)
        throw new Error("Invalid point.");
      i.redIsOdd() !== t && i.redINeg();
    }
    return this.point(e, i);
  }
  pointFromY(e, t = null) {
    fe(e instanceof Ee), fe(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
    const i = this.solveX(e);
    if (t != null) {
      if (i.isZero() && t)
        throw new Error("Invalid point.");
      i.redIsOdd() !== t && i.redINeg();
    }
    return this.point(i, e);
  }
  isIsomorphic(e, t = !1) {
    if (fe(e instanceof k0), fe(typeof t == "boolean"), !e.p.eq(this.p))
      return !1;
    if (e.type === "short")
      return e.isIsomorphic(this);
    if (e.type === "mont") {
      const i = this.field(e.a);
      let n, c;
      return t ? (n = this.d.redAdd(this.a), c = this.d.redSub(this.a)) : (n = this.a.redAdd(this.d), c = this.a.redSub(this.d)), i.redMul(c).eq(n.redIMuln(2));
    }
    if (e.type === "edwards") {
      const i = this.field(e.a), n = this.field(e.d);
      return this.a.redMul(n).eq(i.redMul(this.d));
    }
    return !1;
  }
  isIsogenous(e) {
    if (fe(e instanceof k0), !e.p.eq(this.p))
      return !1;
    if (e.type === "mont") {
      if (!this.a.eq(this.one))
        return !1;
      const t = this.field(e.a), i = this.field(e.b), n = this.two.redSub(this.d.redMuln(4));
      return t.eq(n) && i.eq(this.one);
    }
    if (e.type === "edwards") {
      const t = this.field(e.a), i = this.field(e.d);
      return t.eq(this.a.redNeg()) && i.eq(this.d.redSub(this.a));
    }
    return !1;
  }
  pointFromShort(e) {
    if (fe(e instanceof Nr), this.isIsomorphic(e.curve)) {
      if (e.isInfinity())
        return this.point();
      if (e.y.isZero())
        return this.point(this.zero, this.one.redNeg());
      const { a: t, d: i } = this, [n, c] = this._scale(e.curve), o = t.redMuln(5), d = i.redMuln(5), l = this.field(e.x).redMul(n), h = this.field(e.y).redMul(c), x = l.redMuln(6), b = l.redMuln(12), g = x.redSub(t).redISub(i), w = h.redMuln(6), I = b.redSub(o).redIAdd(i), B = b.redAdd(t).redISub(d);
      return this.cpoint(g, w, I, B);
    }
    throw new Error("Not implemented.");
  }
  pointFromMont(e) {
    fe(e instanceof w0), fe(e.curve.p.eq(this.p));
    const t = this.field(e.x), i = this.field(e.y);
    if (this.isIsogenous(e.curve)) {
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero())
        return this.point();
      const n = t.redSqr(), c = n.redMul(t), o = c.redMul(t), d = o.redMul(t), l = i.redSqr(), h = i.redMuln(4), x = n.redSub(this.one), b = n.redMuln(2), g = l.redMuln(4), w = c.redIMuln(2), I = t.redMul(l).redIMuln(4), B = n.redMul(l).redIMuln(2), y = l.redIMuln(2), A = h.redMul(x), _ = o.redISub(b).redIAdd(g).redIAdd(this.one), q = d.redSub(w).redISub(I).redIAdd(t).redINeg(), U = d.redISub(B).redISub(w).redISub(y).redIAdd(t);
      return this.cpoint(A, _, q, U).divn(4);
    }
    if (this.isIsomorphic(e.curve, !0)) {
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero())
        return this.point(this.zero, this.one.redNeg());
      const c = this._scale(e.curve, !0).redMul(t), o = i, d = t.redAdd(this.one), l = t.redSub(this.one);
      return this.cpoint(c, o, d, l);
    }
    if (this.isIsomorphic(e.curve, !1)) {
      if (e.isInfinity())
        return this.point();
      if (e.x.isZero())
        return this.point(this.zero, this.one.redNeg());
      const c = this._scale(e.curve, !1).redMul(t), o = i, d = t.redSub(this.one), l = t.redAdd(this.one);
      return this.cpoint(c, o, d, l);
    }
    throw new Error("Not implemented.");
  }
  pointFromEdwards(e) {
    fe(e instanceof m0), fe(e.curve.p.eq(this.p));
    const t = this.field(e.curve.a), i = this.field(e.x), n = this.field(e.y), c = this.field(e.z), o = this.field(e.t);
    if (this.isIsogenous(e.curve)) {
      const d = i.redMul(n), l = i.redSqr(), h = n.redSqr(), x = c.redSqr(), b = t.redMul(l), g = d.redIMuln(2), w = h.redSub(b), I = h.redAdd(b), B = x.redIMuln(2).redISub(I), y = this.cpoint(g, w, I, B);
      return this.twisted ? y : y.divn(4);
    }
    if (this.isIsomorphic(e.curve)) {
      const d = this._scale(e.curve), l = d.redMul(i), h = n, x = c, b = d.redMul(o);
      return this.point(l, h, x, b);
    }
    throw new Error("Not implemented.");
  }
  pointFromUniform(e, t = null) {
    fe(e instanceof Ee), fe(e.red === this.red), fe(t == null || t instanceof Or), t || (t = this._alt());
    const i = t.field(e), n = t.pointFromUniform(i);
    return this.pointFromMont(n);
  }
  pointToUniform(e, t, i = null) {
    fe(e instanceof m0), fe(t >>> 0 === t), fe(i == null || i instanceof Or), i || (i = this._alt());
    const n = (t >> 4 & 15) % this.torsion.length, c = e.add(this.torsion[n]), o = i.pointFromEdwards(c), d = i.pointToUniform(o, t & 15);
    return this.field(d);
  }
  pointFromHash(e, t, i = null) {
    fe(i == null || i instanceof Or), i || (i = this._alt());
    const n = i.pointFromHash(e, t);
    return this.pointFromMont(n);
  }
  pointToHash(e, t, i, n = null) {
    fe(e instanceof m0), fe(t >>> 0 === t), fe(n == null || n instanceof Or), n || (n = this._alt());
    const c = t % this.torsion.length, o = e.add(this.torsion[c]), d = n.pointFromEdwards(o);
    return n.pointToHash(d, 0, i);
  }
  decodePoint(e) {
    return m0.decode(this, e);
  }
  toShort(e, t, i = null) {
    const [n, c] = this._short(e, t), o = new Ir({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      b: c,
      n: this.n,
      h: this.h
    });
    if (i != null) {
      const [, d] = o._scale(this);
      d.redIsOdd() !== i && d.redINeg();
    }
    this.g.isInfinity() || (o.g = o.pointFromEdwards(this.g));
    for (let d = 0; d < this.h.word(0); d++)
      o.torsion[d] = o.pointFromEdwards(this.torsion[d]);
    return o;
  }
  toMont(e, t, i = null) {
    const [n, c] = this._mont(e, t), o = new Or({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: n,
      b: c,
      n: this.n,
      h: this.h,
      z: this.z
    });
    if (i != null) {
      const d = this._scale(o, t);
      d.redIsOdd() !== i && d.redINeg();
    }
    this.g.isInfinity() || (o.g = o.pointFromEdwards(this.g));
    for (let d = 0; d < this.h.word(0); d++)
      o.torsion[d] = o.pointFromEdwards(this.torsion[d]);
    return o;
  }
  toEdwards(e, t = null) {
    const [i, n] = this._edwards(e), c = new t0({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: i,
      d: n,
      n: this.n,
      h: this.h,
      z: this.z
    });
    if (t != null) {
      const o = c._scale(this);
      o.redIsOdd() !== t && o.redINeg();
    }
    if (this.g.isInfinity() || (c.g = c.pointFromEdwards(this.g), c.g.normalize()), c.isComplete())
      for (let o = 0; o < this.h.word(0); o++)
        c.torsion[o] = c.pointFromEdwards(this.torsion[o]), c.torsion[o].normalize();
    return c;
  }
  pointFromJSON(e) {
    return m0.fromJSON(this, e);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.a = this.a.fromRed().toJSON(), t.d = this.d.fromRed().toJSON(), this.s.isZero() || (t.s = this.s.fromRed().toJSON()), t;
  }
}
class m0 extends Mr {
  constructor(e, t, i, n, c) {
    fe(e instanceof t0), super(e, Ci.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, t != null && this._init(t, i, n, c);
  }
  _init(e, t, i, n) {
    fe(e instanceof Ee), fe(t instanceof Ee), fe(i == null || i instanceof Ee), fe(n == null || n instanceof Ee), this.x = e, this.y = t, this.z = i || this.curve.one, this.t = n || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)));
  }
  _check() {
    if (this.z.isZero())
      throw new Error("Invalid point.");
  }
  clone() {
    return this.curve.point(this.x, this.y, this.z, this.t);
  }
  normalize() {
    if (this.zOne)
      return this;
    const e = this.z.redInvert();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t = this.t.redMul(e), this.z = this.curve.one, this.zOne = !0, this;
  }
  scale(e) {
    fe(e instanceof Ee);
    const t = this.x.redMul(e), i = this.y.redMul(e), n = this.z.redMul(e), c = this.t.redMul(e);
    return this.curve.point(t, i, n, c);
  }
  neg() {
    const e = this.x.redNeg(), t = this.y, i = this.z, n = this.t.redNeg();
    return this.curve.point(e, t, i, n);
  }
  add(e) {
    return fe(e instanceof m0), this.isInfinity() ? e : e.isInfinity() ? this : this.zOne ? e._add(this) : this._add(e);
  }
  _add(e) {
    return this.curve.mOneA ? this._addM1(e) : this._addA(e);
  }
  _addM1(e) {
    const t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), n = this.t.redMul(this.curve.k).redMul(e.t), c = e.zOne ? this.z.redAdd(this.z) : this.z.redMul(e.z).redIMuln(2), o = i.redSub(t), d = c.redSub(n), l = c.redIAdd(n), h = i.redIAdd(t), x = o.redMul(d), b = l.redMul(h), g = o.redMul(h), w = d.redMul(l);
    return this.curve.point(x, b, w, g);
  }
  _addA(e) {
    const t = this.x.redMul(e.x), i = this.y.redMul(e.y), n = this.curve._mulD(this.t).redMul(e.t), c = e.zOne ? this.z.clone() : this.z.redMul(e.z), d = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(t).redISub(i), l = c.redSub(n), h = c.redIAdd(n), x = i.redISub(this.curve._mulA(t)), b = d.redMul(l), g = h.redMul(x), w = d.redMul(x), I = l.redMul(h);
    return this.curve.point(b, g, I, w);
  }
  dbl() {
    return this.isInfinity() ? this : this._dbl();
  }
  _dbl() {
    const e = this.x.redSqr(), t = this.y.redSqr(), i = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2), n = this.curve._mulA(e), c = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t), o = n.redAdd(t), d = o.redSub(i), l = n.redISub(t), h = c.redMul(d), x = o.redMul(l), b = c.redMul(l), g = d.redMul(o);
    return this.curve.point(h, x, g, b);
  }
  getX() {
    return this.normalize(), this.x.fromRed();
  }
  getY() {
    return this.normalize(), this.y.fromRed();
  }
  eq(e) {
    if (fe(e instanceof m0), fe(!this.z.isZero()), fe(!e.z.isZero()), this === e)
      return !0;
    if (this.z.eq(e.z))
      return this.x.eq(e.x) && this.y.eq(e.y);
    const t = this.x.redMul(e.z), i = e.x.redMul(this.z);
    if (!t.eq(i))
      return !1;
    const n = this.y.redMul(e.z), c = e.y.redMul(this.z);
    return n.eq(c);
  }
  cmp(e) {
    return fe(e instanceof m0), this.order().cmp(e.order()) || this.getY().cmp(e.getY()) || this.getX().cmp(e.getX());
  }
  isInfinity() {
    return fe(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1;
  }
  isOrder2() {
    return this.isInfinity() ? !1 : this.x.isZero();
  }
  isOdd() {
    return this.normalize(), this.x.redIsOdd();
  }
  isEven() {
    return this.normalize(), this.x.redIsEven();
  }
  toP() {
    return this.normalize();
  }
  toJ() {
    return this;
  }
  encode() {
    const e = this.getY();
    return e.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(e);
  }
  static decode(e, t) {
    fe(e instanceof t0);
    const i = e.decodeAdjusted(t), n = i.testn(e.signBit) !== 0;
    if (i.setn(e.signBit, 0), i.cmp(e.p) >= 0)
      throw new Error("Invalid point.");
    return e.pointFromY(i, n);
  }
  toJSON(e) {
    if (this.isInfinity())
      return [];
    const t = this.getX().toJSON(), i = this.getY().toJSON();
    return e === !0 && this.pre ? [t, i, this.pre.toJSON()] : [t, i];
  }
  toPretty() {
    const e = this.curve.fieldSize * 2, t = Cn(this.getX(), e), i = Cn(this.getY(), e);
    return [t, i];
  }
  static fromJSON(e, t) {
    if (fe(e instanceof t0), fe(Array.isArray(t)), fe(t.length === 0 || t.length === 2 || t.length === 3), t.length === 0)
      return e.point();
    const i = Ee.fromJSON(t[0]), n = Ee.fromJSON(t[1]), c = e.point(i, n);
    return t.length > 2 && t[2] != null && (c.pre = Ql.fromJSON(c, t[2])), c;
  }
  [Wn]() {
    return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
  }
}
class Ql {
  constructor() {
    this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null;
  }
  map(e) {
    fe(typeof e == "function");
    const t = new this.constructor();
    return this.naf && (t.naf = this.naf.map(e)), this.doubles && (t.doubles = this.doubles.map(e)), t;
  }
  toJSON() {
    return {
      naf: this.naf ? this.naf.toJSON() : null,
      windows: this.windows ? this.windows.toJSON() : null,
      doubles: this.doubles ? this.doubles.toJSON() : null,
      blinding: this.blinding ? this.blinding.toJSON() : void 0
    };
  }
  fromJSON(e, t) {
    return fe(e instanceof Mr), fe(t && typeof t == "object"), t.naf != null && (this.naf = C1.fromJSON(e, t.naf)), t.windows != null && (this.windows = lp.fromJSON(e, t.windows)), t.doubles != null && (this.doubles = xp.fromJSON(e, t.doubles)), t.blinding != null && (this.blinding = bp.fromJSON(e, t.blinding)), this;
  }
  static fromJSON(e, t) {
    return new this().fromJSON(e, t);
  }
}
class C1 {
  constructor(e, t) {
    this.width = e, this.points = t;
  }
  map(e) {
    fe(typeof e == "function");
    const { width: t } = this, i = [];
    for (const n of this.points)
      i.push(e(n));
    return new this.constructor(t, i);
  }
  toJSON() {
    return {
      width: this.width,
      points: this.points.slice(1).map((e) => e.toJSON())
    };
  }
  static fromJSON(e, t) {
    fe(e instanceof Mr), fe(t && typeof t == "object"), fe(t.width >>> 0 === t.width), fe(Array.isArray(t.points));
    const { curve: i } = e, { width: n } = t, c = [e];
    for (const o of t.points)
      c.push(i.pointFromJSON(o));
    return new this(n, c);
  }
}
class lp {
  constructor(e, t, i) {
    this.width = e, this.bits = t, this.points = i;
  }
  toJSON() {
    return {
      width: this.width,
      bits: this.bits,
      points: this.points.slice(1).map((e) => e.toJSON())
    };
  }
  static fromJSON(e, t) {
    fe(e instanceof Mr), fe(t && typeof t == "object"), fe(t.width >>> 0 === t.width), fe(t.bits >>> 0 === t.bits), fe(Array.isArray(t.points));
    const { curve: i } = e, { width: n, bits: c } = t, o = [e];
    for (const d of t.points)
      o.push(i.pointFromJSON(d));
    return new this(n, c, o);
  }
}
class xp {
  constructor(e, t) {
    this.step = e, this.points = t;
  }
  map(e) {
    fe(typeof e == "function");
    const { step: t } = this, i = [];
    for (const n of this.points)
      i.push(e(n));
    return new this.constructor(t, i);
  }
  toJSON() {
    return {
      step: this.step,
      points: this.points.slice(1).map((e) => e.toJSON())
    };
  }
  static fromJSON(e, t) {
    fe(e instanceof Mr), fe(t && typeof t == "object"), fe(t.step >>> 0 === t.step), fe(Array.isArray(t.points));
    const { curve: i } = e, { step: n } = t, c = [e];
    for (const o of t.points)
      c.push(i.pointFromJSON(o));
    return new this(n, c);
  }
}
class bp {
  constructor(e, t) {
    this.blind = e, this.unblind = t;
  }
  toJSON() {
    return {
      blind: this.blind.toJSON(),
      unblind: this.unblind.toJSON()
    };
  }
  static fromJSON(e, t) {
    fe(e instanceof Mr), fe(t && typeof t == "object");
    const { curve: i } = e, n = Ee.fromJSON(t.blind), c = i.pointFromJSON(t.unblind);
    return new this(n, c);
  }
}
class m4 {
  constructor(e, t, i, n) {
    this.beta = e, this.lambda = t, this.basis = i, this.pre = n;
  }
  toJSON() {
    return {
      beta: this.beta.fromRed().toJSON(),
      lambda: this.lambda.toJSON(),
      basis: [
        this.basis[0].toJSON(),
        this.basis[1].toJSON()
      ],
      pre: [
        this.pre[0],
        this.pre[1].toJSON(),
        this.pre[2].toJSON()
      ]
    };
  }
  static fromJSON(e, t) {
    fe(e instanceof k0), fe(t && typeof t == "object"), fe(Array.isArray(t.basis)), fe(Array.isArray(t.pre)), fe(t.basis.length === 2), fe(t.pre.length === 3), fe(t.pre[0] >>> 0 === t.pre[0]);
    const i = Ee.fromJSON(t.beta).toRed(e.red), n = Ee.fromJSON(t.lambda), c = [
      _n.fromJSON(t.basis[0]),
      _n.fromJSON(t.basis[1])
    ], o = [
      t.pre[0],
      Ee.fromJSON(t.pre[1]),
      Ee.fromJSON(t.pre[2])
    ];
    return new this(i, n, c, o);
  }
}
class _n {
  constructor(e, t) {
    this.a = e, this.b = t;
  }
  toJSON() {
    return {
      a: this.a.toJSON(),
      b: this.b.toJSON()
    };
  }
  static fromJSON(e) {
    fe(e && typeof e == "object");
    const t = Ee.fromJSON(e.a), i = Ee.fromJSON(e.b);
    return new this(t, i);
  }
}
class jI extends Ir {
  constructor(e) {
    super({
      id: "P192",
      ossl: "prime192v1",
      type: "short",
      endian: "be",
      hash: "SHA256",
      prime: "p192",
      // 2^192 - 2^64 - 1 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff fffffffe",
        "ffffffff ffffffff"
      ],
      // -3 mod p
      a: [
        "ffffffff ffffffff ffffffff fffffffe",
        "ffffffff fffffffc"
      ],
      b: [
        "64210519 e59c80e7 0fa7e9ab 72243049",
        "feb8deec c146b9b1"
      ],
      n: [
        "ffffffff ffffffff ffffffff 99def836",
        "146bc9b1 b4d22831"
      ],
      h: "1",
      // Icart
      z: "-5",
      g: [
        [
          "188da80e b03090f6 7cbf20eb 43a18800",
          "f4ff0afd 82ff1012"
        ],
        [
          "07192b95 ffc8da78 631011ed 6b24cdd5",
          "73f977a1 1e794811"
        ],
        e
      ]
    });
  }
}
class QI extends Ir {
  constructor(e) {
    super({
      id: "P224",
      ossl: "secp224r1",
      type: "short",
      endian: "be",
      hash: "SHA256",
      prime: "p224",
      // 2^224 - 2^96 + 1 (1 mod 16)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "00000000 00000000 00000001"
      ],
      // -3 mod p
      a: [
        "ffffffff ffffffff ffffffff fffffffe",
        "ffffffff ffffffff fffffffe"
      ],
      b: [
        "b4050a85 0c04b3ab f5413256 5044b0b7",
        "d7bfd8ba 270b3943 2355ffb4"
      ],
      n: [
        "ffffffff ffffffff ffffffff ffff16a2",
        "e0b8f03e 13dd2945 5c5c2a3d"
      ],
      h: "1",
      // SSWU
      z: "1f",
      g: [
        [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
          "56c21122 343280d6 115c1d21"
        ],
        [
          "bd376388 b5f723fb 4c22dfe6 cd4375a0",
          "5a074764 44d58199 85007e34"
        ],
        e
      ]
    });
  }
}
class eA extends Ir {
  constructor(e) {
    super({
      id: "P256",
      ossl: "prime256v1",
      type: "short",
      endian: "be",
      hash: "SHA256",
      prime: null,
      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
      p: [
        "ffffffff 00000001 00000000 00000000",
        "00000000 ffffffff ffffffff ffffffff"
      ],
      // -3 mod p
      a: [
        "ffffffff 00000001 00000000 00000000",
        "00000000 ffffffff ffffffff fffffffc"
      ],
      b: [
        "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
        "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
      ],
      n: [
        "ffffffff 00000000 ffffffff ffffffff",
        "bce6faad a7179e84 f3b9cac2 fc632551"
      ],
      h: "1",
      // SSWU
      z: "-a",
      g: [
        [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
          "77037d81 2deb33a0 f4a13945 d898c296"
        ],
        [
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
          "2bce3357 6b315ece cbb64068 37bf51f5"
        ],
        e
      ]
    });
  }
}
class tA extends Ir {
  constructor(e) {
    super({
      id: "P384",
      ossl: "secp384r1",
      type: "short",
      endian: "be",
      hash: "SHA384",
      prime: null,
      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff fffffffe",
        "ffffffff 00000000 00000000 ffffffff"
      ],
      // -3 mod p
      a: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff fffffffe",
        "ffffffff 00000000 00000000 fffffffc"
      ],
      b: [
        "b3312fa7 e23ee7e4 988e056b e3f82d19",
        "181d9c6e fe814112 0314088f 5013875a",
        "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
      ],
      n: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff c7634d81 f4372ddf",
        "581a0db2 48b0a77a ecec196a ccc52973"
      ],
      h: "1",
      // Icart
      z: "-c",
      g: [
        [
          "aa87ca22 be8b0537 8eb1c71e f320ad74",
          "6e1d3b62 8ba79b98 59f741e0 82542a38",
          "5502f25d bf55296c 3a545e38 72760ab7"
        ],
        [
          "3617de4a 96262c6f 5d9e98bf 9292dc29",
          "f8f41dbd 289a147c e9da3113 b5f0b8c0",
          "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ],
        e
      ]
    });
  }
}
class rA extends Ir {
  constructor(e) {
    super({
      id: "P521",
      ossl: "secp521r1",
      type: "short",
      endian: "be",
      hash: "SHA512",
      prime: "p521",
      // 2^521 - 1 (= 3 mod 4)
      p: [
        "000001ff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff"
      ],
      // -3 mod p
      a: [
        "000001ff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "fffffffc"
      ],
      b: [
        "00000051 953eb961 8e1c9a1f 929a21a0",
        "b68540ee a2da725b 99b315f3 b8b48991",
        "8ef109e1 56193951 ec7e937b 1652c0bd",
        "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
        "6b503f00"
      ],
      n: [
        "000001ff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "fffffffa 51868783 bf2f966b 7fcc0148",
        "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
        "91386409"
      ],
      h: "1",
      // SSWU
      z: "-4",
      g: [
        [
          "000000c6 858e06b7 0404e9cd 9e3ecb66",
          "2395b442 9c648139 053fb521 f828af60",
          "6b4d3dba a14b5e77 efe75928 fe1dc127",
          "a2ffa8de 3348b3c1 856a429b f97e7e31",
          "c2e5bd66"
        ],
        [
          "00000118 39296a78 9a3bc004 5c8a5fb4",
          "2c7d1bd9 98f54449 579b4468 17afbd17",
          "273e662c 97ee7299 5ef42640 c550b901",
          "3fad0761 353c7086 a272c240 88be9476",
          "9fd16650"
        ],
        e
      ]
    });
  }
}
class iA extends Ir {
  constructor(e) {
    super({
      id: "SECP256K1",
      ossl: "secp256k1",
      type: "short",
      endian: "be",
      hash: "SHA256",
      prime: "k256",
      // 2^256 - 2^32 - 977 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff fffffffe fffffc2f"
      ],
      a: "0",
      b: "7",
      n: [
        "ffffffff ffffffff ffffffff fffffffe",
        "baaedce6 af48a03b bfd25e8c d0364141"
      ],
      h: "1",
      // SVDW
      z: "1",
      // sqrt(-3)
      c: [
        "0a2d2ba9 3507f1df 233770c2 a797962c",
        "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
      ],
      g: [
        [
          "79be667e f9dcbbac 55a06295 ce870b07",
          "029bfcdb 2dce28d9 59f2815b 16f81798"
        ],
        [
          "483ada77 26a3c465 5da4fbfc 0e1108a8",
          "fd17b448 a6855419 9c47d08f fb10d4b8"
        ],
        e
      ],
      // Precomputed endomorphism.
      endo: {
        beta: [
          "7ae96a2b 657c0710 6e64479e ac3434e9",
          "9cf04975 12f58995 c1396c28 719501ee"
        ],
        lambda: [
          "5363ad4c c05c30e0 a5261c02 8812645a",
          "122e22ea 20816678 df02967c 1b23bd72"
        ],
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        pre: [
          384,
          [
            "3086d221 a7d46bcd e86c90e4 9284eb15",
            "3daa8a14 71e8ca7f e893209a 45dbb031"
          ],
          [
            "-",
            "e4437ed6 010e8828 6f547fa9 0abfe4c4",
            "221208ac 9df506c6 1571b4ae 8ac47f71"
          ]
        ]
      }
    });
  }
}
class sA extends Ir {
  constructor(e) {
    super({
      id: "BRAINPOOLP256",
      ossl: "brainpoolP256r1",
      type: "short",
      endian: "be",
      hash: "SHA256",
      prime: null,
      // (= 3 mod 4)
      p: [
        "a9fb57db a1eea9bc 3e660a90 9d838d72",
        "6e3bf623 d5262028 2013481d 1f6e5377"
      ],
      a: [
        "7d5a0975 fc2c3057 eef67530 417affe7",
        "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
      ],
      b: [
        "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
        "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
      ],
      n: [
        "a9fb57db a1eea9bc 3e660a90 9d838d71",
        "8c397aa3 b561a6f7 901e0e82 974856a7"
      ],
      h: "1",
      // Icart
      z: "-2",
      g: [
        [
          "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
          "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
        ],
        [
          "547ef835 c3dac4fd 97f8461a 14611dc9",
          "c2774513 2ded8e54 5c1d54c7 2f046997"
        ],
        e
      ]
    });
  }
}
class nA extends Ir {
  constructor(e) {
    super({
      id: "BRAINPOOLP384",
      ossl: "brainpoolP384r1",
      type: "short",
      endian: "be",
      hash: "SHA384",
      prime: null,
      // (= 3 mod 4)
      p: [
        "8cb91e82 a3386d28 0f5d6f7e 50e641df",
        "152f7109 ed5456b4 12b1da19 7fb71123",
        "acd3a729 901d1a71 87470013 3107ec53"
      ],
      a: [
        "7bc382c6 3d8c150c 3c72080a ce05afa0",
        "c2bea28e 4fb22787 139165ef ba91f90f",
        "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
      ],
      b: [
        "04a8c7dd 22ce2826 8b39b554 16f0447c",
        "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
        "7cb43902 95dbc994 3ab78696 fa504c11"
      ],
      n: [
        "8cb91e82 a3386d28 0f5d6f7e 50e641df",
        "152f7109 ed5456b3 1f166e6c ac0425a7",
        "cf3ab6af 6b7fc310 3b883202 e9046565"
      ],
      h: "1",
      // SSWU
      z: "-5",
      g: [
        [
          "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
          "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
          "e826e034 36d646aa ef87b2e2 47d4af1e"
        ],
        [
          "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
          "62b70b29 feec5864 e19c054f f9912928",
          "0e464621 77918111 42820341 263c5315"
        ],
        e
      ]
    });
  }
}
class fA extends Ir {
  constructor(e) {
    super({
      id: "BRAINPOOLP512",
      ossl: "brainpoolP512r1",
      type: "short",
      endian: "be",
      hash: "SHA512",
      prime: null,
      // (= 3 mod 4)
      p: [
        "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
        "cb308db3 b3c9d20e d6639cca 70330871",
        "7d4d9b00 9bc66842 aecda12a e6a380e6",
        "2881ff2f 2d82c685 28aa6056 583a48f3"
      ],
      a: [
        "7830a331 8b603b89 e2327145 ac234cc5",
        "94cbdd8d 3df91610 a83441ca ea9863bc",
        "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
        "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
      ],
      b: [
        "3df91610 a83441ca ea9863bc 2ded5d5a",
        "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
        "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
        "984050b7 5ebae5dd 2809bd63 8016f723"
      ],
      n: [
        "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
        "cb308db3 b3c9d20e d6639cca 70330870",
        "553e5c41 4ca92619 41866119 7fac1047",
        "1db1d381 085ddadd b5879682 9ca90069"
      ],
      h: "1",
      // Icart
      z: "7",
      g: [
        [
          "81aee4bd d82ed964 5a21322e 9c4c6a93",
          "85ed9f70 b5d916c1 b43b62ee f4d0098e",
          "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
          "7c6d5047 406a5e68 8b352209 bcb9f822"
        ],
        [
          "7dde385d 566332ec c0eabfa9 cf7822fd",
          "f209f700 24a57b1a a000c55b 881f8111",
          "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
          "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
        ],
        e
      ]
    });
  }
}
class cA extends Or {
  constructor() {
    super({
      id: "X25519",
      ossl: "X25519",
      type: "mont",
      endian: "le",
      hash: "SHA512",
      prime: "p25519",
      // 2^255 - 19 (= 5 mod 8)
      p: [
        "7fffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffed"
      ],
      // 486662
      a: "76d06",
      b: "1",
      n: [
        "10000000 00000000 00000000 00000000",
        "14def9de a2f79cd6 5812631a 5cf5d3ed"
      ],
      h: "8",
      // Elligator 2
      z: "2",
      g: [
        [
          "00000000 00000000 00000000 00000000",
          "00000000 00000000 00000000 00000009"
        ],
        // See: https://www.rfc-editor.org/errata/eid4730
        [
          "5f51e65e 475f794b 1fe122d3 88b72eb3",
          "6dc2b281 92839e4d d6163a5d 81312c14"
        ]
      ],
      torsion: [
        [],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000001"
          ],
          [
            "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
            "635a11c7 284a9363 e9a248ef 9c884415"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000001"
          ],
          [
            "141b0b68 06563d50 3de05885 280b5910",
            "9ca5ee38 d7b56c9c 165db710 6377bbd8"
          ]
        ],
        [
          [
            "57119fd0 dd4e22d8 868e1c58 c45c4404",
            "5bef839c 55b1d0b1 248c50a3 bc959c5f"
          ],
          [
            "68c59389 3d458e64 31c6ca00 45fb5015",
            "20a44346 8eaa68dd 0f103842 048065b7"
          ]
        ],
        [
          [
            "57119fd0 dd4e22d8 868e1c58 c45c4404",
            "5bef839c 55b1d0b1 248c50a3 bc959c5f"
          ],
          [
            "173a6c76 c2ba719b ce3935ff ba04afea",
            "df5bbcb9 71559722 f0efc7bd fb7f9a36"
          ]
        ],
        [
          [
            "00b8495f 16056286 fdb1329c eb8d09da",
            "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
          ],
          [
            "3931c129 569e83a5 29482c14 e628b457",
            "933bfc29 ed801b4d 68871483 92507b1a"
          ]
        ],
        [
          [
            "00b8495f 16056286 fdb1329c eb8d09da",
            "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
          ],
          [
            "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
            "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
          ]
        ]
      ]
    });
  }
}
class oA extends Or {
  constructor() {
    super({
      id: "X448",
      ossl: "X448",
      type: "mont",
      endian: "le",
      hash: "SHAKE256",
      prime: "p448",
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff fffffffe ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff"
      ],
      // 156326
      a: "262a6",
      b: "1",
      n: [
        "3fffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff 7cca23e9",
        "c44edb49 aed63690 216cc272 8dc58f55",
        "2378c292 ab5844f3"
      ],
      h: "4",
      // Elligator 2
      z: "-1",
      g: [
        [
          "00000000 00000000 00000000 00000000",
          "00000000 00000000 00000000 00000000",
          "00000000 00000000 00000000 00000000",
          "00000000 00000005"
        ],
        [
          "7d235d12 95f5b1f6 6c98ab6e 58326fce",
          "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
          "b8027e23 46430d21 1312c4b1 50677af7",
          "6fd7223d 457b5b1a"
        ]
      ],
      torsion: [
        [],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ]
        ],
        [
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ],
          [
            "ba4d3a08 29b6112f 8812e51b a0bb2abe",
            "bc1cb08e b48e5569 36ba50fd d2e7d68a",
            "f8cb3216 0522425b 3f990812 abbe635a",
            "d37a21e1 7551b193"
          ]
        ],
        [
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ],
          [
            "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
            "43e34f71 4b71aa96 c945af01 2d182975",
            "0734cde9 faddbda4 c066f7ed 54419ca5",
            "2c85de1e 8aae4e6c"
          ]
        ]
      ]
    });
  }
}
class aA extends Or {
  constructor() {
    super({
      id: "MONT448",
      ossl: null,
      type: "mont",
      endian: "le",
      hash: "SHAKE256",
      prime: "p448",
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff fffffffe ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff"
      ],
      // -78160 / -39082 mod p
      a: [
        "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
        "5d93f8d2 22746997 60ccffc6 49961ed6",
        "c5b05fca c24864ed 6fb59697 931b78da",
        "84ddecd8 ca2b5cfb"
      ],
      b: "1",
      n: [
        "3fffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff 7cca23e9",
        "c44edb49 aed63690 216cc272 8dc58f55",
        "2378c292 ab5844f3"
      ],
      h: "4",
      // Elligator 2
      z: "-1",
      g: [
        [
          "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
          "48e88aee 009a2a24 e795687e c28e125a",
          "3e6730a6 0d46367b aa7fe99d 152128dc",
          "41321bc7 7817f059"
        ],
        [
          "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
          "e786ff33 b6a53d30 98746425 82e66f09",
          "4433dae7 7244a6e2 6b11e905 7228f483",
          "556c41a5 913f55fe"
        ]
      ],
      torsion: [
        [],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ]
        ],
        [
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ],
          [
            "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
            "22e75c18 3c589857 b71924e5 73c2f9ce",
            "e18da5f2 466e2f39 3c2eedf0 f105a60a",
            "b40c717d 4f1e1fd7"
          ]
        ],
        [
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ],
          [
            "4136d02f 925d530d 4b1d9e17 8310f2cb",
            "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
            "1e725a0d b991d0c6 c3d1120f 0efa59f5",
            "4bf38e82 b0e1e028"
          ]
        ]
      ]
    });
  }
}
class hA extends t0 {
  constructor(e) {
    super({
      id: "ED25519",
      ossl: "ED25519",
      type: "edwards",
      endian: "le",
      hash: "SHA512",
      prefix: "SigEd25519 no Ed25519 collisions",
      context: !1,
      prime: "p25519",
      // 2^255 - 19 (= 5 mod 8)
      p: [
        "7fffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff ffffffed"
      ],
      a: "-1",
      // -121665 / 121666 mod p
      d: [
        "52036cee 2b6ffe73 8cc74079 7779e898",
        "00700a4d 4141d8ab 75eb4dca 135978a3"
      ],
      n: [
        "10000000 00000000 00000000 00000000",
        "14def9de a2f79cd6 5812631a 5cf5d3ed"
      ],
      h: "8",
      // Elligator 2
      z: "2",
      g: [
        [
          "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
          "692cc760 9525a7b2 c9562d60 8f25d51a"
        ],
        // 4/5
        [
          "66666666 66666666 66666666 66666666",
          "66666666 66666666 66666666 66666658"
        ],
        e
      ],
      torsion: [
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000001"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000"
          ],
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff ffffffec"
          ]
        ],
        [
          [
            "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
            "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000"
          ]
        ],
        [
          [
            "547cdb7f b03e20f4 d4b2ff66 c2042858",
            "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000"
          ]
        ],
        [
          [
            "1fd5b9a0 06394a28 e9339932 38de4abb",
            "5c193c70 13e5e238 dea14646 c545d14a"
          ],
          [
            "05fc536d 880238b1 3933c6d3 05acdfd5",
            "f098eff2 89f4c345 b027b2c2 8f95e826"
          ]
        ],
        [
          [
            "602a465f f9c6b5d7 16cc66cd c721b544",
            "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
          ],
          [
            "05fc536d 880238b1 3933c6d3 05acdfd5",
            "f098eff2 89f4c345 b027b2c2 8f95e826"
          ]
        ],
        [
          [
            "1fd5b9a0 06394a28 e9339932 38de4abb",
            "5c193c70 13e5e238 dea14646 c545d14a"
          ],
          [
            "7a03ac92 77fdc74e c6cc392c fa53202a",
            "0f67100d 760b3cba 4fd84d3d 706a17c7"
          ]
        ],
        [
          [
            "602a465f f9c6b5d7 16cc66cd c721b544",
            "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
          ],
          [
            "7a03ac92 77fdc74e c6cc392c fa53202a",
            "0f67100d 760b3cba 4fd84d3d 706a17c7"
          ]
        ]
      ]
    });
  }
}
class dA extends t0 {
  constructor(e) {
    super({
      id: "ISO448",
      ossl: null,
      type: "edwards",
      endian: "le",
      hash: "SHAKE256",
      prefix: "SigEd448",
      context: !0,
      prime: "p448",
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff fffffffe ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff"
      ],
      a: "1",
      // 39082 / 39081 mod p
      d: [
        "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
        "ad461572 42a50f37 809b1da3 412a12e7",
        "9ccc9c81 264cfe9a d0809970 58fb61c4",
        "243cc32d baa156b9"
      ],
      n: [
        "3fffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff 7cca23e9",
        "c44edb49 aed63690 216cc272 8dc58f55",
        "2378c292 ab5844f3"
      ],
      h: "4",
      // Elligator 2
      z: "-1",
      g: [
        [
          "79a70b2b 70400553 ae7c9df4 16c792c6",
          "1128751a c9296924 0c25a07d 728bdc93",
          "e21f7787 ed697224 9de732f3 8496cd11",
          "69871309 3e9c04fc"
        ],
        // Note: the RFC has this wrong.
        [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 80000000",
          "00000000 00000000 00000000 00000000",
          "00000000 00000001"
        ],
        e
      ],
      torsion: [
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ],
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ]
        ],
        [
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ]
        ]
      ]
    });
  }
}
class uA extends t0 {
  constructor(e) {
    super({
      id: "ED448",
      ossl: "ED448",
      type: "edwards",
      endian: "le",
      hash: "SHAKE256",
      prefix: "SigEd448",
      context: !0,
      prime: "p448",
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff fffffffe ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff"
      ],
      a: "1",
      // -39081 mod p
      d: [
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff fffffffe ffffffff",
        "ffffffff ffffffff ffffffff ffffffff",
        "ffffffff ffff6756"
      ],
      n: [
        "3fffffff ffffffff ffffffff ffffffff",
        "ffffffff ffffffff ffffffff 7cca23e9",
        "c44edb49 aed63690 216cc272 8dc58f55",
        "2378c292 ab5844f3"
      ],
      h: "4",
      // Elligator 2
      z: "-1",
      g: [
        [
          "4f1970c6 6bed0ded 221d15a6 22bf36da",
          "9e146570 470f1767 ea6de324 a3d3a464",
          "12ae1af7 2ab66511 433b80e1 8b00938e",
          "2626a82b c70cc05e"
        ],
        [
          "693f4671 6eb6bc24 88762037 56c9c762",
          "4bea7373 6ca39840 87789c1e 05a0c2d7",
          "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
          "9808795b f230fa14"
        ],
        e
      ],
      torsion: [
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ],
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ]
        ],
        [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ]
        ],
        [
          [
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff fffffffe ffffffff",
            "ffffffff ffffffff ffffffff ffffffff",
            "ffffffff fffffffe"
          ],
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000"
          ]
        ]
      ]
    });
  }
}
const go = {
  __proto__: null,
  P192: jI,
  P224: QI,
  P256: eA,
  P384: tA,
  P521: rA,
  SECP256K1: iA,
  BRAINPOOLP256: sA,
  BRAINPOOLP384: nA,
  BRAINPOOLP512: fA,
  X25519: cA,
  X448: oA,
  MONT448: aA,
  ED25519: hA,
  ISO448: dA,
  ED448: uA
}, T1 = {
  __proto__: null,
  P192: null,
  P224: null,
  P256: null,
  P384: null,
  P521: null,
  SECP256K1: null,
  BRAINPOOLP256: null,
  BRAINPOOLP384: null,
  BRAINPOOLP512: null,
  X25519: null,
  X448: null,
  MONT448: null,
  ED25519: null,
  ISO448: null,
  ED448: null
};
function lA(r, ...e) {
  fe(typeof r == "string");
  const t = r.toUpperCase();
  let i = T1[t];
  if (!i) {
    const n = go[t];
    if (!n)
      throw new Error(`Curve not found: "${r}".`);
    i = new n(...e), T1[t] = i;
  }
  return i;
}
function xA(r, e) {
  fe(typeof r == "string"), fe(typeof e == "function");
  const t = r.toUpperCase();
  if (go[t])
    throw new Error(`Curve already registered: "${r}".`);
  go[t] = e, T1[t] = null;
}
function Gc(r, e, t) {
  fe(r instanceof Ee), fe(!r.red), fe(e >>> 0 === e), fe(t >>> 0 === t);
  const i = new Array(t), n = r.bitLength() + 1, c = r.sign() | 1;
  fe(n <= t);
  for (let h = 0; h < t; h++)
    i[h] = 0;
  let o = 0, d = 0, l;
  for (; o < n; ) {
    if (r.bit(o) === d) {
      o += 1;
      continue;
    }
    l = r.bits(o, e) + d, d = l >> e - 1 & 1, l -= d << e, i[o] = c * l, o += e;
  }
  return fe(d === 0), i;
}
function bA(r, e, t, i) {
  fe(i >>> 0 === i);
  const n = Gc(r, e, t), c = Math.ceil(n.length / i), o = new Array(c);
  let d = 0;
  for (let l = 0; l < n.length; l += i) {
    let h = 0;
    for (let x = l + i - 1; x >= l; x--)
      h = (h << 1) + n[x];
    o[d++] = h;
  }
  return fe(d === c), o;
}
function pA(r, e, t) {
  fe(r instanceof Ee), fe(e instanceof Ee), fe(!r.red), fe(!e.red), fe(t >>> 0 === t);
  const i = [new Array(t), new Array(t)], n = Math.max(r.bitLength(), e.bitLength()) + 1, c = r.sign() | 1, o = e.sign() | 1;
  fe(n <= t);
  let d = 0, l = 0;
  for (let h = 0; h < n; h++) {
    const x = r.bits(h, 3), b = e.bits(h, 3);
    let g = (x & 3) + d & 3, w = (b & 3) + l & 3, I = 0, B = 0;
    if (g === 3 && (g = -1), w === 3 && (w = -1), g & 1) {
      const y = (x & 7) + d & 7;
      (y === 3 || y === 5) && w === 2 ? I = -g : I = g;
    }
    if (w & 1) {
      const y = (b & 7) + l & 7;
      (y === 3 || y === 5) && g === 2 ? B = -w : B = w;
    }
    i[0][h] = I * c, i[1][h] = B * o, 2 * d === 1 + I && (d = 1 - d), 2 * l === 1 + B && (l = 1 - l);
  }
  for (let h = n; h < t; h++)
    i[0][h] = 0, i[1][h] = 0;
  return i;
}
function mA(r, e, t) {
  const i = pA(r, e, t), n = new Array(t);
  for (let c = 0; c < t; c++) {
    const o = i[0][c], d = i[1][c];
    n[c] = ZI[(o + 1) * 3 + (d + 1)];
  }
  return n;
}
function fe(r, e) {
  if (!r) {
    const t = new Error(e || "Assertion failed");
    throw Error.captureStackTrace && Error.captureStackTrace(t, fe), t;
  }
}
function pp(r) {
  fe(typeof r == "function");
  try {
    return r();
  } catch (e) {
    throw e.message === "X is not a square mod P." || e.message === "Not invertible." ? new Error("Invalid point.") : e;
  }
}
function gA(r, e) {
  let t = r % e;
  return t < 0 && (e < 0 ? t -= e : t += e), t;
}
function wA(r) {
  fe(r instanceof Ee), fe(r.red);
  const e = r.red.m;
  if (e.cmpn(3) <= 0)
    return r.clone();
  if (e.modrn(3) === 2) {
    const i = e.ushln(1).isubn(1).idivn(3);
    return r.redPow(i);
  }
  const t = e.modrn(9);
  if (t === 4) {
    const i = e.ushln(1).iaddn(1).idivn(9), n = r.redPow(i);
    if (!n.redSqr().redMul(n).eq(r))
      throw new Error("X is not a cube mod P.");
    return n;
  }
  if (t === 7) {
    const i = e.addn(2).idivn(9), n = r.redPow(i);
    if (!n.redSqr().redMul(n).eq(r))
      throw new Error("X is not a cube mod P.");
    return n;
  }
  throw new Error("Not implemented.");
}
function mp(r) {
  const e = wA(r);
  if (r.red.m.modrn(3) === 1) {
    const t = new Ee(2).toRed(r.red), i = new Ee(3).toRed(r.red), n = t.redInvert(), c = i.redNeg().redSqrt().redMul(n), o = c.redNeg(), d = c.redSub(n), l = o.redSub(n), h = e.redMul(d), x = e.redMul(l);
    return [e, h, x];
  }
  return [e];
}
function g4(r) {
  for (const e of mp(r))
    if (e.redJacobi() >= 0)
      return e;
  throw new Error("X^(1/3) is not a square mod P.");
}
function w4(r) {
  return Ee.randomBits(r, 32).toNumber();
}
function $d(r, e) {
  const t = /* @__PURE__ */ new WeakMap();
  return function(n, c) {
    const o = c & 1, d = t.get(n);
    if (d && d[o] !== null)
      return d[o];
    const l = r.call(e, n, c);
    return t.has(n) || t.set(n, [null, null]), t.get(n)[o] = l, l;
  };
}
function Cn(r, e) {
  fe(r instanceof Ee), fe(e >>> 0 === e), e & 7 && (e += 8 - (e & 7));
  const t = r.toString(16, e), i = [], n = [];
  fe((t.length & 7) === 0);
  for (let c = 0; c < t.length; c += 8)
    i.push(t.slice(c, c + 8));
  for (let c = 0; c < i.length; c += 4)
    n.push(i.slice(c, c + 4).join(" "));
  return n;
}
U0.Curve = k0;
U0.Point = Mr;
U0.ShortCurve = Ir;
U0.ShortPoint = Nr;
U0.JPoint = On;
U0.MontCurve = Or;
U0.MontPoint = w0;
U0.XPoint = cs;
U0.EdwardsCurve = t0;
U0.EdwardsPoint = m0;
U0.curves = go;
U0.curve = lA;
U0.register = xA;
/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */
const ur = Jr, Ic = fc, yn = MI, es = Z0, yA = FI, SA = XI, BA = U0;
let vA = class {
  constructor(e, t, i, n) {
    ur(typeof e == "string"), ur(t), ur(i), this.id = e, this.type = "ecdsa", this.hash = t, this.xof = i, this.native = 0, this._pre = n || null, this._curve = null, this._schnorr = null;
  }
  get curve() {
    return this._curve || (this._curve = BA.curve(this.id, this._pre), this._curve.precompute(yn), this._pre = null), this._curve;
  }
  get schnorr() {
    return this._schnorr || (this._schnorr = new yA(this.curve, this.xof)), this._schnorr;
  }
  get size() {
    return this.curve.fieldSize;
  }
  get bits() {
    return this.curve.fieldBits;
  }
  privateKeyGenerate() {
    const e = this.curve.randomScalar(yn);
    return this.curve.encodeScalar(e);
  }
  privateKeyVerify(e) {
    ur(Buffer.isBuffer(e));
    let t;
    try {
      t = this.curve.decodeScalar(e);
    } catch {
      return !1;
    }
    return !t.isZero() && t.cmp(this.curve.n) < 0;
  }
  privateKeyExport(e) {
    const t = this.publicKeyCreate(e, !1), { x: i, y: n } = this.publicKeyExport(t);
    return {
      d: Buffer.from(e),
      x: i,
      y: n
    };
  }
  privateKeyImport(e) {
    ur(e && typeof e == "object");
    const t = Ic.decode(e.d, this.curve.endian);
    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    return this.curve.encodeScalar(t);
  }
  privateKeyTweakAdd(e, t) {
    const i = this.curve.decodeScalar(t);
    if (i.cmp(this.curve.n) >= 0)
      throw new Error("Invalid scalar.");
    const n = this.curve.decodeScalar(e);
    if (n.isZero() || n.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    const c = n.add(i).imod(this.curve.n);
    if (c.isZero())
      throw new Error("Invalid private key.");
    return this.curve.encodeScalar(c);
  }
  privateKeyTweakMul(e, t) {
    const i = this.curve.decodeScalar(t);
    if (i.isZero() || i.cmp(this.curve.n) >= 0)
      throw new Error("Invalid scalar.");
    const n = this.curve.decodeScalar(e);
    if (n.isZero() || n.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    const c = n.mul(i).imod(this.curve.n);
    if (c.isZero())
      throw new Error("Invalid private key.");
    return this.curve.encodeScalar(c);
  }
  privateKeyNegate(e) {
    const t = this.curve.decodeScalar(e);
    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    const i = t.neg().imod(this.curve.n);
    return this.curve.encodeScalar(i);
  }
  privateKeyInvert(e) {
    const t = this.curve.decodeScalar(e);
    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    const i = t.invert(this.curve.n);
    return this.curve.encodeScalar(i);
  }
  publicKeyCreate(e, t) {
    const i = this.curve.decodeScalar(e);
    if (i.isZero() || i.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    return this.curve.g.mulBlind(i).encode(t);
  }
  publicKeyConvert(e, t) {
    return this.curve.decodePoint(e).encode(t);
  }
  publicKeyFromUniform(e, t) {
    const i = this.curve.decodeUniform(e);
    return this.curve.pointFromUniform(i).encode(t);
  }
  publicKeyToUniform(e, t = yn.randomInt()) {
    const i = this.curve.decodePoint(e), n = this.curve.pointToUniform(i, t);
    return this.curve.encodeUniform(n, t >>> 8);
  }
  publicKeyFromHash(e, t) {
    return this.curve.pointFromHash(e).encode(t);
  }
  publicKeyToHash(e) {
    const t = this.curve.decodePoint(e);
    return this.curve.pointToHash(t, 0, yn);
  }
  publicKeyVerify(e) {
    ur(Buffer.isBuffer(e));
    try {
      this.curve.decodePoint(e);
    } catch {
      return !1;
    }
    return !0;
  }
  publicKeyExport(e) {
    const { x: t, y: i } = this.curve.decodePoint(e);
    return {
      x: this.curve.encodeField(t.fromRed()),
      y: this.curve.encodeField(i.fromRed())
    };
  }
  publicKeyImport(e, t) {
    ur(e && typeof e == "object");
    const i = Ic.decode(e.x, this.curve.endian);
    if (i.cmp(this.curve.p) >= 0)
      throw new Error("Invalid point.");
    if (e.y != null) {
      const c = Ic.decode(e.y, this.curve.endian);
      if (c.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      const o = this.curve.point(i, c);
      if (!o.validate())
        throw new Error("Invalid point.");
      return o.encode(t);
    }
    return this.curve.pointFromX(i, e.sign).encode(t);
  }
  publicKeyTweakAdd(e, t, i) {
    const n = this.curve.decodeScalar(t);
    if (n.cmp(this.curve.n) >= 0)
      throw new Error("Invalid scalar.");
    const c = this.curve.decodePoint(e);
    return this.curve.g.jmul(n).add(c).encode(i);
  }
  publicKeyTweakMul(e, t, i) {
    const n = this.curve.decodeScalar(t);
    if (n.isZero() || n.cmp(this.curve.n) >= 0)
      throw new Error("Invalid scalar.");
    return this.curve.decodePoint(e).mul(n).encode(i);
  }
  publicKeyCombine(e, t) {
    ur(Array.isArray(e));
    let i = this.curve.jpoint();
    for (const n of e) {
      const c = this.curve.decodePoint(n);
      i = i.add(c);
    }
    return i.encode(t);
  }
  publicKeyNegate(e, t) {
    return this.curve.decodePoint(e).neg().encode(t);
  }
  signatureNormalize(e) {
    const [t, i] = this._decodeCompact(e);
    return i.cmp(this.curve.nh) > 0 && i.ineg().imod(this.curve.n), this._encodeCompact(t, i);
  }
  signatureNormalizeDER(e) {
    const [t, i] = this._decodeDER(e, !1);
    return i.cmp(this.curve.nh) > 0 && i.ineg().imod(this.curve.n), this._encodeDER(t, i);
  }
  signatureExport(e) {
    const [t, i] = this._decodeCompact(e);
    return this._encodeDER(t, i);
  }
  signatureImport(e) {
    const [t, i] = this._decodeDER(e, !1);
    return this._encodeCompact(t, i);
  }
  isLowS(e) {
    ur(Buffer.isBuffer(e));
    let t;
    try {
      [, t] = this._decodeCompact(e);
    } catch {
      return !1;
    }
    return t.cmp(this.curve.nh) <= 0;
  }
  isLowDER(e) {
    ur(Buffer.isBuffer(e));
    let t;
    try {
      [, t] = this._decodeDER(e, !1);
    } catch {
      return !1;
    }
    return t.cmp(this.curve.nh) <= 0;
  }
  sign(e, t) {
    const [i, n] = this._sign(e, t);
    return this._encodeCompact(i, n);
  }
  signRecoverable(e, t) {
    const [i, n, c] = this._sign(e, t);
    return [this._encodeCompact(i, n), c];
  }
  signDER(e, t) {
    const [i, n] = this._sign(e, t);
    return this._encodeDER(i, n);
  }
  signRecoverableDER(e, t) {
    const [i, n, c] = this._sign(e, t);
    return [this._encodeDER(i, n), c];
  }
  _sign(e, t) {
    const { n: i, nh: n } = this.curve, c = this.curve.g, o = this.curve.decodeScalar(t);
    if (o.isZero() || o.cmp(i) >= 0)
      throw new Error("Invalid private key.");
    const d = this._reduce(e), l = this.curve.encodeScalar(d), h = new SA(this.hash, t, l);
    for (; ; ) {
      const x = h.generate(this.curve.scalarSize), b = this._truncate(x);
      if (b.isZero() || b.cmp(i) >= 0)
        continue;
      const g = c.mulBlind(b);
      if (g.isInfinity())
        continue;
      const w = g.getX(), I = w.mod(i);
      if (I.isZero())
        continue;
      const B = this.curve.randomScalar(yn), y = b.mul(B).fermat(i), A = o.mul(B).imod(i), _ = d.mul(B).imod(i), U = I.mul(A).iadd(_).imod(i).mul(y).imod(i);
      if (U.isZero())
        continue;
      let z = g.isOdd() | !w.eq(I) << 1;
      return U.cmp(n) > 0 && (U.ineg().imod(i), z ^= 1), [I, U, z];
    }
  }
  verify(e, t, i) {
    ur(Buffer.isBuffer(e)), ur(Buffer.isBuffer(t)), ur(Buffer.isBuffer(i));
    let n, c;
    try {
      [n, c] = this._decodeCompact(t);
    } catch {
      return !1;
    }
    try {
      return this._verify(e, n, c, i);
    } catch {
      return !1;
    }
  }
  verifyDER(e, t, i) {
    ur(Buffer.isBuffer(e)), ur(Buffer.isBuffer(t)), ur(Buffer.isBuffer(i));
    let n, c;
    try {
      [n, c] = this._decodeDER(t, !1);
    } catch {
      return !1;
    }
    try {
      return this._verify(e, n, c, i);
    } catch {
      return !1;
    }
  }
  _verify(e, t, i, n) {
    const { n: c } = this.curve, o = this.curve.g, d = this._reduce(e), l = this.curve.decodePoint(n);
    if (t.isZero() || t.cmp(c) >= 0 || i.isZero() || i.cmp(c) >= 0)
      return !1;
    const h = i.invert(c), x = d.mul(h).imod(c), b = t.mul(h).imod(c);
    return o.jmulAdd(x, l, b).eqR(t);
  }
  recover(e, t, i, n) {
    ur(Buffer.isBuffer(e)), ur(Buffer.isBuffer(t)), ur(i >>> 0 === i), ur((i & 3) === i, "The recovery param is more than two bits.");
    let c, o;
    try {
      [c, o] = this._decodeCompact(t);
    } catch {
      return null;
    }
    let d;
    try {
      d = this._recover(e, c, o, i);
    } catch {
      return null;
    }
    return d.encode(n);
  }
  recoverDER(e, t, i, n) {
    ur(Buffer.isBuffer(e)), ur(Buffer.isBuffer(t)), ur(i >>> 0 === i), ur((i & 3) === i, "The recovery param is more than two bits.");
    let c, o;
    try {
      [c, o] = this._decodeDER(t, !1);
    } catch {
      return null;
    }
    let d;
    try {
      d = this._recover(e, c, o, i);
    } catch {
      return null;
    }
    return d.encode(n);
  }
  _recover(e, t, i, n) {
    const { n: c, pmodn: o } = this.curve, d = this.curve.g, l = this._reduce(e);
    if (t.isZero() || t.cmp(c) >= 0)
      throw new Error("Invalid R value.");
    if (i.isZero() || i.cmp(c) >= 0)
      throw new Error("Invalid S value.");
    const h = (n & 1) !== 0, x = n >>> 1;
    let b = t;
    if (x) {
      if (this.curve.highOrder)
        throw new Error("Invalid high bit.");
      if (b.cmp(o) >= 0)
        throw new Error("Invalid R value.");
      b = b.add(c);
    }
    const g = this.curve.pointFromX(b, h), w = t.invert(c), I = l.mul(w).ineg().imod(c), B = i.mul(w).imod(c), y = d.mulAdd(I, g, B);
    if (y.isInfinity())
      throw new Error("Invalid point.");
    return y;
  }
  derive(e, t, i) {
    const n = this.curve.decodePoint(e), c = this.curve.decodeScalar(t);
    if (c.isZero() || c.cmp(this.curve.n) >= 0)
      throw new Error("Invalid private key.");
    if (this.curve.h.cmpn(1) > 0 && n.isSmall())
      throw new Error("Invalid point.");
    return n.mulBlind(c, yn).encode(i);
  }
  /*
   * Schnorr
   */
  schnorrSign(e, t) {
    return this.schnorr.sign(e, t);
  }
  schnorrVerify(e, t, i) {
    return this.schnorr.verify(e, t, i);
  }
  schnorrVerifyBatch(e) {
    return this.schnorr.verifyBatch(e);
  }
  /*
   * Helpers
   */
  _encodeCompact(e, t) {
    return Buffer.concat([
      this.curve.encodeScalar(e),
      this.curve.encodeScalar(t)
    ]);
  }
  _decodeCompact(e) {
    ur(Buffer.isBuffer(e));
    const { n: t } = this.curve, i = this.curve.scalarSize;
    if (e.length !== i * 2)
      throw new Error("Invalid signature size.");
    const n = e.slice(0, i), c = e.slice(i, i * 2), o = this.curve.decodeScalar(n), d = this.curve.decodeScalar(c);
    if (o.cmp(t) >= 0 || d.cmp(t) >= 0)
      throw new Error("Invalid signature.");
    return [o, d];
  }
  _encodeDER(e, t) {
    const i = es.sizeInt(e) + es.sizeInt(t), n = Buffer.alloc(es.sizeSeq(i));
    let c = 0;
    return c = es.writeSeq(n, c, i), c = es.writeInt(n, c, e), c = es.writeInt(n, c, t), ur(c === n.length), n;
  }
  _decodeDER(e, t) {
    ur(Buffer.isBuffer(e)), ur(typeof t == "boolean");
    const { n: i } = this.curve;
    let n = 0, c, o;
    if (n = es.readSeq(e, n, t), [c, n] = es.readInt(e, n, t), [o, n] = es.readInt(e, n, t), t && n !== e.length)
      throw new Error("Trailing bytes.");
    if (c.cmp(i) >= 0 || o.cmp(i) >= 0)
      throw new Error("Invalid signature.");
    return [c, o];
  }
  _truncate(e) {
    ur(Buffer.isBuffer(e));
    const t = this.curve.n.bitLength(), i = t + 7 >>> 3;
    e.length > i && (e = e.slice(0, i));
    const n = Ic.decode(e, this.curve.endian), c = e.length * 8 - t;
    return c > 0 && n.iushrn(c), n;
  }
  _reduce(e) {
    return this._truncate(e).imod(this.curve.n);
  }
};
var EA = vA;
const IA = {
  width: 9,
  points: [
    [
      "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
      "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
    ],
    [
      "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
      "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
    ],
    [
      "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
      "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
    ],
    [
      "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
      "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
    ],
    [
      "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
      "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
    ],
    [
      "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
      "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
    ],
    [
      "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
      "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
    ],
    [
      "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
      "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
    ],
    [
      "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
      "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
    ],
    [
      "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
      "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
    ],
    [
      "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
      "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
    ],
    [
      "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
      "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
    ],
    [
      "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
      "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
    ],
    [
      "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
      "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
    ],
    [
      "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
      "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
    ],
    [
      "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
      "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
    ],
    [
      "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
      "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
    ],
    [
      "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
      "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
    ],
    [
      "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
      "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
    ],
    [
      "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
      "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
    ],
    [
      "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
      "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
    ],
    [
      "049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
      "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
    ],
    [
      "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
      "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
    ],
    [
      "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
      "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
    ],
    [
      "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
      "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
    ],
    [
      "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
      "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
    ],
    [
      "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
      "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
    ],
    [
      "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
      "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
    ],
    [
      "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
      "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
    ],
    [
      "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
      "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
    ],
    [
      "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
      "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
    ],
    [
      "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
      "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
    ],
    [
      "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
      "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
    ],
    [
      "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
      "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
    ],
    [
      "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
      "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
    ],
    [
      "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
      "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
    ],
    [
      "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
      "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
    ],
    [
      "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
      "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
    ],
    [
      "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
      "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
    ],
    [
      "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
      "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
    ],
    [
      "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
      "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
    ],
    [
      "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
      "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
    ],
    [
      "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
      "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
    ],
    [
      "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
      "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
    ],
    [
      "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
      "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
    ],
    [
      "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
      "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
    ],
    [
      "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
      "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
    ],
    [
      "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
      "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
    ],
    [
      "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
      "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
    ],
    [
      "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
      "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
    ],
    [
      "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
      "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
    ],
    [
      "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
      "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
    ],
    [
      "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
      "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
    ],
    [
      "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
      "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
    ],
    [
      "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
      "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
    ],
    [
      "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
      "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
    ],
    [
      "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
      "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
    ],
    [
      "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
      "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
    ],
    [
      "078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
      "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
    ],
    [
      "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
      "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
    ],
    [
      "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
      "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
    ],
    [
      "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
      "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
    ],
    [
      "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
      "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
    ],
    [
      "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
      "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
    ],
    [
      "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
      "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
    ],
    [
      "0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
      "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
    ],
    [
      "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
      "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
    ],
    [
      "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
      "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
    ],
    [
      "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
      "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
    ],
    [
      "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
      "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
    ],
    [
      "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
      "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
    ],
    [
      "04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
      "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
    ],
    [
      "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
      "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
    ],
    [
      "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
      "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
    ],
    [
      "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
      "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
    ],
    [
      "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
      "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
    ],
    [
      "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
      "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
    ],
    [
      "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
      "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
    ],
    [
      "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
      "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
    ],
    [
      "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
      "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
    ],
    [
      "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
      "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
    ],
    [
      "0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
      "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
    ],
    [
      "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
      "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
    ],
    [
      "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
      "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
    ],
    [
      "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
      "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
    ],
    [
      "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
      "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
    ],
    [
      "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
      "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
    ],
    [
      "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
      "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
    ],
    [
      "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
      "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
    ],
    [
      "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
      "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
    ],
    [
      "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
      "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
    ],
    [
      "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
      "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
    ],
    [
      "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
      "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
    ],
    [
      "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
      "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
    ],
    [
      "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
      "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
    ],
    [
      "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
      "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
    ],
    [
      "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
      "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
    ],
    [
      "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
      "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
    ],
    [
      "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
      "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
    ],
    [
      "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
      "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
    ],
    [
      "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
      "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
    ],
    [
      "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
      "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
    ],
    [
      "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
      "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
    ],
    [
      "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
      "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
    ],
    [
      "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
      "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
    ],
    [
      "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
      "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
    ],
    [
      "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
      "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
    ],
    [
      "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
      "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
    ],
    [
      "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
      "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
    ],
    [
      "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
      "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
    ],
    [
      "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
      "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
    ],
    [
      "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
      "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
    ],
    [
      "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
      "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
    ],
    [
      "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
      "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
    ],
    [
      "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
      "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
    ],
    [
      "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
      "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
    ],
    [
      "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
      "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
    ],
    [
      "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
      "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
    ],
    [
      "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
      "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
    ],
    [
      "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
      "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
    ],
    [
      "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
      "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
    ],
    [
      "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
      "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
    ],
    [
      "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
      "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
    ],
    [
      "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
      "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
    ],
    [
      "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
      "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
    ],
    [
      "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
      "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
    ],
    [
      "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
      "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
    ]
  ]
}, AA = {
  step: 4,
  points: [
    [
      "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
      "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
    ],
    [
      "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
      "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
    ],
    [
      "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
      "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
    ],
    [
      "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
      "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
    ],
    [
      "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
      "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
    ],
    [
      "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
      "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
    ],
    [
      "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
      "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
    ],
    [
      "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
      "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
    ],
    [
      "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
      "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
    ],
    [
      "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
      "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
    ],
    [
      "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
      "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
    ],
    [
      "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
      "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
    ],
    [
      "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
      "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
    ],
    [
      "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
      "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
    ],
    [
      "06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
      "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
    ],
    [
      "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
      "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
    ],
    [
      "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
      "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
    ],
    [
      "0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
      "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
    ],
    [
      "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
      "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
    ],
    [
      "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
      "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
    ],
    [
      "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
      "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
    ],
    [
      "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
      "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
    ],
    [
      "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
      "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
    ],
    [
      "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
      "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
    ],
    [
      "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
      "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
    ],
    [
      "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
      "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
    ],
    [
      "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
      "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
    ],
    [
      "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
      "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
    ],
    [
      "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
      "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
    ],
    [
      "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
      "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
    ],
    [
      "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
      "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
    ],
    [
      "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
      "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
    ],
    [
      "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
      "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
    ],
    [
      "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
      "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
    ],
    [
      "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
      "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
    ],
    [
      "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
      "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
    ],
    [
      "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
      "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
    ],
    [
      "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
      "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
    ],
    [
      "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
      "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
    ],
    [
      "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
      "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
    ],
    [
      "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
      "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
    ],
    [
      "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
      "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
    ],
    [
      "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
      "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
    ],
    [
      "0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
      "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
    ],
    [
      "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
      "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
    ],
    [
      "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
      "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
    ],
    [
      "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
      "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
    ],
    [
      "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
      "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
    ],
    [
      "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
      "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
    ],
    [
      "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
      "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
    ],
    [
      "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
      "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
    ],
    [
      "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
      "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
    ],
    [
      "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
      "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
    ],
    [
      "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
      "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
    ],
    [
      "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
      "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
    ],
    [
      "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
      "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
    ],
    [
      "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
      "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
    ],
    [
      "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
      "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
    ],
    [
      "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
      "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
    ],
    [
      "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
      "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
    ],
    [
      "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
      "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
    ],
    [
      "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
      "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
    ],
    [
      "08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
      "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
    ],
    [
      "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
      "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
    ],
    [
      "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
      "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
    ]
  ]
}, _A = {
  naf: IA,
  doubles: AA
};
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
const MA = EA, y4 = pa, NA = _A;
var OA = new MA("SECP256K1", y4, y4, NA);
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var cc = OA;
/*!
 * message.js - message signing utilities.
 * Copyright (c) 2019, The Bcoin Developers (MIT License).
 */
(function(r) {
  const e = Ar, t = Me, i = jo, n = cc, c = r;
  c.MAGIC_STRING = `Bitcoin Signed Message:
`, c.magicHash = (o, d = c.MAGIC_STRING) => {
    e(typeof d == "string", "prefix must be a string."), e(typeof o == "string", "message must be a string");
    const l = t.write();
    return l.writeVarString(d), l.writeVarString(o, "utf8"), i.digest(l.render());
  }, c.sign = (o, d, l) => {
    e(d.getPrivateKey(), "Cannot sign without private key.");
    const h = c.magicHash(o, l), x = d.getPublicKey().readInt8(0) !== 4, [b, g] = n.signRecoverable(h, d.getPrivateKey()), w = t.write();
    return w.writeI8(g + 27 + (x ? 4 : 0)), w.writeBytes(b), w.render();
  }, c.recover = (o, d, l) => {
    e(typeof o == "string", "msg must be a string"), e(Buffer.isBuffer(d), "sig must be a buffer");
    const h = c.magicHash(o, l);
    e.strictEqual(d.length, 65, "Invalid signature length");
    const x = d.readUInt8(0) - 27;
    e(x < 8, "Invalid signature parameter");
    const b = !!(x & 4), g = x & 3;
    return n.recover(h, d.slice(1), g, b);
  };
})(np);
/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
Gr.binary = ma;
Gr.fixed = Jl;
Gr.util = Os;
Gr.message = np;
const { inspect: { custom: PA } } = M0;
Gr.inspectSymbol = PA || "inspect";
/*!
 * network.js - network object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Sn = Ar, RA = ma, Ac = sp, S4 = ri, kA = vI, { inspectSymbol: qA } = Gr;
let Ps = class Wt {
  /**
   * Create a network.
   * @constructor
   * @param {Object} options
   */
  constructor(e) {
    Sn(!Wt[e.type], "Cannot create two networks."), this.type = e.type, this.seeds = e.seeds, this.magic = e.magic, this.port = e.port, this.checkpointMap = e.checkpointMap, this.lastCheckpoint = e.lastCheckpoint, this.txnData = e.txnData, this.checkpoints = [], this.halvingInterval = e.halvingInterval, this.genesis = e.genesis, this.genesisBlock = e.genesisBlock, this.pow = e.pow, this.block = e.block, this.bip30 = e.bip30, this.activationThreshold = e.activationThreshold, this.minerWindow = e.minerWindow, this.deployments = e.deployments, this.deploys = e.deploys, this.unknownBits = ~S4.VERSION_TOP_MASK, this.keyPrefix = e.keyPrefix, this.addressPrefix = e.addressPrefix, this.requireStandard = e.requireStandard, this.rpcPort = e.rpcPort, this.walletPort = e.walletPort, this.minRelay = e.minRelay, this.feeRate = e.feeRate, this.maxFeeRate = e.maxFeeRate, this.selfConnect = e.selfConnect, this.requestMempool = e.requestMempool, this.time = new kA(), this.init();
  }
  /**
   * Get a deployment by bit index.
   * @returns {Object}
   */
  init() {
    let e = 0;
    for (const t of this.deploys)
      e |= 1 << t.bit;
    e |= S4.VERSION_TOP_MASK, this.unknownBits = ~e >>> 0;
    for (const t of Object.keys(this.checkpointMap)) {
      const i = this.checkpointMap[t], n = Number(t);
      this.checkpoints.push({ hash: i, height: n });
    }
    this.checkpoints.sort(UA);
  }
  /**
   * Get a deployment by bit index.
   * @param {Number} bit
   * @returns {Object}
   */
  byBit(e) {
    const t = RA.search(this.deploys, e, zA);
    return t === -1 ? null : this.deploys[t];
  }
  /**
   * Get network adjusted time.
   * @returns {Number}
   */
  now() {
    return this.time.now();
  }
  /**
   * Get network adjusted time in milliseconds.
   * @returns {Number}
   */
  ms() {
    return this.time.ms();
  }
  /**
   * Create a network. Get existing network if possible.
   * @param {NetworkType|Object} options
   * @returns {Network}
   */
  static create(e) {
    if (typeof e == "string" && (e = Ac[e]), Sn(e, "Unknown network."), Wt[e.type])
      return Wt[e.type];
    const t = new Wt(e);
    return Wt[t.type] = t, Wt.primary || (Wt.primary = t), t;
  }
  /**
   * Set the default network. This network will be used
   * if nothing is passed as the `network` option for
   * certain objects.
   * @param {NetworkType} type - Network type.
   * @returns {Network}
   */
  static set(e) {
    return Sn(typeof e == "string", "Bad network."), Wt.primary = Wt.get(e), Wt.type = e, Wt.primary;
  }
  /**
   * Get a network with a string or a Network object.
   * @param {NetworkType|Network} type - Network type.
   * @returns {Network}
   */
  static get(e) {
    if (!e)
      return Sn(Wt.primary, "No default network."), Wt.primary;
    if (e instanceof Wt)
      return e;
    if (typeof e == "string")
      return Wt.create(e);
    throw new Error("Unknown network.");
  }
  /**
   * Get a network with a string or a Network object.
   * @param {NetworkType|Network} type - Network type.
   * @returns {Network}
   */
  static ensure(e) {
    return e ? e instanceof Wt ? e : typeof e == "string" && Ac[e] ? Wt.create(e) : (Sn(Wt.primary, "No default network."), Wt.primary) : (Sn(Wt.primary, "No default network."), Wt.primary);
  }
  /**
   * Get a network by an associated comparator.
   * @private
   * @param {Object} value
   * @param {Function} compare
   * @param {Network|null} network
   * @param {String} name
   * @returns {Network}
   */
  static by(e, t, i, n) {
    if (i) {
      if (i = Wt.get(i), t(i, e))
        return i;
      throw new Error(`Network mismatch for ${n}.`);
    }
    for (const c of Ac.types)
      if (i = Ac[c], t(i, e))
        return Wt.get(c);
    throw new Error(`Network not found for ${n}.`);
  }
  /**
   * Get a network by its magic number.
   * @param {Number} value
   * @param {Network?} network
   * @returns {Network}
   */
  static fromMagic(e, t) {
    return Wt.by(e, CA, t, "magic number");
  }
  /**
   * Get a network by its WIF prefix.
   * @param {Number} prefix
   * @param {Network?} network
   * @returns {Network}
   */
  static fromWIF(e, t) {
    return Wt.by(e, TA, t, "WIF");
  }
  /**
   * Get a network by its xpubkey prefix.
   * @param {Number} prefix
   * @param {Network?} network
   * @returns {Network}
   */
  static fromPublic(e, t) {
    return Wt.by(e, DA, t, "xpubkey");
  }
  /**
   * Get a network by its xprivkey prefix.
   * @param {Number} prefix
   * @param {Network?} network
   * @returns {Network}
   */
  static fromPrivate(e, t) {
    return Wt.by(e, LA, t, "xprivkey");
  }
  /**
   * Get a network by its xpubkey base58 prefix.
   * @param {String} prefix
   * @param {Network?} network
   * @returns {Network}
   */
  static fromPublic58(e, t) {
    return Wt.by(e, KA, t, "xpubkey");
  }
  /**
   * Get a network by its xprivkey base58 prefix.
   * @param {String} prefix
   * @param {Network?} network
   * @returns {Network}
   */
  static fromPrivate58(e, t) {
    return Wt.by(e, $A, t, "xprivkey");
  }
  /**
   * Get a network by its base58 address prefix.
   * @param {Number} prefix
   * @param {Network?} network
   * @returns {Network}
   */
  static fromBase58(e, t) {
    return Wt.by(e, HA, t, "base58 address");
  }
  /**
   * Get a network by its bech32 address prefix.
   * @param {String} hrp
   * @param {Network?} network
   * @returns {Network}
   */
  static fromBech32(e, t) {
    return Wt.by(e, B4, t, "bech32 address");
  }
  /**
   * Get a network by its bech32m address prefix.
   * @param {String} hrp
   * @param {Network?} network
   * @returns {Network}
   */
  static fromBech32m(e, t) {
    return Wt.by(e, B4, t, "bech32m address");
  }
  /**
   * Convert the network to a string.
   * @returns {String}
   */
  toString() {
    return this.type;
  }
  /**
   * Inspect the network.
   * @returns {String}
   */
  [qA]() {
    return `<Network: ${this.type}>`;
  }
  /**
   * Test an object to see if it is a Network.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isNetwork(e) {
    return e instanceof Wt;
  }
};
Ps.primary = null;
Ps.type = null;
Ps.main = null;
Ps.testnet = null;
Ps.regtest = null;
Ps.simnet = null;
Ps.set(process.env.BCOIN_NETWORK || "main");
function zA(r, e) {
  return r.bit - e;
}
function UA(r, e) {
  return r.height - e.height;
}
function CA(r, e) {
  return r.magic === e;
}
function TA(r, e) {
  return r.keyPrefix.privkey === e;
}
function DA(r, e) {
  return r.keyPrefix.xpubkey === e;
}
function LA(r, e) {
  return r.keyPrefix.xprivkey === e;
}
function KA(r, e) {
  return r.keyPrefix.xpubkey58 === e;
}
function $A(r, e) {
  return r.keyPrefix.xprivkey58 === e;
}
function HA(r, e) {
  const t = r.addressPrefix;
  switch (e) {
    case t.pubkeyhash:
    case t.scripthash:
      return !0;
  }
  return !1;
}
function B4(r, e) {
  return r.addressPrefix.bech32 === e;
}
var oc = Ps;
/*!
 * address.js - address object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Xt = Ar, v4 = Me, E4 = XE, I4 = eI, A4 = fI, FA = pa, _c = ip, _4 = jo, Bn = oc, VA = ri, { inspectSymbol: GA } = Gr, M4 = Buffer.alloc(20, 0);
let e2 = class jt {
  /**
   * Create an address.
   * @constructor
   * @param {Object?} options
   * @param {Network} network
   */
  constructor(e, t) {
    this.type = jt.types.WITNESS, this.version = 0, this.hash = M4, e && this.fromOptions(e, t);
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   * @param {Network} network
   */
  fromOptions(e, t) {
    if (typeof e == "string")
      return this.fromString(e, t);
    Xt(e);
    const { hash: i, type: n, version: c } = e;
    return this.fromHash(i, n, c);
  }
  /**
   * Insantiate address from options.
   * @param {Object} options
   * @param {Network} network
   * @returns {Address}
   */
  static fromOptions(e, t) {
    return new this().fromOptions(e, t);
  }
  /**
   * Get the address hash.
   * @param {String?} enc - Can be `"hex"` or `null`.
   * @returns {Hash|Buffer}
   */
  getHash(e) {
    return e === "hex" ? this.hash.toString("hex") : this.hash;
  }
  /**
   * Test whether the address is null.
   * @returns {Boolean}
   */
  isNull() {
    if (this.hash.length === 20)
      return this.hash.equals(M4);
    if (this.hash.length === 32)
      return this.hash.equals(VA.ZERO_HASH);
    for (let e = 0; e < this.hash.length; e++)
      if (this.hash[e] !== 0)
        return !1;
    return !0;
  }
  /**
   * Test equality against another address.
   * @param {Address} addr
   * @returns {Boolean}
   */
  equals(e) {
    return Xt(e instanceof jt), this.type === e.type && this.version === e.version && this.hash.equals(e.hash);
  }
  /**
   * Get the address type as a string.
   * @returns {String}
   */
  getType() {
    return jt.typesByVal[this.type].toLowerCase();
  }
  /**
   * Get prefix for indexers
   * It's a single byte encoded as follows:
   *  1 bit whether it's legacy or witness.
   *  7 bits used for the data.
   * @param {Network|String} network
   * @returns {Number}
   */
  getPrefix(e) {
    return this.isProgram() ? this.version : 128 | this.getBase58Prefix(e);
  }
  /**
   * Get a network address prefix for the address.
   * @param {Network?} network
   * @returns {Number}
   */
  getBase58Prefix(e) {
    e = Bn.get(e);
    const t = e.addressPrefix;
    switch (this.type) {
      case jt.types.PUBKEYHASH:
        return t.pubkeyhash;
      case jt.types.SCRIPTHASH:
        return t.scripthash;
    }
    return -1;
  }
  /**
   * Calculate size of serialized address.
   * @returns {Number}
   */
  getSize() {
    let e = 5 + this.hash.length;
    return this.version !== -1 && (e += 2), e;
  }
  /**
   * Compile the address object to its raw serialization.
   * @param {NetworkType | Network} [network]
   * @returns {Buffer}
   * @throws Error on bad hash/prefix.
   */
  toRaw(e) {
    const t = this.getSize(), i = v4.write(t), n = this.getBase58Prefix(e);
    return Xt(n !== -1, "Not a valid address prefix."), i.writeU8(n), this.version !== -1 && (i.writeU8(this.version), i.writeU8(0)), i.writeBytes(this.hash), i.writeChecksum(_4.digest), i.render();
  }
  /**
   * Compile the address object to a base58 address.
   * @param {NetworkType|Network} network
   * @returns {AddressString}
   * @throws Error on bad hash/prefix.
   */
  toBase58(e) {
    return E4.encode(this.toRaw(e));
  }
  /**
   * Compile the address object to a bech32 address.
   * @param {NetworkType|Network} [network]
   * @returns {String}
   * @throws Error on bad hash/prefix.
   */
  toBech32(e) {
    const t = this.version, i = this.hash;
    Xt(t !== -1, "Cannot convert non-program address to bech32."), Xt(t === 0, "Cannot convert program version > 0 to bech32 address."), e = Bn.get(e);
    const n = e.addressPrefix.bech32;
    return I4.encode(n, t, i);
  }
  /**
   * Compile the address object to a bech32m address.
   * @param {NetworkType|Network} [network]
   * @returns {String}
   * @throws Error on bad hash/prefix.
   */
  toBech32m(e) {
    const t = this.version, i = this.hash;
    Xt(t !== -1, "Cannot convert non-program address to bech32m."), Xt(t !== 0, "Cannot convert version 0 program to bech32m address."), e = Bn.get(e);
    const n = e.addressPrefix.bech32;
    return A4.encode(n, t, i);
  }
  /**
   * Inject properties from string.
   * @private
   * @param {String} addr
   * @param {(Network|NetworkType)?} network
   * @returns {Address}
   */
  fromString(e, t) {
    if (Xt(typeof e == "string"), Xt(e.length > 0), Xt(e.length <= 100), YA(e))
      return this.fromBase58(e, t);
    try {
      try {
        return this.fromBech32(e, t);
      } catch {
        return this.fromBech32m(e, t);
      }
    } catch {
      return this.fromBase58(e, t);
    }
  }
  /**
   * Instantiate address from string.
   * @param {String} addr
   * @param {(Network|NetworkType)?} network
   * @returns {Address}
   */
  static fromString(e, t) {
    return new this().fromString(e, t);
  }
  /**
   * Convert the Address to a string.
   * @param {(Network|NetworkType)?} network
   * @returns {AddressString}
   */
  toString(e) {
    return this.version !== -1 ? this.version === 0 ? this.toBech32(e) : this.toBech32m(e) : this.toBase58(e);
  }
  /**
   * Inspect the Address.
   * @returns {Object}
   */
  [GA]() {
    return `<Address: type=${this.getType()} version=${this.version} str=${this.toString()}>`;
  }
  /**
   * Decode base58.
   * @private
   * @param {Buffer} data
   * @param {Network} network
   * @throws Parse error
   */
  fromRaw(e, t) {
    const i = v4.read(e, !0), n = i.readU8();
    t = Bn.fromBase58(n, t);
    const c = jt.getType(n, t);
    if (e.length !== 25)
      throw new Error("Address is too long.");
    const o = i.readBytes(i.left() - 4);
    return i.verifyChecksum(_4.digest), this.fromHash(o, c);
  }
  /**
   * Create an address object from a serialized address.
   * @param {Buffer} data
   * @param {Network} network
   * @returns {Address}
   * @throws Parse error.
   */
  static fromRaw(e, t) {
    return new this().fromRaw(e, t);
  }
  /**
   * Inject properties from base58 address.
   * @private
   * @param {AddressString} data
   * @param {Network?} network
   * @throws Parse error
   */
  fromBase58(e, t) {
    if (Xt(typeof e == "string"), e.length > 55)
      throw new Error("Address is too long.");
    return this.fromRaw(E4.decode(e), t);
  }
  /**
   * Create an address object from a base58 address.
   * @param {AddressString} data
   * @param {Network?} network
   * @returns {Address}
   * @throws Parse error.
   */
  static fromBase58(e, t) {
    return new this().fromBase58(e, t);
  }
  /**
   * Inject properties from bech32 address.
   * @private
   * @param {String} data
   * @param {Network?} network
   * @throws Parse error
   */
  fromBech32(e, t) {
    const i = jt.types.WITNESS;
    Xt(typeof e == "string");
    const [n, c, o] = I4.decode(e);
    return Xt(c !== -1, "Cannot convert non-program address to bech32"), Xt(c === 0, "Cannot convert program version > 0 to bech32"), Bn.fromBech32(n, t), this.fromHash(o, i, c);
  }
  /**
   * Create an address object from a bech32 address.
   * @param {String} data
   * @param {Network?} network
   * @returns {Address}
   * @throws Parse error.
   */
  static fromBech32(e, t) {
    return new this().fromBech32(e, t);
  }
  /**
   * Inject properties from bech32m address.
   * @private
   * @param {String} data
   * @param {Network?} network
   * @throws Parse error
   */
  fromBech32m(e, t) {
    const i = jt.types.WITNESS;
    Xt(typeof e == "string");
    const [n, c, o] = A4.decode(e);
    return Xt(c !== -1, "Cannot convert non-program address to bech32m"), Xt(c > 0, "Cannot convert program version 0 to bech32m."), Bn.fromBech32m(n, t), this.fromHash(o, i, c);
  }
  /**
   * Create an address object from a bech32m address.
   * @param {String} data
   * @param {Network?} network
   * @returns {Address}
   * @throws Parse error.
   */
  static fromBech32m(e, t) {
    return new this().fromBech32m(e, t);
  }
  /**
   * Inject properties from output script.
   * @private
   * @param {Script} script
   */
  fromScript(e) {
    const t = e.getPubkey();
    if (t)
      return this.hash = _c.digest(t), this.type = jt.types.PUBKEYHASH, this.version = -1, this;
    const i = e.getPubkeyhash();
    if (i)
      return this.hash = i, this.type = jt.types.PUBKEYHASH, this.version = -1, this;
    const n = e.getScripthash();
    if (n)
      return this.hash = n, this.type = jt.types.SCRIPTHASH, this.version = -1, this;
    const c = e.getProgram();
    return c && !c.isMalformed() ? (this.hash = c.data, this.type = jt.types.WITNESS, this.version = c.version, this) : e.isMultisig() ? (this.hash = e.hash160(), this.type = jt.types.SCRIPTHASH, this.version = -1, this) : null;
  }
  /**
   * Inject properties from witness.
   * @private
   * @param {Witness} witness
   */
  fromWitness(e) {
    const [, t] = e.getPubkeyhashInput();
    if (t)
      return this.hash = _c.digest(t), this.type = jt.types.WITNESS, this.version = 0, this;
    const i = e.getScripthashInput();
    return i ? (this.hash = FA.digest(i), this.type = jt.types.WITNESS, this.version = 0, this) : null;
  }
  /**
   * Inject properties from input script.
   * @private
   * @param {Script} script
   */
  fromInputScript(e) {
    const [, t] = e.getPubkeyhashInput();
    if (t)
      return this.hash = _c.digest(t), this.type = jt.types.PUBKEYHASH, this.version = -1, this;
    const i = e.getScripthashInput();
    return i ? (this.hash = _c.digest(i), this.type = jt.types.SCRIPTHASH, this.version = -1, this) : null;
  }
  /**
   * Create an Address from a witness.
   * Attempt to extract address
   * properties from a witness.
   * @param {Witness} witness
   * @returns {Address|null}
   */
  static fromWitness(e) {
    return new this().fromWitness(e);
  }
  /**
   * Create an Address from an input script.
   * Attempt to extract address
   * properties from an input script.
   * @param {Script} script
   * @returns {Address|null}
   */
  static fromInputScript(e) {
    return new this().fromInputScript(e);
  }
  /**
   * Create an Address from an output script.
   * Parse an output script and extract address
   * properties. Converts pubkey and multisig
   * scripts to pubkeyhash and scripthash addresses.
   * @param {Script} script
   * @returns {Address|null}
   */
  static fromScript(e) {
    return new this().fromScript(e);
  }
  /**
   * Inject properties from a hash.
   * @private
   * @param {Buffer|Hash} hash
   * @param {AddressPrefix} type
   * @param {Number} [version=-1]
   * @throws on bad hash size
   */
  fromHash(e, t, i) {
    return typeof t == "string" && (t = jt.types[t.toUpperCase()], Xt(t != null, "Not a valid address type.")), t == null && (t = jt.types.PUBKEYHASH), i == null && (i = -1), Xt(Buffer.isBuffer(e)), Xt(t >>> 0 === t), Xt((i | 0) === i), Xt(t >= jt.types.PUBKEYHASH && t <= jt.types.WITNESS, "Not a valid address type."), i === -1 ? (Xt(t !== jt.types.WITNESS, "Wrong version (witness)"), Xt(e.length === 20, "Hash is the wrong size.")) : (Xt(t === jt.types.WITNESS, "Wrong version (non-witness)."), Xt(i >= 0 && i <= 16, "Bad program version."), i === 0 && Xt(e.length === 20 || e.length === 32, "Witness version 0 program hash is the wrong size."), Xt(e.length >= 2 && e.length <= 40, "Hash is the wrong size.")), this.hash = e, this.type = t, this.version = i, this;
  }
  /**
   * Create a naked address from hash/type/version.
   * @param {Hash} hash
   * @param {AddressPrefix} type
   * @param {Number} [version=-1]
   * @returns {Address}
   * @throws on bad hash size
   */
  static fromHash(e, t, i) {
    return new this().fromHash(e, t, i);
  }
  /**
   * Inject properties from pubkeyhash.
   * @private
   * @param {Buffer} hash
   * @returns {Address}
   */
  fromPubkeyhash(e) {
    const t = jt.types.PUBKEYHASH;
    return Xt(e.length === 20, "P2PKH must be 20 bytes."), this.fromHash(e, t, -1);
  }
  /**
   * Instantiate address from pubkeyhash.
   * @param {Buffer} hash
   * @returns {Address}
   */
  static fromPubkeyhash(e) {
    return new this().fromPubkeyhash(e);
  }
  /**
   * Inject properties from scripthash.
   * @private
   * @param {Buffer} hash
   * @returns {Address}
   */
  fromScripthash(e) {
    const t = jt.types.SCRIPTHASH;
    return Xt(e && e.length === 20, "P2SH must be 20 bytes."), this.fromHash(e, t, -1);
  }
  /**
   * Instantiate address from scripthash.
   * @param {Buffer} hash
   * @returns {Address}
   */
  static fromScripthash(e) {
    return new this().fromScripthash(e);
  }
  /**
   * Inject properties from witness pubkeyhash.
   * @private
   * @param {Buffer} hash
   * @returns {Address}
   */
  fromWitnessPubkeyhash(e) {
    const t = jt.types.WITNESS;
    return Xt(e && e.length === 20, "P2WPKH must be 20 bytes."), this.fromHash(e, t, 0);
  }
  /**
   * Instantiate address from witness pubkeyhash.
   * @param {Buffer} hash
   * @returns {Address}
   */
  static fromWitnessPubkeyhash(e) {
    return new this().fromWitnessPubkeyhash(e);
  }
  /**
   * Inject properties from witness scripthash.
   * @private
   * @param {Buffer} hash
   * @returns {Address}
   */
  fromWitnessScripthash(e) {
    const t = jt.types.WITNESS;
    return Xt(e && e.length === 32, "P2WPKH must be 32 bytes."), this.fromHash(e, t, 0);
  }
  /**
   * Instantiate address from witness scripthash.
   * @param {Buffer} hash
   * @returns {Address}
   */
  static fromWitnessScripthash(e) {
    return new this().fromWitnessScripthash(e);
  }
  /**
   * Inject properties from witness program.
   * @private
   * @param {Number} version
   * @param {Buffer} hash
   * @returns {Address}
   */
  fromProgram(e, t) {
    const i = jt.types.WITNESS;
    return Xt(e >= 0, "Bad version for witness program."), this.fromHash(t, i, e);
  }
  /**
   * Instantiate address from witness program.
   * @param {Number} version
   * @param {Buffer} hash
   * @returns {Address}
   */
  static fromProgram(e, t) {
    return new this().fromProgram(e, t);
  }
  /**
   * Test whether the address is pubkeyhash.
   * @returns {Boolean}
   */
  isPubkeyhash() {
    return this.type === jt.types.PUBKEYHASH;
  }
  /**
   * Test whether the address is scripthash.
   * @returns {Boolean}
   */
  isScripthash() {
    return this.type === jt.types.SCRIPTHASH;
  }
  /**
   * Test whether the address is witness pubkeyhash.
   * @returns {Boolean}
   */
  isWitnessPubkeyhash() {
    return this.version === 0 && this.hash.length === 20;
  }
  /**
   * Test whether the address is witness scripthash.
   * @returns {Boolean}
   */
  isWitnessScripthash() {
    return this.version === 0 && this.hash.length === 32;
  }
  /**
   * Test whether the address is a witness program.
   * @returns {Boolean}
   */
  isProgram() {
    return this.version !== -1;
  }
  /**
   * Get the hash of a base58 address or address-related object.
   * @param {String|Address|Hash} data
   * @param {String?} enc - Can be `"hex"` or `null`.
   * @returns {Hash}
   */
  static getHash(e, t) {
    if (!e)
      throw new Error("Object is not an address.");
    let i;
    if (Buffer.isBuffer(e))
      i = e;
    else if (e instanceof jt)
      i = e.hash;
    else
      throw new Error("Object is not an address.");
    return t === "hex" ? i.toString("hex") : i;
  }
  /**
   * Get an address type for a specified network address prefix.
   * @param {Number} prefix
   * @param {Network} network
   * @returns {AddressType}
   */
  static getType(e, t) {
    const i = t.addressPrefix;
    switch (e) {
      case i.pubkeyhash:
        return jt.types.PUBKEYHASH;
      case i.scripthash:
        return jt.types.SCRIPTHASH;
      default:
        throw new Error("Unknown address prefix.");
    }
  }
};
e2.types = {
  PUBKEYHASH: 0,
  SCRIPTHASH: 1,
  WITNESS: 2
};
e2.typesByVal = [
  "PUBKEYHASH",
  "SCRIPTHASH",
  "WITNESS"
];
function YA(r) {
  let e = !1, t = !1;
  for (let i = 0; i < r.length; i++) {
    const n = r.charCodeAt(i);
    if (!(n >= 48 && n <= 57) && (n & 32 ? (Xt(n >= 97 && n <= 122), e = !0) : (Xt(n >= 65 && n <= 90), t = !0), e && t))
      return !0;
  }
  return !1;
}
var ga = e2, ac = {}, gp = {};
gp.custom = "inspect";
/*!
 * buffer-map.js - buffer map for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/buffer-map
 */
const { custom: wp } = gp;
let JA = class {
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), e != null)
      for (const [t, i] of e)
        this.set(t, i);
  }
  get size() {
    return this.map.size;
  }
  get(e) {
    const t = this.map.get(Zs(e));
    if (t)
      return t.value;
  }
  has(e) {
    return this.map.has(Zs(e));
  }
  set(e, t) {
    return this.map.set(Zs(e), new ZA(e, t)), this;
  }
  delete(e) {
    return this.map.delete(Zs(e));
  }
  clear() {
    this.map.clear();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  *entries() {
    for (const { key: e, value: t } of this.map.values())
      yield [e, t];
  }
  *keys() {
    for (const { key: e } of this.map.values())
      yield e;
  }
  *values() {
    for (const { value: e } of this.map.values())
      yield e;
  }
  forEach(e, t) {
    if (typeof e != "function")
      throw new TypeError(`${typeof e} is not a function`);
    for (const { key: i, value: n } of this.map.values())
      e.call(t, n, i, this);
  }
  toKeys() {
    const e = [];
    for (const { key: t } of this.map.values())
      e.push(t);
    return e;
  }
  toValues() {
    const e = [];
    for (const { value: t } of this.map.values())
      e.push(t);
    return e;
  }
  toArray() {
    return this.toValues();
  }
  [wp]() {
    const e = /* @__PURE__ */ new Map();
    for (const { key: t, value: i } of this.map.values())
      e.set(Sp(t), i);
    return e;
  }
}, XA = class {
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), e != null)
      for (const t of e)
        this.add(t);
  }
  get size() {
    return this.map.size;
  }
  has(e) {
    return this.map.has(Zs(e));
  }
  add(e) {
    return this.map.set(Zs(e), e), this;
  }
  delete(e) {
    return this.map.delete(Zs(e));
  }
  clear() {
    this.map.clear();
  }
  [Symbol.iterator]() {
    return this.keys();
  }
  *entries() {
    for (const e of this.map.values())
      yield [e, e];
  }
  keys() {
    return this.map.values();
  }
  values() {
    return this.map.values();
  }
  forEach(e, t) {
    if (typeof e != "function")
      throw new TypeError(`${typeof e} is not a function`);
    for (const i of this.map.values())
      e.call(t, i, i, this);
  }
  toKeys() {
    const e = [];
    for (const t of this.map.values())
      e.push(t);
    return e;
  }
  toValues() {
    return this.toKeys();
  }
  toArray() {
    return this.toKeys();
  }
  [wp]() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.map.values())
      e.add(Sp(t));
    return e;
  }
};
class ZA {
  constructor(e, t) {
    this.key = e, this.value = t;
  }
}
const WA = typeof SharedArrayBuffer == "function";
function jA(r) {
  return !!(r instanceof ArrayBuffer || WA && r instanceof SharedArrayBuffer);
}
function QA(r) {
  if (ArrayBuffer.isView(r))
    return Buffer.from(r.buffer, r.byteOffset, r.byteLength);
  if (jA(r))
    return Buffer.from(r, 0, r.byteLength);
  throw new TypeError("Non-buffer passed to buffer map/set.");
}
function yp(r, e) {
  return Buffer.isBuffer(r) || (r = QA(r)), r.toString(e);
}
function Zs(r) {
  return yp(r, "binary");
}
function Sp(r) {
  return yp(r, "hex");
}
ac.BufferMap = JA;
ac.BufferSet = XA;
/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const e_ = Ar, Mc = Jl, { inspectSymbol: t_ } = Gr;
let r_ = class ki {
  /**
   * Create an amount.
   * @constructor
   * @param {(String|Number)?} value
   * @param {String?} unit
   */
  constructor(e, t) {
    this.value = 0, e != null && this.fromOptions(e, t);
  }
  /**
   * Inject properties from options.
   * @private
   * @param {(String|Number)?} value
   * @param {String?} unit
   * @returns {Amount}
   */
  fromOptions(e, t) {
    return typeof t == "string" ? this.from(t, e) : typeof e == "number" ? this.fromValue(e) : this.fromBTC(e);
  }
  /**
   * Get satoshi value.
   * @returns {Amount}
   */
  toValue() {
    return this.value;
  }
  /**
   * Get satoshi string or value.
   * @param {Boolean?} num
   * @returns {String|Amount}
   */
  toSatoshis(e) {
    return e ? this.value : this.value.toString(10);
  }
  /**
   * Get bits string or value.
   * @param {Boolean?} num
   * @returns {String|Amount}
   */
  toBits(e) {
    return ki.encode(this.value, 2, e);
  }
  /**
   * Get mbtc string or value.
   * @param {Boolean?} num
   * @returns {String|Amount}
   */
  toMBTC(e) {
    return ki.encode(this.value, 5, e);
  }
  /**
   * Get btc string or value.
   * @param {Boolean?} num
   * @returns {String|Amount}
   */
  toBTC(e) {
    return ki.encode(this.value, 8, e);
  }
  /**
   * Get unit string or value.
   * @param {String} unit - Can be `sat`,
   * `ubtc`, `bits`, `mbtc`, or `btc`.
   * @param {Boolean?} num
   * @returns {String|Amount}
   */
  to(e, t) {
    switch (e) {
      case "sat":
        return this.toSatoshis(t);
      case "ubtc":
      case "bits":
        return this.toBits(t);
      case "mbtc":
        return this.toMBTC(t);
      case "btc":
        return this.toBTC(t);
    }
    throw new Error(`Unknown unit "${e}".`);
  }
  /**
   * Convert amount to bitcoin string.
   * @returns {String}
   */
  toString() {
    return this.toBTC();
  }
  /**
   * Inject properties from value.
   * @private
   * @param {Amount} value
   * @returns {Amount}
   */
  fromValue(e) {
    return e_(Number.isSafeInteger(e) && e >= 0, "Value must be a safe integer."), this.value = e, this;
  }
  /**
   * Inject properties from satoshis.
   * @private
   * @param {Number|String} value
   * @returns {Amount}
   */
  fromSatoshis(e) {
    return this.value = ki.decode(e, 0), this;
  }
  /**
   * Inject properties from bits.
   * @private
   * @param {Number|String} value
   * @returns {Amount}
   */
  fromBits(e) {
    return this.value = ki.decode(e, 2), this;
  }
  /**
   * Inject properties from mbtc.
   * @private
   * @param {Number|String} value
   * @returns {Amount}
   */
  fromMBTC(e) {
    return this.value = ki.decode(e, 5), this;
  }
  /**
   * Inject properties from btc.
   * @private
   * @param {Number|String} value
   * @returns {Amount}
   */
  fromBTC(e) {
    return this.value = ki.decode(e, 8), this;
  }
  /**
   * Inject properties from unit.
   * @private
   * @param {String} unit
   * @param {Number|String} value
   * @returns {Amount}
   */
  from(e, t) {
    switch (e) {
      case "sat":
        return this.fromSatoshis(t);
      case "ubtc":
      case "bits":
        return this.fromBits(t);
      case "mbtc":
        return this.fromMBTC(t);
      case "btc":
        return this.fromBTC(t);
    }
    throw new Error(`Unknown unit "${e}".`);
  }
  /**
   * Instantiate amount from options.
   * @param {(String|Number)?} value
   * @param {String?} unit
   * @returns {Amount}
   */
  static fromOptions(e, t) {
    return new this().fromOptions(e, t);
  }
  /**
   * Instantiate amount from value.
   * @private
   * @param {Amount} value
   * @returns {Amount}
   */
  static fromValue(e) {
    return new this().fromValue(e);
  }
  /**
   * Instantiate amount from satoshis.
   * @param {Number|String} value
   * @returns {Amount}
   */
  static fromSatoshis(e) {
    return new this().fromSatoshis(e);
  }
  /**
   * Instantiate amount from bits.
   * @param {Number|String} value
   * @returns {Amount}
   */
  static fromBits(e) {
    return new this().fromBits(e);
  }
  /**
   * Instantiate amount from mbtc.
   * @param {Number|String} value
   * @returns {Amount}
   */
  static fromMBTC(e) {
    return new this().fromMBTC(e);
  }
  /**
   * Instantiate amount from btc.
   * @param {Number|String} value
   * @returns {Amount}
   */
  static fromBTC(e) {
    return new this().fromBTC(e);
  }
  /**
   * Instantiate amount from unit.
   * @param {String} unit
   * @param {Number|String} value
   * @returns {Amount}
   */
  static from(e, t) {
    return new this().from(e, t);
  }
  /**
   * Inspect amount.
   * @returns {String}
   */
  [t_]() {
    return `<Amount: ${this.toString()}>`;
  }
  /**
   * Safely convert satoshis to a BTC string.
   * This function explicitly avoids any
   * floating point arithmetic.
   * @param {Amount} value - Satoshis.
   * @param {Boolean} num
   * @returns {String} BTC string.
   */
  static btc(e, t) {
    return typeof e == "string" ? e : ki.encode(e, 8, t);
  }
  /**
   * Safely convert a BTC string to satoshis.
   * @param {String} str - BTC
   * @returns {Amount} Satoshis.
   * @throws on parse error
   */
  static value(e) {
    return typeof e == "number" ? e : ki.decode(e, 8);
  }
  /**
   * Safely convert satoshis to a BTC string.
   * @param {Amount} value
   * @param {Number} exp - Exponent.
   * @param {Boolean} num - Return a number.
   * @returns {String|Number}
   */
  static encode(e, t, i) {
    return i ? Mc.toFloat(e, t) : Mc.encode(e, t);
  }
  /**
   * Safely convert a BTC string to satoshis.
   * @param {String|Number} value - BTC
   * @param {Number} exp - Exponent.
   * @returns {Amount} Satoshis.
   * @throws on parse error
   */
  static decode(e, t) {
    return typeof e == "number" ? Mc.fromFloat(e, t) : Mc.decode(e, t);
  }
};
var wa = r_;
/*!
 * ripemd160.js - ripemd160 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var i_ = rp;
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */
const wf = Jr, s_ = jf, Nc = -1, Hd = Buffer.alloc(8, 0), Bp = Buffer.alloc(64, 0);
Bp[0] = 128;
const n_ = new Uint32Array([
  1518500249,
  1859775393,
  2400959708,
  3395469782
]);
class d0 {
  constructor() {
    this.state = new Uint32Array(5), this.msg = new Uint32Array(80), this.block = Buffer.alloc(64), this.size = Nc;
  }
  init() {
    return this.state[0] = 1732584193, this.state[1] = 4023233417, this.state[2] = 2562383102, this.state[3] = 271733878, this.state[4] = 3285377520, this.size = 0, this;
  }
  update(e) {
    return wf(Buffer.isBuffer(e)), this._update(e, e.length), this;
  }
  final() {
    return this._final(Buffer.alloc(20));
  }
  _update(e, t) {
    wf(this.size !== Nc, "Context is not initialized.");
    let i = this.size & 63, n = 0;
    if (this.size += t, i > 0) {
      let c = 64 - i;
      if (c > t && (c = t), e.copy(this.block, i, n, n + c), i += c, t -= c, n += c, i < 64)
        return;
      this._transform(this.block, 0);
    }
    for (; t >= 64; )
      this._transform(e, n), n += 64, t -= 64;
    t > 0 && e.copy(this.block, 0, n, n + t);
  }
  _final(e) {
    wf(this.size !== Nc, "Context is not initialized.");
    const t = this.size & 63, i = this.size * 8;
    Vd(Hd, i * (1 / 4294967296) >>> 0, 0), Vd(Hd, i >>> 0, 4), this._update(Bp, 1 + (119 - t & 63)), this._update(Hd, 8);
    for (let n = 0; n < 5; n++)
      Vd(e, this.state[n], n * 4), this.state[n] = 0;
    for (let n = 0; n < 80; n++)
      this.msg[n] = 0;
    for (let n = 0; n < 64; n++)
      this.block[n] = 0;
    return this.size = Nc, e;
  }
  _transform(e, t) {
    const i = this.msg;
    let n = this.state[0], c = this.state[1], o = this.state[2], d = this.state[3], l = this.state[4], h = 0;
    for (; h < 16; h++)
      i[h] = h_(e, t + h * 4);
    for (; h < 80; h++)
      i[h] = Fd(i[h - 3] ^ i[h - 8] ^ i[h - 14] ^ i[h - 16], 1);
    for (h = 0; h < 80; h++) {
      const x = h / 20 | 0, b = Fd(n, 5) + f_(x, c, o, d) + l + i[h] + n_[x];
      l = d, d = o, o = Fd(c, 30), c = n, n = b >>> 0;
    }
    this.state[0] += n, this.state[1] += c, this.state[2] += o, this.state[3] += d, this.state[4] += l;
  }
  static hash() {
    return new d0();
  }
  static hmac() {
    return new s_(d0, 64);
  }
  static digest(e) {
    return d0.ctx.init().update(e).final();
  }
  static root(e, t) {
    return wf(Buffer.isBuffer(e) && e.length === 20), wf(Buffer.isBuffer(t) && t.length === 20), d0.ctx.init().update(e).update(t).final();
  }
  static multi(e, t, i) {
    const { ctx: n } = d0;
    return n.init(), n.update(e), n.update(t), i && n.update(i), n.final();
  }
  static mac(e, t) {
    return d0.hmac().init(t).update(e).final();
  }
}
d0.native = 0;
d0.id = "SHA1";
d0.size = 20;
d0.bits = 160;
d0.blockSize = 64;
d0.zero = Buffer.alloc(20, 0);
d0.ctx = new d0();
function Fd(r, e) {
  return r << e | r >>> 32 - e;
}
function f_(r, e, t, i) {
  return r === 0 ? c_(e, t, i) : r === 1 || r === 3 ? a_(e, t, i) : r === 2 ? o_(e, t, i) : 0;
}
function c_(r, e, t) {
  return r & e ^ ~r & t;
}
function o_(r, e, t) {
  return r & e ^ r & t ^ e & t;
}
function a_(r, e, t) {
  return r ^ e ^ t;
}
function h_(r, e) {
  return r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e];
}
function Vd(r, e, t) {
  return r[t++] = e >>> 24, r[t++] = e >>> 16, r[t++] = e >>> 8, r[t++] = e, t;
}
var d_ = d0;
/*!
 * sha1.js - sha1 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
var u_ = d_, jn = {};
/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  const e = Ar, t = ri;
  r.MAX_TX_VERSION = 2, r.MAX_TX_SIZE = t.MAX_BLOCK_SIZE / 10, r.MAX_TX_WEIGHT = t.MAX_BLOCK_WEIGHT / 10, r.MAX_TX_SIGOPS = t.MAX_BLOCK_SIGOPS / 5, r.MAX_TX_SIGOPS_COST = t.MAX_BLOCK_SIGOPS_COST / 5, r.BYTES_PER_SIGOP = 20, r.MIN_RELAY = 1e3, r.BARE_MULTISIG = !0, r.FREE_THRESHOLD = t.COIN * 144 / 250, r.MAX_P2SH_SIGOPS = 15, r.MAX_OP_RETURN_BYTES = 83, r.MAX_OP_RETURN = 80, r.MAX_P2WSH_STACK = 100, r.MAX_P2WSH_PUSH = 80, r.MAX_P2WSH_SIZE = 3600, r.MEMPOOL_MAX_ANCESTORS = 25, r.MEMPOOL_MAX_SIZE = 100 * 1e6, r.MEMPOOL_EXPIRY_TIME = 72 * 60 * 60, r.MEMPOOL_MAX_ORPHANS = 100, r.MIN_BLOCK_WEIGHT = 0, r.MAX_BLOCK_WEIGHT = 1e6 * t.WITNESS_SCALE_FACTOR, r.BLOCK_PRIORITY_WEIGHT = 0, r.BLOCK_PRIORITY_THRESHOLD = r.FREE_THRESHOLD, r.getMinFee = function(n, c) {
    if (c == null && (c = r.MIN_RELAY), e(n >= 0), e(c >= 0), n === 0)
      return 0;
    let o = Math.floor(c * n / 1e3);
    return o === 0 && c > 0 && (o = c), o;
  }, r.getRoundFee = function(n, c) {
    if (c == null && (c = r.MIN_RELAY), e(n >= 0), e(c >= 0), n === 0)
      return 0;
    let o = c * Math.ceil(n / 1e3);
    return o === 0 && c > 0 && (o = c), o;
  }, r.getRate = function(n, c) {
    return e(n >= 0), e(c >= 0), n === 0 ? 0 : Math.floor(c * 1e3 / n);
  };
})(jn);
var Qn = {}, hc = {};
/*!
 * int64.js - int64 object for javascript.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/n64
 */
function ye(r) {
  je(this instanceof ye, "this", "N64"), je(r === 0 || r === 1, "sign", "bit"), this.hi = 0, this.lo = 0, this.sign = r;
}
ye.prototype._add = function(e, t) {
  const i = this.hi, n = this.lo, c = n + t | 0, o = c >> 31, d = n >> 31, l = t >> 31, h = (d & l | ~o & (d ^ l)) & 1, x = (i + e | 0) + h;
  return this.hi = x | 0, this.lo = c, this;
};
ye.prototype.iadd = function(e) {
  return je(ye.isN64(e), "operand", "int64"), this._add(e.hi, e.lo);
};
ye.prototype.iaddn = function(e) {
  return je(yr(e), "operand", "number"), this._add(e >> 31 & -this.sign, e | 0);
};
ye.prototype.add = function(e) {
  return this.clone().iadd(e);
};
ye.prototype.addn = function(e) {
  return this.clone().iaddn(e);
};
ye.prototype._sub = function(e, t) {
  return e = ~e, t = ~t, t === -1 ? (t = 0, e += 1, e |= 0) : t += 1, this._add(e, t);
};
ye.prototype.isub = function(e) {
  return je(ye.isN64(e), "operand", "int64"), this._sub(e.hi, e.lo);
};
ye.prototype.isubn = function(e) {
  return je(yr(e), "operand", "number"), this._sub(e >> 31 & -this.sign, e | 0);
};
ye.prototype.sub = function(e) {
  return this.clone().isub(e);
};
ye.prototype.subn = function(e) {
  return this.clone().isubn(e);
};
ye.prototype._mul = function(e, t) {
  const i = this.hi, n = this.lo, c = i >>> 16, o = i & 65535, d = n >>> 16, l = n & 65535, h = e >>> 16, x = e & 65535, b = t >>> 16, g = t & 65535;
  let w = 0, I = 0, B = 0, y = 0;
  y += l * g, B += y >>> 16, y &= 65535, B += d * g, I += B >>> 16, B &= 65535, B += l * b, I += B >>> 16, B &= 65535, I += o * g, w += I >>> 16, I &= 65535, I += d * b, w += I >>> 16, I &= 65535, I += l * x, w += I >>> 16, I &= 65535, w += c * g + o * b + d * x + l * h, w &= 65535;
  const A = w << 16 | I, _ = B << 16 | y;
  return this.hi = A, this.lo = _, this;
};
ye.prototype.imul = function(e) {
  return je(ye.isN64(e), "multiplicand", "int64"), this._mul(e.hi, e.lo);
};
ye.prototype.imuln = function(e) {
  return je(yr(e), "multiplicand", "number"), this._mul(e >> 31 & -this.sign, e | 0);
};
ye.prototype.mul = function(e) {
  return this.clone().imul(e);
};
ye.prototype.muln = function(e) {
  return this.clone().imuln(e);
};
ye.prototype.idiv = function(e) {
  let t = this;
  if (je(ye.isN64(e), "divisor", "int64"), e.isZero())
    throw new Error("Cannot divide by zero.");
  if (t.isZero())
    return t;
  if (t.eq(e))
    return t.set(1);
  if (t.isSafe() && e.isSafe()) {
    const h = t.toDouble(), x = e.toDouble(), b = l_(h / x);
    return t.set(b);
  }
  let i = !1;
  t.sign && (t.hi < 0 ? e.hi < 0 ? (t = t.ineg(), e = e.neg()) : (t = t.ineg(), i = !0) : e.hi < 0 && (e = e.neg(), i = !0));
  const n = t.toU64(), c = e.toU64();
  if (n.lt(c))
    return t.set(0);
  if (n.ushrn(1).lt(c))
    return t.set(i ? -1 : 1);
  const o = new Vr(), d = new Vr();
  let l = n.bitLength();
  for (; l--; )
    d.ishln(1), d.lo |= n.testn(l), d.gte(c) && (d.isub(c), o.setn(l, 1));
  return t.hi = o.hi, t.lo = o.lo, i && t.ineg(), t;
};
ye.prototype.idivn = function(e) {
  return je(yr(e), "divisor", "number"), this.idiv(this._small(e));
};
ye.prototype.div = function(e) {
  return this.clone().idiv(e);
};
ye.prototype.divn = function(e) {
  return this.clone().idivn(e);
};
ye.prototype.imod = function(e) {
  const t = this;
  if (je(ye.isN64(e), "divisor", "int64"), e.isZero())
    throw new Error("Cannot divide by zero.");
  if (t.isZero())
    return t;
  if (t.eq(e))
    return t.set(0);
  if (t.isSafe() && e.isSafe()) {
    const i = t.toDouble(), n = e.toDouble(), c = i % n;
    return t.set(c);
  }
  return t.isub(t.div(e).imul(e));
};
ye.prototype.imodn = function(e) {
  return je(yr(e), "divisor", "number"), this.imod(this._small(e));
};
ye.prototype.mod = function(e) {
  return this.clone().imod(e);
};
ye.prototype.modn = function(e) {
  return this.clone().imodn(e);
};
ye.prototype.ipow = function(e) {
  return je(ye.isN64(e), "exponent", "int64"), this.ipown(e.lo);
};
ye.prototype.ipown = function(e) {
  if (je(yr(e), "exponent", "number"), this.isZero())
    return this;
  const t = this.clone(), i = this;
  let n = e >>> 0;
  for (i.set(1); n > 0; )
    n & 1 && i.imul(t), n >>>= 1, t.imul(t);
  return i;
};
ye.prototype.pow = function(e) {
  return this.clone().ipow(e);
};
ye.prototype.pown = function(e) {
  return this.clone().ipown(e);
};
ye.prototype.sqr = function() {
  return this.mul(this);
};
ye.prototype.isqr = function() {
  return this.imul(this);
};
ye.prototype.iand = function(e) {
  return je(ye.isN64(e), "operand", "int64"), this.hi &= e.hi, this.lo &= e.lo, this;
};
ye.prototype.iandn = function(e) {
  return je(yr(e), "operand", "number"), this.hi &= e >> 31 & -this.sign, this.lo &= e | 0, this;
};
ye.prototype.and = function(e) {
  return this.clone().iand(e);
};
ye.prototype.andn = function(e) {
  return this.clone().iandn(e);
};
ye.prototype.ior = function(e) {
  return je(ye.isN64(e), "operand", "int64"), this.hi |= e.hi, this.lo |= e.lo, this;
};
ye.prototype.iorn = function(e) {
  return je(yr(e), "operand", "number"), this.hi |= e >> 31 & -this.sign, this.lo |= e | 0, this;
};
ye.prototype.or = function(e) {
  return this.clone().ior(e);
};
ye.prototype.orn = function(e) {
  return this.clone().iorn(e);
};
ye.prototype.ixor = function(e) {
  return je(ye.isN64(e), "operand", "int64"), this.hi ^= e.hi, this.lo ^= e.lo, this;
};
ye.prototype.ixorn = function(e) {
  return je(yr(e), "operand", "number"), this.hi ^= e >> 31 & -this.sign, this.lo ^= e | 0, this;
};
ye.prototype.xor = function(e) {
  return this.clone().ixor(e);
};
ye.prototype.xorn = function(e) {
  return this.clone().ixorn(e);
};
ye.prototype.inot = function() {
  return this.hi = ~this.hi, this.lo = ~this.lo, this;
};
ye.prototype.not = function() {
  return this.clone().inot();
};
ye.prototype.ishl = function(e) {
  return je(ye.isN64(e), "bits", "int64"), this.ishln(e.lo);
};
ye.prototype.ishln = function(e) {
  if (je(yr(e), "bits", "number"), e &= 63, e === 0)
    return this;
  let t = this.hi, i = this.lo;
  return e < 32 ? (t <<= e, t |= i >>> 32 - e, i <<= e) : (t = i << e - 32, i = 0), this.hi = t, this.lo = i, this;
};
ye.prototype.shl = function(e) {
  return this.clone().ishl(e);
};
ye.prototype.shln = function(e) {
  return this.clone().ishln(e);
};
ye.prototype.ishr = function(e) {
  return je(ye.isN64(e), "bits", "int64"), this.ishrn(e.lo);
};
ye.prototype.ishrn = function(e) {
  if (!this.sign)
    return this.iushrn(e);
  if (je(yr(e), "bits", "number"), e &= 63, e === 0)
    return this;
  let t = this.hi, i = this.lo;
  return e < 32 ? (i >>>= e, i |= t << 32 - e, t >>= e) : (i = t >> e - 32, t = t >> 31), this.hi = t, this.lo = i, this;
};
ye.prototype.shr = function(e) {
  return this.clone().ishr(e);
};
ye.prototype.shrn = function(e) {
  return this.clone().ishrn(e);
};
ye.prototype.iushr = function(e) {
  return je(ye.isN64(e), "bits", "int64"), this.iushrn(e.lo);
};
ye.prototype.iushrn = function(e) {
  if (je(yr(e), "bits", "number"), e &= 63, e === 0)
    return this;
  let t = this.hi, i = this.lo;
  return e < 32 ? (i >>>= e, i |= t << 32 - e, t >>>= e) : (i = t >>> e - 32, t = 0), this.hi = t | 0, this.lo = i | 0, this;
};
ye.prototype.ushr = function(e) {
  return this.clone().iushr(e);
};
ye.prototype.ushrn = function(e) {
  return this.clone().iushrn(e);
};
ye.prototype.setn = function(e, t) {
  return je(yr(e), "bit", "number"), e &= 63, e < 32 ? t ? this.lo |= 1 << e : this.lo &= ~(1 << e) : t ? this.hi |= 1 << e - 32 : this.hi &= ~(1 << e - 32), this;
};
ye.prototype.testn = function(e) {
  return je(yr(e), "bit", "number"), e &= 63, e < 32 ? this.lo >>> e & 1 : this.hi >>> e - 32 & 1;
};
ye.prototype.setb = function(e, t) {
  return je(yr(e), "pos", "number"), je(yr(t), "ch", "number"), e &= 7, t &= 255, e < 4 ? (this.lo &= ~(255 << e * 8), this.lo |= t << e * 8) : (this.hi &= ~(255 << (e - 4) * 8), this.hi |= t << (e - 4) * 8), this;
};
ye.prototype.orb = function(e, t) {
  return je(yr(e), "pos", "number"), je(yr(t), "ch", "number"), e &= 7, t &= 255, e < 4 ? this.lo |= t << e * 8 : this.hi |= t << (e - 4) * 8, this;
};
ye.prototype.getb = function(e) {
  return je(yr(e), "pos", "number"), e &= 7, e < 4 ? this.lo >> e * 8 & 255 : this.hi >> (e - 4) * 8 & 255;
};
ye.prototype.imaskn = function(e) {
  return je(yr(e), "bit", "number"), e &= 63, e < 32 ? (this.hi = 0, this.lo &= (1 << e) - 1) : (this.hi &= (1 << e - 32) - 1, this.lo &= 4294967295), this;
};
ye.prototype.maskn = function(e) {
  return this.clone().imaskn(e);
};
ye.prototype.andln = function(e) {
  return je(yr(e), "operand", "number"), this.lo & e;
};
ye.prototype.ineg = function() {
  let e = ~this.hi, t = ~this.lo;
  return t === -1 ? (t = 0, e += 1, e |= 0) : t += 1, this.hi = e, this.lo = t, this;
};
ye.prototype.neg = function() {
  return this.clone().ineg();
};
ye.prototype.iabs = function() {
  return this.isNeg() && this.ineg(), this;
};
ye.prototype.abs = function() {
  return this.clone().iabs();
};
ye.prototype._cmp = function(e, t) {
  const i = this;
  let n = i.hi, c = i.lo;
  if (n === e && c === t)
    return 0;
  let o = !1;
  if (i.sign) {
    const d = n < 0, l = e < 0;
    if (d && !l)
      return -1;
    if (!d && l)
      return 1;
    o = d;
  }
  return o || (n >>>= 0, e >>>= 0), n < e ? -1 : n > e ? 1 : (c >>>= 0, t >>>= 0, c < t ? -1 : 1);
};
ye.prototype.cmp = function(e) {
  return je(ye.isN64(e), "value", "int64"), this._cmp(e.hi, e.lo);
};
ye.prototype.cmpn = function(e) {
  return je(yr(e), "value", "number"), this._cmp(e >> 31 & -this.sign, e | 0);
};
ye.prototype.eq = function(e) {
  return je(ye.isN64(e), "value", "int64"), this.hi === e.hi && this.lo === e.lo;
};
ye.prototype.eqn = function(e) {
  return je(yr(e), "value", "number"), this.hi === (e >> 31 & -this.sign) && this.lo === (e | 0);
};
ye.prototype.gt = function(e) {
  return this.cmp(e) > 0;
};
ye.prototype.gtn = function(e) {
  return this.cmpn(e) > 0;
};
ye.prototype.gte = function(e) {
  return this.cmp(e) >= 0;
};
ye.prototype.gten = function(e) {
  return this.cmpn(e) >= 0;
};
ye.prototype.lt = function(e) {
  return this.cmp(e) < 0;
};
ye.prototype.ltn = function(e) {
  return this.cmpn(e) < 0;
};
ye.prototype.lte = function(e) {
  return this.cmp(e) <= 0;
};
ye.prototype.lten = function(e) {
  return this.cmpn(e) <= 0;
};
ye.prototype.isZero = function() {
  return this.hi === 0 && this.lo === 0;
};
ye.prototype.isNeg = function() {
  return this.sign === 1 && this.hi < 0;
};
ye.prototype.isOdd = function() {
  return (this.lo & 1) === 1;
};
ye.prototype.isEven = function() {
  return (this.lo & 1) === 0;
};
ye.prototype.clone = function() {
  const e = new this.constructor();
  return e.hi = this.hi, e.lo = this.lo, e;
};
ye.prototype.inject = function(e) {
  return je(ye.isN64(e), "value", "int64"), this.hi = e.hi, this.lo = e.lo, this;
};
ye.prototype.set = function(e) {
  je(x_(e), "number", "integer");
  let t = !1;
  return e < 0 && (e = -e, t = !0), this.hi = e * (1 / 4294967296) | 0, this.lo = e | 0, t && this.ineg(), this;
};
ye.prototype.join = function(e, t) {
  return je(yr(e), "hi", "number"), je(yr(t), "lo", "number"), this.hi = e | 0, this.lo = t | 0, this;
};
ye.prototype._small = function(e) {
  const t = new this.constructor();
  return t.hi = e >> 31 & -this.sign, t.lo = e | 0, t;
};
ye.prototype.bitLength = function() {
  let e = this;
  return this.isNeg() && (e = this.neg()), e.hi === 0 ? N4(e.lo) : N4(e.hi) + 32;
};
ye.prototype.byteLength = function() {
  return Math.ceil(this.bitLength() / 8);
};
ye.prototype.isSafe = function() {
  let e = this.hi;
  return this.isNeg() && (e = ~e, this.lo === 0 && (e += 1)), (e & 4292870144) === 0;
};
ye.prototype.inspect = function() {
  let e = "I64";
  return this.sign || (e = "U64"), `<${e}: ${this.toString(10)}>`;
};
ye.prototype.readLE = function(e, t) {
  return je(e && typeof e.length == "number", "data", "arraylike"), je(t >> 0 === t, "offset", "integer"), je(t + 8 <= e.length, "offset", "valid offset"), this.lo = O4(e, t), this.hi = O4(e, t + 4), t + 8;
};
ye.prototype.readBE = function(e, t) {
  return je(e && typeof e.length == "number", "data", "arraylike"), je(t >> 0 === t, "offset", "integer"), je(t + 8 <= e.length, "offset", "valid offset"), this.hi = P4(e, t), this.lo = P4(e, t + 4), t + 8;
};
ye.prototype.readRaw = function(e, t) {
  return this.readLE(e, t);
};
ye.prototype.writeLE = function(e, t) {
  return je(e && typeof e.length == "number", "data", "arraylike"), je(t >> 0 === t, "offset", "integer"), je(t + 8 <= e.length, "offset", "valid offset"), R4(e, this.lo, t), R4(e, this.hi, t + 4), t + 8;
};
ye.prototype.writeBE = function(e, t) {
  return je(e && typeof e.length == "number", "data", "arraylike"), je(t >> 0 === t, "offset", "integer"), je(t + 8 <= e.length, "offset", "valid offset"), k4(e, this.hi, t), k4(e, this.lo, t + 4), t + 8;
};
ye.prototype.writeRaw = function(e, t) {
  return this.writeLE(e, t);
};
ye.prototype.toU64 = function() {
  const e = new Vr();
  return e.hi = this.hi, e.lo = this.lo, e;
};
ye.prototype.toI64 = function() {
  const e = new i0();
  return e.hi = this.hi, e.lo = this.lo, e;
};
ye.prototype.toNumber = function() {
  if (!this.isSafe())
    throw new Error("Number exceeds 53 bits.");
  return this.toDouble();
};
ye.prototype.toDouble = function() {
  let e = this.hi;
  return this.sign || (e >>>= 0), e * 4294967296 + (this.lo >>> 0);
};
ye.prototype.toInt = function() {
  return this.sign ? this.lo : this.lo >>> 0;
};
ye.prototype.toBool = function() {
  return !this.isZero();
};
ye.prototype.toBits = function() {
  return [this.hi, this.lo];
};
ye.prototype.toObject = function() {
  return { hi: this.hi, lo: this.lo };
};
ye.prototype.toString = function(e, t) {
  if (e = vp(e), t == null && (t = 0), je(e >>> 0 === e, "base", "integer"), je(t >>> 0 === t, "pad", "integer"), e < 2 || e > 16)
    throw new Error("Base ranges between 2 and 16.");
  if (t > 64)
    throw new Error("Maximum padding is 64 characters.");
  let i = this, n = !1;
  i.isNeg() && (i = i.neg(), n = !0);
  let c = i.hi >>> 0, o = i.lo >>> 0, d = "";
  do {
    const l = c % e;
    c -= l, c /= e, o += l * 4294967296;
    const h = o % e;
    o -= h, o /= e;
    let x = h;
    x < 10 ? x += 48 : x += 97 - 10, d = String.fromCharCode(x) + d;
  } while (o > 0 || c > 0);
  for (; d.length < t; )
    d = "0" + d;
  return n && (d = "-" + d), d;
};
ye.prototype.toJSON = function() {
  return this.toString(16, 16);
};
ye.prototype.toBN = function(e) {
  const t = this.isNeg();
  let i = this.hi, n = this.lo;
  t && (i = ~i, n = ~n, n === -1 ? (n = 0, i += 1, i |= 0) : n += 1), i >>>= 0, n >>>= 0;
  const c = new e(i);
  return c.ishln(32), c.iadd(new e(n)), t && c.ineg(), c;
};
ye.prototype.toLE = function(e) {
  je(typeof e == "function", "ArrayLike", "constructor");
  const t = Ip(e, 8);
  return this.writeLE(t, 0), t;
};
ye.prototype.toBE = function(e) {
  je(typeof e == "function", "ArrayLike", "constructor");
  const t = Ip(e, 8);
  return this.writeBE(t, 0), t;
};
ye.prototype.toRaw = function(e) {
  return this.toLE(e);
};
ye.prototype.fromNumber = function(e) {
  return this.set(e);
};
ye.prototype.fromInt = function(e) {
  return je(yr(e), "integer", "number"), this.join(e >> 31 & -this.sign, e);
};
ye.prototype.fromBool = function(e) {
  return je(typeof e == "boolean", "value", "boolean"), this.hi = 0, this.lo = e ? 1 : 0, this;
};
ye.prototype.fromBits = function(e, t) {
  return this.join(e, t);
};
ye.prototype.fromObject = function(e) {
  return je(e && typeof e == "object", "number", "object"), this.fromBits(e.hi, e.lo);
};
ye.prototype.fromString = function(e, t) {
  if (t = vp(t), je(typeof e == "string", "string", "string"), je(t >>> 0 === t, "base", "integer"), t < 2 || t > 16)
    throw new Error("Base ranges between 2 and 16.");
  let i = !1, n = 0;
  if (e.length > 0 && e[0] === "-" && (n += 1, i = !0), e.length === n || e.length > n + 64)
    throw new Error("Invalid string (bad length).");
  let c = 0, o = 0;
  for (; n < e.length; n++) {
    let d = e.charCodeAt(n);
    if (d >= 48 && d <= 57 ? d -= 48 : d >= 65 && d <= 90 ? d -= 65 - 10 : d >= 97 && d <= 122 ? d -= 97 - 10 : d = t, d >= t)
      throw new Error("Invalid string (parse error).");
    if (o *= t, o += d, c *= t, o > 4294967295 && (d = o % 4294967296, c += (o - d) / 4294967296, o = d), c > 4294967295)
      throw new Error("Invalid string (overflow).");
  }
  return this.hi = c | 0, this.lo = o | 0, i && this.ineg(), this;
};
ye.prototype.fromJSON = function(e) {
  return this.fromString(e, 16);
};
ye.prototype.fromBN = function(e) {
  je(e && Ep(e.words), "number", "big number");
  const t = this, i = e.clone(), n = i.isNeg();
  if (t.sign && i.testn(63))
    throw new Error("Big number overflow.");
  let c = 0;
  for (; !i.isZero(); ) {
    if (c === 8)
      throw new Error("Big number overflow.");
    t.orb(c, i.andln(255)), i.iushrn(8), c++;
  }
  return n && t.ineg(), t;
};
ye.prototype.fromLE = function(e) {
  return this.readLE(e, 0), this;
};
ye.prototype.fromBE = function(e) {
  return this.readBE(e, 0), this;
};
ye.prototype.fromRaw = function(e) {
  return this.fromLE(e);
};
ye.prototype.from = function(e, t) {
  if (e == null)
    return this;
  if (typeof e == "number")
    return typeof t == "number" ? this.fromBits(e, t) : this.fromNumber(e);
  if (typeof e == "string")
    return this.fromString(e, t);
  if (typeof e == "object")
    return Ep(e.words) ? this.fromBN(e) : typeof e.length == "number" ? this.fromRaw(e) : this.fromObject(e);
  if (typeof e == "boolean")
    return this.fromBool(e);
  throw new TypeError("Non-numeric object passed to N64.");
};
ye.min = function(e, t) {
  return e.cmp(t) < 0 ? e : t;
};
ye.max = function(e, t) {
  return e.cmp(t) > 0 ? e : t;
};
ye.random = function() {
  const e = new this();
  return e.hi = Math.random() * 4294967296 | 0, e.lo = Math.random() * 4294967296 | 0, e;
};
ye.pow = function(e, t) {
  return new this().fromInt(e).ipown(t);
};
ye.shift = function(e, t) {
  return new this().fromInt(e).ishln(t);
};
ye.readLE = function(e, t) {
  const i = new this();
  return i.readLE(e, t), i;
};
ye.readBE = function(e, t) {
  const i = new this();
  return i.readBE(e, t), i;
};
ye.readRaw = function(e, t) {
  const i = new this();
  return i.readRaw(e, t), i;
};
ye.fromNumber = function(e) {
  return new this().fromNumber(e);
};
ye.fromInt = function(e) {
  return new this().fromInt(e);
};
ye.fromBool = function(e) {
  return new this().fromBool(e);
};
ye.fromBits = function(e, t) {
  return new this().fromBits(e, t);
};
ye.fromObject = function(e) {
  return new this().fromObject(e);
};
ye.fromString = function(e, t) {
  return new this().fromString(e, t);
};
ye.fromJSON = function(e) {
  return new this().fromJSON(e);
};
ye.fromBN = function(e) {
  return new this().fromBN(e);
};
ye.fromLE = function(e) {
  return new this().fromLE(e);
};
ye.fromBE = function(e) {
  return new this().fromBE(e);
};
ye.fromRaw = function(e) {
  return new this().fromRaw(e);
};
ye.from = function(e, t) {
  return new this().from(e, t);
};
ye.isN64 = function(e) {
  return e instanceof ye;
};
ye.isU64 = function(e) {
  return e instanceof Vr;
};
ye.isI64 = function(e) {
  return e instanceof i0;
};
function Vr(r, e) {
  if (!(this instanceof Vr))
    return new Vr(r, e);
  ye.call(this, 0), this.from(r, e);
}
Vr.__proto__ = ye;
Vr.prototype.__proto__ = ye.prototype;
Vr.ULONG_MIN = 0;
Vr.ULONG_MAX = 4294967295;
Vr.UINT32_MIN = Vr(0, 0);
Vr.UINT32_MAX = Vr(0, 4294967295);
Vr.UINT64_MIN = Vr(0, 0);
Vr.UINT64_MAX = Vr(4294967295, 4294967295);
function i0(r, e) {
  if (!(this instanceof i0))
    return new i0(r, e);
  ye.call(this, 1), this.from(r, e);
}
i0.__proto__ = ye;
i0.prototype.__proto__ = ye.prototype;
i0.LONG_MIN = -2147483648;
i0.LONG_MAX = 2147483647;
i0.INT32_MIN = i0(4294967295, 2147483648);
i0.INT32_MAX = i0(0, 2147483647);
i0.INT64_MIN = i0(2147483648, 0);
i0.INT64_MAX = i0(2147483647, 4294967295);
function vp(r) {
  if (r == null)
    return 10;
  if (typeof r == "number")
    return r;
  switch (r) {
    case "bin":
      return 2;
    case "oct":
      return 8;
    case "dec":
      return 10;
    case "hex":
      return 16;
  }
  return 0;
}
function N4(r) {
  if (Math.clz32)
    return 32 - Math.clz32(r);
  let e = 31;
  for (; e >= 0 && !(r & 1 << e); e--)
    ;
  return e + 1;
}
function l_(r) {
  return r < 0 ? -Math.floor(-r) : Math.floor(r);
}
function je(r, e, t) {
  if (!r) {
    const i = new TypeError(`'${e}' must be a(n) ${t}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(i, je), i;
  }
}
function yr(r) {
  return typeof r == "number" && isFinite(r);
}
function Ep(r) {
  return Array.isArray ? Array.isArray(r) : {}.toString.call(r).slice(8, -1) === "Array";
}
function x_(r) {
  return Number.isSafeInteger ? Number.isSafeInteger(r) : yr(r) && Math.floor(r) === r && r >= -9007199254740991 && r <= 9007199254740991;
}
function Ip(r, e) {
  return r.allocUnsafe ? r.allocUnsafe(e) : new r(e);
}
function O4(r, e) {
  return r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24;
}
function P4(r, e) {
  return r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3];
}
function R4(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >>> 8 & 255, r[t + 2] = e >>> 16 & 255, r[t + 3] = e >>> 24 & 255;
}
function k4(r, e, t) {
  r[t] = e >>> 24 & 255, r[t + 1] = e >>> 16 & 255, r[t + 2] = e >>> 8 & 255, r[t + 3] = e & 255;
}
hc.N64 = ye;
hc.U64 = Vr;
hc.I64 = i0;
/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
let b_ = class Ap extends Error {
  /**
   * Create an error.
   * @constructor
   * @param {String} code - Error code.
   * @param {Opcode} op - Opcode.
   * @param {Number?} ip - Instruction pointer.
   */
  constructor(e, t, i) {
    super(), this.type = "ScriptError", this.code = e, this.message = e, this.op = -1, this.ip = -1, typeof t == "string" ? this.message = t : t && (this.message = `${e} (op=${t.toSymbol()}, ip=${i})`, this.op = t.value, this.ip = i), Error.captureStackTrace && Error.captureStackTrace(this, Ap);
  }
};
var t2 = b_;
/*!
 * scriptnum.js - script number object for bcoin.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const ts = Ar, { I64: yf } = hc, q4 = t2, { inspectSymbol: p_ } = Gr, m_ = Buffer.alloc(0);
let g_ = class D1 extends yf {
  /**
   * Create a script number.
   * @constructor
   * @param {(Number|String|Buffer|Object)?} num
   * @param {(String|Number)?} base
   */
  constructor(e, t) {
    super(e, t);
  }
  /**
   * Cast to int32.
   * @returns {Number}
   */
  getInt() {
    return this.lt(yf.INT32_MIN) ? yf.LONG_MIN : this.gt(yf.INT32_MAX) ? yf.LONG_MAX : this.toInt();
  }
  /**
   * Serialize script number.
   * @returns {Buffer}
   */
  toRaw() {
    let e = this;
    if (e.isZero())
      return m_;
    let t = !1;
    e.isNeg() && (e = e.neg(), t = !0);
    const i = e.byteLength();
    let n = 0;
    e.testn(i * 8 - 1) && (n = 1);
    const c = Buffer.allocUnsafe(i + n);
    switch (i) {
      case 8:
        c[7] = e.hi >>> 24 & 255;
      case 7:
        c[6] = e.hi >> 16 & 255;
      case 6:
        c[5] = e.hi >> 8 & 255;
      case 5:
        c[4] = e.hi & 255;
      case 4:
        c[3] = e.lo >>> 24 & 255;
      case 3:
        c[2] = e.lo >> 16 & 255;
      case 2:
        c[1] = e.lo >> 8 & 255;
      case 1:
        c[0] = e.lo & 255;
    }
    return c[i - 1] & 128 ? (ts(n === 1), ts(c.length === i + n), c[i] = t ? 128 : 0) : t ? (ts(n === 0), ts(c.length === i), c[i - 1] |= 128) : (ts(n === 0), ts(c.length === i)), c;
  }
  /**
   * Instantiate script number from serialized data.
   * @private
   * @param {Buffer} data
   * @returns {ScriptNum}
   */
  fromRaw(e) {
    if (ts(Buffer.isBuffer(e)), e.length === 0)
      return this;
    switch (e.length) {
      case 8:
        this.hi |= e[7] << 24;
      case 7:
        this.hi |= e[6] << 16;
      case 6:
        this.hi |= e[5] << 8;
      case 5:
        this.hi |= e[4];
      case 4:
        this.lo |= e[3] << 24;
      case 3:
        this.lo |= e[2] << 16;
      case 2:
        this.lo |= e[1] << 8;
      case 1:
        this.lo |= e[0];
        break;
      default:
        for (let t = 0; t < e.length; t++)
          this.orb(t, e[t]);
        break;
    }
    return e[e.length - 1] & 128 && (this.setn(e.length * 8 - 1, 0), this.ineg()), this;
  }
  /**
   * Serialize script number.
   * @returns {Buffer}
   */
  encode() {
    return this.toRaw();
  }
  /**
   * Decode and verify script number.
   * @private
   * @param {Buffer} data
   * @param {Boolean?} minimal - Require minimal encoding.
   * @param {Number?} limit - Size limit.
   * @returns {ScriptNum}
   */
  decode(e, t, i) {
    if (ts(Buffer.isBuffer(e)), i != null && e.length > i)
      throw new q4("UNKNOWN_ERROR", "Script number overflow.");
    if (t && !D1.isMinimal(e))
      throw new q4("UNKNOWN_ERROR", "Non-minimal script number.");
    return this.fromRaw(e);
  }
  /**
   * Inspect script number.
   * @returns {String}
   */
  [p_]() {
    return `<ScriptNum: ${this.toString(10)}>`;
  }
  /**
   * Test wether a serialized script
   * number is in its most minimal form.
   * @param {Buffer} data
   * @returns {Boolean}
   */
  static isMinimal(e) {
    return ts(Buffer.isBuffer(e)), e.length === 0 ? !0 : !(!(e[e.length - 1] & 127) && (e.length === 1 || !(e[e.length - 2] & 128)));
  }
  /**
   * Decode and verify script number.
   * @param {Buffer} data
   * @param {Boolean?} minimal - Require minimal encoding.
   * @param {Number?} limit - Size limit.
   * @returns {ScriptNum}
   */
  static decode(e, t, i) {
    return new this().decode(e, t, i);
  }
  /**
   * Test whether object is a script number.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isScriptNum(e) {
    return e instanceof D1;
  }
};
var ya = g_;
/*!
 * common.js - common script functions for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  const e = Ar, t = cc, i = ya;
  r.opcodes = {
    // Push
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    // Control
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    // Stack
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    // Splice
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    // Bit
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    // Numeric
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    // Crypto
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    // Expansion
    OP_NOP1: 176,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    // Custom
    OP_INVALIDOPCODE: 255
  }, r.opcodesByVal = {
    // Push
    0: "OP_0",
    76: "OP_PUSHDATA1",
    77: "OP_PUSHDATA2",
    78: "OP_PUSHDATA4",
    79: "OP_1NEGATE",
    80: "OP_RESERVED",
    81: "OP_1",
    82: "OP_2",
    83: "OP_3",
    84: "OP_4",
    85: "OP_5",
    86: "OP_6",
    87: "OP_7",
    88: "OP_8",
    89: "OP_9",
    90: "OP_10",
    91: "OP_11",
    92: "OP_12",
    93: "OP_13",
    94: "OP_14",
    95: "OP_15",
    96: "OP_16",
    // Control
    97: "OP_NOP",
    98: "OP_VER",
    99: "OP_IF",
    100: "OP_NOTIF",
    101: "OP_VERIF",
    102: "OP_VERNOTIF",
    103: "OP_ELSE",
    104: "OP_ENDIF",
    105: "OP_VERIFY",
    106: "OP_RETURN",
    // Stack
    107: "OP_TOALTSTACK",
    108: "OP_FROMALTSTACK",
    109: "OP_2DROP",
    110: "OP_2DUP",
    111: "OP_3DUP",
    112: "OP_2OVER",
    113: "OP_2ROT",
    114: "OP_2SWAP",
    115: "OP_IFDUP",
    116: "OP_DEPTH",
    117: "OP_DROP",
    118: "OP_DUP",
    119: "OP_NIP",
    120: "OP_OVER",
    121: "OP_PICK",
    122: "OP_ROLL",
    123: "OP_ROT",
    124: "OP_SWAP",
    125: "OP_TUCK",
    // Splice
    126: "OP_CAT",
    127: "OP_SUBSTR",
    128: "OP_LEFT",
    129: "OP_RIGHT",
    130: "OP_SIZE",
    // Bit
    131: "OP_INVERT",
    132: "OP_AND",
    133: "OP_OR",
    134: "OP_XOR",
    135: "OP_EQUAL",
    136: "OP_EQUALVERIFY",
    137: "OP_RESERVED1",
    138: "OP_RESERVED2",
    // Numeric
    139: "OP_1ADD",
    140: "OP_1SUB",
    141: "OP_2MUL",
    142: "OP_2DIV",
    143: "OP_NEGATE",
    144: "OP_ABS",
    145: "OP_NOT",
    146: "OP_0NOTEQUAL",
    147: "OP_ADD",
    148: "OP_SUB",
    149: "OP_MUL",
    150: "OP_DIV",
    151: "OP_MOD",
    152: "OP_LSHIFT",
    153: "OP_RSHIFT",
    154: "OP_BOOLAND",
    155: "OP_BOOLOR",
    156: "OP_NUMEQUAL",
    157: "OP_NUMEQUALVERIFY",
    158: "OP_NUMNOTEQUAL",
    159: "OP_LESSTHAN",
    160: "OP_GREATERTHAN",
    161: "OP_LESSTHANOREQUAL",
    162: "OP_GREATERTHANOREQUAL",
    163: "OP_MIN",
    164: "OP_MAX",
    165: "OP_WITHIN",
    // Crypto
    166: "OP_RIPEMD160",
    167: "OP_SHA1",
    168: "OP_SHA256",
    169: "OP_HASH160",
    170: "OP_HASH256",
    171: "OP_CODESEPARATOR",
    172: "OP_CHECKSIG",
    173: "OP_CHECKSIGVERIFY",
    174: "OP_CHECKMULTISIG",
    175: "OP_CHECKMULTISIGVERIFY",
    // Expansion
    176: "OP_NOP1",
    177: "OP_CHECKLOCKTIMEVERIFY",
    178: "OP_CHECKSEQUENCEVERIFY",
    179: "OP_NOP4",
    180: "OP_NOP5",
    181: "OP_NOP6",
    182: "OP_NOP7",
    183: "OP_NOP8",
    184: "OP_NOP9",
    185: "OP_NOP10",
    // Custom
    255: "OP_INVALIDOPCODE"
  }, r.small = [
    Buffer.from([129]),
    Buffer.from([]),
    Buffer.from([1]),
    Buffer.from([2]),
    Buffer.from([3]),
    Buffer.from([4]),
    Buffer.from([5]),
    Buffer.from([6]),
    Buffer.from([7]),
    Buffer.from([8]),
    Buffer.from([9]),
    Buffer.from([10]),
    Buffer.from([11]),
    Buffer.from([12]),
    Buffer.from([13]),
    Buffer.from([14]),
    Buffer.from([15]),
    Buffer.from([16])
  ], r.flags = {
    VERIFY_NONE: 0,
    VERIFY_P2SH: 1,
    VERIFY_STRICTENC: 2,
    VERIFY_DERSIG: 4,
    VERIFY_LOW_S: 8,
    VERIFY_NULLDUMMY: 16,
    VERIFY_SIGPUSHONLY: 32,
    VERIFY_MINIMALDATA: 64,
    VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 128,
    VERIFY_CLEANSTACK: 256,
    VERIFY_CHECKLOCKTIMEVERIFY: 512,
    VERIFY_CHECKSEQUENCEVERIFY: 1024,
    VERIFY_WITNESS: 2048,
    VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: 4096,
    VERIFY_MINIMALIF: 8192,
    VERIFY_NULLFAIL: 16384,
    VERIFY_WITNESS_PUBKEYTYPE: 32768,
    VERIFY_CONST_SCRIPTCODE: 65536
  }, r.flags.MANDATORY_VERIFY_FLAGS = r.flags.VERIFY_P2SH, r.flags.STANDARD_VERIFY_FLAGS = 0 | r.flags.MANDATORY_VERIFY_FLAGS | r.flags.VERIFY_DERSIG | r.flags.VERIFY_STRICTENC | r.flags.VERIFY_MINIMALDATA | r.flags.VERIFY_NULLDUMMY | r.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS | r.flags.VERIFY_CLEANSTACK | r.flags.VERIFY_MINIMALIF | r.flags.VERIFY_NULLFAIL | r.flags.VERIFY_CHECKLOCKTIMEVERIFY | r.flags.VERIFY_CHECKSEQUENCEVERIFY | r.flags.VERIFY_LOW_S | r.flags.VERIFY_WITNESS | r.flags.VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM | r.flags.VERIFY_WITNESS_PUBKEYTYPE | r.flags.VERIFY_CONST_SCRIPTCODE, r.flags.ONLY_STANDARD_VERIFY_FLAGS = r.flags.STANDARD_VERIFY_FLAGS & ~r.flags.MANDATORY_VERIFY_FLAGS, r.hashType = {
    /*
     * Sign all outputs.
     */
    ALL: 1,
    /*
     * Do not sign outputs (zero sequences).
     */
    NONE: 2,
    /*
     * Sign output at the same index (zero sequences).
     */
    SINGLE: 3,
    /*
     * Sign only the current input (mask).
     */
    ANYONECANPAY: 128
  }, r.hashTypeByVal = {
    1: "ALL",
    2: "NONE",
    3: "SINGLE",
    128: "ANYONECANPAY"
  }, r.types = {
    NONSTANDARD: 0,
    PUBKEY: 1,
    PUBKEYHASH: 2,
    SCRIPTHASH: 3,
    MULTISIG: 4,
    NULLDATA: 5,
    WITNESSMALFORMED: 128,
    WITNESSSCRIPTHASH: 129,
    WITNESSPUBKEYHASH: 130
  }, r.typesByVal = {
    0: "NONSTANDARD",
    1: "PUBKEY",
    2: "PUBKEYHASH",
    3: "SCRIPTHASH",
    4: "MULTISIG",
    5: "NULLDATA",
    128: "WITNESSMALFORMED",
    129: "WITNESSSCRIPTHASH",
    130: "WITNESSPUBKEYHASH"
  }, r.isHashType = function(c) {
    if (e(Buffer.isBuffer(c)), c.length === 0)
      return !1;
    const o = c[c.length - 1] & ~r.hashType.ANYONECANPAY;
    return !(o < r.hashType.ALL || o > r.hashType.SINGLE);
  }, r.isLowDER = function(c) {
    return r.isSignatureEncoding(c) ? t.isLowDER(c.slice(0, -1)) : !1;
  }, r.isKeyEncoding = function(c) {
    if (e(Buffer.isBuffer(c)), c.length < 33)
      return !1;
    if (c[0] === 4) {
      if (c.length !== 65)
        return !1;
    } else if (c[0] === 2 || c[0] === 3) {
      if (c.length !== 33)
        return !1;
    } else
      return !1;
    return !0;
  }, r.isCompressedEncoding = function(c) {
    return e(Buffer.isBuffer(c)), !(c.length !== 33 || c[0] !== 2 && c[0] !== 3);
  }, r.isSignatureEncoding = function(c) {
    if (e(Buffer.isBuffer(c)), c.length < 9 || c.length > 73 || c[0] !== 48 || c[1] !== c.length - 3)
      return !1;
    const o = c[3];
    if (5 + o >= c.length)
      return !1;
    const d = c[5 + o];
    return !(o + d + 7 !== c.length || c[2] !== 2 || o === 0 || c[4] & 128 || o > 1 && c[4] === 0 && !(c[5] & 128) || c[o + 4] !== 2 || d === 0 || c[o + 6] & 128 || d > 1 && c[o + 6] === 0 && !(c[o + 7] & 128));
  }, r.toASM = function(c, o) {
    if (c.length <= 4)
      return i.decode(c).toString(10);
    if (o && r.isSignatureEncoding(c)) {
      const d = c[c.length - 1];
      let l = r.hashTypeByVal[d & 31] || "";
      return l && (d & r.hashType.ANYONECANPAY && (l += "|ANYONECANPAY"), l = `[${l}]`), c.slice(0, -1).toString("hex") + l;
    }
    return c.toString("hex");
  };
})(Qn);
/*!
 * program.js - program object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Oc = Ar, _p = Qn, Ts = _p.types, { inspectSymbol: w_ } = Gr;
let y_ = class {
  /**
   * Create a witness program.
   * @constructor
   * @param {Number} version
   * @param {Buffer} data
   */
  constructor(e, t) {
    Oc((e & 255) === e), Oc(e >= 0 && e <= 16), Oc(Buffer.isBuffer(t)), Oc(t.length >= 2 && t.length <= 40), this.version = e, this.data = t;
  }
  /**
   * Get the witness program type.
   * @returns {ScriptType}
   */
  getType() {
    return this.version === 0 ? this.data.length === 20 ? Ts.WITNESSPUBKEYHASH : this.data.length === 32 ? Ts.WITNESSSCRIPTHASH : Ts.WITNESSMALFORMED : Ts.NONSTANDARD;
  }
  /**
   * Test whether the program is either
   * an unknown version or malformed.
   * @returns {Boolean}
   */
  isUnknown() {
    const e = this.getType();
    return e === Ts.WITNESSMALFORMED || e === Ts.NONSTANDARD;
  }
  /**
   * Test whether the program is malformed.
   * @returns {Boolean}
   */
  isMalformed() {
    return this.getType() === Ts.WITNESSMALFORMED;
  }
  /**
   * Inspect the program.
   * @returns {String}
   */
  [w_]() {
    const e = this.data.toString("hex"), t = _p.typesByVal[this.getType()].toLowerCase();
    return `<Program: version=${this.version} data=${e} type=${t}>`;
  }
};
var S_ = y_;
/*!
 * opcode.js - opcode object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const $r = Ar, z4 = Me, vn = ya, qi = Qn, mt = qi.opcodes, wo = [];
let gs = null, r2 = class Yc {
  /**
   * Create an opcode.
   * Note: this should not be called directly.
   * @constructor
   * @param {Number} value - Opcode.
   * @param {Buffer?} data - Pushdata buffer.
   */
  constructor(e, t) {
    this.value = e || 0, this.data = t || null;
  }
  /**
   * Test whether a pushdata abides by minimaldata.
   * @returns {Boolean}
   */
  isMinimal() {
    return this.data ? this.data.length === 1 && (this.data[0] === 129 || this.data[0] >= 1 && this.data[0] <= 16) ? !1 : this.data.length <= 75 ? this.value === this.data.length : this.data.length <= 255 ? this.value === mt.OP_PUSHDATA1 : this.data.length <= 65535 ? this.value === mt.OP_PUSHDATA2 : ($r(this.value === mt.OP_PUSHDATA4), !0) : !0;
  }
  /**
   * Test whether opcode is a disabled opcode.
   * @returns {Boolean}
   */
  isDisabled() {
    switch (this.value) {
      case mt.OP_CAT:
      case mt.OP_SUBSTR:
      case mt.OP_LEFT:
      case mt.OP_RIGHT:
      case mt.OP_INVERT:
      case mt.OP_AND:
      case mt.OP_OR:
      case mt.OP_XOR:
      case mt.OP_2MUL:
      case mt.OP_2DIV:
      case mt.OP_MUL:
      case mt.OP_DIV:
      case mt.OP_MOD:
      case mt.OP_LSHIFT:
      case mt.OP_RSHIFT:
        return !0;
    }
    return !1;
  }
  /**
   * Test whether opcode is a branch (if/else/endif).
   * @returns {Boolean}
   */
  isBranch() {
    return this.value >= mt.OP_IF && this.value <= mt.OP_ENDIF;
  }
  /**
   * Test opcode equality.
   * @param {Opcode} op
   * @returns {Boolean}
   */
  equals(e) {
    return $r(Yc.isOpcode(e)), this.value !== e.value ? !1 : this.data ? ($r(e.data), this.data.equals(e.data)) : ($r(!e.data), !0);
  }
  /**
   * Convert Opcode to opcode value.
   * @returns {Number}
   */
  toOp() {
    return this.value;
  }
  /**
   * Covert opcode to data push.
   * @returns {Buffer|null}
   */
  toData() {
    return this.data;
  }
  /**
   * Covert opcode to data length.
   * @returns {Number}
   */
  toLength() {
    return this.data ? this.data.length : -1;
  }
  /**
   * Covert and _cast_ opcode to data push.
   * @returns {Buffer|null}
   */
  toPush() {
    return this.value === mt.OP_0 ? qi.small[0 + 1] : this.value === mt.OP_1NEGATE ? qi.small[-1 + 1] : this.value >= mt.OP_1 && this.value <= mt.OP_16 ? qi.small[this.value - 80 + 1] : this.toData();
  }
  /**
   * Get string for opcode.
   * @param {String?} enc
   * @returns {Buffer|null}
   */
  toString(e) {
    const t = this.toPush();
    return t ? t.toString(e || "utf8") : null;
  }
  /**
   * Convert opcode to small integer.
   * @returns {Number}
   */
  toSmall() {
    return this.value === mt.OP_0 ? 0 : this.value >= mt.OP_1 && this.value <= mt.OP_16 ? this.value - 80 : -1;
  }
  /**
   * Convert opcode to script number.
   * @param {Boolean?} minimal
   * @param {Number?} limit
   * @returns {ScriptNum|null}
   */
  toNum(e, t) {
    return this.value === mt.OP_0 ? vn.fromInt(0) : this.value === mt.OP_1NEGATE ? vn.fromInt(-1) : this.value >= mt.OP_1 && this.value <= mt.OP_16 ? vn.fromInt(this.value - 80) : this.data ? vn.decode(this.data, e, t) : null;
  }
  /**
   * Convert opcode to integer.
   * @param {Boolean?} minimal
   * @param {Number?} limit
   * @returns {Number}
   */
  toInt(e, t) {
    const i = this.toNum(e, t);
    return i ? i.getInt() : -1;
  }
  /**
   * Convert opcode to boolean.
   * @returns {Boolean}
   */
  toBool() {
    const e = this.toSmall();
    return e === -1 ? !1 : e === 1;
  }
  /**
   * Convert opcode to its symbolic representation.
   * @returns {String}
   */
  toSymbol() {
    if (this.value === -1)
      return "OP_INVALIDOPCODE";
    const e = qi.opcodesByVal[this.value];
    return e || `0x${Gd(this.value)}`;
  }
  /**
   * Calculate opcode size.
   * @returns {Number}
   */
  getSize() {
    if (!this.data)
      return 1;
    switch (this.value) {
      case mt.OP_PUSHDATA1:
        return 2 + this.data.length;
      case mt.OP_PUSHDATA2:
        return 3 + this.data.length;
      case mt.OP_PUSHDATA4:
        return 5 + this.data.length;
      default:
        return 1 + this.data.length;
    }
  }
  /**
   * Encode the opcode to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    if (this.value === -1)
      throw new Error("Cannot reserialize a parse error.");
    if (!this.data)
      return e.writeU8(this.value), e;
    switch (this.value) {
      case mt.OP_PUSHDATA1:
        e.writeU8(this.value), e.writeU8(this.data.length), e.writeBytes(this.data);
        break;
      case mt.OP_PUSHDATA2:
        e.writeU8(this.value), e.writeU16(this.data.length), e.writeBytes(this.data);
        break;
      case mt.OP_PUSHDATA4:
        e.writeU8(this.value), e.writeU32(this.data.length), e.writeBytes(this.data);
        break;
      default:
        $r(this.value === this.data.length), e.writeU8(this.value), e.writeBytes(this.data);
        break;
    }
    return e;
  }
  /**
   * Encode the opcode.
   * @returns {Buffer}
   */
  toRaw() {
    const e = this.getSize();
    return this.toWriter(z4.write(e)).render();
  }
  /**
   * Convert the opcode to a bitcoind test string.
   * @returns {String} Human-readable script code.
   */
  toFormat() {
    if (this.value === -1)
      return "0x01";
    if (this.data) {
      if (this.data.length <= 4) {
        const o = this.toNum();
        if (this.equals(Yc.fromNum(o)))
          return o.toString(10);
      }
      const i = qi.opcodesByVal[this.value], n = this.data.toString("hex");
      if (!i)
        return `0x${Gd(this.value)} 0x${n}`;
      let c = this.data.length.toString(16);
      for (; c.length % 2 !== 0; )
        c = "0" + c;
      return `${i} 0x${c} 0x${n}`;
    }
    const e = qi.opcodesByVal[this.value];
    return e || `0x${Gd(this.value)}`;
  }
  /**
   * Format the opcode as bitcoind asm.
   * @param {Boolean?} decode - Attempt to decode hash types.
   * @returns {String} Human-readable script.
   */
  toASM(e) {
    return this.value === -1 ? "[error]" : this.data ? qi.toASM(this.data, e) : qi.opcodesByVal[this.value] || "OP_UNKNOWN";
  }
  /**
   * Instantiate an opcode from a number opcode.
   * @param {Number} op
   * @returns {Opcode}
   */
  static fromOp(e) {
    $r(typeof e == "number");
    const t = wo[e];
    return $r(t, "Bad opcode."), t;
  }
  /**
   * Instantiate a pushdata opcode from
   * a buffer (will encode minimaldata).
   * @param {Buffer} data
   * @returns {Opcode}
   */
  static fromData(e) {
    if ($r(Buffer.isBuffer(e)), e.length === 1) {
      if (e[0] === 129)
        return this.fromOp(mt.OP_1NEGATE);
      if (e[0] >= 1 && e[0] <= 16)
        return this.fromOp(e[0] + 80);
    }
    return this.fromPush(e);
  }
  /**
   * Instantiate a pushdata opcode from a
   * buffer (this differs from fromData in
   * that it will _always_ be a pushdata op).
   * @param {Buffer} data
   * @returns {Opcode}
   */
  static fromPush(e) {
    if ($r(Buffer.isBuffer(e)), e.length === 0)
      return this.fromOp(mt.OP_0);
    if (e.length <= 75)
      return new this(e.length, e);
    if (e.length <= 255)
      return new this(mt.OP_PUSHDATA1, e);
    if (e.length <= 65535)
      return new this(mt.OP_PUSHDATA2, e);
    if (e.length <= 4294967295)
      return new this(mt.OP_PUSHDATA4, e);
    throw new Error("Pushdata size too large.");
  }
  /**
   * Instantiate a pushdata opcode from a string.
   * @param {String} str
   * @param {String} [enc=utf8]
   * @returns {Opcode}
   */
  static fromString(e, t) {
    $r(typeof e == "string");
    const i = Buffer.from(e, t || "utf8");
    return this.fromData(i);
  }
  /**
   * Instantiate an opcode from a small number.
   * @param {Number} num
   * @returns {Opcode}
   */
  static fromSmall(e) {
    return $r((e & 255) === e && e >= 0 && e <= 16), this.fromOp(e === 0 ? 0 : e + 80);
  }
  /**
   * Instantiate an opcode from a ScriptNum.
   * @param {ScriptNum} num
   * @returns {Opcode}
   */
  static fromNum(e) {
    return $r(vn.isScriptNum(e)), this.fromData(e.encode());
  }
  /**
   * Instantiate an opcode from a Number.
   * @param {Number} num
   * @returns {Opcode}
   */
  static fromInt(e) {
    return $r(Number.isSafeInteger(e)), e === 0 ? this.fromOp(mt.OP_0) : e === -1 ? this.fromOp(mt.OP_1NEGATE) : e >= 1 && e <= 16 ? this.fromOp(e + 80) : this.fromNum(vn.fromNumber(e));
  }
  /**
   * Instantiate an opcode from a Number.
   * @param {Boolean} value
   * @returns {Opcode}
   */
  static fromBool(e) {
    return $r(typeof e == "boolean"), this.fromSmall(e ? 1 : 0);
  }
  /**
   * Instantiate a pushdata opcode from symbolic name.
   * @example
   *   Opcode.fromSymbol('checksequenceverify')
   * @param {String} name
   * @returns {Opcode}
   */
  static fromSymbol(e) {
    $r(typeof e == "string"), $r(e.length > 0), e.charCodeAt(0) & 32 && (e = e.toUpperCase()), /^OP_/.test(e) || (e = `OP_${e}`);
    const t = qi.opcodes[e];
    if (t != null)
      return this.fromOp(t);
    $r(/^OP_0X/.test(e), "Unknown opcode."), $r(e.length === 7, "Unknown opcode.");
    const i = parseInt(e.substring(5), 16);
    return $r((i & 255) === i, "Unknown opcode."), this.fromOp(i);
  }
  /**
   * Instantiate opcode from buffer reader.
   * @param {BufferReader} br
   * @returns {Opcode}
   */
  static fromReader(e) {
    const t = e.readU8(), i = wo[t];
    if (i)
      return i;
    switch (t) {
      case mt.OP_PUSHDATA1: {
        if (e.left() < 1)
          return gs;
        const n = e.readU8();
        if (e.left() < n)
          return e.seek(e.left()), gs;
        const c = e.readBytes(n);
        return new this(t, c);
      }
      case mt.OP_PUSHDATA2: {
        if (e.left() < 2)
          return e.seek(e.left()), gs;
        const n = e.readU16();
        if (e.left() < n)
          return e.seek(e.left()), gs;
        const c = e.readBytes(n);
        return new this(t, c);
      }
      case mt.OP_PUSHDATA4: {
        if (e.left() < 4)
          return e.seek(e.left()), gs;
        const n = e.readU32();
        if (e.left() < n)
          return e.seek(e.left()), gs;
        const c = e.readBytes(n);
        return new this(t, c);
      }
      default: {
        if (e.left() < t)
          return e.seek(e.left()), gs;
        const n = e.readBytes(t);
        return new this(t, n);
      }
    }
  }
  /**
   * Instantiate opcode from serialized data.
   * @param {Buffer} data
   * @returns {Opcode}
   */
  static fromRaw(e) {
    return this.fromReader(z4.read(e));
  }
  /**
   * Test whether an object an Opcode.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isOpcode(e) {
    return e instanceof Yc;
  }
};
function Gd(r) {
  return r <= 15 ? "0" + r.toString(16) : r.toString(16);
}
gs = Object.freeze(new r2(-1));
for (let r = 0; r <= 255; r++) {
  if (r >= 1 && r <= 78) {
    wo.push(null);
    continue;
  }
  const e = new r2(r);
  wo.push(Object.freeze(e));
}
var B_ = r2;
/*!
 * stack.js - stack object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const W0 = Ar, U4 = Qn, Yd = ya, { inspectSymbol: v_ } = Gr;
let E_ = class $t {
  /**
   * Create a stack.
   * @constructor
   * @param {Buffer[]?} items - Stack items.
   */
  constructor(e) {
    this.items = e || [];
  }
  /**
   * Get length.
   * @returns {Number}
   */
  get length() {
    return this.items.length;
  }
  /**
   * Set length.
   * @param {Number} value
   */
  set length(e) {
    this.items.length = e;
  }
  /**
   * Instantiate a value-only iterator.
   * @returns {StackIterator}
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  /**
   * Instantiate a value-only iterator.
   * @returns {StackIterator}
   */
  values() {
    return this.items.values();
  }
  /**
   * Instantiate a key and value iterator.
   * @returns {StackIterator}
   */
  entries() {
    return this.items.entries();
  }
  /**
   * Inspect the stack.
   * @returns {String} Human-readable stack.
   */
  [v_]() {
    return `<Stack: ${this.toString()}>`;
  }
  /**
   * Convert the stack to a string.
   * @returns {String} Human-readable stack.
   */
  toString() {
    const e = [];
    for (const t of this.items)
      e.push(t.toString("hex"));
    return e.join(" ");
  }
  /**
   * Format the stack as bitcoind asm.
   * @param {Boolean?} decode - Attempt to decode hash types.
   * @returns {String} Human-readable script.
   */
  toASM(e) {
    const t = [];
    for (const i of this.items)
      t.push(U4.toASM(i, e));
    return t.join(" ");
  }
  /**
   * Clone the stack.
   * @returns {Stack} Cloned stack.
   */
  clone() {
    return new this.constructor(this.items.slice());
  }
  /**
   * Clear the stack.
   * @returns {Stack}
   */
  clear() {
    return this.items.length = 0, this;
  }
  /**
   * Get a stack item by index.
   * @param {Number} index
   * @returns {Buffer|null}
   */
  get(e) {
    return e < 0 && (e += this.items.length), e < 0 || e >= this.items.length ? null : this.items[e];
  }
  /**
   * Pop a stack item.
   * @see Array#pop
   * @returns {Buffer|null}
   */
  pop() {
    return this.items.pop() || null;
  }
  /**
   * Shift a stack item.
   * @see Array#shift
   * @returns {Buffer|null}
   */
  shift() {
    return this.items.shift() || null;
  }
  /**
   * Remove an item.
   * @param {Number} index
   * @returns {Buffer}
   */
  remove(e) {
    if (e < 0 && (e += this.items.length), e < 0 || e >= this.items.length)
      return null;
    const t = this.items.splice(e, 1);
    return t.length === 0 ? null : t[0];
  }
  /**
   * Set stack item at index.
   * @param {Number} index
   * @param {Buffer} item
   * @returns {Buffer}
   */
  set(e, t) {
    return e < 0 && (e += this.items.length), W0(Buffer.isBuffer(t)), W0(e >= 0 && e <= this.items.length), this.items[e] = t, this;
  }
  /**
   * Push item onto stack.
   * @see Array#push
   * @param {Buffer} item
   * @returns {Number} Stack size.
   */
  push(e) {
    return W0(Buffer.isBuffer(e)), this.items.push(e), this;
  }
  /**
   * Unshift item from stack.
   * @see Array#unshift
   * @param {Buffer} item
   * @returns {Number}
   */
  unshift(e) {
    return W0(Buffer.isBuffer(e)), this.items.unshift(e), this;
  }
  /**
   * Insert an item.
   * @param {Number} index
   * @param {Buffer} item
   * @returns {Buffer}
   */
  insert(e, t) {
    return e < 0 && (e += this.items.length), W0(Buffer.isBuffer(t)), W0(e >= 0 && e <= this.items.length), this.items.splice(e, 0, t), this;
  }
  /**
   * Erase stack items.
   * @param {Number} start
   * @param {Number} end
   * @returns {Buffer[]}
   */
  erase(e, t) {
    e < 0 && (e = this.items.length + e), t < 0 && (t = this.items.length + t), this.items.splice(e, t - e);
  }
  /**
   * Swap stack values.
   * @param {Number} i1 - Index 1.
   * @param {Number} i2 - Index 2.
   */
  swap(e, t) {
    e < 0 && (e = this.items.length + e), t < 0 && (t = this.items.length + t);
    const i = this.items[e], n = this.items[t];
    this.items[e] = n, this.items[t] = i;
  }
  /*
   * Data
   */
  getData(e) {
    return this.get(e);
  }
  popData() {
    return this.pop();
  }
  shiftData() {
    return this.shift();
  }
  removeData(e) {
    return this.remove(e);
  }
  setData(e, t) {
    return this.set(e, t);
  }
  pushData(e) {
    return this.push(e);
  }
  unshiftData(e) {
    return this.unshift(e);
  }
  insertData(e, t) {
    return this.insert(e, t);
  }
  /*
   * Length
   */
  getLength(e) {
    const t = this.get(e);
    return t ? t.length : -1;
  }
  /*
   * String
   */
  getString(e, t) {
    const i = this.get(e);
    return i ? $t.toString(i, t) : null;
  }
  popString(e) {
    const t = this.pop();
    return t ? $t.toString(t, e) : null;
  }
  shiftString(e) {
    const t = this.shift();
    return t ? $t.toString(t, e) : null;
  }
  removeString(e, t) {
    const i = this.remove(e);
    return i ? $t.toString(i, t) : null;
  }
  setString(e, t, i) {
    return this.set(e, $t.fromString(t, i));
  }
  pushString(e, t) {
    return this.push($t.fromString(e, t));
  }
  unshiftString(e, t) {
    return this.unshift($t.fromString(e, t));
  }
  insertString(e, t, i) {
    return this.insert(e, $t.fromString(t, i));
  }
  /*
   * Num
   */
  getNum(e, t, i) {
    const n = this.get(e);
    return n ? $t.toNum(n, t, i) : null;
  }
  popNum(e, t) {
    const i = this.pop();
    return i ? $t.toNum(i, e, t) : null;
  }
  shiftNum(e, t) {
    const i = this.shift();
    return i ? $t.toNum(i, e, t) : null;
  }
  removeNum(e, t, i) {
    const n = this.remove(e);
    return n ? $t.toNum(n, t, i) : null;
  }
  setNum(e, t) {
    return this.set(e, $t.fromNum(t));
  }
  pushNum(e) {
    return this.push($t.fromNum(e));
  }
  unshiftNum(e) {
    return this.unshift($t.fromNum(e));
  }
  insertNum(e, t) {
    return this.insert(e, $t.fromNum(t));
  }
  /*
   * Int
   */
  getInt(e, t, i) {
    const n = this.get(e);
    return n ? $t.toInt(n, t, i) : -1;
  }
  popInt(e, t) {
    const i = this.pop();
    return i ? $t.toInt(i, e, t) : -1;
  }
  shiftInt(e, t) {
    const i = this.shift();
    return i ? $t.toInt(i, e, t) : -1;
  }
  removeInt(e, t, i) {
    const n = this.remove(e);
    return n ? $t.toInt(n, t, i) : -1;
  }
  setInt(e, t) {
    return this.set(e, $t.fromInt(t));
  }
  pushInt(e) {
    return this.push($t.fromInt(e));
  }
  unshiftInt(e) {
    return this.unshift($t.fromInt(e));
  }
  insertInt(e, t) {
    return this.insert(e, $t.fromInt(t));
  }
  /*
   * Bool
   */
  getBool(e) {
    const t = this.get(e);
    return t ? $t.toBool(t) : !1;
  }
  popBool() {
    const e = this.pop();
    return e ? $t.toBool(e) : !1;
  }
  shiftBool() {
    const e = this.shift();
    return e ? $t.toBool(e) : !1;
  }
  removeBool(e) {
    const t = this.remove(e);
    return t ? $t.toBool(t) : !1;
  }
  setBool(e, t) {
    return this.set(e, $t.fromBool(t));
  }
  pushBool(e) {
    return this.push($t.fromBool(e));
  }
  unshiftBool(e) {
    return this.unshift($t.fromBool(e));
  }
  insertBool(e, t) {
    return this.insert(e, $t.fromBool(t));
  }
  /**
   * Test an object to see if it is a Stack.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isStack(e) {
    return e instanceof $t;
  }
  /*
   * Encoding
   */
  static toString(e, t) {
    return W0(Buffer.isBuffer(e)), e.toString(t || "utf8");
  }
  static fromString(e, t) {
    return W0(typeof e == "string"), Buffer.from(e, t || "utf8");
  }
  static toNum(e, t, i) {
    return Yd.decode(e, t, i);
  }
  static fromNum(e) {
    return W0(Yd.isScriptNum(e)), e.encode();
  }
  static toInt(e, t, i) {
    return $t.toNum(e, t, i).getInt();
  }
  static fromInt(e) {
    if (W0(typeof e == "number"), e >= -1 && e <= 16)
      return U4.small[e + 1];
    const t = Yd.fromNumber(e);
    return $t.fromNum(t);
  }
  static toBool(e) {
    W0(Buffer.isBuffer(e));
    for (let t = 0; t < e.length; t++)
      if (e[t] !== 0)
        return !(t === e.length - 1 && e[t] === 128);
    return !1;
  }
  static fromBool(e) {
    return W0(typeof e == "boolean"), $t.fromInt(e ? 1 : 0);
  }
};
var i2 = E_;
/*!
 * script.js - script interpreter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const kt = Ar, vf = Me, I_ = i_, A_ = u_, Jd = pa, Xd = ip, __ = jo, M_ = cc, j0 = ri, Zd = jn, N_ = S_, rt = B_, C4 = i2, qe = t2, _0 = ya, u0 = Qn, Pc = ga, pe = u0.opcodes, f0 = u0.types, { encoding: O_ } = vf, { inspectSymbol: P_ } = Gr, { MAX_MULTISIG_PUBKEYS: T4, MAX_SCRIPT_PUSH: R_ } = j0, Wd = Buffer.alloc(0);
let S0 = class qt {
  /**
   * Create a script.
   * @constructor
   * @param {Buffer|Array|Object} options
   */
  constructor(e) {
    this.raw = Wd, this.code = [], e && this.fromOptions(e);
  }
  /**
   * Get length.
   * @returns {Number}
   */
  get length() {
    return this.code.length;
  }
  /**
   * Set length.
   * @param {Number} value
   */
  set length(e) {
    this.code.length = e;
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    if (kt(e, "Script data is required."), Buffer.isBuffer(e))
      return this.fromRaw(e);
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.raw) {
      if (!e.code)
        return this.fromRaw(e.raw);
      kt(Buffer.isBuffer(e.raw), "Raw must be a Buffer."), this.raw = e.raw;
    }
    if (e.code) {
      if (!e.raw)
        return this.fromArray(e.code);
      kt(Array.isArray(e.code), "Code must be an array."), this.code = e.code;
    }
    return this;
  }
  /**
   * Insantiate script from options object.
   * @param {Object} options
   * @returns {Script}
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Instantiate a value-only iterator.
   * @returns {ScriptIterator}
   */
  values() {
    return this.code.values();
  }
  /**
   * Instantiate a key and value iterator.
   * @returns {ScriptIterator}
   */
  entries() {
    return this.code.entries();
  }
  /**
   * Instantiate a value-only iterator.
   * @returns {ScriptIterator}
   */
  [Symbol.iterator]() {
    return this.code[Symbol.iterator]();
  }
  /**
   * Convert the script to an array of
   * Buffers (pushdatas) and Numbers
   * (opcodes).
   * @returns {Array}
   */
  toArray() {
    return this.code.slice();
  }
  /**
   * Inject properties from an array of
   * of buffers and numbers.
   * @private
   * @param {Array} code
   * @returns {Script}
   */
  fromArray(e) {
    kt(Array.isArray(e)), this.clear();
    for (const t of e)
      this.push(t);
    return this.compile();
  }
  /**
   * Instantiate script from an array
   * of buffers and numbers.
   * @param {Array} code
   * @returns {Script}
   */
  static fromArray(e) {
    return new this().fromArray(e);
  }
  /**
   * Convert script to stack items.
   * @returns {Buffer[]}
   */
  toItems() {
    const e = [];
    for (const t of this.code) {
      const i = t.toPush();
      if (!i)
        throw new Error("Non-push opcode in script.");
      e.push(i);
    }
    return e;
  }
  /**
   * Inject data from stack items.
   * @private
   * @param {Buffer[]} items
   * @returns {Script}
   */
  fromItems(e) {
    kt(Array.isArray(e)), this.clear();
    for (const t of e)
      this.pushData(t);
    return this.compile();
  }
  /**
   * Instantiate script from stack items.
   * @param {Buffer[]} items
   * @returns {Script}
   */
  static fromItems(e) {
    return new this().fromItems(e);
  }
  /**
   * Convert script to stack.
   * @returns {Stack}
   */
  toStack() {
    return new C4(this.toItems());
  }
  /**
   * Inject data from stack.
   * @private
   * @param {Stack} stack
   * @returns {Script}
   */
  fromStack(e) {
    return this.fromItems(e.items);
  }
  /**
   * Instantiate script from stack.
   * @param {Stack} stack
   * @returns {Script}
   */
  static fromStack(e) {
    return new this().fromStack(e);
  }
  /**
   * Clone the script.
   * @returns {Script} Cloned script.
   */
  clone() {
    return new this.constructor().inject(this);
  }
  /**
   * Inject properties from script.
   * Used for cloning.
   * @private
   * @param {Script} script
   * @returns {Script}
   */
  inject(e) {
    return this.raw = e.raw, this.code = e.code.slice(), this;
  }
  /**
   * Test equality against script.
   * @param {Script} script
   * @returns {Boolean}
   */
  equals(e) {
    return kt(qt.isScript(e)), this.raw.equals(e.raw);
  }
  /**
   * Compare against another script.
   * @param {Script} script
   * @returns {Number}
   */
  compare(e) {
    return kt(qt.isScript(e)), this.raw.compare(e.raw);
  }
  /**
   * Clear the script.
   * @returns {Script}
   */
  clear() {
    return this.raw = Wd, this.code.length = 0, this;
  }
  /**
   * Inspect the script.
   * @returns {String} Human-readable script code.
   */
  [P_]() {
    return `<Script: ${this.toString()}>`;
  }
  /**
   * Convert the script to a bitcoind test string.
   * @returns {String} Human-readable script code.
   */
  toString() {
    const e = [];
    for (const t of this.code)
      e.push(t.toFormat());
    return e.join(" ");
  }
  /**
   * Format the script as bitcoind asm.
   * @param {Boolean?} decode - Attempt to decode hash types.
   * @returns {String} Human-readable script.
   */
  toASM(e) {
    this.isNulldata() && (e = !1);
    const t = [];
    for (const i of this.code)
      t.push(i.toASM(e));
    return t.join(" ");
  }
  /**
   * Re-encode the script internally. Useful if you
   * changed something manually in the `code` array.
   * @returns {Script}
   */
  compile() {
    if (this.code.length === 0)
      return this.clear();
    let e = 0;
    for (const i of this.code)
      e += i.getSize();
    const t = vf.write(e);
    for (const i of this.code)
      i.toWriter(t);
    return this.raw = t.render(), this;
  }
  /**
   * Write the script to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    return e.writeVarBytes(this.raw), e;
  }
  /**
   * Encode the script to a Buffer. See {@link Script#encode}.
   * @returns {Buffer|String} Serialized script.
   */
  toRaw() {
    return this.raw;
  }
  /**
   * Convert script to a hex string.
   * @returns {String}
   */
  toJSON() {
    return this.toRaw().toString("hex");
  }
  /**
   * Inject properties from json object.
   * @private
   * @param {String} json
   */
  fromJSON(e) {
    return kt(typeof e == "string", "Code must be a string."), this.fromRaw(Buffer.from(e, "hex"));
  }
  /**
   * Instantiate script from a hex string.
   * @params {String} json
   * @returns {Script}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Get the script's "subscript" starting at a separator.
   * @param {Number} index - The last separator to sign/verify beyond.
   * @returns {Script} Subscript.
   */
  getSubscript(e) {
    if (e === 0)
      return this.clone();
    const t = new qt();
    for (let i = e; i < this.code.length; i++) {
      const n = this.code[i];
      if (n.value === -1)
        break;
      t.code.push(n);
    }
    return t.compile();
  }
  /**
   * Get the script's "subscript" starting at a separator.
   * Remove all OP_CODESEPARATORs if present. This bizarre
   * behavior is necessary for signing and verification when
   * code separators are present.
   * @returns {Script} Subscript.
   */
  removeSeparators() {
    let e = !1;
    for (const i of this.code) {
      if (i.value === -1)
        break;
      if (i.value === pe.OP_CODESEPARATOR) {
        e = !0;
        break;
      }
    }
    if (!e)
      return this;
    const t = new qt();
    for (const i of this.code) {
      if (i.value === -1)
        break;
      i.value !== pe.OP_CODESEPARATOR && t.code.push(i);
    }
    return t.compile();
  }
  /**
   * Execute and interpret the script.
   * @param {Stack} stack - Script execution stack.
   * @param {Number?} flags - Script standard flags.
   * @param {TX?} tx - Transaction being verified.
   * @param {Number?} index - Index of input being verified.
   * @param {Amount?} value - Previous output value.
   * @param {Number?} version - Signature hash version (0=legacy, 1=segwit).
   * @throws {ScriptError} Will be thrown on VERIFY failures.
   */
  execute(e, t, i, n, c, o) {
    if (t == null && (t = qt.flags.STANDARD_VERIFY_FLAGS), o == null && (o = 0), this.raw.length > j0.MAX_SCRIPT_SIZE)
      throw new qe("SCRIPT_SIZE");
    const d = [], l = [];
    let h = 0, x = 0, b = 0, g = !1;
    t & qt.flags.VERIFY_MINIMALDATA && (g = !0);
    for (let w = 0; w < this.code.length; w++) {
      const I = this.code[w];
      if (I.value === -1)
        throw new qe("BAD_OPCODE", I, w);
      if (I.data && I.data.length > j0.MAX_SCRIPT_PUSH)
        throw new qe("PUSH_SIZE", I, w);
      if (I.value > pe.OP_16 && ++x > j0.MAX_SCRIPT_OPS)
        throw new qe("OP_COUNT", I, w);
      if (I.isDisabled())
        throw new qe("DISABLED_OPCODE", I, w);
      if (I.value === pe.OP_CODESEPARATOR && o === 0 && t & qt.flags.VERIFY_CONST_SCRIPTCODE)
        throw new qe("OP_CODESEPARATOR", I, w);
      if (b && !I.isBranch()) {
        if (e.length + l.length > j0.MAX_SCRIPT_STACK)
          throw new qe("STACK_SIZE", I, w);
        continue;
      }
      if (I.data) {
        if (g && !I.isMinimal())
          throw new qe("MINIMALDATA", I, w);
        if (e.push(I.data), e.length + l.length > j0.MAX_SCRIPT_STACK)
          throw new qe("STACK_SIZE", I, w);
        continue;
      }
      switch (I.value) {
        case pe.OP_0: {
          e.pushInt(0);
          break;
        }
        case pe.OP_1NEGATE: {
          e.pushInt(-1);
          break;
        }
        case pe.OP_1:
        case pe.OP_2:
        case pe.OP_3:
        case pe.OP_4:
        case pe.OP_5:
        case pe.OP_6:
        case pe.OP_7:
        case pe.OP_8:
        case pe.OP_9:
        case pe.OP_10:
        case pe.OP_11:
        case pe.OP_12:
        case pe.OP_13:
        case pe.OP_14:
        case pe.OP_15:
        case pe.OP_16: {
          e.pushInt(I.value - 80);
          break;
        }
        case pe.OP_NOP:
          break;
        case pe.OP_CHECKLOCKTIMEVERIFY: {
          if (!(t & qt.flags.VERIFY_CHECKLOCKTIMEVERIFY))
            break;
          if (!i)
            throw new qe("UNKNOWN_ERROR", "No TX passed in.");
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.getNum(-1, g, 5);
          if (B.isNeg())
            throw new qe("NEGATIVE_LOCKTIME", I, w);
          const y = B.toDouble();
          if (!i.verifyLocktime(n, y))
            throw new qe("UNSATISFIED_LOCKTIME", I, w);
          break;
        }
        case pe.OP_CHECKSEQUENCEVERIFY: {
          if (!(t & qt.flags.VERIFY_CHECKSEQUENCEVERIFY))
            break;
          if (!i)
            throw new qe("UNKNOWN_ERROR", "No TX passed in.");
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.getNum(-1, g, 5);
          if (B.isNeg())
            throw new qe("NEGATIVE_LOCKTIME", I, w);
          const y = B.toDouble();
          if (!i.verifySequence(n, y))
            throw new qe("UNSATISFIED_LOCKTIME", I, w);
          break;
        }
        case pe.OP_NOP1:
        case pe.OP_NOP4:
        case pe.OP_NOP5:
        case pe.OP_NOP6:
        case pe.OP_NOP7:
        case pe.OP_NOP8:
        case pe.OP_NOP9:
        case pe.OP_NOP10: {
          if (t & qt.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
            throw new qe("DISCOURAGE_UPGRADABLE_NOPS", I, w);
          break;
        }
        case pe.OP_IF:
        case pe.OP_NOTIF: {
          let B = !1;
          if (!b) {
            if (e.length < 1)
              throw new qe("UNBALANCED_CONDITIONAL", I, w);
            if (o === 1 && t & qt.flags.VERIFY_MINIMALIF) {
              const y = e.get(-1);
              if (y.length > 1)
                throw new qe("MINIMALIF");
              if (y.length === 1 && y[0] !== 1)
                throw new qe("MINIMALIF");
            }
            B = e.getBool(-1), I.value === pe.OP_NOTIF && (B = !B), e.pop();
          }
          d.push(B), B || (b += 1);
          break;
        }
        case pe.OP_ELSE: {
          if (d.length === 0)
            throw new qe("UNBALANCED_CONDITIONAL", I, w);
          d[d.length - 1] = !d[d.length - 1], d[d.length - 1] ? b -= 1 : b += 1;
          break;
        }
        case pe.OP_ENDIF: {
          if (d.length === 0)
            throw new qe("UNBALANCED_CONDITIONAL", I, w);
          d.pop() || (b -= 1);
          break;
        }
        case pe.OP_VERIFY: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          if (!e.getBool(-1))
            throw new qe("VERIFY", I, w);
          e.pop();
          break;
        }
        case pe.OP_RETURN:
          throw new qe("OP_RETURN", I, w);
        case pe.OP_TOALTSTACK: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          l.push(e.pop());
          break;
        }
        case pe.OP_FROMALTSTACK: {
          if (l.length === 0)
            throw new qe("INVALID_ALTSTACK_OPERATION", I, w);
          e.push(l.pop());
          break;
        }
        case pe.OP_2DROP: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.pop(), e.pop();
          break;
        }
        case pe.OP_2DUP: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.get(-2), y = e.get(-1);
          e.push(B), e.push(y);
          break;
        }
        case pe.OP_3DUP: {
          if (e.length < 3)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.get(-3), y = e.get(-2), A = e.get(-1);
          e.push(B), e.push(y), e.push(A);
          break;
        }
        case pe.OP_2OVER: {
          if (e.length < 4)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.get(-4), y = e.get(-3);
          e.push(B), e.push(y);
          break;
        }
        case pe.OP_2ROT: {
          if (e.length < 6)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.get(-6), y = e.get(-5);
          e.erase(-6, -4), e.push(B), e.push(y);
          break;
        }
        case pe.OP_2SWAP: {
          if (e.length < 4)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.swap(-4, -2), e.swap(-3, -1);
          break;
        }
        case pe.OP_IFDUP: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          if (e.getBool(-1)) {
            const B = e.get(-1);
            e.push(B);
          }
          break;
        }
        case pe.OP_DEPTH: {
          e.pushInt(e.length);
          break;
        }
        case pe.OP_DROP: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.pop();
          break;
        }
        case pe.OP_DUP: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(e.get(-1));
          break;
        }
        case pe.OP_NIP: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.remove(-2);
          break;
        }
        case pe.OP_OVER: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(e.get(-2));
          break;
        }
        case pe.OP_PICK:
        case pe.OP_ROLL: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.getInt(-1, g, 4);
          if (e.pop(), B < 0 || B >= e.length)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const y = e.get(-B - 1);
          I.value === pe.OP_ROLL && e.remove(-B - 1), e.push(y);
          break;
        }
        case pe.OP_ROT: {
          if (e.length < 3)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.swap(-3, -2), e.swap(-2, -1);
          break;
        }
        case pe.OP_SWAP: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.swap(-2, -1);
          break;
        }
        case pe.OP_TUCK: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.insert(-2, e.get(-1));
          break;
        }
        case pe.OP_SIZE: {
          if (e.length < 1)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.pushInt(e.get(-1).length);
          break;
        }
        case pe.OP_EQUAL:
        case pe.OP_EQUALVERIFY: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.get(-2), y = e.get(-1), A = B.equals(y);
          if (e.pop(), e.pop(), e.pushBool(A), I.value === pe.OP_EQUALVERIFY) {
            if (!A)
              throw new qe("EQUALVERIFY", I, w);
            e.pop();
          }
          break;
        }
        case pe.OP_1ADD:
        case pe.OP_1SUB:
        case pe.OP_NEGATE:
        case pe.OP_ABS:
        case pe.OP_NOT:
        case pe.OP_0NOTEQUAL: {
          if (e.length < 1)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          let B = e.getNum(-1, g, 4), y;
          switch (I.value) {
            case pe.OP_1ADD:
              B.iaddn(1);
              break;
            case pe.OP_1SUB:
              B.isubn(1);
              break;
            case pe.OP_NEGATE:
              B.ineg();
              break;
            case pe.OP_ABS:
              B.iabs();
              break;
            case pe.OP_NOT:
              y = B.isZero(), B = _0.fromBool(y);
              break;
            case pe.OP_0NOTEQUAL:
              y = !B.isZero(), B = _0.fromBool(y);
              break;
            default:
              kt(!1, "Fatal script error.");
              break;
          }
          e.pop(), e.pushNum(B);
          break;
        }
        case pe.OP_ADD:
        case pe.OP_SUB:
        case pe.OP_BOOLAND:
        case pe.OP_BOOLOR:
        case pe.OP_NUMEQUAL:
        case pe.OP_NUMEQUALVERIFY:
        case pe.OP_NUMNOTEQUAL:
        case pe.OP_LESSTHAN:
        case pe.OP_GREATERTHAN:
        case pe.OP_LESSTHANOREQUAL:
        case pe.OP_GREATERTHANOREQUAL:
        case pe.OP_MIN:
        case pe.OP_MAX: {
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.getNum(-2, g, 4), y = e.getNum(-1, g, 4);
          let A, _;
          switch (I.value) {
            case pe.OP_ADD:
              A = B.iadd(y);
              break;
            case pe.OP_SUB:
              A = B.isub(y);
              break;
            case pe.OP_BOOLAND:
              _ = B.toBool() && y.toBool(), A = _0.fromBool(_);
              break;
            case pe.OP_BOOLOR:
              _ = B.toBool() || y.toBool(), A = _0.fromBool(_);
              break;
            case pe.OP_NUMEQUAL:
              _ = B.eq(y), A = _0.fromBool(_);
              break;
            case pe.OP_NUMEQUALVERIFY:
              _ = B.eq(y), A = _0.fromBool(_);
              break;
            case pe.OP_NUMNOTEQUAL:
              _ = !B.eq(y), A = _0.fromBool(_);
              break;
            case pe.OP_LESSTHAN:
              _ = B.lt(y), A = _0.fromBool(_);
              break;
            case pe.OP_GREATERTHAN:
              _ = B.gt(y), A = _0.fromBool(_);
              break;
            case pe.OP_LESSTHANOREQUAL:
              _ = B.lte(y), A = _0.fromBool(_);
              break;
            case pe.OP_GREATERTHANOREQUAL:
              _ = B.gte(y), A = _0.fromBool(_);
              break;
            case pe.OP_MIN:
              A = _0.min(B, y);
              break;
            case pe.OP_MAX:
              A = _0.max(B, y);
              break;
            default:
              kt(!1, "Fatal script error.");
              break;
          }
          if (e.pop(), e.pop(), e.pushNum(A), I.value === pe.OP_NUMEQUALVERIFY) {
            if (!e.getBool(-1))
              throw new qe("NUMEQUALVERIFY", I, w);
            e.pop();
          }
          break;
        }
        case pe.OP_WITHIN: {
          if (e.length < 3)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.getNum(-3, g, 4), y = e.getNum(-2, g, 4), A = e.getNum(-1, g, 4), _ = y.lte(B) && B.lt(A);
          e.pop(), e.pop(), e.pop(), e.pushBool(_);
          break;
        }
        case pe.OP_RIPEMD160: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(I_.digest(e.pop()));
          break;
        }
        case pe.OP_SHA1: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(A_.digest(e.pop()));
          break;
        }
        case pe.OP_SHA256: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(Jd.digest(e.pop()));
          break;
        }
        case pe.OP_HASH160: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(Xd.digest(e.pop()));
          break;
        }
        case pe.OP_HASH256: {
          if (e.length === 0)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          e.push(__.digest(e.pop()));
          break;
        }
        case pe.OP_CODESEPARATOR: {
          h = w + 1;
          break;
        }
        case pe.OP_CHECKSIG:
        case pe.OP_CHECKSIGVERIFY: {
          if (!i)
            throw new qe("UNKNOWN_ERROR", "No TX passed in.");
          if (e.length < 2)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const B = e.get(-2), y = e.get(-1), A = this.getSubscript(h);
          if (o === 0 && A.findAndDelete(B) > 0 && t & qt.flags.VERIFY_CONST_SCRIPTCODE)
            throw new qe("SIG_FINDANDDELETE", I, w);
          L4(B, t), D4(y, t, o);
          let _ = !1;
          if (B.length > 0) {
            const q = B[B.length - 1], U = i.signatureHash(n, A, c, q, o);
            _ = K4(U, B, y);
          }
          if (!_ && t & qt.flags.VERIFY_NULLFAIL && B.length !== 0)
            throw new qe("NULLFAIL", I, w);
          if (e.pop(), e.pop(), e.pushBool(_), I.value === pe.OP_CHECKSIGVERIFY) {
            if (!_)
              throw new qe("CHECKSIGVERIFY", I, w);
            e.pop();
          }
          break;
        }
        case pe.OP_CHECKMULTISIG:
        case pe.OP_CHECKMULTISIGVERIFY: {
          if (!i)
            throw new qe("UNKNOWN_ERROR", "No TX passed in.");
          let B = 1;
          if (e.length < B)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          let y = e.getInt(-B, g, 4), A = y + 2, _, q;
          if (y < 0 || y > j0.MAX_MULTISIG_PUBKEYS)
            throw new qe("PUBKEY_COUNT", I, w);
          if (x += y, x > j0.MAX_SCRIPT_OPS)
            throw new qe("OP_COUNT", I, w);
          if (B += 1, _ = B, B += y, e.length < B)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          let U = e.getInt(-B, g, 4);
          if (U < 0 || U > y)
            throw new qe("SIG_COUNT", I, w);
          if (B += 1, q = B, B += U, e.length < B)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          const z = this.getSubscript(h);
          for (let H = 0; H < U; H++) {
            const k = e.get(-q - H);
            if (o === 0 && z.findAndDelete(k) > 0 && t & qt.flags.VERIFY_CONST_SCRIPTCODE)
              throw new qe("SIG_FINDANDDELETE", I, w);
          }
          let E = !0;
          for (; E && U > 0; ) {
            const H = e.get(-q), k = e.get(-_);
            if (L4(H, t), D4(k, t, o), H.length > 0) {
              const V = H[H.length - 1], T = i.signatureHash(n, z, c, V, o);
              K4(T, H, k) && (q += 1, U -= 1);
            }
            _ += 1, y -= 1, U > y && (E = !1);
          }
          for (; B > 1; ) {
            if (!E && t & qt.flags.VERIFY_NULLFAIL && A === 0 && e.get(-1).length !== 0)
              throw new qe("NULLFAIL", I, w);
            A > 0 && (A -= 1), e.pop(), B -= 1;
          }
          if (e.length < 1)
            throw new qe("INVALID_STACK_OPERATION", I, w);
          if (t & qt.flags.VERIFY_NULLDUMMY && e.get(-1).length !== 0)
            throw new qe("SIG_NULLDUMMY", I, w);
          if (e.pop(), e.pushBool(E), I.value === pe.OP_CHECKMULTISIGVERIFY) {
            if (!E)
              throw new qe("CHECKMULTISIGVERIFY", I, w);
            e.pop();
          }
          break;
        }
        default:
          throw new qe("BAD_OPCODE", I, w);
      }
      if (e.length + l.length > j0.MAX_SCRIPT_STACK)
        throw new qe("STACK_SIZE", I, w);
    }
    if (d.length !== 0)
      throw new qe("UNBALANCED_CONDITIONAL");
  }
  /**
   * Remove all matched data elements from
   * a script's code (used to remove signatures
   * before verification). Note that this
   * compares and removes data on the _byte level_.
   * It also reserializes the data to a single
   * script with minimaldata encoding beforehand.
   * A signature will _not_ be removed if it is
   * not minimaldata.
   * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
   * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
   * @param {Buffer} data - Data element to match against.
   * @returns {Number} Total.
   */
  findAndDelete(e) {
    const t = rt.fromPush(e);
    if (this.raw.length < t.getSize())
      return 0;
    let i = !1;
    for (const o of this.code) {
      if (o.value === -1)
        break;
      if (o.equals(t)) {
        i = !0;
        break;
      }
    }
    if (!i)
      return 0;
    const n = [];
    let c = 0;
    for (const o of this.code) {
      if (o.value === -1)
        break;
      if (o.equals(t)) {
        c += 1;
        continue;
      }
      n.push(o);
    }
    return this.code = n, this.compile(), c;
  }
  /**
   * Find a data element in a script.
   * @param {Buffer} data - Data element to match against.
   * @returns {Number} Index (`-1` if not present).
   */
  indexOf(e) {
    for (let t = 0; t < this.code.length; t++) {
      const i = this.code[t];
      if (i.value === -1)
        break;
      if (i.data && i.data.equals(e))
        return t;
    }
    return -1;
  }
  /**
   * Test a script to see if it is likely
   * to be script code (no weird opcodes).
   * @returns {Boolean}
   */
  isCode() {
    for (const e of this.code) {
      if (e.value === -1 || e.isDisabled())
        return !1;
      switch (e.value) {
        case pe.OP_RESERVED:
        case pe.OP_NOP:
        case pe.OP_VER:
        case pe.OP_VERIF:
        case pe.OP_VERNOTIF:
        case pe.OP_RESERVED1:
        case pe.OP_RESERVED2:
        case pe.OP_NOP1:
          return !1;
      }
      if (e.value > pe.OP_CHECKSEQUENCEVERIFY)
        return !1;
    }
    return !0;
  }
  /**
   * Inject properties from a pay-to-pubkey script.
   * @private
   * @param {Buffer} key
   */
  fromPubkey(e) {
    return kt(Buffer.isBuffer(e) && (e.length === 33 || e.length === 65)), this.raw = Buffer.allocUnsafe(1 + e.length + 1), this.raw[0] = e.length, e.copy(this.raw, 1), this.raw[1 + e.length] = pe.OP_CHECKSIG, e = this.raw.slice(1, 1 + e.length), this.code.length = 0, this.code.push(rt.fromPush(e)), this.code.push(rt.fromOp(pe.OP_CHECKSIG)), this;
  }
  /**
   * Create a pay-to-pubkey script.
   * @param {Buffer} key
   * @returns {Script}
   */
  static fromPubkey(e) {
    return new this().fromPubkey(e);
  }
  /**
   * Inject properties from a pay-to-pubkeyhash script.
   * @private
   * @param {Buffer} hash
   */
  fromPubkeyhash(e) {
    return kt(Buffer.isBuffer(e) && e.length === 20), this.raw = Buffer.allocUnsafe(25), this.raw[0] = pe.OP_DUP, this.raw[1] = pe.OP_HASH160, this.raw[2] = 20, e.copy(this.raw, 3), this.raw[23] = pe.OP_EQUALVERIFY, this.raw[24] = pe.OP_CHECKSIG, e = this.raw.slice(3, 23), this.code.length = 0, this.code.push(rt.fromOp(pe.OP_DUP)), this.code.push(rt.fromOp(pe.OP_HASH160)), this.code.push(rt.fromPush(e)), this.code.push(rt.fromOp(pe.OP_EQUALVERIFY)), this.code.push(rt.fromOp(pe.OP_CHECKSIG)), this;
  }
  /**
   * Create a pay-to-pubkeyhash script.
   * @param {Buffer} hash
   * @returns {Script}
   */
  static fromPubkeyhash(e) {
    return new this().fromPubkeyhash(e);
  }
  /**
   * Inject properties from pay-to-multisig script.
   * @private
   * @param {Number} m
   * @param {Number} n
   * @param {Buffer[]} keys
   * @param {Boolean?} isSorted
   * @param {Boolean?} isWitness
   * @returns {Script}
   */
  fromMultisig(e, t, i, n = !0, c = !0) {
    kt((e & 255) === e && (t & 255) === t), kt(Array.isArray(i)), kt(i.length === t, "`n` keys are required for multisig."), kt(e >= 1 && e <= t), kt(t >= 1 && t <= T4, `${t} keys not allowed in script. Max allowed: ${T4}`), this.clear(), this.pushInt(e);
    for (const d of n ? k_(i) : i)
      this.pushData(d);
    this.pushInt(t), this.pushOp(pe.OP_CHECKMULTISIG);
    const o = this.compile();
    return c || kt(o.getSize() <= R_, "Script size is too large"), o;
  }
  /**
   * Create a pay-to-multisig script.
   * @param {Number} m
   * @param {Number} n
   * @param {Buffer[]} keys
   * @param {Boolean?} isSorted
   * @param {Boolean?} isWitness
   * @returns {Script}
   */
  static fromMultisig(e, t, i, n = !0, c = !0) {
    return new this().fromMultisig(e, t, i, n, c);
  }
  /**
   * Inject properties from a pay-to-scripthash script.
   * @private
   * @param {Buffer} hash
   */
  fromScripthash(e) {
    return kt(Buffer.isBuffer(e) && e.length === 20), this.raw = Buffer.allocUnsafe(23), this.raw[0] = pe.OP_HASH160, this.raw[1] = 20, e.copy(this.raw, 2), this.raw[22] = pe.OP_EQUAL, e = this.raw.slice(2, 22), this.code.length = 0, this.code.push(rt.fromOp(pe.OP_HASH160)), this.code.push(rt.fromPush(e)), this.code.push(rt.fromOp(pe.OP_EQUAL)), this;
  }
  /**
   * Create a pay-to-scripthash script.
   * @param {Buffer} hash
   * @returns {Script}
   */
  static fromScripthash(e) {
    return new this().fromScripthash(e);
  }
  /**
   * Inject properties from a nulldata/opreturn script.
   * @private
   * @param {Buffer} flags
   */
  fromNulldata(e) {
    return kt(Buffer.isBuffer(e)), kt(e.length <= Zd.MAX_OP_RETURN, "Nulldata too large."), this.clear(), this.pushOp(pe.OP_RETURN), this.pushData(e), this.compile();
  }
  /**
   * Create a nulldata/opreturn script.
   * @param {Buffer} flags
   * @returns {Script}
   */
  static fromNulldata(e) {
    return new this().fromNulldata(e);
  }
  /**
   * Inject properties from a witness program.
   * @private
   * @param {Number} version
   * @param {Buffer} data
   */
  fromProgram(e, t) {
    return kt((e & 255) === e && e >= 0 && e <= 16), kt(Buffer.isBuffer(t) && t.length >= 2 && t.length <= 40), this.raw = Buffer.allocUnsafe(2 + t.length), this.raw[0] = e === 0 ? 0 : e + 80, this.raw[1] = t.length, t.copy(this.raw, 2), t = this.raw.slice(2, 2 + t.length), this.code.length = 0, this.code.push(rt.fromSmall(e)), this.code.push(rt.fromPush(t)), this;
  }
  /**
   * Create a witness program.
   * @param {Number} version
   * @param {Buffer} data
   * @returns {Script}
   */
  static fromProgram(e, t) {
    return new this().fromProgram(e, t);
  }
  /**
   * Inject properties from an address.
   * @private
   * @param {Address|AddressString} address
   */
  fromAddress(e) {
    if (typeof e == "string" && (e = Pc.fromString(e)), kt(e instanceof Pc, "Not an address."), e.isPubkeyhash())
      return this.fromPubkeyhash(e.hash);
    if (e.isScripthash())
      return this.fromScripthash(e.hash);
    if (e.isProgram())
      return this.fromProgram(e.version, e.hash);
    throw new Error("Unknown address type.");
  }
  /**
   * Create an output script from an address.
   * @param {Address|AddressString} address
   * @returns {Script}
   */
  static fromAddress(e) {
    return new this().fromAddress(e);
  }
  /**
   * Inject properties from a witness block commitment.
   * @private
   * @param {Buffer} hash
   * @param {String|Buffer} flags
   */
  fromCommitment(e, t) {
    const i = vf.write(36);
    return i.writeU32BE(2854332909), i.writeHash(e), this.clear(), this.pushOp(pe.OP_RETURN), this.pushData(i.render()), t && this.pushData(t), this.compile();
  }
  /**
   * Create a witness block commitment.
   * @param {Buffer} hash
   * @param {String|Buffer} flags
   * @returns {Script}
   */
  static fromCommitment(e, t) {
    return new this().fromCommitment(e, t);
  }
  /**
   * Grab and deserialize the redeem script.
   * @returns {Script|null} Redeem script.
   */
  getRedeem() {
    let e = null;
    for (const t of this.code) {
      if (t.value === -1 || t.value > pe.OP_16)
        return null;
      e = t.data;
    }
    return e ? qt.fromRaw(e) : null;
  }
  /**
   * Get the standard script type.
   * @returns {ScriptType}
   */
  getType() {
    return this.isPubkey() ? f0.PUBKEY : this.isPubkeyhash() ? f0.PUBKEYHASH : this.isScripthash() ? f0.SCRIPTHASH : this.isWitnessPubkeyhash() ? f0.WITNESSPUBKEYHASH : this.isWitnessScripthash() ? f0.WITNESSSCRIPTHASH : this.isMultisig() ? f0.MULTISIG : this.isNulldata() ? f0.NULLDATA : f0.NONSTANDARD;
  }
  /**
   * Test whether a script is of an unknown/non-standard type.
   * @returns {Boolean}
   */
  isUnknown() {
    return this.getType() === f0.NONSTANDARD;
  }
  /**
   * Test whether the script is standard by policy standards.
   * @returns {Boolean}
   */
  isStandard() {
    const [e, t] = this.getMultisig();
    return e !== -1 ? !(t < 1 || t > 3 || e < 1 || e > t) : this.isNulldata() ? this.raw.length <= Zd.MAX_OP_RETURN_BYTES : this.getType() !== f0.NONSTANDARD;
  }
  /**
   * Calculate the size of the script
   * excluding the varint size bytes.
   * @returns {Number}
   */
  getSize() {
    return this.raw.length;
  }
  /**
   * Calculate the size of the script
   * including the varint size bytes.
   * @returns {Number}
   */
  getVarSize() {
    return O_.sizeVarBytes(this.raw);
  }
  /**
   * "Guess" the address of the input script.
   * This method is not 100% reliable.
   * @returns {Address|null}
   */
  getInputAddress() {
    return Pc.fromInputScript(this);
  }
  /**
   * Get the address of the script if present. Note that
   * pubkey and multisig scripts will be treated as though
   * they are pubkeyhash and scripthashes respectively.
   * @returns {Address|null}
   */
  getAddress() {
    return Pc.fromScript(this);
  }
  /**
   * Get the hash160 of the raw script.
   * @param {String?} enc
   * @returns {Hash}
   */
  hash160(e) {
    let t = Xd.digest(this.toRaw());
    return e === "hex" && (t = t.toString("hex")), t;
  }
  /**
   * Get the sha256 of the raw script.
   * @param {String?} enc
   * @returns {Hash}
   */
  sha256(e) {
    let t = Jd.digest(this.toRaw());
    return e === "hex" && (t = t.toString("hex")), t;
  }
  /**
   * Test whether the output script is pay-to-pubkey.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Boolean}
   */
  isPubkey(e) {
    if (e)
      return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === pe.OP_CHECKSIG;
    if (this.code.length !== 2)
      return !1;
    const t = this.getLength(0);
    return (t === 33 || t === 65) && this.getOp(1) === pe.OP_CHECKSIG;
  }
  /**
   * Get P2PK key if present.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Buffer|null}
   */
  getPubkey(e) {
    return this.isPubkey(e) ? e ? this.raw.slice(1, 1 + this.raw[0]) : this.getData(0) : null;
  }
  /**
   * Test whether the output script is pay-to-pubkeyhash.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Boolean}
   */
  isPubkeyhash(e) {
    return e || this.raw.length === 25 ? this.raw.length === 25 && this.raw[0] === pe.OP_DUP && this.raw[1] === pe.OP_HASH160 && this.raw[2] === 20 && this.raw[23] === pe.OP_EQUALVERIFY && this.raw[24] === pe.OP_CHECKSIG : this.code.length !== 5 ? !1 : this.getOp(0) === pe.OP_DUP && this.getOp(1) === pe.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === pe.OP_EQUALVERIFY && this.getOp(4) === pe.OP_CHECKSIG;
  }
  /**
   * Get P2PKH hash if present.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Buffer|null}
   */
  getPubkeyhash(e) {
    return this.isPubkeyhash(e) ? e ? this.raw.slice(3, 23) : this.getData(2) : null;
  }
  /**
   * Test whether the output script is pay-to-multisig.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Boolean}
   */
  isMultisig(e) {
    if (this.code.length < 4 || this.code.length > 19 || this.getOp(-1) !== pe.OP_CHECKMULTISIG)
      return !1;
    const t = this.getSmall(0);
    if (t < 1)
      return !1;
    const i = this.getSmall(-2);
    if (i < 1 || t > i || this.code.length !== i + 3)
      return !1;
    for (let n = 1; n < i + 1; n++) {
      const c = this.code[n], o = c.toLength();
      if (o !== 33 && o !== 65 || e && !c.isMinimal())
        return !1;
    }
    return !0;
  }
  /**
   * Get multisig m and n values if present.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Array} [m, n]
   */
  getMultisig(e) {
    return this.isMultisig(e) ? [this.getSmall(0), this.getSmall(-2)] : [-1, -1];
  }
  /**
   * Test whether the output script is pay-to-scripthash. Note that
   * bitcoin itself requires scripthashes to be in strict minimaldata
   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
   * _not_ be recognized as a scripthash.
   * @returns {Boolean}
   */
  isScripthash() {
    return this.raw.length === 23 && this.raw[0] === pe.OP_HASH160 && this.raw[1] === 20 && this.raw[22] === pe.OP_EQUAL;
  }
  /**
   * Get P2SH hash if present.
   * @returns {Buffer|null}
   */
  getScripthash() {
    return this.isScripthash() ? this.getData(1) : null;
  }
  /**
   * Test whether the output script is nulldata/opreturn.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Boolean}
   */
  isNulldata(e) {
    if (this.code.length === 0 || this.getOp(0) !== pe.OP_RETURN)
      return !1;
    if (this.code.length === 1)
      return !0;
    if (e && this.raw.length > Zd.MAX_OP_RETURN_BYTES)
      return !1;
    for (let t = 1; t < this.code.length; t++) {
      const i = this.code[t];
      if (i.value === -1 || i.value > pe.OP_16 || e && !i.isMinimal())
        return !1;
    }
    return !0;
  }
  /**
   * Get OP_RETURN data if present.
   * @param {Boolean} [minimal=false] - Minimaldata only.
   * @returns {Buffer|null}
   */
  getNulldata(e) {
    if (!this.isNulldata(e))
      return null;
    for (let t = 1; t < this.code.length; t++) {
      const n = this.code[t].toPush();
      if (n)
        return n;
    }
    return Wd;
  }
  /**
   * Test whether the output script is a segregated witness
   * commitment.
   * @returns {Boolean}
   */
  isCommitment() {
    return this.raw.length >= 38 && this.raw[0] === pe.OP_RETURN && this.raw[1] === 36 && this.raw.readUInt32BE(2, !0) === 2854332909;
  }
  /**
   * Get the commitment hash if present.
   * @returns {Buffer|null}
   */
  getCommitment() {
    return this.isCommitment() ? this.raw.slice(6, 38) : null;
  }
  /**
   * Test whether the output script is a witness program.
   * Note that this will return true even for malformed
   * witness v0 programs.
   * @return {Boolean}
   */
  isProgram() {
    return !(this.raw.length < 4 || this.raw.length > 42 || this.raw[0] !== pe.OP_0 && (this.raw[0] < pe.OP_1 || this.raw[0] > pe.OP_16) || this.raw[1] + 2 !== this.raw.length);
  }
  /**
   * Get the witness program if present.
   * @returns {Program|null}
   */
  getProgram() {
    if (!this.isProgram())
      return null;
    const e = this.getSmall(0), t = this.getData(1);
    return new N_(e, t);
  }
  /**
   * Get the script to the equivalent witness
   * program (mimics bitcoind's scriptForWitness).
   * @returns {Script|null}
   */
  forWitness() {
    if (this.isProgram())
      return this.clone();
    const e = this.getPubkey();
    if (e) {
      const i = Xd.digest(e);
      return qt.fromProgram(0, i);
    }
    const t = this.getPubkeyhash();
    return t ? qt.fromProgram(0, t) : qt.fromProgram(0, this.sha256());
  }
  /**
   * Test whether the output script is
   * a pay-to-witness-pubkeyhash program.
   * @returns {Boolean}
   */
  isWitnessPubkeyhash() {
    return this.raw.length === 22 && this.raw[0] === pe.OP_0 && this.raw[1] === 20;
  }
  /**
   * Get P2WPKH hash if present.
   * @returns {Buffer|null}
   */
  getWitnessPubkeyhash() {
    return this.isWitnessPubkeyhash() ? this.getData(1) : null;
  }
  /**
   * Test whether the output script is
   * a pay-to-witness-scripthash program.
   * @returns {Boolean}
   */
  isWitnessScripthash() {
    return this.raw.length === 34 && this.raw[0] === pe.OP_0 && this.raw[1] === 32;
  }
  /**
   * Get P2WSH hash if present.
   * @returns {Buffer|null}
   */
  getWitnessScripthash() {
    return this.isWitnessScripthash() ? this.getData(1) : null;
  }
  /**
   * Test whether the output script is unspendable.
   * @returns {Boolean}
   */
  isUnspendable() {
    return this.raw.length > j0.MAX_SCRIPT_SIZE ? !0 : this.raw.length > 0 && this.raw[0] === pe.OP_RETURN;
  }
  /**
   * "Guess" the type of the input script.
   * This method is not 100% reliable.
   * @returns {ScriptType}
   */
  getInputType() {
    return this.isPubkeyInput() ? f0.PUBKEY : this.isPubkeyhashInput() ? f0.PUBKEYHASH : this.isScripthashInput() ? f0.SCRIPTHASH : this.isMultisigInput() ? f0.MULTISIG : f0.NONSTANDARD;
  }
  /**
   * "Guess" whether the input script is an unknown/non-standard type.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isUnknownInput() {
    return this.getInputType() === f0.NONSTANDARD;
  }
  /**
   * "Guess" whether the input script is pay-to-pubkey.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isPubkeyInput() {
    if (this.code.length !== 1)
      return !1;
    const e = this.getLength(0);
    return e >= 9 && e <= 73;
  }
  /**
   * Get P2PK signature if present.
   * @returns {Buffer|null}
   */
  getPubkeyInput() {
    return this.isPubkeyInput() ? this.getData(0) : null;
  }
  /**
   * "Guess" whether the input script is pay-to-pubkeyhash.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isPubkeyhashInput() {
    if (this.code.length !== 2)
      return !1;
    const e = this.getLength(0), t = this.getLength(1);
    return e >= 9 && e <= 73 && (t === 33 || t === 65);
  }
  /**
   * Get P2PKH signature and key if present.
   * @returns {Array} [sig, key]
   */
  getPubkeyhashInput() {
    return this.isPubkeyhashInput() ? [this.getData(0), this.getData(1)] : [null, null];
  }
  /**
   * "Guess" whether the input script is pay-to-multisig.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isMultisigInput() {
    if (this.code.length < 2 || this.getOp(0) !== pe.OP_0 || this.getOp(1) > pe.OP_PUSHDATA4 || this.isScripthashInput())
      return !1;
    for (let e = 1; e < this.code.length; e++) {
      const t = this.getLength(e);
      if (t < 9 || t > 73)
        return !1;
    }
    return !0;
  }
  /**
   * Get multisig signatures if present.
   * @returns {Buffer[]|null}
   */
  getMultisigInput() {
    if (!this.isMultisigInput())
      return null;
    const e = [];
    for (let t = 1; t < this.code.length; t++)
      e.push(this.getData(t));
    return e;
  }
  /**
   * "Guess" whether the input script is pay-to-scripthash.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isScripthashInput() {
    if (this.code.length < 1)
      return !1;
    const e = this.getData(-1);
    if (!e || e.length === 0 || u0.isSignatureEncoding(e) || u0.isKeyEncoding(e))
      return !1;
    const t = qt.fromRaw(e);
    return !(!t.isCode() || t.isUnspendable() || !this.isPushOnly());
  }
  /**
   * Get P2SH redeem script if present.
   * @returns {Buffer|null}
   */
  getScripthashInput() {
    return this.isScripthashInput() ? this.getData(-1) : null;
  }
  /**
   * Get coinbase height.
   * @returns {Number} `-1` if not present.
   */
  getCoinbaseHeight() {
    return qt.getCoinbaseHeight(this.raw);
  }
  /**
   * Get coinbase height.
   * @param {Buffer} raw - Raw script.
   * @returns {Number} `-1` if not present.
   */
  static getCoinbaseHeight(e) {
    if (e.length === 0)
      return -1;
    if (e[0] >= pe.OP_1 && e[0] <= pe.OP_16)
      return e[0] - 80;
    if (e[0] > 6)
      return -1;
    const t = rt.fromRaw(e), i = t.toNum();
    return i ? i.isNeg() || !t.equals(rt.fromNum(i)) ? -1 : i.toDouble() : 1;
  }
  /**
   * Test the script against a bloom filter.
   * @param {BloomFilter} filter
   * @returns {Boolean}
   */
  test(e) {
    for (const t of this.code) {
      if (t.value === -1)
        break;
      if (!(!t.data || t.data.length === 0) && e.test(t.data))
        return !0;
    }
    return !1;
  }
  /**
   * Test the script to see if it contains only push ops.
   * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
   * @returns {Boolean}
   */
  isPushOnly() {
    for (const e of this.code)
      if (e.value === -1 || e.value > pe.OP_16)
        return !1;
    return !0;
  }
  /**
   * Count the sigops in the script.
   * @param {Boolean} accurate - Whether to enable accurate counting. This will
   * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
   * @returns {Number} sigop count
   */
  getSigops(e) {
    let t = 0, i = -1;
    for (const n of this.code) {
      if (n.value === -1)
        break;
      switch (n.value) {
        case pe.OP_CHECKSIG:
        case pe.OP_CHECKSIGVERIFY:
          t += 1;
          break;
        case pe.OP_CHECKMULTISIG:
        case pe.OP_CHECKMULTISIGVERIFY:
          e && i >= pe.OP_1 && i <= pe.OP_16 ? t += i - 80 : t += j0.MAX_MULTISIG_PUBKEYS;
          break;
      }
      i = n.value;
    }
    return t;
  }
  /**
   * Count the sigops in the script, taking into account redeem scripts.
   * @param {Script} input - Input script, needed for access to redeem script.
   * @returns {Number} sigop count
   */
  getScripthashSigops(e) {
    if (!this.isScripthash())
      return this.getSigops(!0);
    const t = e.getRedeem();
    return t ? t.getSigops(!0) : 0;
  }
  /**
   * Count the sigops in a script, taking into account witness programs.
   * @param {Script} input
   * @param {Witness} witness
   * @returns {Number} sigop count
   */
  getWitnessSigops(e, t) {
    let i = this.getProgram();
    if (!i && this.isScripthash()) {
      const n = e.getRedeem();
      n && (i = n.getProgram());
    }
    if (!i)
      return 0;
    if (i.version === 0) {
      if (i.data.length === 20)
        return 1;
      if (i.data.length === 32 && t.items.length > 0)
        return t.getRedeem().getSigops(!0);
    }
    return 0;
  }
  /*
   * Mutation
   */
  get(e) {
    return e < 0 && (e += this.code.length), e < 0 || e >= this.code.length ? null : this.code[e];
  }
  pop() {
    return this.code.pop() || null;
  }
  shift() {
    return this.code.shift() || null;
  }
  remove(e) {
    if (e < 0 && (e += this.code.length), e < 0 || e >= this.code.length)
      return null;
    const t = this.code.splice(e, 1);
    return t.length === 0 ? null : t[0];
  }
  set(e, t) {
    return e < 0 && (e += this.code.length), kt(rt.isOpcode(t)), kt(e >= 0 && e <= this.code.length), this.code[e] = t, this;
  }
  push(e) {
    return kt(rt.isOpcode(e)), this.code.push(e), this;
  }
  unshift(e) {
    return kt(rt.isOpcode(e)), this.code.unshift(e), this;
  }
  insert(e, t) {
    return e < 0 && (e += this.code.length), kt(rt.isOpcode(t)), kt(e >= 0 && e <= this.code.length), this.code.splice(e, 0, t), this;
  }
  /*
   * Op
   */
  getOp(e) {
    const t = this.get(e);
    return t ? t.value : -1;
  }
  popOp() {
    const e = this.pop();
    return e ? e.value : -1;
  }
  shiftOp() {
    const e = this.shift();
    return e ? e.value : -1;
  }
  removeOp(e) {
    const t = this.remove(e);
    return t ? t.value : -1;
  }
  setOp(e, t) {
    return this.set(e, rt.fromOp(t));
  }
  pushOp(e) {
    return this.push(rt.fromOp(e));
  }
  unshiftOp(e) {
    return this.unshift(rt.fromOp(e));
  }
  insertOp(e, t) {
    return this.insert(e, rt.fromOp(t));
  }
  /*
   * Data
   */
  getData(e) {
    const t = this.get(e);
    return t ? t.data : null;
  }
  popData() {
    const e = this.pop();
    return e ? e.data : null;
  }
  shiftData() {
    const e = this.shift();
    return e ? e.data : null;
  }
  removeData(e) {
    const t = this.remove(e);
    return t ? t.data : null;
  }
  setData(e, t) {
    return this.set(e, rt.fromData(t));
  }
  pushData(e) {
    return this.push(rt.fromData(e));
  }
  unshiftData(e) {
    return this.unshift(rt.fromData(e));
  }
  insertData(e, t) {
    return this.insert(e, rt.fromData(t));
  }
  /*
   * Length
   */
  getLength(e) {
    const t = this.get(e);
    return t ? t.toLength() : -1;
  }
  /*
   * Push
   */
  getPush(e) {
    const t = this.get(e);
    return t ? t.toPush() : null;
  }
  popPush() {
    const e = this.pop();
    return e ? e.toPush() : null;
  }
  shiftPush() {
    const e = this.shift();
    return e ? e.toPush() : null;
  }
  removePush(e) {
    const t = this.remove(e);
    return t ? t.toPush() : null;
  }
  setPush(e, t) {
    return this.set(e, rt.fromPush(t));
  }
  pushPush(e) {
    return this.push(rt.fromPush(e));
  }
  unshiftPush(e) {
    return this.unshift(rt.fromPush(e));
  }
  insertPush(e, t) {
    return this.insert(e, rt.fromPush(t));
  }
  /*
   * String
   */
  getString(e, t) {
    const i = this.get(e);
    return i ? i.toString(t) : null;
  }
  popString(e) {
    const t = this.pop();
    return t ? t.toString(e) : null;
  }
  shiftString(e) {
    const t = this.shift();
    return t ? t.toString(e) : null;
  }
  removeString(e, t) {
    const i = this.remove(e);
    return i ? i.toString(t) : null;
  }
  setString(e, t, i) {
    return this.set(e, rt.fromString(t, i));
  }
  pushString(e, t) {
    return this.push(rt.fromString(e, t));
  }
  unshiftString(e, t) {
    return this.unshift(rt.fromString(e, t));
  }
  insertString(e, t, i) {
    return this.insert(e, rt.fromString(t, i));
  }
  /*
   * Small
   */
  getSmall(e) {
    const t = this.get(e);
    return t ? t.toSmall() : -1;
  }
  popSmall() {
    const e = this.pop();
    return e ? e.toSmall() : -1;
  }
  shiftSmall() {
    const e = this.shift();
    return e ? e.toSmall() : -1;
  }
  removeSmall(e) {
    const t = this.remove(e);
    return t ? t.toSmall() : -1;
  }
  setSmall(e, t) {
    return this.set(e, rt.fromSmall(t));
  }
  pushSmall(e) {
    return this.push(rt.fromSmall(e));
  }
  unshiftSmall(e) {
    return this.unshift(rt.fromSmall(e));
  }
  insertSmall(e, t) {
    return this.insert(e, rt.fromSmall(t));
  }
  /*
   * Num
   */
  getNum(e, t, i) {
    const n = this.get(e);
    return n ? n.toNum(t, i) : null;
  }
  popNum(e, t) {
    const i = this.pop();
    return i ? i.toNum(e, t) : null;
  }
  shiftNum(e, t) {
    const i = this.shift();
    return i ? i.toNum(e, t) : null;
  }
  removeNum(e, t, i) {
    const n = this.remove(e);
    return n ? n.toNum(t, i) : null;
  }
  setNum(e, t) {
    return this.set(e, rt.fromNum(t));
  }
  pushNum(e) {
    return this.push(rt.fromNum(e));
  }
  unshiftNum(e) {
    return this.unshift(rt.fromNum(e));
  }
  insertNum(e, t) {
    return this.insert(e, rt.fromNum(t));
  }
  /*
   * Int
   */
  getInt(e, t, i) {
    const n = this.get(e);
    return n ? n.toInt(t, i) : -1;
  }
  popInt(e, t) {
    const i = this.pop();
    return i ? i.toInt(e, t) : -1;
  }
  shiftInt(e, t) {
    const i = this.shift();
    return i ? i.toInt(e, t) : -1;
  }
  removeInt(e, t, i) {
    const n = this.remove(e);
    return n ? n.toInt(t, i) : -1;
  }
  setInt(e, t) {
    return this.set(e, rt.fromInt(t));
  }
  pushInt(e) {
    return this.push(rt.fromInt(e));
  }
  unshiftInt(e) {
    return this.unshift(rt.fromInt(e));
  }
  insertInt(e, t) {
    return this.insert(e, rt.fromInt(t));
  }
  /*
   * Bool
   */
  getBool(e) {
    const t = this.get(e);
    return t ? t.toBool() : !1;
  }
  popBool() {
    const e = this.pop();
    return e ? e.toBool() : !1;
  }
  shiftBool() {
    const e = this.shift();
    return e ? e.toBool() : !1;
  }
  removeBool(e) {
    const t = this.remove(e);
    return t ? t.toBool() : !1;
  }
  setBool(e, t) {
    return this.set(e, rt.fromBool(t));
  }
  pushBool(e) {
    return this.push(rt.fromBool(e));
  }
  unshiftBool(e) {
    return this.unshift(rt.fromBool(e));
  }
  insertBool(e, t) {
    return this.insert(e, rt.fromBool(t));
  }
  /*
   * Symbol
   */
  getSym(e) {
    const t = this.get(e);
    return t ? t.toSymbol() : null;
  }
  popSym() {
    const e = this.pop();
    return e ? e.toSymbol() : null;
  }
  shiftSym() {
    const e = this.shift();
    return e ? e.toSymbol() : null;
  }
  removeSym(e) {
    const t = this.remove(e);
    return t ? t.toSymbol() : null;
  }
  setSym(e, t) {
    return this.set(e, rt.fromSymbol(t));
  }
  pushSym(e) {
    return this.push(rt.fromSymbol(e));
  }
  unshiftSym(e) {
    return this.unshift(rt.fromSymbol(e));
  }
  insertSym(e, t) {
    return this.insert(e, rt.fromSymbol(t));
  }
  /**
   * Inject properties from bitcoind test string.
   * @private
   * @param {String} code - Script string.
   * @throws Parse error.
   */
  fromString(e) {
    if (kt(typeof e == "string"), e = e.trim(), e.length === 0)
      return this;
    const t = e.split(/\s+/), i = vf.write();
    for (const n of t) {
      let c = n;
      c.charCodeAt(0) & 32 && (c = c.toUpperCase()), /^OP_/.test(c) || (c = `OP_${c}`);
      const o = pe[c];
      if (o == null) {
        if (n[0] === "'") {
          kt(n[n.length - 1] === "'", "Invalid string.");
          const h = n.slice(1, -1), x = rt.fromString(h);
          i.writeBytes(x.toRaw());
          continue;
        }
        if (/^-?\d+$/.test(n)) {
          const h = _0.fromString(n, 10), x = rt.fromNum(h);
          i.writeBytes(x.toRaw());
          continue;
        }
        kt(n.indexOf("0x") === 0, "Unknown opcode.");
        const d = n.substring(2), l = Buffer.from(d, "hex");
        kt(l.length === d.length / 2, "Invalid hex string."), i.writeBytes(l);
        continue;
      }
      i.writeU8(o);
    }
    return this.fromRaw(i.render());
  }
  /**
   * Parse a bitcoind test script
   * string into a script object.
   * @param {String} code - Script string.
   * @returns {Script}
   * @throws Parse error.
   */
  static fromString(e) {
    return new this().fromString(e);
  }
  /**
   * Verify an input and output script, and a witness if present.
   * @param {Script} input
   * @param {Witness} witness
   * @param {Script} output
   * @param {TX} tx
   * @param {Number} index
   * @param {Amount} value
   * @param {VerifyFlags} flags
   * @throws {ScriptError}
   */
  static verify(e, t, i, n, c, o, d) {
    if (d == null && (d = qt.flags.STANDARD_VERIFY_FLAGS), d & qt.flags.VERIFY_SIGPUSHONLY && !e.isPushOnly())
      throw new qe("SIG_PUSHONLY");
    let l = new C4();
    e.execute(l, d, n, c, o, 0);
    let h;
    if (d & qt.flags.VERIFY_P2SH && (h = l.clone()), i.execute(l, d, n, c, o, 0), l.length === 0 || !l.getBool(-1))
      throw new qe("EVAL_FALSE");
    let x = !1;
    if (d & qt.flags.VERIFY_WITNESS && i.isProgram()) {
      if (x = !0, e.raw.length !== 0)
        throw new qe("WITNESS_MALLEATED");
      qt.verifyProgram(t, i, d, n, c, o), l.length = 1;
    }
    if (d & qt.flags.VERIFY_P2SH && i.isScripthash()) {
      if (!e.isPushOnly())
        throw new qe("SIG_PUSHONLY");
      if (l = h, l.length === 0)
        throw new qe("EVAL_FALSE");
      const b = l.pop(), g = qt.fromRaw(b);
      if (g.execute(l, d, n, c, o, 0), l.length === 0 || !l.getBool(-1))
        throw new qe("EVAL_FALSE");
      if (d & qt.flags.VERIFY_WITNESS && g.isProgram()) {
        if (x = !0, !e.raw.equals(rt.fromPush(b).toRaw()))
          throw new qe("WITNESS_MALLEATED_P2SH");
        qt.verifyProgram(t, g, d, n, c, o), l.length = 1;
      }
    }
    if (d & qt.flags.VERIFY_CLEANSTACK && (kt((d & qt.flags.VERIFY_P2SH) !== 0), l.length !== 1))
      throw new qe("CLEANSTACK");
    if (d & qt.flags.VERIFY_WITNESS && (kt((d & qt.flags.VERIFY_P2SH) !== 0), !x && t.items.length > 0))
      throw new qe("WITNESS_UNEXPECTED");
  }
  /**
   * Verify a witness program. This runs after regular script
   * execution if a witness program is present. It will convert
   * the witness to a stack and execute the program.
   * @param {Witness} witness
   * @param {Script} output
   * @param {VerifyFlags} flags
   * @param {TX} tx
   * @param {Number} index
   * @param {Amount} value
   * @throws {ScriptError}
   */
  static verifyProgram(e, t, i, n, c, o) {
    const d = t.getProgram();
    kt(d, "verifyProgram called on non-witness-program."), kt((i & qt.flags.VERIFY_WITNESS) !== 0);
    const l = e.toStack();
    let h;
    if (d.version === 0)
      if (d.data.length === 32) {
        if (l.length === 0)
          throw new qe("WITNESS_PROGRAM_WITNESS_EMPTY");
        const x = l.pop();
        if (!Jd.digest(x).equals(d.data))
          throw new qe("WITNESS_PROGRAM_MISMATCH");
        h = qt.fromRaw(x);
      } else if (d.data.length === 20) {
        if (l.length !== 2)
          throw new qe("WITNESS_PROGRAM_MISMATCH");
        h = qt.fromPubkeyhash(d.data);
      } else
        throw new qe("WITNESS_PROGRAM_WRONG_LENGTH");
    else {
      if (i & qt.flags.VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)
        throw new qe("DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM");
      return;
    }
    for (let x = 0; x < l.length; x++)
      if (l.get(x).length > j0.MAX_SCRIPT_PUSH)
        throw new qe("PUSH_SIZE");
    if (h.execute(l, i, n, c, o, 1), l.length !== 1)
      throw new qe("CLEANSTACK");
    if (!l.getBool(-1))
      throw new qe("EVAL_FALSE");
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    return this.fromRaw(e.readVarBytes());
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    const t = vf.read(e);
    for (this.raw = e; t.left(); )
      this.code.push(rt.fromReader(t));
    return this;
  }
  /**
   * Create a script from buffer reader.
   * @param {BufferReader} br
   * @returns {Script}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Create a script from a serialized buffer.
   * @param {Buffer|String} data - Serialized script.
   * @param {String?} enc - Either `"hex"` or `null`.
   * @returns {Script}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Test whether an object a Script.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isScript(e) {
    return e instanceof qt;
  }
};
S0.opcodes = u0.opcodes;
S0.opcodesByVal = u0.opcodesByVal;
S0.flags = u0.flags;
S0.hashType = u0.hashType;
S0.hashTypeByVal = u0.hashTypeByVal;
S0.types = u0.types;
S0.typesByVal = u0.typesByVal;
function k_(r) {
  return r.slice().sort((e, t) => e.compare(t));
}
function D4(r, e, t) {
  if (kt(Buffer.isBuffer(r)), kt(typeof e == "number"), kt(typeof t == "number"), e & S0.flags.VERIFY_STRICTENC && !u0.isKeyEncoding(r))
    throw new qe("PUBKEYTYPE");
  if (t === 1 && e & S0.flags.VERIFY_WITNESS_PUBKEYTYPE && !u0.isCompressedEncoding(r))
    throw new qe("WITNESS_PUBKEYTYPE");
  return !0;
}
function L4(r, e) {
  if (kt(Buffer.isBuffer(r)), kt(typeof e == "number"), r.length === 0)
    return !0;
  if ((e & S0.flags.VERIFY_DERSIG || e & S0.flags.VERIFY_LOW_S || e & S0.flags.VERIFY_STRICTENC) && !u0.isSignatureEncoding(r))
    throw new qe("SIG_DER");
  if (e & S0.flags.VERIFY_LOW_S && !u0.isLowDER(r))
    throw new qe("SIG_HIGH_S");
  if (e & S0.flags.VERIFY_STRICTENC && !u0.isHashType(r))
    throw new qe("SIG_HASHTYPE");
  return !0;
}
function K4(r, e, t) {
  return M_.verifyDER(r, e.slice(0, -1), t);
}
var dc = S0;
/*!
 * witness.js - witness object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Sf = Ar, L1 = Me, q_ = dc, K1 = Qn, z_ = ga, $4 = i2, { encoding: H4 } = L1, Rc = K1.types, { inspectSymbol: U_ } = Gr;
let C_ = class Mp extends $4 {
  /**
   * Create a witness.
   * @alias module:script.Witness
   * @constructor
   * @param {Buffer[]|Object} options - Array of
   * stack items.
   * @property {Buffer[]} items
   * @property {Script?} redeem
   * @property {Number} length
   */
  constructor(e) {
    super(), e && this.fromOptions(e);
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    return Sf(e, "Witness data is required."), Array.isArray(e) ? this.fromArray(e) : e.items ? this.fromArray(e.items) : this;
  }
  /**
   * Instantiate witness from options.
   * @param {Object} options
   * @returns {Witness}
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Convert witness to an array of buffers.
   * @returns {Buffer[]}
   */
  toArray() {
    return this.items.slice();
  }
  /**
   * Inject properties from an array of buffers.
   * @private
   * @param {Buffer[]} items
   */
  fromArray(e) {
    return Sf(Array.isArray(e)), this.items = e, this;
  }
  /**
   * Insantiate witness from an array of buffers.
   * @param {Buffer[]} items
   * @returns {Witness}
   */
  static fromArray(e) {
    return new this().fromArray(e);
  }
  /**
   * Convert witness to an array of buffers.
   * @returns {Buffer[]}
   */
  toItems() {
    return this.items.slice();
  }
  /**
   * Inject properties from an array of buffers.
   * @private
   * @param {Buffer[]} items
   */
  fromItems(e) {
    return Sf(Array.isArray(e)), this.items = e, this;
  }
  /**
   * Insantiate witness from an array of buffers.
   * @param {Buffer[]} items
   * @returns {Witness}
   */
  static fromItems(e) {
    return new this().fromItems(e);
  }
  /**
   * Convert witness to a stack.
   * @returns {Stack}
   */
  toStack() {
    return new $4(this.toArray());
  }
  /**
   * Inject properties from a stack.
   * @private
   * @param {Stack} stack
   */
  fromStack(e) {
    return this.fromArray(e.items);
  }
  /**
   * Insantiate witness from a stack.
   * @param {Stack} stack
   * @returns {Witness}
   */
  static fromStack(e) {
    return new this().fromStack(e);
  }
  /**
   * Inspect a Witness object.
   * @returns {String} Human-readable script.
   */
  [U_]() {
    return `<Witness: ${this.toString()}>`;
  }
  /**
   * Clone the witness object.
   * @returns {Witness} A clone of the current witness object.
   */
  clone() {
    return new this.constructor().inject(this);
  }
  /**
   * Inject properties from witness.
   * Used for cloning.
   * @private
   * @param {Witness} witness
   * @returns {Witness}
   */
  inject(e) {
    return this.items = e.items.slice(), this;
  }
  /**
   * Compile witness (NOP).
   * @returns {Witness}
   */
  compile() {
    return this;
  }
  /**
   * "Guess" the type of the witness.
   * This method is not 100% reliable.
   * @returns {ScriptType}
   */
  getInputType() {
    return this.isPubkeyhashInput() ? Rc.WITNESSPUBKEYHASH : this.isScripthashInput() ? Rc.WITNESSSCRIPTHASH : Rc.NONSTANDARD;
  }
  /**
   * "Guess" the address of the witness.
   * This method is not 100% reliable.
   * @returns {Address|null}
   */
  getInputAddress() {
    return z_.fromWitness(this);
  }
  /**
   * "Test" whether the witness is a pubkey input.
   * Always returns false.
   * @returns {Boolean}
   */
  isPubkeyInput() {
    return !1;
  }
  /**
   * Get P2PK signature if present.
   * Always returns null.
   * @returns {Buffer|null}
   */
  getPubkeyInput() {
    return null;
  }
  /**
   * "Guess" whether the witness is a pubkeyhash input.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isPubkeyhashInput() {
    return this.items.length === 2 && K1.isSignatureEncoding(this.items[0]) && K1.isKeyEncoding(this.items[1]);
  }
  /**
   * Get P2PKH signature and key if present.
   * @returns {Array} [sig, key]
   */
  getPubkeyhashInput() {
    return this.isPubkeyhashInput() ? [this.items[0], this.items[1]] : [null, null];
  }
  /**
   * "Test" whether the witness is a multisig input.
   * Always returns false.
   * @returns {Boolean}
   */
  isMultisigInput() {
    return !1;
  }
  /**
   * Get multisig signatures key if present.
   * Always returns null.
   * @returns {Buffer[]|null}
   */
  getMultisigInput() {
    return null;
  }
  /**
   * "Guess" whether the witness is a scripthash input.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isScripthashInput() {
    return this.items.length > 0 && !this.isPubkeyhashInput();
  }
  /**
   * Get P2SH redeem script if present.
   * @returns {Buffer|null}
   */
  getScripthashInput() {
    return this.isScripthashInput() ? this.items[this.items.length - 1] : null;
  }
  /**
   * "Guess" whether the witness is an unknown/non-standard type.
   * This method is not 100% reliable.
   * @returns {Boolean}
   */
  isUnknownInput() {
    return this.getInputType() === Rc.NONSTANDARD;
  }
  /**
   * Test the witness against a bloom filter.
   * @param {BloomFilter} filter
   * @returns {Boolean}
   */
  test(e) {
    for (const t of this.items)
      if (t.length !== 0 && e.test(t))
        return !0;
    return !1;
  }
  /**
   * Grab and deserialize the redeem script from the witness.
   * @returns {Script} Redeem script.
   */
  getRedeem() {
    if (this.items.length === 0)
      return null;
    const e = this.items[this.items.length - 1];
    return e ? q_.fromRaw(e) : null;
  }
  /**
   * Find a data element in a witness.
   * @param {Buffer} data - Data element to match against.
   * @returns {Number} Index (`-1` if not present).
   */
  indexOf(e) {
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].equals(e))
        return t;
    return -1;
  }
  /**
   * Calculate size of the witness
   * excluding the varint size bytes.
   * @returns {Number}
   */
  getSize() {
    let e = 0;
    for (const t of this.items)
      e += H4.sizeVarBytes(t);
    return e;
  }
  /**
   * Calculate size of the witness
   * including the varint size bytes.
   * @returns {Number}
   */
  getVarSize() {
    return H4.sizeVarint(this.items.length) + this.getSize();
  }
  /**
   * Write witness to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    e.writeVarint(this.items.length);
    for (const t of this.items)
      e.writeVarBytes(t);
    return e;
  }
  /**
   * Encode the witness to a Buffer.
   * @returns {Buffer|String} Serialized script.
   */
  toRaw() {
    const e = this.getVarSize();
    return this.toWriter(L1.write(e)).render();
  }
  /**
   * Convert witness to a hex string.
   * @returns {String}
   */
  toJSON() {
    return this.toRaw().toString("hex");
  }
  /**
   * Inject properties from json object.
   * @private
   * @param {String} json
   */
  fromJSON(e) {
    return Sf(typeof e == "string", "Witness must be a string."), this.fromRaw(Buffer.from(e, "hex"));
  }
  /**
   * Insantiate witness from a hex string.
   * @param {String} json
   * @returns {Witness}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    const t = e.readVarint();
    for (let i = 0; i < t; i++)
      this.items.push(e.readVarBytes());
    return this;
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(L1.read(e));
  }
  /**
   * Create a witness from a buffer reader.
   * @param {BufferReader} br
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Create a witness from a serialized buffer.
   * @param {Buffer|String} data - Serialized witness.
   * @param {String?} enc - Either `"hex"` or `null`.
   * @returns {Witness}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Inject items from string.
   * @private
   * @param {String|String[]} items
   */
  fromString(e) {
    if (!Array.isArray(e)) {
      if (Sf(typeof e == "string"), e = e.trim(), e.length === 0)
        return this;
      e = e.split(/\s+/);
    }
    for (const t of e)
      this.items.push(Buffer.from(t, "hex"));
    return this;
  }
  /**
   * Parse a test script/array
   * string into a witness object. _Must_
   * contain only stack items (no non-push
   * opcodes).
   * @param {String|String[]} items - Script string.
   * @returns {Witness}
   * @throws Parse error.
   */
  static fromString(e) {
    return new this().fromString(e);
  }
  /**
   * Test an object to see if it is a Witness.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isWitness(e) {
    return e instanceof Mp;
  }
};
var T_ = C_;
/*!
 * outpoint.js - outpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const $0 = Ar, jd = Me, Qd = Os, F4 = ri, { inspectSymbol: D_ } = Gr;
let L_ = class Ef {
  /**
   * Create an outpoint.
   * @constructor
   * @param {Hash?} hash
   * @param {Number?} index
   */
  constructor(e, t) {
    this.hash = F4.ZERO_HASH, this.index = 4294967295, e != null && ($0(Buffer.isBuffer(e)), $0(t >>> 0 === t, "Index must be a uint32."), this.hash = e, this.index = t);
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    return $0(e, "Outpoint data is required."), $0(Buffer.isBuffer(e.hash)), $0(e.index >>> 0 === e.index, "Index must be a uint32."), this.hash = e.hash, this.index = e.index, this;
  }
  /**
   * Instantate outpoint from options object.
   * @param {Object} options
   * @returns {Outpoint}
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Clone the outpoint.
   * @returns {Outpoint}
   */
  clone() {
    const e = new this.constructor();
    return e.hash = this.hash, e.index = this.index, e;
  }
  /**
   * Test equality against another outpoint.
   * @param {Outpoint} prevout
   * @returns {Boolean}
   */
  equals(e) {
    return $0(Ef.isOutpoint(e)), this.hash.equals(e.hash) && this.index === e.index;
  }
  /**
   * Compare against another outpoint (BIP69).
   * @param {Outpoint} prevout
   * @returns {Number}
   */
  compare(e) {
    $0(Ef.isOutpoint(e));
    const t = K_(this.txid(), e.txid());
    return t !== 0 ? t : this.index - e.index;
  }
  /**
   * Test whether the outpoint is null (hash of zeroes
   * with max-u32 index). Used to detect coinbases.
   * @returns {Boolean}
   */
  isNull() {
    return this.index === 4294967295 && this.hash.equals(F4.ZERO_HASH);
  }
  /**
   * Get little-endian hash.
   * @returns {Hash}
   */
  rhash() {
    return Qd.revHex(this.hash);
  }
  /**
   * Get little-endian hash.
   * @returns {Hash}
   */
  txid() {
    return this.rhash();
  }
  /**
   * Serialize outpoint to a key
   * suitable for a hash table.
   * @returns {String}
   */
  toKey() {
    return this.toRaw();
  }
  /**
   * Inject properties from hash table key.
   * @private
   * @param {String} key
   * @returns {Outpoint}
   */
  fromKey(e) {
    return this.hash = e.slice(0, 32), this.index = jd.readU32(e, 32), this;
  }
  /**
   * Instantiate outpoint from hash table key.
   * @param {String} key
   * @returns {Outpoint}
   */
  static fromKey(e) {
    return new this().fromKey(e);
  }
  /**
   * Write outpoint to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    return e.writeHash(this.hash), e.writeU32(this.index), e;
  }
  /**
   * Calculate size of outpoint.
   * @returns {Number}
   */
  getSize() {
    return 36;
  }
  /**
   * Serialize outpoint.
   * @returns {Buffer}
   */
  toRaw() {
    return this.toWriter(jd.write(36)).render();
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    return this.hash = e.readHash(), this.index = e.readU32(), this;
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(jd.read(e));
  }
  /**
   * Instantiate outpoint from a buffer reader.
   * @param {BufferReader} br
   * @returns {Outpoint}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Instantiate outpoint from serialized data.
   * @param {Buffer} data
   * @returns {Outpoint}
   */
  static fromRaw(e) {
    return new this().fromRaw(e);
  }
  /**
   * Inject properties from json object.
   * @private
   * @params {Object} json
   */
  fromJSON(e) {
    return $0(e, "Outpoint data is required."), $0(typeof e.hash == "string", "Hash must be a string."), $0(e.index >>> 0 === e.index, "Index must be a uint32."), this.hash = Qd.fromRev(e.hash), this.index = e.index, this;
  }
  /**
   * Convert the outpoint to an object suitable
   * for JSON serialization. Note that the hash
   * will be reversed to abide by bitcoind's legacy
   * of little-endian uint256s.
   * @returns {Object}
   */
  toJSON() {
    return {
      hash: Qd.revHex(this.hash),
      index: this.index
    };
  }
  /**
   * Instantiate outpoint from json object.
   * @param {Object} json
   * @returns {Outpoint}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Inject properties from tx.
   * @private
   * @param {TX} tx
   * @param {Number} index
   */
  fromTX(e, t) {
    return $0(e), $0(typeof t == "number"), $0(t >= 0), this.hash = e.hash(), this.index = t, this;
  }
  /**
   * Instantiate outpoint from tx.
   * @param {TX} tx
   * @param {Number} index
   * @returns {Outpoint}
   */
  static fromTX(e, t) {
    return new this().fromTX(e, t);
  }
  /**
   * Serialize outpoint to a key
   * suitable for a hash table.
   * @param {Hash} hash
   * @param {Number} index
   * @returns {String}
   */
  static toKey(e, t) {
    return new Ef(e, t).toKey();
  }
  /**
   * Convert the outpoint to a user-friendly string.
   * @returns {String}
   */
  [D_]() {
    return `<Outpoint: ${this.rhash()}/${this.index}>`;
  }
  /**
   * Test an object to see if it is an outpoint.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isOutpoint(e) {
    return e instanceof Ef;
  }
};
function K_(r, e) {
  const t = Math.min(r.length, e.length);
  for (let i = 0; i < t; i++) {
    if (r[i] < e[i])
      return -1;
    if (r[i] > e[i])
      return 1;
  }
  return r.length < e.length ? -1 : r.length > e.length ? 1 : 0;
}
var ef = L_;
/*!
 * input.js - input object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const H0 = Ar, V4 = Me, $_ = oc, eu = dc, H_ = T_, F_ = ef, { inspectSymbol: V_ } = Gr;
let G_ = class Jc {
  /**
   * Create transaction input.
   * @constructor
   * @param {Object} options
   */
  constructor(e) {
    this.prevout = new F_(), this.script = new eu(), this.sequence = 4294967295, this.witness = new H_(), e && this.fromOptions(e);
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    return H0(e, "Input data is required."), this.prevout.fromOptions(e.prevout), e.script && this.script.fromOptions(e.script), e.sequence != null && (H0(e.sequence >>> 0 === e.sequence, "Sequence must be a uint32."), this.sequence = e.sequence), e.witness && this.witness.fromOptions(e.witness), this;
  }
  /**
   * Instantiate an Input from options object.
   * @param {Object} options
   * @returns {Input}
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Clone the input.
   * @returns {Input}
   */
  clone() {
    const e = new this.constructor();
    return e.prevout = this.prevout, e.script.inject(this.script), e.sequence = this.sequence, e.witness.inject(this.witness), e;
  }
  /**
   * Test equality against another input.
   * @param {Input} input
   * @returns {Boolean}
   */
  equals(e) {
    return H0(Jc.isInput(e)), this.prevout.equals(e.prevout);
  }
  /**
   * Compare against another input (BIP69).
   * @param {Input} input
   * @returns {Number}
   */
  compare(e) {
    return H0(Jc.isInput(e)), this.prevout.compare(e.prevout);
  }
  /**
   * Get the previous output script type as a string.
   * Will "guess" based on the input script and/or
   * witness if coin is not available.
   * @param {Coin?} coin
   * @returns {ScriptType} type
   */
  getType(e) {
    if (this.isCoinbase())
      return "coinbase";
    if (e)
      return e.getType();
    let t;
    return this.witness.items.length > 0 ? t = this.witness.getInputType() : t = this.script.getInputType(), eu.typesByVal[t].toLowerCase();
  }
  /**
   * Get the redeem script. Will attempt to resolve nested
   * redeem scripts if witnessscripthash is behind a scripthash.
   * @param {Coin?} coin
   * @returns {Script|null} Redeem script.
   */
  getRedeem(e) {
    if (this.isCoinbase())
      return null;
    if (!e)
      return this.witness.isScripthashInput() ? this.witness.getRedeem() : this.script.isScripthashInput() ? this.script.getRedeem() : null;
    let t = e.script, i = null;
    return t.isScripthash() && (t = this.script.getRedeem(), i = t), t && t.isWitnessScripthash() && (t = this.witness.getRedeem(), i = t), i;
  }
  /**
   * Get the redeem script type.
   * @param {Coin?} coin
   * @returns {String} subtype
   */
  getSubtype(e) {
    if (this.isCoinbase())
      return null;
    const t = this.getRedeem(e);
    if (!t)
      return null;
    const i = t.getType();
    return eu.typesByVal[i].toLowerCase();
  }
  /**
   * Get the previous output script's address. Will "guess"
   * based on the input script and/or witness if coin
   * is not available.
   * @param {Coin?} coin
   * @returns {Address|null} addr
   */
  getAddress(e) {
    return this.isCoinbase() ? null : e ? e.getAddress() : this.script.code.length > 0 ? this.script.getInputAddress() : this.witness.items.length > 0 ? this.witness.getInputAddress() : null;
  }
  /**
   * Get the address hash.
   * @param {Coin?} coin
   * @param {String?} enc
   * @returns {Hash} hash
   */
  getHash(e, t) {
    const i = this.getAddress(e);
    return i ? i.getHash(t) : null;
  }
  /**
   * Test to see if nSequence is equal to uint32max.
   * @returns {Boolean}
   */
  isFinal() {
    return this.sequence === 4294967295;
  }
  /**
   * Test to see if nSequence is less than 0xfffffffe.
   * @returns {Boolean}
   */
  isRBF() {
    return this.sequence < 4294967294;
  }
  /**
   * Test to see if outpoint is null.
   * @returns {Boolean}
   */
  isCoinbase() {
    return this.prevout.isNull();
  }
  /**
   * Convert the input to a more user-friendly object.
   * @returns {Object}
   */
  [V_]() {
    return this.format();
  }
  /**
   * Convert the input to a more user-friendly object.
   * @param {Coin?} coin
   * @returns {Object}
   */
  format(e) {
    return {
      type: this.getType(e),
      subtype: this.getSubtype(e),
      address: this.getAddress(e),
      script: this.script,
      witness: this.witness,
      redeem: this.getRedeem(e),
      sequence: this.sequence,
      prevout: this.prevout,
      coin: e || null
    };
  }
  /**
   * Convert the input to an object suitable
   * for JSON serialization.
   * @returns {Object}
   */
  toJSON(e, t) {
    return this.getJSON(e, t);
  }
  /**
   * Convert the input to an object suitable
   * for JSON serialization. Note that the hashes
   * will be reversed to abide by bitcoind's legacy
   * of little-endian uint256s.
   * @param {Network} network
   * @param {Coin} coin
   * @returns {Object}
   */
  getJSON(e, t) {
    e = $_.get(e);
    let i;
    return t || (i = this.getAddress(), i && (i = i.toString(e))), {
      prevout: this.prevout.toJSON(),
      script: this.script.toJSON(),
      witness: this.witness.toJSON(),
      sequence: this.sequence,
      address: i,
      coin: t ? t.getJSON(e, !0) : void 0
    };
  }
  /**
   * Inject properties from a JSON object.
   * @private
   * @param {Object} json
   */
  fromJSON(e) {
    return H0(e, "Input data is required."), H0(e.sequence >>> 0 === e.sequence, "Sequence must be a uint32."), this.prevout.fromJSON(e.prevout), this.script.fromJSON(e.script), this.witness.fromJSON(e.witness), this.sequence = e.sequence, this;
  }
  /**
   * Instantiate an Input from a jsonified input object.
   * @param {Object} json - The jsonified input object.
   * @returns {Input}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Calculate size of serialized input.
   * @returns {Number}
   */
  getSize() {
    return 40 + this.script.getVarSize();
  }
  /**
   * Serialize the input.
   * @returns {Buffer|String}
   */
  toRaw() {
    const e = this.getSize();
    return this.toWriter(V4.write(e)).render();
  }
  /**
   * Write the input to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    return this.prevout.toWriter(e), e.writeVarBytes(this.script.toRaw()), e.writeU32(this.sequence), e;
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    return this.prevout.fromReader(e), this.script.fromRaw(e.readVarBytes()), this.sequence = e.readU32(), this;
  }
  /**
   * Inject properties from serialized data.
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(V4.read(e));
  }
  /**
   * Instantiate an input from a buffer reader.
   * @param {BufferReader} br
   * @returns {Input}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Instantiate an input from a serialized Buffer.
   * @param {Buffer} data
   * @param {String?} enc - Encoding, can be `'hex'` or null.
   * @returns {Input}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Inject properties from outpoint.
   * @private
   * @param {Outpoint} outpoint
   */
  fromOutpoint(e) {
    return H0(Buffer.isBuffer(e.hash)), H0(typeof e.index == "number"), this.prevout.hash = e.hash, this.prevout.index = e.index, this;
  }
  /**
   * Instantiate input from outpoint.
   * @param {Outpoint} outpoint
   * @returns {Input}
   */
  static fromOutpoint(e) {
    return new this().fromOutpoint(e);
  }
  /**
   * Inject properties from coin.
   * @private
   * @param {Coin} coin
   */
  fromCoin(e) {
    return H0(Buffer.isBuffer(e.hash)), H0(typeof e.index == "number"), this.prevout.hash = e.hash, this.prevout.index = e.index, this;
  }
  /**
   * Instantiate input from coin.
   * @param {Coin} coin
   * @returns {Input}
   */
  static fromCoin(e) {
    return new this().fromCoin(e);
  }
  /**
   * Inject properties from transaction.
   * @private
   * @param {TX} tx
   * @param {Number} index
   */
  fromTX(e, t) {
    return H0(e), H0(typeof t == "number"), H0(t >= 0 && t < e.outputs.length), this.prevout.hash = e.hash(), this.prevout.index = t, this;
  }
  /**
   * Instantiate input from tx.
   * @param {TX} tx
   * @param {Number} index
   * @returns {Input}
   */
  static fromTX(e, t) {
    return new this().fromTX(e, t);
  }
  /**
   * Test an object to see if it is an Input.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isInput(e) {
    return e instanceof Jc;
  }
};
var Np = G_;
/*!
 * output.js - output object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const ps = Ar, G4 = Me, Y_ = wa, J_ = oc, Y4 = ga, kc = dc, X_ = ri, Z_ = jn, { inspectSymbol: W_ } = Gr;
let j_ = class Xc {
  /**
   * Create an output.
   * @constructor
   * @param {Object?} options
   */
  constructor(e) {
    this.value = 0, this.script = new kc(), e && this.fromOptions(e);
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    return ps(e, "Output data is required."), e.value && (ps(Number.isSafeInteger(e.value) && e.value >= 0, "Value must be a safe integer."), this.value = e.value), e.script && this.script.fromOptions(e.script), e.address && this.script.fromAddress(e.address), this;
  }
  /**
   * Instantiate output from options object.
   * @param {Object} options
   * @returns {Output}
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Inject properties from script/value pair.
   * @private
   * @param {Script|Address} script
   * @param {Amount} value
   * @returns {Output}
   */
  fromScript(e, t) {
    return typeof e == "string" && (e = Y4.fromString(e)), e instanceof Y4 && (e = kc.fromAddress(e)), ps(e instanceof kc, "Script must be a Script."), ps(Number.isSafeInteger(t) && t >= 0, "Value must be a safe integer."), this.script = e, this.value = t, this;
  }
  /**
   * Instantiate output from script/value pair.
   * @param {Script|Address} script
   * @param {Amount} value
   * @returns {Output}
   */
  static fromScript(e, t) {
    return new this().fromScript(e, t);
  }
  /**
   * Clone the output.
   * @returns {Output}
   */
  clone() {
    const e = new this.constructor();
    return e.value = this.value, e.script.inject(this.script), e;
  }
  /**
   * Test equality against another output.
   * @param {Output} output
   * @returns {Boolean}
   */
  equals(e) {
    return ps(Xc.isOutput(e)), this.value === e.value && this.script.equals(e.script);
  }
  /**
   * Compare against another output (BIP69).
   * @param {Output} output
   * @returns {Number}
   */
  compare(e) {
    ps(Xc.isOutput(e));
    const t = this.value - e.value;
    return t !== 0 ? t : this.script.compare(e.script);
  }
  /**
   * Get the script type as a string.
   * @returns {ScriptType} type
   */
  getType() {
    return kc.typesByVal[this.script.getType()].toLowerCase();
  }
  /**
   * Get the address.
   * @returns {Address} address
   */
  getAddress() {
    return this.script.getAddress();
  }
  /**
   * Get the address hash.
   * @param {String?} enc
   * @returns {Hash} hash
   */
  getHash(e) {
    const t = this.getAddress();
    return t ? t.getHash(e) : null;
  }
  /**
   * Convert the input to a more user-friendly object.
   * @returns {Object}
   */
  [W_]() {
    return {
      type: this.getType(),
      value: Y_.btc(this.value),
      script: this.script,
      address: this.getAddress()
    };
  }
  /**
   * Convert the output to an object suitable
   * for JSON serialization.
   * @returns {Object}
   */
  toJSON() {
    return this.getJSON();
  }
  /**
   * Convert the output to an object suitable
   * for JSON serialization.
   * @param {Network} network
   * @returns {Object}
   */
  getJSON(e) {
    let t = this.getAddress();
    return e = J_.get(e), t && (t = t.toString(e)), {
      value: this.value,
      script: this.script.toJSON(),
      address: t
    };
  }
  /**
   * Calculate the dust threshold for this
   * output, based on serialize size and rate.
   * @param {Rate?} rate
   * @returns {Amount}
   */
  getDustThreshold(e) {
    const t = X_.WITNESS_SCALE_FACTOR;
    if (this.script.isUnspendable())
      return 0;
    let i = this.getSize();
    return this.script.isProgram() ? i += 32 + 4 + 1 + (107 / t | 0) + 4 : i += 32 + 4 + 1 + 107 + 4, 3 * Z_.getMinFee(i, e);
  }
  /**
   * Calculate size of serialized output.
   * @returns {Number}
   */
  getSize() {
    return 8 + this.script.getVarSize();
  }
  /**
   * Test whether the output should be considered dust.
   * @param {Rate?} rate
   * @returns {Boolean}
   */
  isDust(e) {
    return this.value < this.getDustThreshold(e);
  }
  /**
   * Inject properties from a JSON object.
   * @private
   * @param {Object} json
   */
  fromJSON(e) {
    return ps(e, "Output data is required."), ps(Number.isSafeInteger(e.value) && e.value >= 0, "Value must be a uint64."), this.value = e.value, this.script.fromJSON(e.script), this;
  }
  /**
   * Instantiate an Output from a jsonified output object.
   * @param {Object} json - The jsonified output object.
   * @returns {Output}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Write the output to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    return e.writeI64(this.value), e.writeVarBytes(this.script.toRaw()), e;
  }
  /**
   * Serialize the output.
   * @returns {Buffer|String}
   */
  toRaw() {
    const e = this.getSize();
    return this.toWriter(G4.write(e)).render();
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    return this.value = e.readI64(), this.script.fromRaw(e.readVarBytes()), this;
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(G4.read(e));
  }
  /**
   * Instantiate an output from a buffer reader.
   * @param {BufferReader} br
   * @returns {Output}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Instantiate an output from a serialized Buffer.
   * @param {Buffer} data
   * @param {String?} enc - Encoding, can be `'hex'` or null.
   * @returns {Output}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Test an object to see if it is an Output.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isOutput(e) {
    return e instanceof Xc;
  }
};
var uc = j_;
/*!
 * tx.js - transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const ar = Ar, zi = Me, ms = jo, J4 = cc, { BufferSet: qc } = ac, Ds = Os, zc = wa, Q_ = oc, Gs = dc, Uc = Np, Cc = uc, X4 = ef, Z4 = HE, Ur = ri, p0 = jn, tu = t2, { encoding: Ls } = zi, { hashType: jr } = Gs, { inspectSymbol: eM } = Gr;
class s2 {
  /**
   * Create a transaction.
   * @constructor
   * @param {Object?} options
   */
  constructor(e) {
    this.version = 1, this.inputs = [], this.outputs = [], this.locktime = 0, this.mutable = !1, this._hash = null, this._hhash = null, this._whash = null, this._raw = null, this._offset = -1, this._block = !1, this._size = -1, this._witness = -1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null, e && this.fromOptions(e);
  }
  /**
   * Inject properties from options object.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    if (ar(e, "TX data is required."), e.version != null && (ar(e.version >>> 0 === e.version, "Version must be a uint32."), this.version = e.version), e.inputs) {
      ar(Array.isArray(e.inputs), "Inputs must be an array.");
      for (const t of e.inputs)
        this.inputs.push(new Uc(t));
    }
    if (e.outputs) {
      ar(Array.isArray(e.outputs), "Outputs must be an array.");
      for (const t of e.outputs)
        this.outputs.push(new Cc(t));
    }
    return e.locktime != null && (ar(e.locktime >>> 0 === e.locktime, "Locktime must be a uint32."), this.locktime = e.locktime), this;
  }
  /**
   * Instantiate TX from options object.
   * @param {Object} options
   * @returns {TX}
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Clone the transaction.
   * @returns {TX}
   */
  clone() {
    return new this.constructor().inject(this);
  }
  /**
   * Inject properties from tx.
   * Used for cloning.
   * @private
   * @param {TX} tx
   * @returns {TX}
   */
  inject(e) {
    this.version = e.version;
    for (const t of e.inputs)
      this.inputs.push(t.clone());
    for (const t of e.outputs)
      this.outputs.push(t.clone());
    return this.locktime = e.locktime, this;
  }
  /**
   * Clear any cached values.
   */
  refresh() {
    this._hash = null, this._hhash = null, this._whash = null, this._raw = null, this._size = -1, this._offset = -1, this._block = !1, this._witness = -1, this._sigops = -1, this._hashPrevouts = null, this._hashSequence = null, this._hashOutputs = null;
  }
  /**
   * Hash the transaction with the non-witness serialization.
   * @param {String?} enc - Can be `'hex'` or `null`.
   * @returns {Hash|Buffer} hash
   */
  hash(e) {
    let t = this._hash;
    if (t || (t = ms.digest(this.toNormal()), this.mutable || (this._hash = t)), e === "hex") {
      let i = this._hhash;
      i || (i = t.toString("hex"), this.mutable || (this._hhash = i)), t = i;
    }
    return t;
  }
  /**
   * Hash the transaction with the witness
   * serialization, return the wtxid (normal
   * hash if no witness is present, all zeroes
   * if coinbase).
   * @param {String?} enc - Can be `'hex'` or `null`.
   * @returns {Hash|Buffer} hash
   */
  witnessHash(e) {
    if (!this.hasWitness())
      return this.hash(e);
    let t = this._whash;
    return t || (t = ms.digest(this.toRaw()), this.mutable || (this._whash = t)), e === "hex" ? t.toString("hex") : t;
  }
  /**
   * Serialize the transaction. Note
   * that this is cached. This will use
   * the witness serialization if a
   * witness is present.
   * @returns {Buffer} Serialized transaction.
   */
  toRaw() {
    return this.frame().data;
  }
  /**
   * Serialize the transaction without the
   * witness vector, regardless of whether it
   * is a witness transaction or not.
   * @returns {Buffer} Serialized transaction.
   */
  toNormal() {
    return this.hasWitness() ? this.frameNormal().data : this.toRaw();
  }
  /**
   * Write the transaction to a buffer writer.
   * @param {BufferWriter} bw
   * @param {Boolean} block
   */
  toWriter(e, t) {
    return this.mutable ? this.hasWitness() ? this.writeWitness(e) : this.writeNormal(e) : (t && (this._offset = e.offset, this._block = !0), e.writeBytes(this.toRaw()), e);
  }
  /**
   * Write the transaction to a buffer writer.
   * Uses non-witness serialization.
   * @param {BufferWriter} bw
   */
  toNormalWriter(e) {
    return this.hasWitness() ? (this.writeNormal(e), e) : this.toWriter(e);
  }
  /**
   * Serialize the transaction. Note
   * that this is cached. This will use
   * the witness serialization if a
   * witness is present.
   * @private
   * @returns {RawTX}
   */
  frame() {
    if (this.mutable)
      return ar(!this._raw), this.hasWitness() ? this.frameWitness() : this.frameNormal();
    if (this._raw) {
      ar(this._size >= 0), ar(this._witness >= 0);
      const t = new ru(this._size, this._witness);
      return t.data = this._raw, t;
    }
    let e;
    return this.hasWitness() ? e = this.frameWitness() : e = this.frameNormal(), this._raw = e.data, this._size = e.size, this._witness = e.witness, e;
  }
  /**
   * Return the offset and size of the transaction. Useful
   * when the transaction is deserialized within a block.
   * @returns {Object} Contains `size` and `offset`.
   */
  getPosition() {
    return ar(this._block && this._offset > 80, "Position not available."), {
      offset: this._offset,
      size: this._size
    };
  }
  /**
   * Calculate total size and size of the witness bytes.
   * @returns {Object} Contains `size` and `witness`.
   */
  getSizes() {
    return this.mutable ? this.hasWitness() ? this.getWitnessSizes() : this.getNormalSizes() : this.frame();
  }
  /**
   * Calculate the virtual size of the transaction.
   * Note that this is cached.
   * @returns {Number} vsize
   */
  getVirtualSize() {
    const e = Ur.WITNESS_SCALE_FACTOR;
    return (this.getWeight() + e - 1) / e | 0;
  }
  /**
   * Calculate the virtual size of the transaction
   * (weighted against bytes per sigop cost).
   * @param {Number} sigops - Sigops cost.
   * @returns {Number} vsize
   */
  getSigopsSize(e) {
    const t = Ur.WITNESS_SCALE_FACTOR, i = p0.BYTES_PER_SIGOP;
    return (Math.max(this.getWeight(), e * i) + t - 1) / t | 0;
  }
  /**
   * Calculate the weight of the transaction.
   * Note that this is cached.
   * @returns {Number} weight
   */
  getWeight() {
    const e = this.getSizes();
    return (e.size - e.witness) * (Ur.WITNESS_SCALE_FACTOR - 1) + e.size;
  }
  /**
   * Calculate the real size of the transaction
   * with the witness included.
   * @returns {Number} size
   */
  getSize() {
    return this.getSizes().size;
  }
  /**
   * Calculate the size of the transaction
   * without the witness.
   * with the witness included.
   * @returns {Number} size
   */
  getBaseSize() {
    const e = this.getSizes();
    return e.size - e.witness;
  }
  /**
   * Test whether the transaction has a non-empty witness.
   * @returns {Boolean}
   */
  hasWitness() {
    if (this._witness !== -1)
      return this._witness !== 0;
    for (const e of this.inputs)
      if (e.witness.items.length > 0)
        return !0;
    return !1;
  }
  /**
   * Get the signature hash of the transaction for signing verifying.
   * @param {Number} index - Index of input being signed/verified.
   * @param {Script} prev - Previous output script or redeem script
   * (in the case of witnesspubkeyhash, this should be the generated
   * p2pkh script).
   * @param {Amount} value - Previous output value.
   * @param {SighashType} type - Sighash type.
   * @param {Number} version - Sighash version (0=legacy, 1=segwit).
   * @returns {Buffer} Signature hash.
   */
  signatureHash(e, t, i, n, c) {
    if (ar(e >= 0 && e < this.inputs.length), ar(t instanceof Gs), ar(typeof i == "number"), ar(typeof n == "number"), c === 0)
      return this.signatureHashV0(e, t, n);
    if (c === 1)
      return this.signatureHashV1(e, t, i, n);
    throw new Error("Unknown sighash version.");
  }
  /**
   * Legacy sighashing -- O(n^2).
   * @private
   * @param {Number} index
   * @param {Script} prev
   * @param {SighashType} type
   * @returns {Buffer}
   */
  signatureHashV0(e, t, i) {
    if ((i & 31) === jr.SINGLE && e >= this.outputs.length) {
      const o = Buffer.alloc(32, 0);
      return o[0] = 1, o;
    }
    t = t.removeSeparators();
    const n = this.hashSize(e, t, i), c = zi.pool(n);
    if (c.writeU32(this.version), i & jr.ANYONECANPAY) {
      const o = this.inputs[e];
      c.writeVarint(1), o.prevout.toWriter(c), c.writeVarBytes(t.toRaw()), c.writeU32(o.sequence);
    } else {
      c.writeVarint(this.inputs.length);
      for (let o = 0; o < this.inputs.length; o++) {
        const d = this.inputs[o];
        if (d.prevout.toWriter(c), o === e) {
          c.writeVarBytes(t.toRaw()), c.writeU32(d.sequence);
          continue;
        }
        switch (c.writeVarint(0), i & 31) {
          case jr.NONE:
          case jr.SINGLE:
            c.writeU32(0);
            break;
          default:
            c.writeU32(d.sequence);
            break;
        }
      }
    }
    switch (i & 31) {
      case jr.NONE: {
        c.writeVarint(0);
        break;
      }
      case jr.SINGLE: {
        const o = this.outputs[e];
        c.writeVarint(e + 1);
        for (let d = 0; d < e; d++)
          c.writeI64(-1), c.writeVarint(0);
        o.toWriter(c);
        break;
      }
      default: {
        c.writeVarint(this.outputs.length);
        for (const o of this.outputs)
          o.toWriter(c);
        break;
      }
    }
    return c.writeU32(this.locktime), c.writeU32(i), ms.digest(c.render());
  }
  /**
   * Calculate sighash size.
   * @private
   * @param {Number} index
   * @param {Script} prev
   * @param {Number} type
   * @returns {Number}
   */
  hashSize(e, t, i) {
    let n = 0;
    switch (n += 4, i & jr.ANYONECANPAY ? (n += 1, n += 36, n += t.getVarSize(), n += 4) : (n += Ls.sizeVarint(this.inputs.length), n += 41 * (this.inputs.length - 1), n += 36, n += t.getVarSize(), n += 4), i & 31) {
      case jr.NONE:
        n += 1;
        break;
      case jr.SINGLE:
        n += Ls.sizeVarint(e + 1), n += 9 * e, n += this.outputs[e].getSize();
        break;
      default:
        n += Ls.sizeVarint(this.outputs.length);
        for (const c of this.outputs)
          n += c.getSize();
        break;
    }
    return n += 8, n;
  }
  /**
   * Witness sighashing -- O(n).
   * @private
   * @param {Number} index
   * @param {Script} prev
   * @param {Amount} value
   * @param {SighashType} type
   * @returns {Buffer}
   */
  signatureHashV1(e, t, i, n) {
    const c = this.inputs[e];
    let o = Ur.ZERO_HASH, d = Ur.ZERO_HASH, l = Ur.ZERO_HASH;
    if (!(n & jr.ANYONECANPAY))
      if (this._hashPrevouts)
        o = this._hashPrevouts;
      else {
        const b = zi.pool(this.inputs.length * 36);
        for (const g of this.inputs)
          g.prevout.toWriter(b);
        o = ms.digest(b.render()), this.mutable || (this._hashPrevouts = o);
      }
    if (!(n & jr.ANYONECANPAY) && (n & 31) !== jr.SINGLE && (n & 31) !== jr.NONE)
      if (this._hashSequence)
        d = this._hashSequence;
      else {
        const b = zi.pool(this.inputs.length * 4);
        for (const g of this.inputs)
          b.writeU32(g.sequence);
        d = ms.digest(b.render()), this.mutable || (this._hashSequence = d);
      }
    if ((n & 31) !== jr.SINGLE && (n & 31) !== jr.NONE)
      if (this._hashOutputs)
        l = this._hashOutputs;
      else {
        let b = 0;
        for (const w of this.outputs)
          b += w.getSize();
        const g = zi.pool(b);
        for (const w of this.outputs)
          w.toWriter(g);
        l = ms.digest(g.render()), this.mutable || (this._hashOutputs = l);
      }
    else if ((n & 31) === jr.SINGLE && e < this.outputs.length) {
      const b = this.outputs[e];
      l = ms.digest(b.toRaw());
    }
    const h = 156 + t.getVarSize(), x = zi.pool(h);
    return x.writeU32(this.version), x.writeBytes(o), x.writeBytes(d), x.writeHash(c.prevout.hash), x.writeU32(c.prevout.index), x.writeVarBytes(t.toRaw()), x.writeI64(i), x.writeU32(c.sequence), x.writeBytes(l), x.writeU32(this.locktime), x.writeU32(n), ms.digest(x.render());
  }
  /**
   * Verify signature.
   * @param {Number} index
   * @param {Script} prev
   * @param {Amount} value
   * @param {Buffer} sig
   * @param {Buffer} key
   * @param {Number} version
   * @returns {Boolean}
   */
  checksig(e, t, i, n, c, o) {
    if (n.length === 0)
      return !1;
    const d = n[n.length - 1], l = this.signatureHash(e, t, i, d, o);
    return J4.verifyDER(l, n.slice(0, -1), c);
  }
  /**
   * Create a signature suitable for inserting into scriptSigs/witnesses.
   * @param {Number} index - Index of input being signed.
   * @param {Script} prev - Previous output script or redeem script
   * (in the case of witnesspubkeyhash, this should be the generated
   * p2pkh script).
   * @param {Amount} value - Previous output value.
   * @param {Buffer} key
   * @param {SighashType} type
   * @param {Number} version - Sighash version (0=legacy, 1=segwit).
   * @returns {Buffer} Signature in DER format.
   */
  signature(e, t, i, n, c, o) {
    c == null && (c = jr.ALL), o == null && (o = 0);
    const d = this.signatureHash(e, t, i, c, o), l = J4.signDER(d, n), h = zi.write(l.length + 1);
    return h.writeBytes(l), h.writeU8(c), h.render();
  }
  /**
   * Verify all transaction inputs.
   * @param {CoinView} view
   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
   * @throws {ScriptError} on invalid inputs
   */
  check(e, t) {
    if (this.inputs.length === 0)
      throw new tu("UNKNOWN_ERROR", "No inputs.");
    if (!this.isCoinbase())
      for (let i = 0; i < this.inputs.length; i++) {
        const { prevout: n } = this.inputs[i], c = e.getOutput(n);
        if (!c)
          throw new tu("UNKNOWN_ERROR", "No coin available.");
        this.checkInput(i, c, t);
      }
  }
  /**
   * Verify a transaction input.
   * @param {Number} index - Index of output being
   * verified.
   * @param {Coin|Output} coin - Previous output.
   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
   * @throws {ScriptError} on invalid input
   */
  checkInput(e, t, i) {
    const n = this.inputs[e];
    ar(n, "Input does not exist."), ar(t, "No coin passed."), Gs.verify(n.script, n.witness, t.script, this, e, t.value, i);
  }
  /**
   * Verify the transaction inputs on the worker pool
   * (if workers are enabled).
   * @param {CoinView} view
   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
   * @param {WorkerPool?} pool
   * @returns {Promise}
   */
  async checkAsync(e, t, i) {
    if (this.inputs.length === 0)
      throw new tu("UNKNOWN_ERROR", "No inputs.");
    if (!this.isCoinbase()) {
      if (!i) {
        this.check(e, t);
        return;
      }
      await i.check(this, e, t);
    }
  }
  /**
   * Verify a transaction input asynchronously.
   * @param {Number} index - Index of output being
   * verified.
   * @param {Coin|Output} coin - Previous output.
   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
   * @param {WorkerPool?} pool
   * @returns {Promise}
   */
  async checkInputAsync(e, t, i, n) {
    const c = this.inputs[e];
    if (ar(c, "Input does not exist."), ar(t, "No coin passed."), !n) {
      this.checkInput(e, t, i);
      return;
    }
    await n.checkInput(this, e, t, i);
  }
  /**
   * Verify all transaction inputs.
   * @param {CoinView} view
   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
   * @returns {Boolean} Whether the inputs are valid.
   */
  verify(e, t) {
    try {
      this.check(e, t);
    } catch (i) {
      if (i.type === "ScriptError")
        return !1;
      throw i;
    }
    return !0;
  }
  /**
   * Verify a transaction input.
   * @param {Number} index - Index of output being
   * verified.
   * @param {Coin|Output} coin - Previous output.
   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
   * @returns {Boolean} Whether the input is valid.
   */
  verifyInput(e, t, i) {
    try {
      this.checkInput(e, t, i);
    } catch (n) {
      if (n.type === "ScriptError")
        return !1;
      throw n;
    }
    return !0;
  }
  /**
   * Verify the transaction inputs on the worker pool
   * (if workers are enabled).
   * @param {CoinView} view
   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
   * @param {WorkerPool?} pool
   * @returns {Promise}
   */
  async verifyAsync(e, t, i) {
    try {
      await this.checkAsync(e, t, i);
    } catch (n) {
      if (n.type === "ScriptError")
        return !1;
      throw n;
    }
    return !0;
  }
  /**
   * Verify a transaction input asynchronously.
   * @param {Number} index - Index of output being
   * verified.
   * @param {Coin|Output} coin - Previous output.
   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
   * @param {WorkerPool?} pool
   * @returns {Promise}
   */
  async verifyInputAsync(e, t, i, n) {
    try {
      await this.checkInput(e, t, i, n);
    } catch (c) {
      if (c.type === "ScriptError")
        return !1;
      throw c;
    }
    return !0;
  }
  /**
   * Test whether the transaction is a coinbase
   * by examining the inputs.
   * @returns {Boolean}
   */
  isCoinbase() {
    return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
  }
  /**
   * Test whether the transaction is replaceable.
   * @returns {Boolean}
   */
  isRBF() {
    if (this.version === 2)
      return !1;
    for (const e of this.inputs)
      if (e.isRBF())
        return !0;
    return !1;
  }
  /**
   * Calculate the fee for the transaction.
   * @param {CoinView} view
   * @returns {Amount} fee (zero if not all coins are available).
   */
  getFee(e) {
    return this.hasCoins(e) ? this.getInputValue(e) - this.getOutputValue() : 0;
  }
  /**
   * Calculate the total input value.
   * @param {CoinView} view
   * @returns {Amount} value
   */
  getInputValue(e) {
    let t = 0;
    for (const { prevout: i } of this.inputs) {
      const n = e.getOutput(i);
      if (!n)
        return 0;
      t += n.value;
    }
    return t;
  }
  /**
   * Calculate the total output value.
   * @returns {Amount} value
   */
  getOutputValue() {
    let e = 0;
    for (const t of this.outputs)
      e += t.value;
    return e;
  }
  /**
   * Get all input addresses.
   * @private
   * @param {CoinView} view
   * @returns {Array} [addrs, table]
   */
  _getInputAddresses(e) {
    const t = new qc(), i = [];
    if (this.isCoinbase())
      return [i, t];
    for (const n of this.inputs) {
      const c = e ? e.getOutputFor(n) : null, o = n.getAddress(c);
      if (!o)
        continue;
      const d = o.getHash();
      t.has(d) || (t.add(d), i.push(o));
    }
    return [i, t];
  }
  /**
   * Get all output addresses.
   * @private
   * @returns {Array} [addrs, table]
   */
  _getOutputAddresses() {
    const e = new qc(), t = [];
    for (const i of this.outputs) {
      const n = i.getAddress();
      if (!n)
        continue;
      const c = n.getHash();
      e.has(c) || (e.add(c), t.push(n));
    }
    return [t, e];
  }
  /**
   * Get all addresses.
   * @private
   * @param {CoinView} view
   * @returns {Array} [addrs, table]
   */
  _getAddresses(e) {
    const [t, i] = this._getInputAddresses(e), n = this.getOutputAddresses();
    for (const c of n) {
      const o = c.getHash();
      i.has(o) || (i.add(o), t.push(c));
    }
    return [t, i];
  }
  /**
   * Get all input addresses.
   * @param {CoinView|null} view
   * @returns {Address[]} addresses
   */
  getInputAddresses(e) {
    const [t] = this._getInputAddresses(e);
    return t;
  }
  /**
   * Get all output addresses.
   * @returns {Address[]} addresses
   */
  getOutputAddresses() {
    const [e] = this._getOutputAddresses();
    return e;
  }
  /**
   * Get all addresses.
   * @param {CoinView|null} view
   * @returns {Address[]} addresses
   */
  getAddresses(e) {
    const [t] = this._getAddresses(e);
    return t;
  }
  /**
   * Get all input address hashes.
   * @param {CoinView|null} view
   * @param {String?} enc - Encoding, can be `'hex'` or null.
   * @returns {Hash[]} hashes
   */
  getInputHashes(e, t) {
    const [, i] = this._getInputAddresses(e);
    return t !== "hex" ? i.toArray() : i.toArray().map((n) => n.toString("hex"));
  }
  /**
   * Get all output address hashes.
   * @returns {Hash[]} hashes
   */
  getOutputHashes(e) {
    const [, t] = this._getOutputAddresses();
    return e !== "hex" ? t.toArray() : t.toArray().map((i) => i.toString("hex"));
  }
  /**
   * Get all address hashes.
   * @param {CoinView|null} view
   * @param {String?} enc - Encoding, can be `'hex'` or null.
   * @returns {Hash[]} hashes
   */
  getHashes(e, t) {
    const [, i] = this._getAddresses(e);
    return t !== "hex" ? i.toArray() : i.toArray().map((n) => n.toString("hex"));
  }
  /**
   * Test whether the transaction has
   * all coins available.
   * @param {CoinView} view
   * @returns {Boolean}
   */
  hasCoins(e) {
    if (this.inputs.length === 0)
      return !1;
    for (const { prevout: t } of this.inputs)
      if (!e.hasEntry(t))
        return !1;
    return !0;
  }
  /**
   * Check finality of transaction by examining
   * nLocktime and nSequence values.
   * @example
   * tx.isFinal(chain.height + 1, network.now());
   * @param {Number} height - Height at which to test. This
   * is usually the chain height, or the chain height + 1
   * when the transaction entered the mempool.
   * @param {Number} time - Time at which to test. This is
   * usually the chain tip's parent's median time, or the
   * time at which the transaction entered the mempool. If
   * MEDIAN_TIME_PAST is enabled this will be the median
   * time of the chain tip's previous entry's median time.
   * @returns {Boolean}
   */
  isFinal(e, t) {
    const i = Ur.LOCKTIME_THRESHOLD;
    if (this.locktime === 0 || this.locktime < (this.locktime < i ? e : t))
      return !0;
    for (const n of this.inputs)
      if (n.sequence !== 4294967295)
        return !1;
    return !0;
  }
  /**
   * Verify the absolute locktime of a transaction.
   * Called by OP_CHECKLOCKTIMEVERIFY.
   * @param {Number} index - Index of input being verified.
   * @param {Number} predicate - Locktime to verify against.
   * @returns {Boolean}
   */
  verifyLocktime(e, t) {
    const i = Ur.LOCKTIME_THRESHOLD, n = this.inputs[e];
    return ar(n, "Input does not exist."), ar(t >= 0, "Locktime must be non-negative."), !(this.locktime < i != t < i || t > this.locktime || n.sequence === 4294967295);
  }
  /**
   * Verify the relative locktime of an input.
   * Called by OP_CHECKSEQUENCEVERIFY.
   * @param {Number} index - Index of input being verified.
   * @param {Number} predicate - Relative locktime to verify against.
   * @returns {Boolean}
   */
  verifySequence(e, t) {
    const i = Ur.SEQUENCE_DISABLE_FLAG, n = Ur.SEQUENCE_TYPE_FLAG, c = Ur.SEQUENCE_MASK, o = this.inputs[e];
    return ar(o, "Input does not exist."), ar(t >= 0, "Locktime must be non-negative."), t & i ? !0 : !(this.version < 2 || o.sequence & i || (o.sequence & n) !== (t & n) || (t & c) > (o.sequence & c));
  }
  /**
   * Calculate legacy (inaccurate) sigop count.
   * @returns {Number} sigop count
   */
  getLegacySigops() {
    if (this._sigops !== -1)
      return this._sigops;
    let e = 0;
    for (const t of this.inputs)
      e += t.script.getSigops(!1);
    for (const t of this.outputs)
      e += t.script.getSigops(!1);
    return this.mutable || (this._sigops = e), e;
  }
  /**
   * Calculate accurate sigop count, taking into account redeem scripts.
   * @param {CoinView} view
   * @returns {Number} sigop count
   */
  getScripthashSigops(e) {
    if (this.isCoinbase())
      return 0;
    let t = 0;
    for (const i of this.inputs) {
      const n = e.getOutputFor(i);
      n && n.script.isScripthash() && (t += n.script.getScripthashSigops(i.script));
    }
    return t;
  }
  /**
   * Calculate accurate sigop count, taking into account redeem scripts.
   * @param {CoinView} view
   * @returns {Number} sigop count
   */
  getWitnessSigops(e) {
    if (this.isCoinbase())
      return 0;
    let t = 0;
    for (const i of this.inputs) {
      const n = e.getOutputFor(i);
      n && (t += n.script.getWitnessSigops(i.script, i.witness));
    }
    return t;
  }
  /**
   * Calculate sigops cost, taking into account witness programs.
   * @param {CoinView} view
   * @param {VerifyFlags?} flags
   * @returns {Number} sigop weight
   */
  getSigopsCost(e, t) {
    t == null && (t = Gs.flags.STANDARD_VERIFY_FLAGS);
    const i = Ur.WITNESS_SCALE_FACTOR;
    let n = this.getLegacySigops() * i;
    return t & Gs.flags.VERIFY_P2SH && (n += this.getScripthashSigops(e) * i), t & Gs.flags.VERIFY_WITNESS && (n += this.getWitnessSigops(e)), n;
  }
  /**
   * Calculate virtual sigop count.
   * @param {CoinView} view
   * @param {VerifyFlags?} flags
   * @returns {Number} sigop count
   */
  getSigops(e, t) {
    const i = Ur.WITNESS_SCALE_FACTOR;
    return (this.getSigopsCost(e, t) + i - 1) / i | 0;
  }
  /**
   * Non-contextual sanity checks for the transaction.
   * Will mostly verify coin and output values.
   * @see CheckTransaction()
   * @returns {Array} [result, reason, score]
   */
  isSane() {
    const [e] = this.checkSanity();
    return e;
  }
  /**
   * Non-contextual sanity checks for the transaction.
   * Will mostly verify coin and output values.
   * @see CheckTransaction()
   * @returns {Array} [valid, reason, score]
   */
  checkSanity() {
    if (this.inputs.length === 0)
      return [!1, "bad-txns-vin-empty", 100];
    if (this.outputs.length === 0)
      return [!1, "bad-txns-vout-empty", 100];
    if (this.getBaseSize() > Ur.MAX_BLOCK_SIZE)
      return [!1, "bad-txns-oversize", 100];
    let e = 0;
    for (const i of this.outputs) {
      if (i.value < 0)
        return [!1, "bad-txns-vout-negative", 100];
      if (i.value > Ur.MAX_MONEY)
        return [!1, "bad-txns-vout-toolarge", 100];
      if (e += i.value, e < 0 || e > Ur.MAX_MONEY)
        return [!1, "bad-txns-txouttotal-toolarge", 100];
    }
    const t = new qc();
    for (const i of this.inputs) {
      const n = i.prevout.toKey();
      if (t.has(n))
        return [!1, "bad-txns-inputs-duplicate", 100];
      t.add(n);
    }
    if (this.isCoinbase()) {
      const i = this.inputs[0].script.getSize();
      if (i < 2 || i > 100)
        return [!1, "bad-cb-length", 100];
    } else
      for (const i of this.inputs)
        if (i.prevout.isNull())
          return [!1, "bad-txns-prevout-null", 10];
    return [!0, "valid", 0];
  }
  /**
   * Non-contextual checks to determine whether the
   * transaction has all standard output script
   * types and standard input script size with only
   * pushdatas in the code.
   * Will mostly verify coin and output values.
   * @see IsStandardTx()
   * @returns {Array} [valid, reason, score]
   */
  isStandard() {
    const [e] = this.checkStandard();
    return e;
  }
  /**
   * Non-contextual checks to determine whether the
   * transaction has all standard output script
   * types and standard input script size with only
   * pushdatas in the code.
   * Will mostly verify coin and output values.
   * @see IsStandardTx()
   * @returns {Array} [valid, reason, score]
   */
  checkStandard() {
    if (this.version < 1 || this.version > p0.MAX_TX_VERSION)
      return [!1, "version", 0];
    if (this.getWeight() >= p0.MAX_TX_WEIGHT)
      return [!1, "tx-size", 0];
    for (const t of this.inputs) {
      if (t.script.getSize() > 1650)
        return [!1, "scriptsig-size", 0];
      if (!t.script.isPushOnly())
        return [!1, "scriptsig-not-pushonly", 0];
    }
    let e = 0;
    for (const t of this.outputs) {
      if (!t.script.isStandard())
        return [!1, "scriptpubkey", 0];
      if (t.script.isNulldata()) {
        e++;
        continue;
      }
      if (t.script.isMultisig() && !p0.BARE_MULTISIG)
        return [!1, "bare-multisig", 0];
      if (t.isDust(p0.MIN_RELAY))
        return [!1, "dust", 0];
    }
    return e > 1 ? [!1, "multi-op-return", 0] : [!0, "valid", 0];
  }
  /**
   * Perform contextual checks to verify coin and input
   * script standardness (including the redeem script).
   * @see AreInputsStandard()
   * @param {CoinView} view
   * @returns {Boolean}
   */
  hasStandardInputs(e) {
    if (this.isCoinbase())
      return !0;
    for (const t of this.inputs) {
      const i = e.getOutputFor(t);
      if (!i)
        return !1;
      if (!i.script.isPubkeyhash()) {
        if (i.script.isScripthash()) {
          const n = t.script.getRedeem();
          if (!n || n.getSigops(!0) > p0.MAX_P2SH_SIGOPS)
            return !1;
          continue;
        }
        if (i.script.isUnknown())
          return !1;
      }
    }
    return !0;
  }
  /**
   * Perform contextual checks to verify coin and witness standardness.
   * @see IsBadWitness()
   * @param {CoinView} view
   * @returns {Boolean}
   */
  hasStandardWitness(e) {
    if (this.isCoinbase())
      return !0;
    for (const t of this.inputs) {
      const i = t.witness, n = e.getOutputFor(t);
      if (!n || i.items.length === 0)
        continue;
      let c = n.script;
      if (c.isScripthash() && (c = t.script.getRedeem(), !c) || !c.isProgram())
        return !1;
      if (c.isWitnessPubkeyhash()) {
        if (i.items.length !== 2 || i.items[0].length > 73 || i.items[1].length > 65)
          return !1;
        continue;
      }
      if (c.isWitnessScripthash()) {
        if (i.items.length - 1 > p0.MAX_P2WSH_STACK)
          return !1;
        for (let h = 0; h < i.items.length - 1; h++)
          if (i.items[h].length > p0.MAX_P2WSH_PUSH)
            return !1;
        const o = i.items[i.items.length - 1];
        if (o.length > p0.MAX_P2WSH_SIZE)
          return !1;
        const d = Gs.fromRaw(o);
        if (d.isPubkey()) {
          if (i.items.length - 1 !== 1 || i.items[0].length > 73)
            return !1;
          continue;
        }
        if (d.isPubkeyhash()) {
          if (t.witness.items.length - 1 !== 2 || i.items[0].length > 73 || i.items[1].length > 65)
            return !1;
          continue;
        }
        const [l] = d.getMultisig();
        if (l !== -1) {
          if (i.items.length - 1 !== l + 1 || i.items[0].length !== 0)
            return !1;
          for (let h = 1; h < i.items.length - 1; h++)
            if (i.items[h].length > 73)
              return !1;
        }
        continue;
      }
      if (i.items.length > p0.MAX_P2WSH_STACK)
        return !1;
      for (const o of i.items)
        if (o.length > p0.MAX_P2WSH_PUSH)
          return !1;
    }
    return !0;
  }
  /**
   * Perform contextual checks to verify input, output,
   * and fee values, as well as coinbase spend maturity
   * (coinbases can only be spent 100 blocks or more
   * after they're created). Note that this function is
   * consensus critical.
   * @param {CoinView} view
   * @param {Number} height - Height at which the
   * transaction is being spent. In the mempool this is
   * the chain height plus one at the time it entered the pool.
   * @returns {Boolean}
   */
  verifyInputs(e, t) {
    const [i] = this.checkInputs(e, t);
    return i !== -1;
  }
  /**
   * Perform contextual checks to verify input, output,
   * and fee values, as well as coinbase spend maturity
   * (coinbases can only be spent 100 blocks or more
   * after they're created). Note that this function is
   * consensus critical.
   * @param {CoinView} view
   * @param {Number} height - Height at which the
   * transaction is being spent. In the mempool this is
   * the chain height plus one at the time it entered the pool.
   * @returns {Array} [fee, reason, score]
   */
  checkInputs(e, t) {
    ar(typeof t == "number");
    let i = 0;
    for (const { prevout: o } of this.inputs) {
      const d = e.getEntry(o);
      if (!d)
        return [-1, "bad-txns-inputs-missingorspent", 0];
      if (d.coinbase && t - d.height < Ur.COINBASE_MATURITY)
        return [-1, "bad-txns-premature-spend-of-coinbase", 0];
      const l = e.getOutput(o);
      if (ar(l), l.value < 0 || l.value > Ur.MAX_MONEY)
        return [-1, "bad-txns-inputvalues-outofrange", 100];
      if (i += l.value, i < 0 || i > Ur.MAX_MONEY)
        return [-1, "bad-txns-inputvalues-outofrange", 100];
    }
    const n = this.getOutputValue();
    if (i < n)
      return [-1, "bad-txns-in-belowout", 100];
    const c = i - n;
    return c < 0 ? [-1, "bad-txns-fee-negative", 100] : c > Ur.MAX_MONEY ? [-1, "bad-txns-fee-outofrange", 100] : [c, "valid", 0];
  }
  /**
   * Calculate the modified size of the transaction. This
   * is used in the mempool for calculating priority.
   * @param {Number?} size - The size to modify. If not present,
   * virtual size will be used.
   * @returns {Number} Modified size.
   */
  getModifiedSize(e) {
    e == null && (e = this.getVirtualSize());
    for (const t of this.inputs) {
      const i = 41 + Math.min(110, t.script.getSize());
      e > i && (e -= i);
    }
    return e;
  }
  /**
   * Calculate the transaction priority.
   * @param {CoinView} view
   * @param {Number} height
   * @param {Number?} size - Size to calculate priority
   * based on. If not present, virtual size will be used.
   * @returns {Number}
   */
  getPriority(e, t, i) {
    if (ar(typeof t == "number", "Must pass in height."), this.isCoinbase())
      return 0;
    i == null && (i = this.getVirtualSize());
    let n = 0;
    for (const { prevout: c } of this.inputs) {
      const o = e.getOutput(c);
      if (!o)
        continue;
      const d = e.getHeight(c);
      if (d !== -1 && d <= t) {
        const l = t - d;
        n += o.value * l;
      }
    }
    return Math.floor(n / i);
  }
  /**
   * Calculate the transaction's on-chain value.
   * @param {CoinView} view
   * @returns {Number}
   */
  getChainValue(e) {
    if (this.isCoinbase())
      return 0;
    let t = 0;
    for (const { prevout: i } of this.inputs) {
      const n = e.getOutput(i);
      !n || e.getHeight(i) === -1 || (t += n.value);
    }
    return t;
  }
  /**
   * Determine whether the transaction is above the
   * free threshold in priority. A transaction which
   * passed this test is most likely relayable
   * without a fee.
   * @param {CoinView} view
   * @param {Number?} height - If not present, tx
   * height or network height will be used.
   * @param {Number?} size - If not present, modified
   * size will be calculated and used.
   * @returns {Boolean}
   */
  isFree(e, t, i) {
    return this.getPriority(e, t, i) > p0.FREE_THRESHOLD;
  }
  /**
   * Calculate minimum fee in order for the transaction
   * to be relayable (not the constant min relay fee).
   * @param {Number?} size - If not present, max size
   * estimation will be calculated and used.
   * @param {Rate?} rate - Rate of satoshi per kB.
   * @returns {Amount} fee
   */
  getMinFee(e, t) {
    return e == null && (e = this.getVirtualSize()), p0.getMinFee(e, t);
  }
  /**
   * Calculate the minimum fee in order for the transaction
   * to be relayable, but _round to the nearest kilobyte
   * when taking into account size.
   * @param {Number?} size - If not present, max size
   * estimation will be calculated and used.
   * @param {Rate?} rate - Rate of satoshi per kB.
   * @returns {Amount} fee
   */
  getRoundFee(e, t) {
    return e == null && (e = this.getVirtualSize()), p0.getRoundFee(e, t);
  }
  /**
   * Calculate the transaction's rate based on size
   * and fees. Size will be calculated if not present.
   * @param {CoinView} view
   * @param {Number?} size
   * @returns {Rate}
   */
  getRate(e, t) {
    const i = this.getFee(e);
    return i < 0 ? 0 : (t == null && (t = this.getVirtualSize()), p0.getRate(t, i));
  }
  /**
   * Get all unique outpoint hashes.
   * @returns {Hash[]} Outpoint hashes.
   */
  getPrevout() {
    if (this.isCoinbase())
      return [];
    const e = new qc();
    for (const t of this.inputs)
      e.add(t.prevout.hash);
    return e.toArray();
  }
  /**
   * Test a transaction against a bloom filter using
   * the BIP37 matching algorithm. Note that this may
   * update the filter depending on what the `update`
   * value is.
   * @see "Filter matching algorithm":
   * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
   * @param {BloomFilter} filter
   * @returns {Boolean} True if the transaction matched.
   */
  isWatched(e) {
    let t = !1;
    e.test(this.hash()) && (t = !0);
    for (let i = 0; i < this.outputs.length; i++) {
      const n = this.outputs[i];
      if (n.script.test(e)) {
        if (e.update === 1) {
          const c = X4.fromTX(this, i);
          e.add(c.toRaw());
        } else if (e.update === 2 && (n.script.isPubkey() || n.script.isMultisig())) {
          const c = X4.fromTX(this, i);
          e.add(c.toRaw());
        }
        t = !0;
      }
    }
    if (t)
      return t;
    for (const i of this.inputs) {
      const n = i.prevout;
      if (e.test(n.toRaw()) || i.script.test(e))
        return !0;
    }
    return !1;
  }
  /**
   * Get little-endian tx hash.
   * @returns {Hash}
   */
  rhash() {
    return Ds.revHex(this.hash());
  }
  /**
   * Get little-endian wtx hash.
   * @returns {Hash}
   */
  rwhash() {
    return Ds.revHex(this.witnessHash());
  }
  /**
   * Get little-endian tx hash.
   * @returns {Hash}
   */
  txid() {
    return this.rhash();
  }
  /**
   * Get little-endian wtx hash.
   * @returns {Hash}
   */
  wtxid() {
    return this.rwhash();
  }
  /**
   * Convert the tx to an inv item.
   * @returns {InvItem}
   */
  toInv() {
    return new Z4(Z4.types.TX, this.hash());
  }
  /**
   * Inspect the transaction and return a more
   * user-friendly representation of the data.
   * @returns {Object}
   */
  [eM]() {
    return this.format();
  }
  /**
   * Inspect the transaction and return a more
   * user-friendly representation of the data.
   * @param {CoinView} view
   * @param {ChainEntry} entry
   * @param {Number} index
   * @returns {Object}
   */
  format(e, t, i) {
    let n = 0, c = 0, o = -1, d = null, l = 0, h = null;
    return e && (c = this.getFee(e), n = this.getRate(e), Number.isSafeInteger(n) || (n = 0)), t && (o = t.height, d = Ds.revHex(t.hash), l = t.time, h = Ds.date(l)), i == null && (i = -1), {
      hash: this.txid(),
      witnessHash: this.wtxid(),
      size: this.getSize(),
      virtualSize: this.getVirtualSize(),
      value: zc.btc(this.getOutputValue()),
      fee: zc.btc(c),
      rate: zc.btc(n),
      minFee: zc.btc(this.getMinFee()),
      height: o,
      block: d,
      time: l,
      date: h,
      index: i,
      version: this.version,
      inputs: this.inputs.map((x) => {
        const b = e ? e.getOutputFor(x) : null;
        return x.format(b);
      }),
      outputs: this.outputs,
      locktime: this.locktime
    };
  }
  /**
   * Convert the transaction to an object suitable
   * for JSON serialization.
   * @returns {Object}
   */
  toJSON() {
    return this.getJSON();
  }
  /**
   * Convert the transaction to an object suitable
   * for JSON serialization. Note that the hashes
   * will be reversed to abide by bitcoind's legacy
   * of little-endian uint256s.
   * @param {Network} network
   * @param {CoinView} view
   * @param {ChainEntry} entry
   * @param {Number} index
   * @returns {Object}
   */
  getJSON(e, t, i, n) {
    let c, o, d, l, h, x;
    return t && (o = this.getFee(t), c = this.getRate(t), Number.isSafeInteger(c) || (c = 0)), i && (d = i.height, l = Ds.revHex(i.hash), h = i.time, x = Ds.date(h)), e = Q_.get(e), {
      hash: this.txid(),
      witnessHash: this.wtxid(),
      fee: o,
      rate: c,
      mtime: Ds.now(),
      height: d,
      block: l,
      time: h,
      date: x,
      index: n,
      version: this.version,
      inputs: this.inputs.map((b) => {
        const g = t ? t.getCoinFor(b) : null;
        return b.getJSON(e, g);
      }),
      outputs: this.outputs.map((b) => b.getJSON(e)),
      locktime: this.locktime,
      hex: this.toRaw().toString("hex")
    };
  }
  /**
   * Inject properties from a json object.
   * @private
   * @param {Object} json
   */
  fromJSON(e) {
    ar(e, "TX data is required."), ar(e.version >>> 0 === e.version, "Version must be a uint32."), ar(Array.isArray(e.inputs), "Inputs must be an array."), ar(Array.isArray(e.outputs), "Outputs must be an array."), ar(e.locktime >>> 0 === e.locktime, "Locktime must be a uint32."), this.version = e.version;
    for (const t of e.inputs)
      this.inputs.push(Uc.fromJSON(t));
    for (const t of e.outputs)
      this.outputs.push(Cc.fromJSON(t));
    return this.locktime = e.locktime, this;
  }
  /**
   * Instantiate a transaction from a
   * jsonified transaction object.
   * @param {Object} json - The jsonified transaction object.
   * @returns {TX}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Instantiate a transaction from a serialized Buffer.
   * @param {Buffer} data
   * @param {String?} enc - Encoding, can be `'hex'` or null.
   * @returns {TX}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Instantiate a transaction from a buffer reader.
   * @param {BufferReader} br
   * @param {Boolean} block
   * @returns {TX}
   */
  static fromReader(e, t) {
    const i = e.offset;
    try {
      return new this().fromWitnessReader(e, t);
    } catch {
      return e.end(), e.offset = i, new this().fromLegacyReader(e, t);
    }
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(zi.read(e));
  }
  /**
   * Instantiate a transaction from a buffer reader.
   * @param {BufferReader} br
   * @param {Boolean} block
   * @returns {TX}
   */
  fromReader(e, t) {
    const i = e.offset;
    try {
      return this.fromWitnessReader(e, t);
    } catch {
      return this.inputs.length = 0, this.outputs.length = 0, e.end(), e.offset = i, this.fromLegacyReader(e, t);
    }
  }
  /**
   * Inject properties from buffer reader.
   * @private
   * @param {BufferReader} br
   * @param {Boolean} block
   */
  fromLegacyReader(e, t) {
    const i = e.start();
    this.version = e.readU32();
    const n = e.readVarint();
    for (let o = 0; o < n; o++)
      this.inputs.push(Uc.fromReader(e));
    const c = e.readVarint();
    for (let o = 0; o < c; o++)
      this.outputs.push(Cc.fromReader(e));
    return this.locktime = e.readU32(), t && (this._offset = i, this._block = !0), this.mutable ? e.end() : (this._raw = e.endData(), this._size = this._raw.length, this._witness = 0), this;
  }
  /**
   * Inject properties from serialized
   * buffer reader (witness serialization).
   * @private
   * @param {BufferReader} br
   * @param {Boolean} block
   */
  fromWitnessReader(e, t) {
    const i = e.start();
    this.version = e.readU32(), ar(e.readU8() === 0, "Non-zero marker.");
    let n = e.readU8();
    ar(n !== 0, "Flags byte is zero.");
    const c = e.readVarint();
    for (let h = 0; h < c; h++)
      this.inputs.push(Uc.fromReader(e));
    const o = e.readVarint();
    for (let h = 0; h < o; h++)
      this.outputs.push(Cc.fromReader(e));
    let d = 0, l = !1;
    if (n & 1) {
      n ^= 1, d = e.offset;
      for (const h of this.inputs)
        h.witness.fromReader(e), h.witness.items.length > 0 && (l = !0);
      d = e.offset - d + 2;
    }
    if (n !== 0)
      throw new Error("Unknown witness flag.");
    if (this.inputs.length === 0 && this.outputs.length !== 0)
      throw new Error("Zero input witness tx.");
    return this.locktime = e.readU32(), t && (this._offset = i, this._block = !0), !this.mutable && l ? (this._raw = e.endData(), this._size = this._raw.length, this._witness = d) : e.end(), this;
  }
  /**
   * Serialize transaction without witness.
   * @private
   * @returns {RawTX}
   */
  frameNormal() {
    const e = this.getNormalSizes(), t = zi.write(e.size);
    return this.writeNormal(t), e.data = t.render(), e;
  }
  /**
   * Serialize transaction with witness. Calculates the witness
   * size as it is framing (exposed on return value as `witness`).
   * @private
   * @returns {RawTX}
   */
  frameWitness() {
    const e = this.getWitnessSizes(), t = zi.write(e.size);
    return this.writeWitness(t), e.data = t.render(), e;
  }
  /**
   * Serialize transaction without witness.
   * @private
   * @param {BufferWriter} bw
   * @returns {RawTX}
   */
  writeNormal(e) {
    e.writeU32(this.version), e.writeVarint(this.inputs.length);
    for (const t of this.inputs)
      t.toWriter(e);
    e.writeVarint(this.outputs.length);
    for (const t of this.outputs)
      t.toWriter(e);
    return e.writeU32(this.locktime), e;
  }
  /**
   * Serialize transaction with witness. Calculates the witness
   * size as it is framing (exposed on return value as `witness`).
   * @private
   * @param {BufferWriter} bw
   * @returns {RawTX}
   */
  writeWitness(e) {
    e.writeU32(this.version), e.writeU8(0), e.writeU8(1), e.writeVarint(this.inputs.length);
    for (const n of this.inputs)
      n.toWriter(e);
    e.writeVarint(this.outputs.length);
    for (const n of this.outputs)
      n.toWriter(e);
    const t = e.offset;
    for (const n of this.inputs)
      n.witness.toWriter(e);
    const i = e.offset - t;
    if (e.writeU32(this.locktime), i === this.inputs.length)
      throw new Error("Cannot serialize empty-witness tx.");
    return e;
  }
  /**
   * Calculate the real size of the transaction
   * without the witness vector.
   * @returns {RawTX}
   */
  getNormalSizes() {
    let e = 0;
    e += 4, e += Ls.sizeVarint(this.inputs.length);
    for (const t of this.inputs)
      e += t.getSize();
    e += Ls.sizeVarint(this.outputs.length);
    for (const t of this.outputs)
      e += t.getSize();
    return e += 4, new ru(e, 0);
  }
  /**
   * Calculate the real size of the transaction
   * with the witness included.
   * @returns {RawTX}
   */
  getWitnessSizes() {
    let e = 0, t = 0;
    e += 4, t += 2, e += Ls.sizeVarint(this.inputs.length);
    for (const i of this.inputs)
      e += i.getSize(), t += i.witness.getVarSize();
    e += Ls.sizeVarint(this.outputs.length);
    for (const i of this.outputs)
      e += i.getSize();
    return e += 4, new ru(e + t, t);
  }
  /**
   * Test whether an object is a TX.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isTX(e) {
    return e instanceof s2;
  }
}
class ru {
  constructor(e, t) {
    this.data = null, this.size = e, this.witness = t;
  }
}
var tM = s2;
/*!
 * merkleblock.js - merkleblock object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
Buffer.from([0]);
/*!
 * golomb.js - gcs filters for bcoin
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const { U64: rM } = hc;
Buffer.alloc(0);
new rM(-1);
var iM = {};
/*!
 * common.js - blockstore constants for bcoin
 * Copyright (c) 2019, Braydon Fuller (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r) {
  r.types = {
    BLOCK: 1,
    UNDO: 2,
    FILTER_BASIC: 3,
    MERKLE: 4
  }, r.filters = {
    BASIC: r.types.FILTER_BASIC
  }, r.prefixes = {
    1: "blk",
    2: "blu",
    3: "blf",
    4: "blm"
  };
})(iM);
/*!
 * coin.js - coin object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Cr = Ar, W4 = Me, iu = Os, sM = wa, nM = uc, fM = oc, j4 = ri, Q4 = ef, { inspectSymbol: cM } = Gr, { encoding: oM } = Me;
let aM = class Op extends nM {
  /**
   * Create a coin.
   * @constructor
   * @param {Object} options
   */
  constructor(e) {
    super(), this.version = 1, this.height = -1, this.coinbase = !1, this.hash = j4.ZERO_HASH, this.index = 0, e && this.fromOptions(e);
  }
  /**
   * Inject options into coin.
   * @private
   * @param {Object} options
   */
  fromOptions(e) {
    return Cr(e, "Coin data is required."), e.version != null && (Cr(e.version >>> 0 === e.version, "Version must be a uint32."), this.version = e.version), e.height != null && (e.height !== -1 ? (Cr(e.height >>> 0 === e.height, "Height must be a uint32."), this.height = e.height) : this.height = -1), e.value != null && (Cr(Number.isSafeInteger(e.value) && e.value >= 0, "Value must be a safe integer."), this.value = e.value), e.script && this.script.fromOptions(e.script), e.coinbase != null && (Cr(typeof e.coinbase == "boolean", "Coinbase must be a boolean."), this.coinbase = e.coinbase), e.hash != null && (Cr(Buffer.isBuffer(e.hash)), this.hash = e.hash), e.index != null && (Cr(e.index >>> 0 === e.index, "Index must be a uint32."), this.index = e.index), this;
  }
  /**
   * Instantiate Coin from options object.
   * @private
   * @param {Object} options
   */
  static fromOptions(e) {
    return new this().fromOptions(e);
  }
  /**
   * Clone the coin.
   * @private
   * @returns {Coin}
   */
  clone() {
    Cr(!1, "Coins are not cloneable.");
  }
  /**
   * Calculate number of confirmations since coin was created.
   * @param {Number?} height - Current chain height. Network
   * height is used if not passed in.
   * @return {Number}
   */
  getDepth(e) {
    return Cr(typeof e == "number", "Must pass a height."), this.height === -1 || e === -1 || e < this.height ? 0 : e - this.height + 1;
  }
  /**
   * Serialize coin to a key
   * suitable for a hash table.
   * @returns {String}
   */
  toKey() {
    return Q4.toKey(this.hash, this.index);
  }
  /**
   * Inject properties from hash table key.
   * @private
   * @param {String} key
   * @returns {Coin}
   */
  fromKey(e) {
    const { hash: t, index: i } = Q4.fromKey(e);
    return this.hash = t, this.index = i, this;
  }
  /**
   * Instantiate coin from hash table key.
   * @param {String} key
   * @returns {Coin}
   */
  static fromKey(e) {
    return new this().fromKey(e);
  }
  /**
   * Get little-endian hash.
   * @returns {Hash}
   */
  rhash() {
    return iu.revHex(this.hash);
  }
  /**
   * Get little-endian hash.
   * @returns {Hash}
   */
  txid() {
    return this.rhash();
  }
  /**
   * Convert the coin to a more user-friendly object.
   * @returns {Object}
   */
  [cM]() {
    return {
      type: this.getType(),
      version: this.version,
      height: this.height,
      value: sM.btc(this.value),
      script: this.script,
      coinbase: this.coinbase,
      hash: this.hash ? iu.revHex(this.hash) : null,
      index: this.index,
      address: this.getAddress()
    };
  }
  /**
   * Convert the coin to an object suitable
   * for JSON serialization.
   * @returns {Object}
   */
  toJSON() {
    return this.getJSON();
  }
  /**
   * Convert the coin to an object suitable
   * for JSON serialization. Note that the hash
   * will be reversed to abide by bitcoind's legacy
   * of little-endian uint256s.
   * @param {Network} network
   * @param {Boolean} minimal
   * @returns {Object}
   */
  getJSON(e, t) {
    let i = this.getAddress();
    return e = fM.get(e), i && (i = i.toString(e)), {
      version: this.version,
      height: this.height,
      value: this.value,
      script: this.script.toJSON(),
      address: i,
      coinbase: this.coinbase,
      hash: t ? void 0 : this.rhash(),
      index: t ? void 0 : this.index
    };
  }
  /**
   * Inject JSON properties into coin.
   * @private
   * @param {Object} json
   */
  fromJSON(e) {
    return Cr(e, "Coin data required."), Cr(e.version >>> 0 === e.version, "Version must be a uint32."), Cr(e.height === -1 || e.height >>> 0 === e.height, "Height must be a uint32."), Cr(Number.isSafeInteger(e.value) && e.value >= 0, "Value must be a safe integer."), Cr(typeof e.coinbase == "boolean", "Coinbase must be a boolean."), this.version = e.version, this.height = e.height, this.value = e.value, this.script.fromJSON(e.script), this.coinbase = e.coinbase, e.hash != null && (Cr(typeof e.hash == "string", "Hash must be a string."), Cr(e.hash.length === 64, "Hash must be a string."), Cr(e.index >>> 0 === e.index, "Index must be a uint32."), this.hash = iu.fromRev(e.hash), this.index = e.index), this;
  }
  /**
   * Instantiate an Coin from a jsonified coin object.
   * @param {Object} json - The jsonified coin object.
   * @returns {Coin}
   */
  static fromJSON(e) {
    return new this().fromJSON(e);
  }
  /**
   * Calculate size of coin.
   * @returns {Number}
   */
  getSize() {
    return 17 + this.script.getVarSize();
  }
  /**
   * Estimate spending size.
   * @param {Function?} getAccount - Returns account that can spend
   * from a given address.
   * @returns {Number}
   */
  async estimateSpendingSize(e) {
    let t = 0;
    t += 32 + 4 + 4;
    const i = j4.WITNESS_SCALE_FACTOR, n = this.script;
    if (n.isPubkey())
      return t += 1, t += 1 + 73, t;
    if (n.isPubkeyhash())
      return t += 1, t += 1 + 73, t += 1 + 33, t;
    let [c] = n.getMultisig();
    if (c !== -1) {
      let h = 0;
      return h += 1, h += (1 + 73) * c, h += oM.sizeVarint(h), t += h, t;
    }
    if (n.isWitnessPubkeyhash()) {
      let h = 0;
      return t += 1, h += 1, h += 1 + 73, h += 1 + 33, h = (h + i - 1) / i | 0, t += h, t;
    }
    c = 2;
    let o = 3, d = 1, l = !1;
    if (e) {
      const h = await e(n.getAddress());
      h && (c = h.m, o = h.n, d = h.type, l = h.witness);
    }
    if (n.isScripthash()) {
      let h = 0;
      return l ? d ? (t += 1 + 1 + 1 + 32, h += 1, h += (1 + 73) * c, h += 1 + 1, h += 1, h += (1 + 33) * o, h += 1 + 1, h = (h + i - 1) / i | 0, t += h) : (t += 1 + 1 + 1 + 32, h += 1, h += 1 + 73, h += 1 + 33, h = (h + i - 1) / i | 0, t += h) : (h += 1, h += (1 + 73) * c, h += 1 + 1, h += 1, h += (1 + 33) * o, h += 1 + 1, t += h), t;
    }
    if (n.isWitnessScripthash()) {
      t += 1;
      let h = 0;
      return h += 1, h += 1, h += (1 + 73) * c, h += 1 + 1, h += 1, h += (1 + 33) * o, h += 1 + 1, h = (h + i - 1) / i | 0, t += h, t;
    }
    return t += 110, t;
  }
  /**
   * Write the coin to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    let t = this.height;
    return t === -1 && (t = 2147483647), e.writeU32(this.version), e.writeU32(t), e.writeI64(this.value), e.writeVarBytes(this.script.toRaw()), e.writeU8(this.coinbase ? 1 : 0), e;
  }
  /**
   * Serialize the coin.
   * @returns {Buffer|String}
   */
  toRaw() {
    const e = this.getSize();
    return this.toWriter(W4.write(e)).render();
  }
  /**
   * Inject properties from serialized buffer writer.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    return this.version = e.readU32(), this.height = e.readU32(), this.value = e.readI64(), this.script.fromRaw(e.readVarBytes()), this.coinbase = e.readU8() === 1, this.height === 2147483647 && (this.height = -1), this;
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader(W4.read(e));
  }
  /**
   * Instantiate a coin from a buffer reader.
   * @param {BufferReader} br
   * @returns {Coin}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Instantiate a coin from a serialized Buffer.
   * @param {Buffer} data
   * @param {String?} enc - Encoding, can be `'hex'` or null.
   * @returns {Coin}
   */
  static fromRaw(e, t) {
    return typeof e == "string" && (e = Buffer.from(e, t)), new this().fromRaw(e);
  }
  /**
   * Inject properties from TX.
   * @param {TX} tx
   * @param {Number} index
   * @param {Number} height
   * @returns {Coin}
   */
  fromTX(e, t, i) {
    return Cr(typeof t == "number"), Cr(typeof i == "number"), Cr(t >= 0 && t < e.outputs.length), this.version = e.version, this.height = i, this.value = e.outputs[t].value, this.script = e.outputs[t].script, this.coinbase = e.isCoinbase(), this.hash = e.hash(), this.index = t, this;
  }
  /**
   * Instantiate a coin from a TX
   * @param {TX} tx
   * @param {Number} index - Output index.
   * @param {Number} height
   * @returns {Coin}
   */
  static fromTX(e, t, i) {
    return new this().fromTX(e, t, i);
  }
  /**
   * Test an object to see if it is a Coin.
   * @param {Object} obj
   * @returns {Boolean}
   */
  static isCoin(e) {
    return e instanceof Op;
  }
};
var n2 = aM;
/*!
 * keyring.js - keyring object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
Buffer.alloc(33, 0);
/*!
 * memblock.js - memblock block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
Buffer.alloc(0);
var e8 = { exports: {} }, Sa = {};
/*!
 * compress.js - coin compressor for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const Pp = Ar, { encoding: Rp } = Me, f2 = cc, hM = ri, c2 = 6, dM = Buffer.alloc(0);
function uM(r, e) {
  const t = r.getPubkeyhash(!0);
  if (t)
    return e.writeU8(0), e.writeBytes(t), e;
  const i = r.getScripthash();
  if (i)
    return e.writeU8(1), e.writeBytes(i), e;
  const n = r.getPubkey(!0);
  if (n && kp(n)) {
    const c = gM(n);
    return e.writeBytes(c), e;
  }
  return e.writeVarint(r.raw.length + c2), e.writeBytes(r.raw), e;
}
function lM(r, e) {
  switch (e.readU8()) {
    case 0: {
      const t = e.readBytes(20, !0);
      r.fromPubkeyhash(t);
      break;
    }
    case 1: {
      const t = e.readBytes(20, !0);
      r.fromScripthash(t);
      break;
    }
    case 2:
    case 3:
    case 4:
    case 5: {
      e.offset -= 1;
      const t = e.readBytes(33, !0), i = wM(t);
      r.fromPubkey(i);
      break;
    }
    default: {
      e.offset -= 1;
      const t = e.readVarint() - c2;
      if (t > hM.MAX_SCRIPT_SIZE)
        r.fromNulldata(dM), e.seek(t);
      else {
        const i = e.readBytes(t);
        r.fromRaw(i);
      }
      break;
    }
  }
  return r;
}
function xM(r) {
  if (r.isPubkeyhash(!0) || r.isScripthash())
    return 21;
  const e = r.getPubkey(!0);
  if (e && kp(e))
    return 33;
  let t = 0;
  return t += Rp.sizeVarint(r.raw.length + c2), t += r.raw.length, t;
}
function bM(r, e) {
  return e.writeVarint(r.value), uM(r.script, e), e;
}
function pM(r, e) {
  return r.value = e.readVarint(), lM(r.script, e), r;
}
function mM(r) {
  let e = 0;
  return e += Rp.sizeVarint(r.value), e += xM(r.script), e;
}
function kp(r) {
  if (r.length === 0)
    return !1;
  switch (r[0]) {
    case 2:
    case 3:
      return r.length === 33;
    case 4:
      return r.length !== 65 ? !1 : f2.publicKeyVerify(r);
    default:
      return !1;
  }
}
function gM(r) {
  let e;
  switch (r[0]) {
    case 2:
    case 3:
      e = r;
      break;
    case 4:
      e = f2.publicKeyConvert(r, !0), e[0] = 4 | r[64] & 1;
      break;
    default:
      throw new Error("Bad point format.");
  }
  return Pp(e.length === 33), e;
}
function wM(r) {
  const e = r[0];
  switch (Pp(r.length === 33), e) {
    case 2:
    case 3:
      return r;
    case 4:
      r[0] = 2;
      break;
    case 5:
      r[0] = 3;
      break;
    default:
      throw new Error("Bad point format.");
  }
  const t = f2.publicKeyConvert(r, !1);
  return r[0] = e, t;
}
Sa.pack = bM;
Sa.unpack = pM;
Sa.size = mM;
/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const su = Ar, $1 = Me, yM = n2, SM = uc, nu = Sa, { encoding: BM } = $1, H1 = 1, t8 = (1 << 32 - H1 >>> 0) - 1;
let vM = class {
  /**
   * Create a coin entry.
   * @constructor
   */
  constructor() {
    this.version = 1, this.height = -1, this.coinbase = !1, this.output = new SM(), this.spent = !1, this.raw = null;
  }
  /**
   * Convert coin entry to an output.
   * @returns {Output}
   */
  toOutput() {
    return this.output;
  }
  /**
   * Convert coin entry to a coin.
   * @param {Outpoint} prevout
   * @returns {Coin}
   */
  toCoin(e) {
    const t = new yM();
    return t.version = this.version, t.height = this.height, t.coinbase = this.coinbase, t.script = this.output.script, t.value = this.output.value, t.hash = e.hash, t.index = e.index, t;
  }
  /**
   * Inject properties from TX.
   * @param {Output} output
   */
  fromOutput(e) {
    return this.output = e, this;
  }
  /**
   * Instantiate a coin from a TX
   * @param {Output} output
   * @returns {CoinEntry}
   */
  static fromOutput(e) {
    return new this().fromOutput(e);
  }
  /**
   * Inject properties from TX.
   * @param {Coin} coin
   */
  fromCoin(e) {
    return this.version = e.version, this.height = e.height, this.coinbase = e.coinbase, this.output.script = e.script, this.output.value = e.value, this;
  }
  /**
   * Instantiate a coin from a TX
   * @param {Coin} coin
   * @returns {CoinEntry}
   */
  static fromCoin(e) {
    return new this().fromCoin(e);
  }
  /**
   * Inject properties from TX.
   * @param {TX} tx
   * @param {Number} index
   * @param {Number} height
   */
  fromTX(e, t, i) {
    return su(typeof t == "number"), su(typeof i == "number"), su(t >= 0 && t < e.outputs.length), this.version = e.version, this.height = i, this.coinbase = e.isCoinbase(), this.output = e.outputs[t], this;
  }
  /**
   * Instantiate a coin from a TX
   * @param {TX} tx
   * @param {Number} index - Output index.
   * @param {Number} height
   * @returns {CoinEntry}
   */
  static fromTX(e, t, i) {
    return new this().fromTX(e, t, i);
  }
  /**
   * Calculate size of coin.
   * @returns {Number}
   */
  getSize() {
    if (this.raw)
      return this.raw.length;
    let e = 0;
    return e += BM.sizeVarint(this.version), e += 4, e += nu.size(this.output), e;
  }
  /**
   * Write the coin to a buffer writer.
   * @param {BufferWriter} bw
   */
  toWriter(e) {
    if (this.raw)
      return e.writeBytes(this.raw), e;
    let t = this.height, i = 0;
    return this.coinbase && (i |= 1), t === -1 && (t = t8), i |= t << H1, e.writeVarint(this.version), e.writeU32(i), nu.pack(this.output, e), e;
  }
  /**
   * Serialize the coin.
   * @returns {Buffer}
   */
  toRaw() {
    if (this.raw)
      return this.raw;
    const e = this.getSize(), t = $1.write(e);
    return this.toWriter(t), this.raw = t.render(), this.raw;
  }
  /**
   * Inject properties from serialized buffer writer.
   * @private
   * @param {BufferReader} br
   */
  fromReader(e) {
    const t = e.readVarint(), i = e.readU32();
    let n = i >>> H1;
    return n === t8 && (n = -1), this.version = t, this.coinbase = (i & 1) !== 0, this.height = n, nu.unpack(this.output, e), this;
  }
  /**
   * Instantiate a coin from a serialized Buffer.
   * @param {Buffer} data
   * @returns {CoinEntry}
   */
  static fromReader(e) {
    return new this().fromReader(e);
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   */
  fromRaw(e) {
    return this.fromReader($1.read(e)), this.raw = e, this;
  }
  /**
   * Instantiate a coin from a serialized Buffer.
   * @param {Buffer} data
   * @returns {CoinEntry}
   */
  static fromRaw(e) {
    return new this().fromRaw(e);
  }
};
var o2 = vM;
/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const fu = Ar, Tc = o2;
let EM = class {
  /**
   * Create coins.
   * @constructor
   */
  constructor() {
    this.outputs = /* @__PURE__ */ new Map();
  }
  /**
   * Add a single entry to the collection.
   * @param {Number} index
   * @param {CoinEntry} coin
   * @returns {CoinEntry}
   */
  add(e, t) {
    return fu(e >>> 0 === e), fu(t), this.outputs.set(e, t), t;
  }
  /**
   * Add a single output to the collection.
   * @param {Number} index
   * @param {Output} output
   * @returns {CoinEntry}
   */
  addOutput(e, t) {
    return this.add(e, Tc.fromOutput(t));
  }
  /**
   * Add an output to the collection by output index.
   * @param {TX} tx
   * @param {Number} index
   * @param {Number} height
   * @returns {CoinEntry}
   */
  addIndex(e, t, i) {
    return this.add(t, Tc.fromTX(e, t, i));
  }
  /**
   * Add a single coin to the collection.
   * @param {Coin} coin
   * @returns {CoinEntry}
   */
  addCoin(e) {
    return this.add(e.index, Tc.fromCoin(e));
  }
  /**
   * Test whether the collection has a coin.
   * @param {Number} index
   * @returns {Boolean}
   */
  has(e) {
    return this.outputs.has(e);
  }
  /**
   * Test whether the collection has an unspent coin.
   * @param {Number} index
   * @returns {Boolean}
   */
  isUnspent(e) {
    const t = this.outputs.get(e);
    return !(!t || t.spent);
  }
  /**
   * Get a coin entry.
   * @param {Number} index
   * @returns {CoinEntry|null}
   */
  get(e) {
    return this.outputs.get(e) || null;
  }
  /**
   * Get an output.
   * @param {Number} index
   * @returns {Output|null}
   */
  getOutput(e) {
    const t = this.outputs.get(e);
    return t ? t.output : null;
  }
  /**
   * Get a coin.
   * @param {Outpoint} prevout
   * @returns {Coin|null}
   */
  getCoin(e) {
    const t = this.outputs.get(e.index);
    return t ? t.toCoin(e) : null;
  }
  /**
   * Spend a coin entry and return it.
   * @param {Number} index
   * @returns {CoinEntry|null}
   */
  spend(e) {
    const t = this.get(e);
    return !t || t.spent ? null : (t.spent = !0, t);
  }
  /**
   * Remove a coin entry and return it.
   * @param {Number} index
   * @returns {CoinEntry|null}
   */
  remove(e) {
    const t = this.get(e);
    return t ? (this.outputs.delete(e), t) : null;
  }
  /**
   * Test whether the coins are fully spent.
   * @returns {Boolean}
   */
  isEmpty() {
    return this.outputs.size === 0;
  }
  /**
   * Inject properties from tx.
   * @private
   * @param {TX} tx
   * @param {Number} height
   * @returns {Coins}
   */
  fromTX(e, t) {
    fu(typeof t == "number");
    for (let i = 0; i < e.outputs.length; i++) {
      if (e.outputs[i].script.isUnspendable())
        continue;
      const c = Tc.fromTX(e, i, t);
      this.outputs.set(i, c);
    }
    return this;
  }
  /**
   * Instantiate a coins object from a transaction.
   * @param {TX} tx
   * @param {Number} height
   * @returns {Coins}
   */
  static fromTX(e, t) {
    return new this().fromTX(e, t);
  }
};
var IM = EM;
/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const AM = Ar, r8 = Me, _M = o2;
let MM = class {
  /**
   * Create undo coins.
   * @constructor
   */
  constructor() {
    this.items = [];
  }
  /**
   * Push coin entry onto undo coin array.
   * @param {CoinEntry} coin
   * @returns {Number}
   */
  push(e) {
    return this.items.push(e);
  }
  /**
   * Calculate undo coins size.
   * @returns {Number}
   */
  getSize() {
    let e = 0;
    e += 4;
    for (const t of this.items)
      e += t.getSize();
    return e;
  }
  /**
   * Serialize all undo coins.
   * @returns {Buffer}
   */
  toRaw() {
    const e = this.getSize(), t = r8.write(e);
    t.writeU32(this.items.length);
    for (const i of this.items)
      i.toWriter(t);
    return t.render();
  }
  /**
   * Inject properties from serialized data.
   * @private
   * @param {Buffer} data
   * @returns {UndoCoins}
   */
  fromRaw(e) {
    const t = r8.read(e), i = t.readU32();
    for (let n = 0; n < i; n++)
      this.items.push(_M.fromReader(t));
    return this;
  }
  /**
   * Instantiate undo coins from serialized data.
   * @param {Buffer} data
   * @returns {UndoCoins}
   */
  static fromRaw(e) {
    return new this().fromRaw(e);
  }
  /**
   * Test whether the undo coins have any members.
   * @returns {Boolean}
   */
  isEmpty() {
    return this.items.length === 0;
  }
  /**
   * Render the undo coins.
   * @returns {Buffer}
   */
  commit() {
    const e = this.toRaw();
    return this.items.length = 0, e;
  }
  /**
   * Re-apply undo coins to a view, effectively unspending them.
   * @param {CoinView} view
   * @param {Outpoint} prevout
   */
  apply(e, t) {
    const i = this.items.pop();
    AM(i), e.addEntry(t, i);
  }
};
var NM = MM;
/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
const { BufferMap: OM } = ac, cu = IM, PM = NM, RM = o2;
class kM {
  /**
   * Create a coin view.
   * @constructor
   */
  constructor() {
    this.map = new OM(), this.undo = new PM();
  }
  /**
   * Get coins.
   * @param {Hash} hash
   * @returns {Coins} coins
   */
  get(e) {
    return this.map.get(e);
  }
  /**
   * Test whether the view has an entry.
   * @param {Hash} hash
   * @returns {Boolean}
   */
  has(e) {
    return this.map.has(e);
  }
  /**
   * Add coins to the collection.
   * @param {Hash} hash
   * @param {Coins} coins
   * @returns {Coins}
   */
  add(e, t) {
    return this.map.set(e, t), t;
  }
  /**
   * Ensure existence of coins object in the collection.
   * @param {Hash} hash
   * @returns {Coins}
   */
  ensure(e) {
    const t = this.map.get(e);
    return t || this.add(e, new cu());
  }
  /**
   * Remove coins from the collection.
   * @param {Hash} hash
   * @returns {Coins|null}
   */
  remove(e) {
    const t = this.map.get(e);
    return t ? (this.map.delete(e), t) : null;
  }
  /**
   * Add a tx to the collection.
   * @param {TX} tx
   * @param {Number} height
   * @returns {Coins}
   */
  addTX(e, t) {
    const i = e.hash(), n = cu.fromTX(e, t);
    return this.add(i, n);
  }
  /**
   * Remove a tx from the collection.
   * @param {TX} tx
   * @param {Number} height
   * @returns {Coins}
   */
  removeTX(e, t) {
    const i = e.hash(), n = cu.fromTX(e, t);
    for (const c of n.outputs.values())
      c.spent = !0;
    return this.add(i, n);
  }
  /**
   * Add an entry to the collection.
   * @param {Outpoint} prevout
   * @param {CoinEntry} coin
   * @returns {CoinEntry|null}
   */
  addEntry(e, t) {
    const { hash: i, index: n } = e;
    return this.ensure(i).add(n, t);
  }
  /**
   * Add a coin to the collection.
   * @param {Coin} coin
   * @returns {CoinEntry|null}
   */
  addCoin(e) {
    return this.ensure(e.hash).addCoin(e);
  }
  /**
   * Add an output to the collection.
   * @param {Outpoint} prevout
   * @param {Output} output
   * @returns {CoinEntry|null}
   */
  addOutput(e, t) {
    const { hash: i, index: n } = e;
    return this.ensure(i).addOutput(n, t);
  }
  /**
   * Add an output to the collection by output index.
   * @param {TX} tx
   * @param {Number} index
   * @param {Number} height
   * @returns {CoinEntry|null}
   */
  addIndex(e, t, i) {
    const n = e.hash();
    return this.ensure(n).addIndex(e, t, i);
  }
  /**
   * Spend an output.
   * @param {Outpoint} prevout
   * @returns {CoinEntry|null}
   */
  spendEntry(e) {
    const { hash: t, index: i } = e, n = this.get(t);
    if (!n)
      return null;
    const c = n.spend(i);
    return c ? (this.undo.push(c), c) : null;
  }
  /**
   * Remove an output.
   * @param {Outpoint} prevout
   * @returns {CoinEntry|null}
   */
  removeEntry(e) {
    const { hash: t, index: i } = e, n = this.get(t);
    return n ? n.remove(i) : null;
  }
  /**
   * Test whether the view has an entry by prevout.
   * @param {Outpoint} prevout
   * @returns {Boolean}
   */
  hasEntry(e) {
    const { hash: t, index: i } = e, n = this.get(t);
    return n ? n.has(i) : !1;
  }
  /**
   * Get a single entry by prevout.
   * @param {Outpoint} prevout
   * @returns {CoinEntry|null}
   */
  getEntry(e) {
    const { hash: t, index: i } = e, n = this.get(t);
    return n ? n.get(i) : null;
  }
  /**
   * Test whether an entry has been spent by prevout.
   * @param {Outpoint} prevout
   * @returns {Boolean}
   */
  isUnspent(e) {
    const { hash: t, index: i } = e, n = this.get(t);
    return n ? n.isUnspent(i) : !1;
  }
  /**
   * Get a single coin by prevout.
   * @param {Outpoint} prevout
   * @returns {Coin|null}
   */
  getCoin(e) {
    const t = this.get(e.hash);
    return t ? t.getCoin(e) : null;
  }
  /**
   * Get a single output by prevout.
   * @param {Outpoint} prevout
   * @returns {Output|null}
   */
  getOutput(e) {
    const { hash: t, index: i } = e, n = this.get(t);
    return n ? n.getOutput(i) : null;
  }
  /**
   * Get coins height by prevout.
   * @param {Outpoint} prevout
   * @returns {Number}
   */
  getHeight(e) {
    const t = this.getEntry(e);
    return t ? t.height : -1;
  }
  /**
   * Get coins coinbase flag by prevout.
   * @param {Outpoint} prevout
   * @returns {Boolean}
   */
  isCoinbase(e) {
    const t = this.getEntry(e);
    return t ? t.coinbase : !1;
  }
  /**
   * Test whether the view has an entry by input.
   * @param {Input} input
   * @returns {Boolean}
   */
  hasEntryFor(e) {
    return this.hasEntry(e.prevout);
  }
  /**
   * Get a single entry by input.
   * @param {Input} input
   * @returns {CoinEntry|null}
   */
  getEntryFor(e) {
    return this.getEntry(e.prevout);
  }
  /**
   * Test whether an entry has been spent by input.
   * @param {Input} input
   * @returns {Boolean}
   */
  isUnspentFor(e) {
    return this.isUnspent(e.prevout);
  }
  /**
   * Get a single coin by input.
   * @param {Input} input
   * @returns {Coin|null}
   */
  getCoinFor(e) {
    return this.getCoin(e.prevout);
  }
  /**
   * Get a single output by input.
   * @param {Input} input
   * @returns {Output|null}
   */
  getOutputFor(e) {
    return this.getOutput(e.prevout);
  }
  /**
   * Get coins height by input.
   * @param {Input} input
   * @returns {Number}
   */
  getHeightFor(e) {
    return this.getHeight(e.prevout);
  }
  /**
   * Get coins coinbase flag by input.
   * @param {Input} input
   * @returns {Boolean}
   */
  isCoinbaseFor(e) {
    return this.isCoinbase(e.prevout);
  }
  /**
   * Retrieve coins from database.
   * @method
   * @param {ChainDB} db
   * @param {Outpoint} prevout
   * @returns {Promise} - Returns {@link CoinEntry}.
   */
  async readCoin(e, t) {
    const i = this.getEntry(t);
    if (i)
      return i;
    const n = await e.readCoin(t);
    return n ? this.addEntry(t, n) : null;
  }
  /**
   * Read all input coins into unspent map.
   * @method
   * @param {ChainDB} db
   * @param {TX} tx
   * @returns {Promise} - Returns {Boolean}.
   */
  async readInputs(e, t) {
    let i = !0;
    for (const { prevout: n } of t.inputs)
      await this.readCoin(e, n) || (i = !1);
    return i;
  }
  /**
   * Spend coins for transaction.
   * @method
   * @param {ChainDB} db
   * @param {TX} tx
   * @returns {Promise} - Returns {Boolean}.
   */
  async spendInputs(e, t) {
    let i = 0;
    for (; i < t.inputs.length; ) {
      const n = Math.min(i + 4, t.inputs.length), c = [];
      for (; i < n; i++) {
        const { prevout: d } = t.inputs[i];
        c.push(this.readCoin(e, d));
      }
      const o = await Promise.all(c);
      for (const d of o) {
        if (!d || d.spent)
          return !1;
        d.spent = !0, this.undo.push(d);
      }
    }
    return !0;
  }
  /**
   * Calculate serialization size.
   * @returns {Number}
   */
  getSize(e) {
    let t = 0;
    t += e.inputs.length;
    for (const { prevout: i } of e.inputs) {
      const n = this.getEntry(i);
      n && (t += n.getSize());
    }
    return t;
  }
  /**
   * Write coin data to buffer writer
   * as it pertains to a transaction.
   * @param {BufferWriter} bw
   * @param {TX} tx
   */
  toWriter(e, t) {
    for (const { prevout: i } of t.inputs) {
      const n = this.getEntry(i);
      if (!n) {
        e.writeU8(0);
        continue;
      }
      e.writeU8(1), n.toWriter(e);
    }
    return e;
  }
  /**
   * Read serialized view data from a buffer
   * reader as it pertains to a transaction.
   * @private
   * @param {BufferReader} br
   * @param {TX} tx
   */
  fromReader(e, t) {
    for (const { prevout: i } of t.inputs) {
      if (e.readU8() === 0)
        continue;
      const n = RM.fromReader(e);
      this.addEntry(i, n);
    }
    return this;
  }
  /**
   * Read serialized view data from a buffer
   * reader as it pertains to a transaction.
   * @param {BufferReader} br
   * @param {TX} tx
   * @returns {CoinView}
   */
  static fromReader(e, t) {
    return new this().fromReader(e, t);
  }
}
var qM = kM, F1 = { exports: {} };
/*!
 * coinselector.js - coin selector class for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r, e) {
  const t = Ar, { BufferMap: i } = ac, n = uc, c = n2, o = ef, d = ga, l = ri, h = jn, x = wa;
  class b {
    /**
     * Create a credit.
     * @constructor
     * @param {Number} spendingSize
     * @param {Number} effectiveValue
     * @param {number} index
     */
    constructor(_, q, U) {
      this.spendingSize = _, this.effectiveValue = q, this.index = U;
    }
  }
  class g {
    /**
     * Create a coin selector.
     * @constructor
     * @param {MTX} tx
     * @param {Object?} options
     */
    constructor(_, q) {
      this.tx = _.clone(), this.coins = [], this.coinPointers = [], this.outputValue = 0, this.chosen = [], this.change = 0, this.fee = g.MIN_FEE, this.selection = "value", this.subtractFee = !1, this.subtractIndex = -1, this.height = -1, this.depth = -1, this.hardFee = -1, this.rate = g.FEE_RATE, this.maxFee = -1, this.round = !1, this.changeAddress = null, this.inputs = new i(), this.useSelectEstimate = !1, this.getAccount = null, this.injectInputs(), q && this.fromOptions(q);
    }
    /**
     * Initialize selector options.
     * @param {Object} options
     * @private
     */
    fromOptions(_) {
      if (_.selection && (t(typeof _.selection == "string"), this.selection = _.selection), _.subtractFee != null && (typeof _.subtractFee == "number" ? (t(Number.isSafeInteger(_.subtractFee)), t(_.subtractFee >= -1), this.subtractIndex = _.subtractFee, this.subtractFee = this.subtractIndex !== -1) : (t(typeof _.subtractFee == "boolean"), this.subtractFee = _.subtractFee)), _.subtractIndex != null && (t(Number.isSafeInteger(_.subtractIndex)), t(_.subtractIndex >= -1), this.subtractIndex = _.subtractIndex, this.subtractFee = this.subtractIndex !== -1), _.height != null && (t(Number.isSafeInteger(_.height)), t(_.height >= -1), this.height = _.height), _.confirmations != null && (t(Number.isSafeInteger(_.confirmations)), t(_.confirmations >= -1), this.depth = _.confirmations), _.depth != null && (t(Number.isSafeInteger(_.depth)), t(_.depth >= -1), this.depth = _.depth), _.hardFee != null && (t(Number.isSafeInteger(_.hardFee)), t(_.hardFee >= -1), this.hardFee = _.hardFee), _.rate != null && (t(Number.isSafeInteger(_.rate)), t(_.rate >= 0), this.rate = _.rate), _.maxFee != null && (t(Number.isSafeInteger(_.maxFee)), t(_.maxFee >= -1), this.maxFee = _.maxFee), _.round != null && (t(typeof _.round == "boolean"), this.round = _.round), _.useSelectEstimate != null && (t(typeof _.useSelectEstimate == "boolean"), this.useSelectEstimate = _.useSelectEstimate), _.changeAddress) {
        const q = _.changeAddress;
        typeof q == "string" ? this.changeAddress = d.fromString(q) : (t(q instanceof d), this.changeAddress = q);
      }
      if (_.getAccount && (t(typeof _.getAccount == "function"), this.getAccount = _.getAccount), _.inputs) {
        t(Array.isArray(_.inputs));
        for (let q = 0; q < _.inputs.length; q++) {
          const U = _.inputs[q];
          t(U && typeof U == "object");
          const { hash: z, index: E } = U;
          t(Buffer.isBuffer(z)), t(typeof E == "number"), this.inputs.set(o.toKey(z, E), q);
        }
      }
      return this;
    }
    /**
     * Attempt to inject existing inputs.
     * @private
     */
    injectInputs() {
      if (this.tx.inputs.length > 0)
        for (let _ = 0; _ < this.tx.inputs.length; _++) {
          const { prevout: q } = this.tx.inputs[_];
          this.inputs.set(q.toKey(), _);
        }
    }
    /**
     * Initialize the selector with coins to select from.
     * @param {Coin[]} coins
     */
    async init(_) {
      switch (this.coins = _.slice(), this.outputValue = this.tx.getOutputValue(), this.chosen = [], this.change = 0, this.fee = g.MIN_FEE, this.tx.inputs.length = 0, this.selection) {
        case "all":
        case "random":
          this.coins.sort(B);
          break;
        case "age":
          this.coins.sort(I);
          break;
        case "value":
          this.coins.sort(y);
          break;
        default:
          throw new w(`Bad selection type: ${this.selection}.`);
      }
      if (!this.useSelectEstimate) {
        for (let q = 0, U = _.length; q < U; q++) {
          const z = this.coins[q];
          if (this.isSpendable(z)) {
            const E = await z.estimateSpendingSize(this.getAccount), H = z.value - this.getFee(E), k = new b(E, H, q);
            this.coinPointers.push(k);
          }
        }
        this.coinPointers.sort((q, U) => U.effectiveValue - q.effectiveValue);
      }
    }
    /**
     * Calculate total value required.
     * @returns {Number}
     */
    total() {
      return this.subtractFee ? this.outputValue : this.outputValue + this.fee;
    }
    /**
     * Test whether the selector has
     * completely funded the transaction.
     * @returns {Boolean}
     */
    isFull() {
      return this.tx.getInputValue() >= this.total();
    }
    /**
     * Test whether a coin is spendable
     * with regards to the options.
     * @param {Coin} coin
     * @returns {Boolean}
     */
    isSpendable(_) {
      return this.tx.view.hasEntry(_) ? !1 : this.height === -1 ? !0 : _.coinbase ? !(_.height === -1 || this.height + 1 < _.height + l.COINBASE_MATURITY) : this.depth === -1 ? !0 : !(_.getDepth(this.height) < this.depth);
    }
    /**
     * Get the current fee based on a size.
     * @param {Number} size
     * @returns {Number} fee
     */
    getFee(_) {
      if (this.round) {
        const U = h.getRoundFee(_, this.rate);
        return Math.min(U, g.MAX_FEE);
      }
      const q = h.getMinFee(_, this.rate);
      return Math.min(q, g.MAX_FEE);
    }
    /**
     * Fund the transaction with more
     * coins if the `output value + fee`
     * total was updated.
     * @param {Number} index
     * @returns {Number} index
     */
    fund(_) {
      if (this.inputs.size > 0) {
        const q = [];
        for (let U = 0; U < this.inputs.size; U++)
          q.push(null);
        for (const U of this.coins) {
          const { hash: z, index: E } = U, H = o.toKey(z, E), k = this.inputs.get(H);
          k != null && (q[k] = U, this.inputs.delete(H));
        }
        if (this.inputs.size > 0)
          throw new Error("Could not resolve preferred inputs.");
        for (const U of q)
          this.tx.addCoin(U), this.chosen.push(U);
      }
      for (; _ < this.coins.length; ) {
        const q = this.coins[_++];
        if (this.isSpendable(q) && (this.tx.addCoin(q), this.chosen.push(q), this.selection !== "all" && this.isFull()))
          break;
      }
      return _;
    }
    /**
     * Initiate selection from `coins`.
     * @param {Coin[]} coins
     * @returns {CoinSelector}
     */
    async select(_) {
      if (await this.init(_), this.hardFee !== -1)
        this.selectHard();
      else if (this.useSelectEstimate) {
        if (await this.selectEstimate(), !this.isFull())
          throw new w("Not enough funds.", this.tx.getInputValue(), this.total());
      } else
        await this.attemptSelection();
      return this.change = this.tx.getInputValue() - this.total(), this;
    }
    /**
     * Initialize selection based on size estimate.
     */
    async selectEstimate() {
      let _ = 0;
      this.fee = g.MIN_FEE, _ = this.fund(_);
      const q = new n();
      this.changeAddress ? q.script.fromAddress(this.changeAddress) : q.script.fromProgram(0, Buffer.allocUnsafe(20)), this.tx.outputs.push(q);
      do {
        const U = await this.tx.estimateSize(this.getAccount);
        if (this.fee = this.getFee(U), this.maxFee > 0 && this.fee > this.maxFee)
          throw new w("Fee is too high.");
        this.isFull() || (_ = this.fund(_));
      } while (!this.isFull() && _ < this.coins.length);
    }
    /**
     * Initiate selection based on a hard fee.
     */
    selectHard() {
      this.fee = Math.min(this.hardFee, g.MAX_FEE), this.fund(0);
    }
    /**
     * Initiate multi algorithm coin selection.
     */
    async attemptSelection() {
      const _ = new n();
      this.changeAddress ? _.script.fromAddress(this.changeAddress) : _.script.fromProgram(0, Buffer.allocUnsafe(20));
      const q = _.getSize(), U = new c();
      U.script = _.script;
      const E = await U.estimateSpendingSize(this.getAccount) * g.LONG_TERM_FEERATE, H = this.getFee(q) + E;
      let k = this.outputValue, V = await this.tx.estimateSize(this.getAccount);
      const T = this.getFee(V);
      k += T;
      let ie = [], N = l.MAX_MONEY, G = !1, F = this.selectBnB(k, H);
      if (F && F.length > 0 && (ie = F, N = this.getWaste(F, H, k)), k += this.getFee(q), F = this.selectLowestLarger(k), F.length > 0) {
        const W = this.getWaste(F, H, k);
        W < N && (ie = F, N = W, G = !0);
      }
      if (F = this.selectSRD(k), F.length > 0) {
        const W = this.getWaste(F, H, k);
        W <= N && (ie = F, N = W, G = !0);
      }
      if (ie && ie.length > 0) {
        for (const W of ie) {
          const ce = this.coins[this.coinPointers[W].index];
          this.tx.addCoin(ce), this.chosen.push(ce);
        }
        G && this.tx.outputs.push(_), V = await this.tx.estimateSize(this.getAccount), this.fee = this.getFee(V);
      }
    }
    /**
     * Initiate selection using Single Random Draw selection.
     * @param {Number} target - Selection target
     * @returns {Number[]} selected - array of indicies of selected coins
     */
    selectSRD(_) {
      const q = [...this.coinPointers.keys()];
      q.sort(() => Math.random() - 0.5);
      let U = 0;
      const z = [];
      let E = 0;
      for (; U < q.length; ) {
        const H = this.coinPointers[q[U]];
        if (E += H.effectiveValue, z.push(q[U]), E >= _)
          return z;
        U++;
      }
      return [];
    }
    /**
     * Initiate selection using Branch and Bound selection.
     * @param {Number} target - Selection target
     * @param {Number} costOfChange - Cost of producing and spending change
     * @returns {Number[]} selected - array of indicies of selected coins
     */
    selectBnB(_, q) {
      const U = [];
      let z = 0, E = 0, H = 0;
      for (const ie of this.coinPointers)
        E += ie.effectiveValue;
      if (E < _)
        throw new w("Not enough funds.", E, _);
      let k = 1e5, V = l.MAX_MONEY, T = [];
      for (; k-- > 0; ) {
        let ie = !1;
        if (z + E < _ || z > _ + q)
          ie = !0;
        else if (z >= _) {
          const N = this.getWaste(U, 0, _);
          N <= V && (T = U.slice(), V = N), ie = !0;
        }
        if (ie) {
          if (U.length === 0)
            break;
          for (; --H > U[U.length - 1]; )
            E += this.coinPointers[H].effectiveValue;
          z -= this.coinPointers[H].effectiveValue, U.pop();
        } else {
          const N = this.coinPointers[H];
          E -= N.effectiveValue, (U.length === 0 || H - 1 === U[U.length - 1] || N.effectiveValue !== this.coinPointers[H - 1].effectiveValue) && (U.push(H), z += this.coinPointers[H].effectiveValue);
        }
        H++;
      }
      return T;
    }
    /**
     * Initiate selection using Lowest Larger selection algorithm.
     * @param {Number} target - Selection target
     * @returns {Number[]} selected - array of indicies of selected coins
     */
    selectLowestLarger(_) {
      let q = 0;
      const U = [];
      let z = this.coinPointers[q].effectiveValue;
      for (; _ >= z && (U.push(q), _ -= z, q++, q !== this.coinPointers.length); )
        z = this.coinPointers[q].effectiveValue;
      if (_ > 0 && q !== this.coinPointers.length) {
        const E = this.findLowestLarger(_, q);
        _ -= this.coinPointers[E].effectiveValue, U.push(E);
      }
      return _ > 0 ? [] : U;
    }
    /**
     * Find smallest coin greater than
     * the target using binary search
     * @param {Number} target
     * @param {Number} index
     * @returns {Number} index
     */
    findLowestLarger(_, q) {
      let U = q, z = this.coinPointers.length - 1, E = 0, H = 0;
      for (; U <= z; ) {
        H = Math.floor((U + z) / 2);
        const k = this.coinPointers[H].effectiveValue;
        _ <= k ? (E = H, U = H + 1) : z = H - 1;
      }
      return E;
    }
    /**
     * Calculate waste for a selection
     * @param {Number[]} selected - indicies of selected coins
     * @param {Number} costOfChange - the cost of making change and spending it
     * @param {Number} target - selection target
     * @returns {Number} - waste
     */
    getWaste(_, q, U) {
      let z = 0, E = 0;
      const H = this.getFee(1);
      for (const k of _) {
        const V = this.coinPointers[k];
        E += V.effectiveValue, z += (H - g.LONG_TERM_FEERATE) * V.spendingSize;
      }
      return q > 0 ? z += q : z += E - U, z;
    }
  }
  g.FEE_RATE = 1e4, g.MIN_FEE = 1e4, g.MAX_FEE = l.COIN / 10, g.LONG_TERM_FEERATE = 5;
  class w extends Error {
    /**
     * Create a funding error.
     * @constructor
     * @param {String} msg
     * @param {Number} available
     * @param {Number} required
     */
    constructor(_, q, U) {
      super(), this.type = "FundingError", this.message = _, this.availableFunds = -1, this.requiredFunds = -1, q != null && (this.message += ` (available=${x.btc(q)},`, this.message += ` required=${x.btc(U)})`, this.availableFunds = q, this.requiredFunds = U), Error.captureStackTrace && Error.captureStackTrace(this, w);
    }
  }
  function I(A, _) {
    return A = A.height === -1 ? 2147483647 : A.height, _ = _.height === -1 ? 2147483647 : _.height, A - _;
  }
  function B(A, _) {
    return Math.random() > 0.5 ? 1 : -1;
  }
  function y(A, _) {
    return A.height === -1 && _.height !== -1 ? 1 : A.height !== -1 && _.height === -1 ? -1 : _.value - A.value;
  }
  e.CoinSelector = g, e.CoinPointer = b, e.FundingError = w, r.exports = e;
})(F1, F1.exports);
var zM = F1.exports;
/*!
 * mtx.js - mutable transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
(function(r, e) {
  const t = Ar, { encoding: i } = Me, n = dc, c = tM, o = Np, d = uc, l = n2, h = ef, x = qM, b = ri, g = jn, w = i2, I = Os, { inspectSymbol: B } = Gr, { CoinSelector: y, FundingError: A } = zM;
  class _ extends c {
    /**
     * Create a mutable transaction.
     * @alias module:primitives.MTX
     * @constructor
     * @param {Object} options
     */
    constructor(E) {
      super(), this.mutable = !0, this.changeIndex = -1, this.view = new x(), E && this.fromOptions(E);
    }
    /**
     * Inject properties from options object.
     * @private
     * @param {Object} options
     */
    fromOptions(E) {
      if (E.version != null && (t(E.version >>> 0 === E.version, "Version must a be uint32."), this.version = E.version), E.inputs) {
        t(Array.isArray(E.inputs), "Inputs must be an array.");
        for (const H of E.inputs)
          this.addInput(H);
      }
      if (E.outputs) {
        t(Array.isArray(E.outputs), "Outputs must be an array.");
        for (const H of E.outputs)
          this.addOutput(H);
      }
      return E.locktime != null && (t(E.locktime >>> 0 === E.locktime, "Locktime must be a uint32."), this.locktime = E.locktime), E.changeIndex != null && (E.changeIndex !== -1 ? (t(E.changeIndex >>> 0 === E.changeIndex, "Change index must be a uint32."), this.changeIndex = E.changeIndex) : this.changeIndex = -1), this;
    }
    /**
     * Instantiate MTX from options.
     * @param {Object} options
     * @returns {MTX}
     */
    static fromOptions(E) {
      return new this().fromOptions(E);
    }
    /**
     * Clone the transaction. Note that
     * this will not carry over the view.
     * @returns {MTX}
     */
    clone() {
      const E = new this.constructor();
      return E.inject(this), E.changeIndex = this.changeIndex, E;
    }
    /**
     * Add an input to the transaction.
     * @param {Input|Object} options
     * @returns {Input}
     *
     * @example
     * mtx.addInput({ prevout: { hash: ... }, script: ... });
     * mtx.addInput(new Input());
     */
    addInput(E) {
      const H = o.fromOptions(E);
      return this.inputs.push(H), H;
    }
    /**
     * Add an outpoint as an input.
     * @param {Outpoint|Object} outpoint
     * @returns {Input}
     *
     * @example
     * mtx.addOutpoint({ hash: ..., index: 0 });
     * mtx.addOutpoint(new Outpoint(hash, index));
     */
    addOutpoint(E) {
      const H = h.fromOptions(E), k = o.fromOutpoint(H);
      return this.inputs.push(k), k;
    }
    /**
     * Add a coin as an input. Note that this will
     * add the coin to the internal coin viewpoint.
     * @param {Coin} coin
     * @returns {Input}
     *
     * @example
     * mtx.addCoin(Coin.fromTX(tx, 0, -1));
     */
    addCoin(E) {
      t(E instanceof l, "Cannot add non-coin.");
      const H = o.fromCoin(E);
      return this.inputs.push(H), this.view.addCoin(E), H;
    }
    /**
     * Add a transaction as an input. Note that
     * this will add the coin to the internal
     * coin viewpoint.
     * @param {TX} tx
     * @param {Number} index
     * @param {Number?} height
     * @returns {Input}
     *
     * @example
     * mtx.addTX(tx, 0);
     */
    addTX(E, H, k) {
      t(E instanceof c, "Cannot add non-transaction."), k == null && (k = -1);
      const V = o.fromTX(E, H);
      return this.inputs.push(V), this.view.addIndex(E, H, k), V;
    }
    /**
     * Add an output.
     * @param {Address|Script|Output|Object} script - Script or output options.
     * @param {Amount?} value
     * @returns {Output}
     *
     * @example
     * mtx.addOutput(new Output());
     * mtx.addOutput({ address: ..., value: 100000 });
     * mtx.addOutput(address, 100000);
     * mtx.addOutput(script, 100000);
     */
    addOutput(E, H) {
      let k;
      return H != null ? k = d.fromScript(E, H) : k = d.fromOptions(E), this.outputs.push(k), k;
    }
    /**
     * Verify all transaction inputs.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the inputs are valid.
     * @throws {ScriptError} on invalid inputs
     */
    check(E) {
      return super.check(this.view, E);
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    checkAsync(E, H) {
      return super.checkAsync(this.view, E, H);
    }
    /**
     * Verify all transaction inputs.
     * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
     * @returns {Boolean} Whether the inputs are valid.
     */
    verify(E) {
      try {
        this.check(E);
      } catch (H) {
        if (H.type === "ScriptError")
          return !1;
        throw H;
      }
      return !0;
    }
    /**
     * Verify the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async verifyAsync(E, H) {
      try {
        await this.checkAsync(E, H);
      } catch (k) {
        if (k.type === "ScriptError")
          return !1;
        throw k;
      }
      return !0;
    }
    /**
     * Calculate the fee for the transaction.
     * @returns {Amount} fee (zero if not all coins are available).
     */
    getFee() {
      return super.getFee(this.view);
    }
    /**
     * Calculate the total input value.
     * @returns {Amount} value
     */
    getInputValue() {
      return super.getInputValue(this.view);
    }
    /**
     * Get all input addresses.
     * @returns {Address[]} addresses
     */
    getInputAddresses() {
      return super.getInputAddresses(this.view);
    }
    /**
     * Get all addresses.
     * @returns {Address[]} addresses
     */
    getAddresses() {
      return super.getAddresses(this.view);
    }
    /**
     * Get all input address hashes.
     * @returns {Hash[]} hashes
     */
    getInputHashes(E) {
      return super.getInputHashes(this.view, E);
    }
    /**
     * Get all address hashes.
     * @returns {Hash[]} hashes
     */
    getHashes(E) {
      return super.getHashes(this.view, E);
    }
    /**
     * Test whether the transaction has
     * all coins available/filled.
     * @returns {Boolean}
     */
    hasCoins() {
      return super.hasCoins(this.view);
    }
    /**
     * Calculate virtual sigop count.
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop count
     */
    getSigops(E) {
      return super.getSigops(this.view, E);
    }
    /**
     * Calculate sigops weight, taking into account witness programs.
     * @param {VerifyFlags?} flags
     * @returns {Number} sigop weight
     */
    getSigopsCost(E) {
      return super.getSigopsCost(this.view, E);
    }
    /**
     * Calculate the virtual size of the transaction
     * (weighted against bytes per sigop cost).
     * @returns {Number} vsize
     */
    getSigopsSize() {
      return super.getSigopsSize(this.getSigopsCost());
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Boolean}
     */
    verifyInputs(E) {
      const [H] = this.checkInputs(E);
      return H !== -1;
    }
    /**
     * Perform contextual checks to verify input, output,
     * and fee values, as well as coinbase spend maturity
     * (coinbases can only be spent 100 blocks or more
     * after they're created). Note that this function is
     * consensus critical.
     * @param {Number} height - Height at which the
     * transaction is being spent. In the mempool this is
     * the chain height plus one at the time it entered the pool.
     * @returns {Array} [fee, reason, score]
     */
    checkInputs(E) {
      return super.checkInputs(this.view, E);
    }
    /**
     * Build input script (or witness) templates (with
     * OP_0 in place of signatures).
     * @param {Number} index - Input index.
     * @param {Coin|Output} coin
     * @param {KeyRing} ring
     * @returns {Boolean} Whether the script was able to be built.
     */
    scriptInput(E, H, k) {
      const V = this.inputs[E];
      if (t(V, "Input does not exist."), t(H, "No coin passed."), V.script.raw.length !== 0 || V.witness.items.length !== 0)
        return !0;
      const T = H.script, ie = T.getScripthash();
      if (ie) {
        const G = k.getRedeem(ie);
        if (!G)
          return !1;
        if (G.isProgram()) {
          const W = G.getWitnessScripthash();
          if (W) {
            const ne = k.getRedeem(W);
            if (!ne)
              return !1;
            const xe = this.scriptVector(ne, k);
            return xe ? (xe.push(ne.toRaw()), V.witness.fromStack(xe), V.script.fromItems([G.toRaw()]), !0) : !1;
          }
          const ce = G.getWitnessPubkeyhash();
          if (ce) {
            const ne = n.fromPubkeyhash(ce), xe = this.scriptVector(ne, k);
            return xe ? (V.witness.fromStack(xe), V.script.fromItems([G.toRaw()]), !0) : !1;
          }
          return !1;
        }
        const F = this.scriptVector(G, k);
        return F ? (F.push(G.toRaw()), V.script.fromStack(F), !0) : !1;
      }
      if (T.isProgram()) {
        const G = T.getWitnessScripthash();
        if (G) {
          const W = k.getRedeem(G);
          if (!W)
            return !1;
          const ce = this.scriptVector(W, k);
          return ce ? (ce.push(W.toRaw()), V.witness.fromStack(ce), !0) : !1;
        }
        const F = T.getWitnessPubkeyhash();
        if (F) {
          const W = n.fromPubkeyhash(F), ce = this.scriptVector(W, k);
          return ce ? (V.witness.fromStack(ce), !0) : !1;
        }
        return !1;
      }
      const N = this.scriptVector(T, k);
      return N ? (V.script.fromStack(N), !0) : !1;
    }
    /**
     * Build script for a single vector
     * based on a previous script.
     * @param {Script} prev
     * @param {Buffer} ring
     * @return {Stack}
     */
    scriptVector(E, H) {
      const k = E.getPubkey();
      if (k) {
        if (!k.equals(H.publicKey))
          return null;
        const ie = new w();
        return ie.pushInt(0), ie;
      }
      const V = E.getPubkeyhash();
      if (V) {
        if (!V.equals(H.getKeyHash()))
          return null;
        const ie = new w();
        return ie.pushInt(0), ie.pushData(H.publicKey), ie;
      }
      const [, T] = E.getMultisig();
      if (T !== -1) {
        if (E.indexOf(H.publicKey) === -1)
          return null;
        const ie = new w();
        ie.pushInt(0);
        for (let N = 0; N < T; N++)
          ie.pushInt(0);
        return ie;
      }
      return null;
    }
    /**
     * Sign a transaction input on the worker pool
     * (if workers are enabled).
     * @param {Number} index
     * @param {Coin|Output} coin
     * @param {KeyRing} ring
     * @param {SighashType?} type
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async signInputAsync(E, H, k, V, T) {
      return T ? await T.signInput(this, E, H, k, V, T) : this.signInput(E, H, k, V);
    }
    /**
     * Sign an input.
     * @param {Number} index - Index of input being signed.
     * @param {Coin|Output} coin
     * @param {KeyRing} ring - Private key.
     * @param {SighashType} type
     * @returns {Boolean} Whether the input was able to be signed.
     */
    signInput(E, H, k, V) {
      const T = this.inputs[E], ie = k.privateKey;
      t(T, "Input does not exist."), t(H, "No coin passed.");
      const N = H.value;
      let G = H.script, F = T.script, W = 0, ce = !1;
      if (G.isScripthash()) {
        if (G = T.script.getRedeem(), !G)
          throw new Error("Input has not been templated.");
        ce = !0;
      }
      if (G.isWitnessScripthash()) {
        if (G = T.witness.getRedeem(), !G)
          throw new Error("Input has not been templated.");
        F = T.witness, ce = !0, W = 1;
      } else {
        const me = G.getWitnessPubkeyhash();
        me && (G = n.fromPubkeyhash(me), F = T.witness, ce = !1, W = 1);
      }
      const ne = this.signature(E, G, N, ie, V, W);
      if (ce) {
        const me = F.toStack(), Ne = me.pop(), Je = this.signVector(G, me, ne, k);
        return Je ? (Je.push(Ne), F.fromStack(Je), !0) : !1;
      }
      const xe = F.toStack(), he = this.signVector(G, xe, ne, k);
      return he ? (F.fromStack(he), !0) : !1;
    }
    /**
     * Add a signature to a vector
     * based on a previous script.
     * @param {Script} prev
     * @param {Stack} vector
     * @param {Buffer} sig
     * @param {KeyRing} ring
     * @return {Stack|null}
     */
    signVector(E, H, k, V) {
      const T = E.getPubkey();
      if (T) {
        if (!V.publicKey.equals(T))
          return null;
        if (H.length === 0)
          throw new Error("Input has not been templated.");
        return H.get(0).length > 0 || H.set(0, k), H;
      }
      const ie = E.getPubkeyhash();
      if (ie) {
        if (!V.getKeyHash().equals(ie))
          return null;
        if (H.length !== 2)
          throw new Error("Input has not been templated.");
        if (H.get(1).length === 0)
          throw new Error("Input has not been templated.");
        return H.get(0).length > 0 || H.set(0, k), H;
      }
      const [N, G] = E.getMultisig();
      if (N !== -1) {
        if (H.length < 2)
          throw new Error("Input has not been templated.");
        if (H.get(0).length !== 0)
          throw new Error("Input has not been templated.");
        if (H.length - 1 > G)
          throw new Error("Input has not been templated.");
        let F = 0;
        for (let ne = 1; ne < H.length; ne++)
          H.get(ne).length > 0 && (F += 1);
        if (F === N && H.length - 1 === N)
          return H;
        for (; H.length - 1 < G; )
          H.pushInt(0);
        const W = [];
        for (const ne of E.code)
          ne.data && W.push(ne.data);
        let ce = -1;
        for (let ne = 0; ne < W.length; ne++)
          if (W[ne].equals(V.publicKey)) {
            ce = ne;
            break;
          }
        if (ce === -1)
          return null;
        if (ce += 1, ce < H.length && F < N && H.get(ce).length === 0 && (H.set(ce, k), F += 1), F >= N) {
          for (let ne = H.length - 1; ne >= 1; ne--)
            H.get(ne).length === 0 && H.remove(ne);
          for (; F > N; )
            H.pop(), F -= 1;
          t(F === N), t(H.length - 1 === N);
        }
        return H;
      }
      return null;
    }
    /**
     * Test whether the transaction is fully-signed.
     * @returns {Boolean}
     */
    isSigned() {
      for (let E = 0; E < this.inputs.length; E++) {
        const { prevout: H } = this.inputs[E], k = this.view.getOutput(H);
        if (!k || !this.isInputSigned(E, k))
          return !1;
      }
      return !0;
    }
    /**
     * Test whether an input is fully-signed.
     * @param {Number} index
     * @param {Coin|Output} coin
     * @returns {Boolean}
     */
    isInputSigned(E, H) {
      const k = this.inputs[E];
      t(k, "Input does not exist."), t(H, "No coin passed.");
      let V = H.script, T = k.script, ie = !1;
      if (V.isScripthash()) {
        if (V = k.script.getRedeem(), !V)
          return !1;
        ie = !0;
      }
      if (V.isWitnessScripthash()) {
        if (V = k.witness.getRedeem(), !V)
          return !1;
        T = k.witness, ie = !0;
      } else {
        const G = V.getWitnessPubkeyhash();
        G && (V = n.fromPubkeyhash(G), T = k.witness, ie = !1);
      }
      const N = T.toStack();
      return ie && N.pop(), this.isVectorSigned(V, N);
    }
    /**
     * Test whether a vector is fully-signed.
     * @param {Script} prev
     * @param {Stack} vector
     * @returns {Boolean}
     */
    isVectorSigned(E, H) {
      if (E.isPubkey())
        return !(H.length !== 1 || H.get(0).length === 0);
      if (E.isPubkeyhash())
        return !(H.length !== 2 || H.get(0).length === 0 || H.get(1).length === 0);
      const [k] = E.getMultisig();
      if (k !== -1) {
        if (H.length - 1 !== k)
          return !1;
        for (let V = 1; V < H.length; V++)
          if (H.get(V).length === 0)
            return !1;
        return !0;
      }
      return !1;
    }
    /**
     * Build input scripts (or witnesses).
     * @param {KeyRing} ring - Address used to sign. The address
     * must be able to redeem the coin.
     * @returns {Number} Number of inputs templated.
     */
    template(E) {
      if (Array.isArray(E)) {
        let k = 0;
        for (const V of E)
          k += this.template(V);
        return k;
      }
      let H = 0;
      for (let k = 0; k < this.inputs.length; k++) {
        const { prevout: V } = this.inputs[k], T = this.view.getOutput(V);
        T && E.ownOutput(T) && this.scriptInput(k, T, E) && (H += 1);
      }
      return H;
    }
    /**
     * Build input scripts (or witnesses) and sign the inputs.
     * @param {KeyRing} ring - Address used to sign. The address
     * must be able to redeem the coin.
     * @param {SighashType} type
     * @returns {Number} Number of inputs signed.
     */
    sign(E, H) {
      if (Array.isArray(E)) {
        let V = 0;
        for (const T of E)
          V += this.sign(T, H);
        return V;
      }
      t(E.privateKey, "No private key available.");
      let k = 0;
      for (let V = 0; V < this.inputs.length; V++) {
        const { prevout: T } = this.inputs[V], ie = this.view.getOutput(T);
        ie && E.ownOutput(ie) && this.scriptInput(V, ie, E) && this.signInput(V, ie, E, H) && (k += 1);
      }
      return k;
    }
    /**
     * Sign the transaction inputs on the worker pool
     * (if workers are enabled).
     * @param {KeyRing} ring
     * @param {SighashType?} type
     * @param {WorkerPool?} pool
     * @returns {Promise}
     */
    async signAsync(E, H, k) {
      return k ? await k.sign(this, E, H) : this.sign(E, H);
    }
    /**
     * Estimate maximum possible size.
     * @param {Function?} getAccount - Returns account that can spend
     * from a given address.
     * @returns {Number}
     */
    async estimateSize(E) {
      let H = 0;
      H += 4, H += 4, H += i.sizeVarint(this.inputs.length), H += i.sizeVarint(this.outputs.length);
      for (const k of this.outputs)
        H += k.getSize();
      H += 2;
      for (const k of this.inputs) {
        const V = this.view.getCoinFor(k);
        if (!V) {
          H += 110;
          continue;
        }
        H += await V.estimateSpendingSize(E);
      }
      return H;
    }
    /**
     * Select necessary coins based on total output value.
     * @param {Coin[]} coins
     * @param {Object?} options
     * @returns {CoinSelector}
     * @throws on not enough funds available.
     */
    selectCoins(E, H) {
      return new y(this, H).select(E);
    }
    /**
     * Attempt to subtract a fee from a single output.
     * @param {Number} index
     * @param {Amount} fee
     */
    subtractIndex(E, H) {
      t(typeof E == "number"), t(typeof H == "number");
      const k = this.outputs[E];
      if (!k)
        throw new Error("Subtraction index does not exist.");
      if (k.value < H + k.getDustThreshold())
        throw new Error("Could not subtract fee.");
      k.value -= H;
    }
    /**
     * Attempt to subtract a fee from all outputs evenly.
     * @param {Amount} fee
     */
    subtractFee(E) {
      t(typeof E == "number");
      let H = 0;
      for (const T of this.outputs)
        T.script.isUnspendable() || (H += 1);
      if (H === 0)
        throw new Error("Could not subtract fee.");
      const k = E % H, V = (E - k) / H;
      for (const T of this.outputs)
        if (!T.script.isUnspendable()) {
          if (T.value < V + T.getDustThreshold())
            throw new Error("Could not subtract fee.");
          T.value -= V;
        }
      for (const T of this.outputs)
        if (!T.script.isUnspendable() && T.value >= k + T.getDustThreshold()) {
          T.value -= k;
          return;
        }
      throw new Error("Could not subtract fee.");
    }
    /**
     * Select coins and fill the inputs.
     * @param {Coin[]} coins
     * @param {Object} options - See {@link MTX#selectCoins} options.
     * @returns {CoinSelector}
     */
    async fund(E, H) {
      t(H, "Options are required."), t(H.changeAddress, "Change address is required."), t(this.inputs.length === 0, "TX is already funded.");
      const k = await this.selectCoins(E, H);
      for (const T of k.chosen)
        this.addCoin(T);
      if (k.subtractFee) {
        const T = k.subtractIndex;
        T !== -1 ? this.subtractIndex(T, k.fee) : this.subtractFee(k.fee);
      }
      const V = new d();
      return V.value = k.change, V.script.fromAddress(k.changeAddress), V.isDust(g.MIN_RELAY) ? (this.changeIndex = -1, t.strictEqual(this.getFee(), k.fee + k.change)) : (this.outputs.push(V), this.changeIndex = this.outputs.length - 1, t.strictEqual(this.getFee(), k.fee)), k;
    }
    /**
     * Sort inputs and outputs according to BIP69.
     * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
     */
    sortMembers() {
      let E = null;
      this.changeIndex !== -1 && (E = this.outputs[this.changeIndex], t(E)), this.inputs.sort(q), this.outputs.sort(U), this.changeIndex !== -1 && (this.changeIndex = this.outputs.indexOf(E), t(this.changeIndex !== -1));
    }
    /**
     * Avoid fee sniping.
     * @param {Number} height - Current chain height.
     * @see bitcoin/src/wallet/wallet.cpp
     */
    avoidFeeSniping(E) {
      t(typeof E == "number", "Must pass in height."), Math.random() * 10 | 0 || (E -= Math.random() * 100 | 0, E < 0 && (E = 0)), this.setLocktime(E);
    }
    /**
     * Set locktime and sequences appropriately.
     * @param {Number} locktime
     */
    setLocktime(E) {
      t(E >>> 0 === E, "Locktime must be a uint32."), t(this.inputs.length > 0, "Cannot set sequence with no inputs.");
      for (const H of this.inputs)
        H.sequence === 4294967295 && (H.sequence = 4294967294);
      this.locktime = E;
    }
    /**
     * Set sequence locktime.
     * @param {Number} index - Input index.
     * @param {Number} locktime
     * @param {Boolean?} seconds
     */
    setSequence(E, H, k) {
      const V = this.inputs[E];
      t(V, "Input does not exist."), t(H >>> 0 === H, "Locktime must be a uint32."), this.version = 2, k ? (H >>>= b.SEQUENCE_GRANULARITY, H &= b.SEQUENCE_MASK, H |= b.SEQUENCE_TYPE_FLAG) : H &= b.SEQUENCE_MASK, V.sequence = H;
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    [B]() {
      return this.format();
    }
    /**
     * Inspect the transaction.
     * @returns {Object}
     */
    format() {
      return super.format(this.view);
    }
    /**
     * Convert transaction to JSON.
     * @returns {Object}
     */
    toJSON() {
      return super.toJSON(null, this.view);
    }
    /**
     * Convert transaction to JSON.
     * @param {Network} network
     * @returns {Object}
     */
    getJSON(E) {
      return super.getJSON(E, this.view);
    }
    /**
     * Inject properties from a json object
     * @param {Object} json
     */
    fromJSON(E) {
      super.fromJSON(E);
      for (let H = 0; H < E.inputs.length; H++) {
        const k = E.inputs[H], { prevout: V } = k;
        if (!k.coin)
          continue;
        const T = l.fromJSON(k.coin);
        T.hash = I.fromRev(V.hash), T.index = V.index, this.view.addCoin(T);
      }
      return this;
    }
    /**
     * Instantiate a transaction from a
     * jsonified transaction object.
     * @param {Object} json - The jsonified transaction object.
     * @returns {MTX}
     */
    static fromJSON(E) {
      return new this().fromJSON(E);
    }
    /**
     * Instantiate a transaction from a buffer reader.
     * @param {BufferReader} br
     * @returns {MTX}
     */
    static fromReader(E) {
      return new this().fromReader(E);
    }
    /**
     * Instantiate a transaction from a serialized Buffer.
     * @param {Buffer} data
     * @param {String?} enc - Encoding, can be `'hex'` or null.
     * @returns {MTX}
     */
    static fromRaw(E, H) {
      return typeof E == "string" && (E = Buffer.from(E, H)), new this().fromRaw(E);
    }
    /**
     * Convert the MTX to a TX.
     * @returns {TX}
     */
    toTX() {
      return new c().inject(this);
    }
    /**
     * Convert the MTX to a TX.
     * @returns {Array} [tx, view]
     */
    commit() {
      return [this.toTX(), this.view];
    }
    /**
     * Instantiate MTX from TX.
     * @param {TX} tx
     * @returns {MTX}
     */
    static fromTX(E) {
      return new this().inject(E);
    }
    /**
     * Test whether an object is an MTX.
     * @param {Object} obj
     * @returns {Boolean}
     */
    static isMTX(E) {
      return E instanceof _;
    }
  }
  function q(z, E) {
    return z.compare(E);
  }
  function U(z, E) {
    return z.compare(E);
  }
  e = _, e.MTX = _, e.FundingError = A, r.exports = e;
})(e8, e8.exports);
/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */
var UM = ef;
const wN = (r) => {
  if (r.depth != 0 || r.parentFingerPrint != 0)
    throw new Error("Bad master key!");
  return {
    scanKey: r.derivePath("m/352h/0h/0h/1h/0"),
    spendKey: r.derivePath("m/352h/0h/0h/0h/0")
  };
}, yN = (r) => {
  const e = Buffer.concat(
    r.map(
      (t) => UM.fromJSON({
        hash: t.txid,
        index: t.vout
      }).toRaw()
    ).sort((t, i) => t.compare(i))
  );
  return If.SHA256.digest(e);
}, SN = (r) => {
  const e = r.map((t) => {
    const i = Buffer.from(t.key, "hex");
    return t.isXOnly && If.secp256k1.publicKeyCreate(i, !0)[0] === 3 ? If.secp256k1.privateKeyNegate(i) : i;
  });
  return e.slice(1).reduce((t, i) => If.secp256k1.privateKeyTweakAdd(t, i), e[0]);
};
export {
  SN as calculateSumOfPrivateKeys,
  rN as decodeSilentPaymentAddress,
  wN as deriveSilentPaymentsKeyPair,
  tN as encodeSilentPaymentAddress,
  yN as hashOutpoints
};
